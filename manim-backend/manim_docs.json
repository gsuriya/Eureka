{
  "https://3b1b.github.io/manim/": {
    "url": "https://3b1b.github.io/manim/",
    "title": "Home - manim  documentation",
    "content": "Manim’s documentation\n¶\nManim is an animation engine for explanatory math videos. It’s used to create precise animations programmatically, as seen in the videos\nat\n3Blue1Brown\n.\nAnd here is a Chinese version of this documentation:\nhttps://docs.manim.org.cn/\nGetting Started\nInstallation\nInstall FFmpeg\nInstall FFmpeg Windows\n# Install FFmepeg Linux\n# Install FFmpeg MacOS\nDirectly\nDirectly (Windows)\nFor Anaconda\nQuick Start\nMake an image\nAdd animations\nEnable interaction\nYou succeeded!\nCLI flags and configuration\nCommand Line Interface\ncustom_config\nExample Scenes\nInteractiveDevlopment\nAnimatingMethods\nTextExample\nTexTransformExample\nUpdatersExample\nCoordinateSystemExample\nGraphExample\nSurfaceExample\nOpeningManimExample\nManim’s structure\nManim’s directory structure\nInheritance structure of manim’s classes\nManim execution process\nWhat’s new\nUsage changes of new version manim\nDocumentation\nconstants\nFrame and pixel shape\nBuffs\nRun times\nCoordinates\nMathematical constant\nText\nStroke width\nColours\ncustom_config\ndirectories\ntex\nuniversal_import_line\nstyle\nwindow_position\nwindow_monitor\nfull_screen\nbreak_into_partial_movies\ncamera_resolutions\nfps\nDevelopment\nChangelog\nUnreleased\nv1.6.1\nv1.6.0\nv1.5.0\nv1.4.1\nv1.4.0\nv1.3.0\nv1.2.0\nv1.1.0\nContributing\nHow to build this documentation\nAbout\nAbout Manim\nAbout this documentation",
    "code_examples": [
      "directories",
      "universal_import_line",
      "window_position",
      "window_monitor",
      "full_screen",
      "break_into_partial_movies",
      "camera_resolutions"
    ],
    "links": [
      "https://3b1b.github.io/manim/getting_started/installation.html",
      "https://3b1b.github.io/manim/getting_started/quickstart.html",
      "https://3b1b.github.io/manim/getting_started/configuration.html",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html",
      "https://3b1b.github.io/manim/getting_started/structure.html",
      "https://3b1b.github.io/manim/getting_started/whatsnew.html",
      "https://3b1b.github.io/manim/documentation/constants.html",
      "https://3b1b.github.io/manim/documentation/custom_config.html",
      "https://3b1b.github.io/manim/development/changelog.html",
      "https://3b1b.github.io/manim/development/contributing.html",
      "https://3b1b.github.io/manim/development/about.html",
      "https://3b1b.github.io/manim/#manim-s-documentation",
      "https://3b1b.github.io/manim/getting_started/installation.html",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmepeg-linux",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-macos",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda",
      "https://3b1b.github.io/manim/getting_started/quickstart.html",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#make-an-image",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#add-animations",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#enable-interaction",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#you-succeeded",
      "https://3b1b.github.io/manim/getting_started/configuration.html",
      "https://3b1b.github.io/manim/getting_started/configuration.html#command-line-interface",
      "https://3b1b.github.io/manim/getting_started/configuration.html#custom-config",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevlopment",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#animatingmethods",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/structure.html",
      "https://3b1b.github.io/manim/getting_started/structure.html#manim-s-directory-structure",
      "https://3b1b.github.io/manim/getting_started/structure.html#inheritance-structure-of-manim-s-classes",
      "https://3b1b.github.io/manim/getting_started/structure.html#manim-execution-process",
      "https://3b1b.github.io/manim/getting_started/whatsnew.html",
      "https://3b1b.github.io/manim/getting_started/whatsnew.html#usage-changes-of-new-version-manim",
      "https://3b1b.github.io/manim/documentation/constants.html",
      "https://3b1b.github.io/manim/documentation/constants.html#frame-and-pixel-shape",
      "https://3b1b.github.io/manim/documentation/constants.html#buffs",
      "https://3b1b.github.io/manim/documentation/constants.html#run-times",
      "https://3b1b.github.io/manim/documentation/constants.html#coordinates",
      "https://3b1b.github.io/manim/documentation/constants.html#mathematical-constant",
      "https://3b1b.github.io/manim/documentation/constants.html#text",
      "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
      "https://3b1b.github.io/manim/documentation/constants.html#colours",
      "https://3b1b.github.io/manim/documentation/custom_config.html",
      "https://3b1b.github.io/manim/documentation/custom_config.html#directories",
      "https://3b1b.github.io/manim/documentation/custom_config.html#tex",
      "https://3b1b.github.io/manim/documentation/custom_config.html#universal-import-line",
      "https://3b1b.github.io/manim/documentation/custom_config.html#style",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-position",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-monitor",
      "https://3b1b.github.io/manim/documentation/custom_config.html#full-screen",
      "https://3b1b.github.io/manim/documentation/custom_config.html#break-into-partial-movies",
      "https://3b1b.github.io/manim/documentation/custom_config.html#camera-resolutions",
      "https://3b1b.github.io/manim/documentation/custom_config.html#fps",
      "https://3b1b.github.io/manim/development/changelog.html",
      "https://3b1b.github.io/manim/development/changelog.html#unreleased",
      "https://3b1b.github.io/manim/development/changelog.html#v1-6-1",
      "https://3b1b.github.io/manim/development/changelog.html#v1-6-0",
      "https://3b1b.github.io/manim/development/changelog.html#v1-5-0",
      "https://3b1b.github.io/manim/development/changelog.html#v1-4-1",
      "https://3b1b.github.io/manim/development/changelog.html#v1-4-0",
      "https://3b1b.github.io/manim/development/changelog.html#v1-3-0",
      "https://3b1b.github.io/manim/development/changelog.html#v1-2-0",
      "https://3b1b.github.io/manim/development/changelog.html#v1-1-0",
      "https://3b1b.github.io/manim/development/contributing.html",
      "https://3b1b.github.io/manim/development/contributing.html#how-to-build-this-documentation",
      "https://3b1b.github.io/manim/development/about.html",
      "https://3b1b.github.io/manim/development/about.html#about-manim",
      "https://3b1b.github.io/manim/development/about.html#about-this-documentation"
    ],
    "scraped_at": 1752428815.02606
  },
  "https://3b1b.github.io/manim/getting_started/installation.html": {
    "url": "https://3b1b.github.io/manim/getting_started/installation.html",
    "title": "Installation - manim  documentation",
    "content": "Installation\n¶\nManim runs on Python 3.7 or higher.\nSystem requirements are：\nFFmpeg\nOpenGL\n(included in python package\nPyOpenGL\n)\nLaTeX\n(optional, if you want to use LaTeX)\nPango\n(only for Linux)\nInstall FFmpeg\n¶\nInstall FFmpeg Windows\n¶\nchoco install ffmpeg\n# Install FFmepeg Linux\n¶\n$\nsudo\napt\nupdate\n$\nsudo\napt\ninstall\nffmpeg\n$\nffmpeg\n-version\n# Install FFmpeg MacOS\n¶\nDownload This ZIP file\n`\nhttps://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full\n.7z`(if the link is not working download this zip file from there original website)\nDirectly\n¶\n# Install manimgl\npip\ninstall\nmanimgl\n# Try it out\nmanimgl\nIf you want to hack on manimlib itself, clone this repository and in\nthat directory execute:\n# Install python requirements\npip\ninstall\n-e\n.\n# Try it out\nmanimgl\nexample_scenes.py\nOpeningManimExample\n# or\nmanim-render\nexample_scenes.py\nOpeningManimExample\nIf you run the above command and no error message appears,\nthen you have successfully installed all the environments required by manim.\nDirectly (Windows)\n¶\nInstall\nFFmpeg\n, and make sure that its path is in the PATH environment variable.\nInstall a LaTeX distribution.\nTeXLive-full\nis recommended.\nInstall the remaining Python packages.\ngit\nclone\nhttps://github.com/3b1b/manim.git\ncd\nmanim\npip\ninstall\n-e\n.\nmanimgl\nexample_scenes.py\nOpeningManimExample\nFor Anaconda\n¶\nInstall FFmpeg and LaTeX as above.\nCreate a conda environment using\ngit\nclone\nhttps://github.com/3b1b/manim.git\ncd\nmanim\nconda\ncreate\n-n\nmanim\npython\n=\n3\n.8\nconda\nactivate\nmanim\npip\ninstall\n-e\n.\nContents\nInstallation\nInstall FFmpeg\nInstall FFmpeg Windows\n# Install FFmepeg Linux\n# Install FFmpeg MacOS\nDirectly\nDirectly (Windows)\nFor Anaconda",
    "code_examples": [
      "choco install ffmpeg",
      "$ sudo apt update\n$ sudo apt install ffmpeg\n$ ffmpeg -version",
      "# Install manimgl\npip install manimgl\n\n# Try it out\nmanimgl",
      "# Install python requirements\npip install -e .\n\n# Try it out\nmanimgl example_scenes.py OpeningManimExample\n# or\nmanim-render example_scenes.py OpeningManimExample",
      "git clone https://github.com/3b1b/manim.git\ncd manim\npip install -e .\nmanimgl example_scenes.py OpeningManimExample",
      "git clone https://github.com/3b1b/manim.git\ncd manim\nconda create -n manim python=3.8\nconda activate manim\npip install -e ."
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/quickstart.html",
      "https://3b1b.github.io/manim/getting_started/configuration.html",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html",
      "https://3b1b.github.io/manim/getting_started/structure.html",
      "https://3b1b.github.io/manim/getting_started/whatsnew.html",
      "https://3b1b.github.io/manim/documentation/constants.html",
      "https://3b1b.github.io/manim/documentation/custom_config.html",
      "https://3b1b.github.io/manim/development/changelog.html",
      "https://3b1b.github.io/manim/development/contributing.html",
      "https://3b1b.github.io/manim/development/about.html",
      "https://3b1b.github.io/manim/getting_started/installation.html#installation",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmepeg-linux",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-macos",
      "https://3b1b.github.io/manim/getting_started/installation.html#system-message-1",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmepeg-linux",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-macos",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda"
    ],
    "scraped_at": 1752428816.134717
  },
  "https://3b1b.github.io/manim/getting_started/quickstart.html": {
    "url": "https://3b1b.github.io/manim/getting_started/quickstart.html",
    "title": "Quick Start - manim  documentation",
    "content": "Quick Start\n¶\nAfter installing the manim environment according to the instructions on the\nInstallation\npage, you can try to make a scene yourself from scratch.\nFirst, create a new\n.py\nfile (such as\nstart.py\n) according to the following\ndirectory structure:\nmanim/\n├── manimlib/\n│   ├── animation/\n│   ├── ...\n│   ├── default_config.yml\n│   └── window.py\n├── custom_config.yml\n└── start.py\nAnd paste the following code (I will explain the function of each line in detail later):\n1\n2\n3\n4\n5\n6\n7\n8\n9\nfrom\nmanimlib\nimport\n*\nclass\nSquareToCircle\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nself\n.\nadd\n(\ncircle\n)\nAnd run this command:\nmanimgl\nstart.py\nSquareToCircle\nA window will pop up on the screen. And then you can :\nscroll the middle mouse button to move the screen up and down\nhold down the\nz\non the keyboard while scrolling the middle mouse button to zoom the screen\nhold down the\ns\nkey on the keyboard and move the mouse to pan the screen\nhold down the\nd\nkey on the keyboard and move the mouse to change the three-dimensional perspective.\nFinally, you can close the window and exit the program by pressing\nq\n.\nRun this command again:\nmanimgl\nstart.py\nSquareToCircle\n-os\nAt this time, no window will pop up. When the program is finished, this rendered\nimage will be automatically opened (saved in the subdirectory\nimages/\nof the same\nlevel directory of\nstart.py\nby default):\nMake an image\n¶\nNext, let’s take a detailed look at what each row does.\nLine 1\n:\nfrom\nmanimlib\nimport\n*\nThis will import all the classes that may be used when using manim.\nLine 3\n:\nclass\nSquareToCircle\n(\nScene\n):\nCreate a\nScene\nsubclass\nSquareToCircle\n, which will be\nthe scene you write and render.\nLine 4\n:\ndef\nconstruct\n(\nself\n):\nWrite the\nconstruct()\nmethod, the content of which will determine\nhow to create the mobjects in the screen and what operations need to be performed.\nLine 5\n:\ncircle\n=\nCircle\n()\nCreate a circle (an instance of the\nCircle\nclass), called\ncircle\nLine 6~7\n:\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nSet the circle style by calling the circle’s method.\nThe\n.set_fill()\nmethod sets the fill color of this circle to blue (\nBLUE\n, defined in\nconstants\n), and the fill transparency to 0.5.\nThe\n.set_stroke()\nmethod sets the stroke color of this circle to dark blue (\nBLUE_E\n, defined in\nconstants\n), and the stroke width to 4.\nLine 9\n:\nself\n.\nadd\n(\ncircle\n)\nAdd this circle to the screen through the\n.add()\nmethod of\nScene\n.\nAdd animations\n¶\nLet’s change some codes and add some animations to make videos instead of just pictures.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nfrom\nmanimlib\nimport\n*\nclass\nSquareToCircle\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nsquare\n=\nSquare\n()\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nself\n.\nwait\n()\nRun this command this time:\nmanimgl\nstart.py\nSquareToCircle\nThe pop-up window will play animations of drawing a square and transforming\nit into a circle. If you want to save this video, run:\nmanimgl\nstart.py\nSquareToCircle\n-o\nThis time there will be no pop-up window, but the video file (saved in the subdirectory\nvideos/\nof the same level directory of\nstart.py\nby default) will be automatically\nopened after the operation is over:\nLet’s take a look at the code this time. The first 7 lines are the same as the previous\nones, and the 8th line is similar to the 5th line, which creates an instance of the\nSquare\nclass and named it\nsquare\n.\nLine 10\n:\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nAn animation is played through\nScene\n’s\n.play()\nmethod.\nShowCreation\nis an animation that shows the process of creating a given mobject.\nself.play(ShowCreation(square))\nis to play the animation of creating\nsquare\n.\nLine 11\n:\nself\n.\nwait\n()\nUse\nScene\n’s\n.wait()\nmethod to pause (default 1s), you can pass in\nparameters to indicate the pause time (for example,\nself.wait(3)\nmeans pause for 3s).\nLine 12\n:\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nPlay the animation that transforms\nsquare\ninto\ncircle\n.\nReplacementTransform(A,\nB)\nmeans to transform A into B’s pattern and replace A with B.\nLine 13\n: Same as line 11, pause for 1s.\nEnable interaction\n¶\nInteraction is a new feature of the new version. You can add the following line\nat the end of the code to enable interaction:\nself\n.\nembed\n()\nThen run\nmanimgl\nstart.py\nSquareToCircle\n.\nAfter the previous animation is executed, the ipython terminal will be opened on\nthe command line. After that, you can continue to write code in it, and the statement\nyou entered will be executed immediately after pressing\nEnter\n.\nFor example: input the following lines (without comment lines) into it respectively\n(\nself.play\ncan be abbreviated as\nplay\nin this mode):\n# Stretched 4 times in the vertical direction\nplay\n(\ncircle\n.\nanimate\n.\nstretch\n(\n4\n,\ndim\n=\n0\n))\n# Rotate the ellipse 90°\nplay\n(\nRotate\n(\ncircle\n,\nTAU\n/\n4\n))\n# Move 2 units to the right and shrink to 1/4 of the original\nplay\n(\ncircle\n.\nanimate\n.\nshift\n(\n2\n*\nRIGHT\n),\ncircle\n.\nanimate\n.\nscale\n(\n0.25\n))\n# Insert 10 curves into circle for non-linear transformation (no animation will play)\ncircle\n.\ninsert_n_curves\n(\n10\n)\n# Apply a complex transformation of f(z)=z^2 to all points on the circle\nplay\n(\ncircle\n.\nanimate\n.\napply_complex_function\n(\nlambda\nz\n:\nz\n**\n2\n))\n# Close the window and exit the program\nexit\n()\nYou will get an animation similar to the following:\nIf you want to enter the interactive mode directly, you don’t have to write an\nempty scene containing only\nself.embed()\n, you can directly run the following command\n(this will enter the ipython terminal while the window pops up):\nmanimgl\nYou succeeded!\n¶\nAfter reading the above content, you already know how to use manim.\nBelow you can see some examples, in the\nExample Scenes\npage.\nBut before that, you’d better have a look at the\nCLI flags and configuration\nof manim.\nContents\nQuick Start\nMake an image\nAdd animations\nEnable interaction\nYou succeeded!",
    "code_examples": [
      "manim/\n├── manimlib/\n│   ├── animation/\n│   ├── ...\n│   ├── default_config.yml\n│   └── window.py\n├── custom_config.yml\n└── start.py",
      "1\n2\n3\n4\n5\n6\n7\n8\n9",
      "from manimlib import *\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n\n        self.add(circle)",
      "manimgl start.py SquareToCircle",
      "manimgl start.py SquareToCircle -os",
      "from manimlib import *",
      "class SquareToCircle(Scene):",
      "SquareToCircle",
      "def construct(self):",
      "construct()",
      "circle = Circle()",
      "circle.set_fill(BLUE, opacity=0.5)\ncircle.set_stroke(BLUE_E, width=4)",
      ".set_fill()",
      ".set_stroke()",
      "self.add(circle)",
      "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13",
      "from manimlib import *\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n        self.play(ReplacementTransform(square, circle))\n        self.wait()",
      "manimgl start.py SquareToCircle",
      "manimgl start.py SquareToCircle -o",
      "self.play(ShowCreation(square))",
      "ShowCreation",
      "self.play(ShowCreation(square))",
      "self.wait()",
      "self.wait(3)",
      "self.play(ReplacementTransform(square, circle))",
      "ReplacementTransform(A, B)",
      "self.embed()",
      "manimgl start.py SquareToCircle",
      "# Stretched 4 times in the vertical direction\nplay(circle.animate.stretch(4, dim=0))\n# Rotate the ellipse 90°\nplay(Rotate(circle, TAU / 4))\n# Move 2 units to the right and shrink to 1/4 of the original\nplay(circle.animate.shift(2 * RIGHT), circle.animate.scale(0.25))\n# Insert 10 curves into circle for non-linear transformation (no animation will play)\ncircle.insert_n_curves(10)\n# Apply a complex transformation of f(z)=z^2 to all points on the circle\nplay(circle.animate.apply_complex_function(lambda z: z**2))\n# Close the window and exit the program\nexit()",
      "self.embed()"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/configuration.html",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html",
      "https://3b1b.github.io/manim/getting_started/structure.html",
      "https://3b1b.github.io/manim/getting_started/whatsnew.html",
      "https://3b1b.github.io/manim/documentation/constants.html",
      "https://3b1b.github.io/manim/documentation/custom_config.html",
      "https://3b1b.github.io/manim/development/changelog.html",
      "https://3b1b.github.io/manim/development/contributing.html",
      "https://3b1b.github.io/manim/development/about.html",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#quick-start",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#make-an-image",
      "https://3b1b.github.io/manim/documentation/constants.html",
      "https://3b1b.github.io/manim/documentation/constants.html",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#add-animations",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#enable-interaction",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#you-succeeded",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html",
      "https://3b1b.github.io/manim/getting_started/configuration.html",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#make-an-image",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#add-animations",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#enable-interaction",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#you-succeeded"
    ],
    "scraped_at": 1752428817.2778518
  },
  "https://3b1b.github.io/manim/getting_started/configuration.html": {
    "url": "https://3b1b.github.io/manim/getting_started/configuration.html",
    "title": "CLI flags and configuration - manim  documentation",
    "content": "CLI flags and configuration\n¶\nCommand Line Interface\n¶\nTo run manim, you need to enter the directory at the same level as\nmanimlib/\nand enter the command in the following format into terminal:\nmanimgl\n<code>.py\n<Scene>\n<flags>\n# or\nmanim-render\n<code>.py\n<Scene>\n<flags>\n<code>.py\n: The python file you wrote. Needs to be at the same level as\nmanimlib/\n, otherwise you need to use an absolute path or a relative path.\n<Scene>\n: The scene you want to render here. If it is not written or written incorrectly, it will list all for you to choose. And if there is only one\nScene\nin the file, this class will be rendered directly.\n<flags>\n: CLI flags.\nSome useful flags\n¶\n-w\nto write the scene to a file.\n-o\nto write the scene to a file and open the result.\n-s\nto skip to the end and just show the final frame.\n-so\nwill save the final frame to an image and show it.\n-n\n<number>\nto skip ahead to the\nn\n’th animation of a scene.\n-f\nto make the playback window fullscreen.\nAll supported flags\n¶\nflag\nabbr\nfunction\n--help\n-h\nShow the help message and exit\n--version\n-v\nDisplay the version of manimgl\n--write_file\n-w\nRender the scene as a movie file\n--skip_animations\n-s\nSkip to the last frame\n--low_quality\n-l\nRender at a low quality (for faster rendering)\n--medium_quality\n-m\nRender at a medium quality\n--hd\nRender at a 1080p quality\n--uhd\nRender at a 4k quality\n--full_screen\n-f\nShow window in full screen\n--presenter_mode\n-p\nScene will stay paused during wait calls until space bar or right arrow is hit, like a slide show\n--save_pngs\n-g\nSave each frame as a png\n--gif\n-i\nSave the video as gif\n--transparent\n-t\nRender to a movie file with an alpha channel\n--quiet\n-q\n--write_all\n-a\nWrite all the scenes from a file\n--open\n-o\nAutomatically open the saved file once its done\n--finder\nShow the output file in finder\n--config\nGuide for automatic configuration\n--file_name\nFILE_NAME\nName for the movie or image file\n--start_at_animation_number\nSTART_AT_ANIMATION_NUMBER\n-n\nStart rendering not from the first animation, but from another, specified by its index. If you passing two comma separated values, e.g. “3,6”, it will end the rendering at the second value.\n--embed\n[EMBED]\n-e\nCreates a new file where the line\nself.embed\nis inserted into the Scenes construct method. If a string is passed in, the line will be inserted below the last line of code including that string.\n--resolution\nRESOLUTION\n-r\nResolution, passed as “WxH”, e.g. “1920x1080”\n--fps\nFPS\nFrame rate, as an integer\n--color\nCOLOR\n-c\nBackground color\n--leave_progress_bars\nLeave progress bars displayed in terminal\n--video_dir\nVIDEO_DIR\nDirectory to write video\n--config_file\nCONFIG_FILE\nPath to the custom configuration file\n--log-level\nLOG_LEVEL\nLevel of messages to Display, can be DEBUG / INFO / WARNING / ERROR / CRITICAL\ncustom_config\n¶\nIn order to perform more configuration (about directories, etc.) and permanently\nchange the default value (you don’t have to add flags to the command every time),\nyou can modify\ncustom_config.yml\n. The meaning of each option is in\npage\ncustom_config\n.\nYou can also use different\ncustom_config.yml\nfor different directories, such as\nfollowing the directory structure:\nmanim/\n├── manimlib/\n│   ├── animation/\n│   ├── ...\n│   ├── default_config.yml\n│   └── window.py\n├── project/\n│   ├── code.py\n│   └── custom_config.yml\n└── custom_config.yml\nWhen you enter the\nproject/\nfolder and run\nmanimgl\ncode.py\n<Scene>\n,\nit will overwrite\nmanim/default_config.yml\nwith\ncustom_config.yml\nin the\nproject\nfolder.\nAlternatively, you can use\n--config_file\nflag in CLI to specify configuration file manually.\nmanimgl\nproject/code.py\n--config_file\n/path/to/custom_config.yml\nContents\nCLI flags and configuration\nCommand Line Interface\nSome useful flags\nAll supported flags\ncustom_config",
    "code_examples": [
      "manimgl <code>.py <Scene> <flags>\n# or\nmanim-render <code>.py <Scene> <flags>",
      "-n <number>",
      "--write_file",
      "--skip_animations",
      "--low_quality",
      "--medium_quality",
      "--full_screen",
      "--presenter_mode",
      "--save_pngs",
      "--transparent",
      "--write_all",
      "--file_name FILE_NAME",
      "--start_at_animation_number START_AT_ANIMATION_NUMBER",
      "--embed [EMBED]",
      "--resolution RESOLUTION",
      "--color COLOR",
      "--leave_progress_bars",
      "--video_dir VIDEO_DIR",
      "--config_file CONFIG_FILE",
      "--log-level LOG_LEVEL",
      "custom_config.yml",
      "custom_config.yml",
      "manim/\n├── manimlib/\n│   ├── animation/\n│   ├── ...\n│   ├── default_config.yml\n│   └── window.py\n├── project/\n│   ├── code.py\n│   └── custom_config.yml\n└── custom_config.yml",
      "manimgl code.py <Scene>",
      "manim/default_config.yml",
      "custom_config.yml",
      "--config_file",
      "manimgl project/code.py --config_file /path/to/custom_config.yml"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html",
      "https://3b1b.github.io/manim/getting_started/structure.html",
      "https://3b1b.github.io/manim/getting_started/whatsnew.html",
      "https://3b1b.github.io/manim/documentation/constants.html",
      "https://3b1b.github.io/manim/documentation/custom_config.html",
      "https://3b1b.github.io/manim/development/changelog.html",
      "https://3b1b.github.io/manim/development/contributing.html",
      "https://3b1b.github.io/manim/development/about.html",
      "https://3b1b.github.io/manim/getting_started/configuration.html#cli-flags-and-configuration",
      "https://3b1b.github.io/manim/getting_started/configuration.html#command-line-interface",
      "https://3b1b.github.io/manim/getting_started/configuration.html#some-useful-flags",
      "https://3b1b.github.io/manim/getting_started/configuration.html#all-supported-flags",
      "https://3b1b.github.io/manim/getting_started/configuration.html#custom-config",
      "https://3b1b.github.io/manim/documentation/custom_config.html",
      "https://3b1b.github.io/manim/getting_started/configuration.html#command-line-interface",
      "https://3b1b.github.io/manim/getting_started/configuration.html#some-useful-flags",
      "https://3b1b.github.io/manim/getting_started/configuration.html#all-supported-flags",
      "https://3b1b.github.io/manim/getting_started/configuration.html#custom-config"
    ],
    "scraped_at": 1752428818.402737
  },
  "https://3b1b.github.io/manim/getting_started/example_scenes.html": {
    "url": "https://3b1b.github.io/manim/getting_started/example_scenes.html",
    "title": "Example Scenes - manim  documentation",
    "content": "Example Scenes\n¶\nAfter understanding the previous knowledge, we can understand more scenes.\nMany example scenes are given in\nexample_scenes.py\n, let’s start with\nthe simplest and one by one.\nInteractiveDevlopment\n¶\nInteractiveDevelopment\n¶\nfrom\nmanimlib\nimport\n*\nclass\nInteractiveDevelopment\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nsquare\n=\nSquare\n()\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nself\n.\nwait\n()\n# This opens an iPython terminal where you can keep writing\n# lines as if they were part of this construct method.\n# In particular, 'square', 'circle' and 'self' will all be\n# part of the local namespace in that terminal.\nself\n.\nembed\n()\n# Try copying and pasting some of the lines below into\n# the interactive shell\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nstretch\n(\n4\n,\n0\n))\nself\n.\nplay\n(\nRotate\n(\ncircle\n,\n90\n*\nDEGREES\n))\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nshift\n(\n2\n*\nRIGHT\n)\n.\nscale\n(\n0.25\n))\ntext\n=\nText\n(\n\"\"\"\nIn general, using the interactive shell\nis very helpful when developing new scenes\n\"\"\"\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\n# In the interactive shell, you can just type\n# play, add, remove, clear, wait, save_state and restore,\n# instead of self.play, self.add, self.remove, etc.\n# To interact with the window, type touch().  You can then\n# scroll in the window, or zoom by holding down 'z' while scrolling,\n# and change camera perspective by holding down 'd' while moving\n# the mouse.  Press 'r' to reset to the standard camera position.\n# Press 'q' to stop interacting with the window and go back to\n# typing new commands into the shell.\n# In principle you can customize a scene to be responsive to\n# mouse and keyboard interactions\nalways\n(\ncircle\n.\nmove_to\n,\nself\n.\nmouse_point\n)\nThis scene is similar to what we wrote in\nQuick Start\n.\nAnd how to interact has been written in the comments.\nNo more explanation here.\nAnimatingMethods\n¶\nAnimatingMethods\n¶\nclass\nAnimatingMethods\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ngrid\n=\nOldTex\n(\nr\n\"\\pi\"\n)\n.\nget_grid\n(\n10\n,\n10\n,\nheight\n=\n4\n)\nself\n.\nadd\n(\ngrid\n)\n# You can animate the application of mobject methods with the\n# \".animate\" syntax:\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nshift\n(\nLEFT\n))\n# Alternatively, you can use the older syntax by passing the\n# method and then the arguments to the scene's \"play\" function:\nself\n.\nplay\n(\ngrid\n.\nshift\n,\nLEFT\n)\n# Both of those will interpolate between the mobject's initial\n# state and whatever happens when you apply that method.\n# For this example, calling grid.shift(LEFT) would shift the\n# grid one unit to the left, but both of the previous calls to\n# \"self.play\" animate that motion.\n# The same applies for any method, including those setting colors.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_color\n(\nYELLOW\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_submobject_colors_by_gradient\n(\nBLUE\n,\nGREEN\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_height\n(\nTAU\n-\nMED_SMALL_BUFF\n))\nself\n.\nwait\n()\n# The method Mobject.apply_complex_function lets you apply arbitrary\n# complex functions, treating the points defining the mobject as\n# complex numbers.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_complex_function\n(\nnp\n.\nexp\n),\nrun_time\n=\n5\n)\nself\n.\nwait\n()\n# Even more generally, you could apply Mobject.apply_function,\n# which takes in functions form R^3 to R^3\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_function\n(\nlambda\np\n:\n[\np\n[\n0\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n1\n]),\np\n[\n1\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n0\n]),\np\n[\n2\n]\n]\n),\nrun_time\n=\n5\n,\n)\nself\n.\nwait\n()\nThe new usage in this scene is\n.get_grid()\nand\nself.play(mob.animate.method(args))\n.\n.get_grid()\nmethod will return a new mobject containing multiple copies of this one arranged in a grid.\nself.play(mob.animate.method(args))\nanimates the method, and the details are in the comments above.\nTextExample\n¶\nTextExample\n¶\nclass\nTextExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\n# To run this scene properly, you should have \"Consolas\" font in your computer\n# for full usage, you can see https://github.com/3b1b/manim/pull/680\ntext\n=\nText\n(\n\"Here is a text\"\n,\nfont\n=\n\"Consolas\"\n,\nfont_size\n=\n90\n)\ndifference\n=\nText\n(\n\"\"\"\nThe most important difference between Text and TexText is that\\n\nyou can change the font more easily, but can't use the LaTeX grammar\n\"\"\"\n,\nfont\n=\n\"Arial\"\n,\nfont_size\n=\n24\n,\n# t2c is a dict that you can choose color for different text\nt2c\n=\n{\n\"Text\"\n:\nBLUE\n,\n\"TexText\"\n:\nBLUE\n,\n\"LaTeX\"\n:\nORANGE\n}\n)\nVGroup\n(\ntext\n,\ndifference\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\nself\n.\nplay\n(\nFadeIn\n(\ndifference\n,\nUP\n))\nself\n.\nwait\n(\n3\n)\nfonts\n=\nText\n(\n\"And you can also set the font according to different words\"\n,\nfont\n=\n\"Arial\"\n,\nt2f\n=\n{\n\"font\"\n:\n\"Consolas\"\n,\n\"words\"\n:\n\"Consolas\"\n},\nt2c\n=\n{\n\"font\"\n:\nBLUE\n,\n\"words\"\n:\nGREEN\n}\n)\nfonts\n.\nset_width\n(\nFRAME_WIDTH\n-\n1\n)\nslant\n=\nText\n(\n\"And the same as slant and weight\"\n,\nfont\n=\n\"Consolas\"\n,\nt2s\n=\n{\n\"slant\"\n:\nITALIC\n},\nt2w\n=\n{\n\"weight\"\n:\nBOLD\n},\nt2c\n=\n{\n\"slant\"\n:\nORANGE\n,\n\"weight\"\n:\nRED\n}\n)\nVGroup\n(\nfonts\n,\nslant\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n0.8\n)\nself\n.\nplay\n(\nFadeOut\n(\ntext\n),\nFadeOut\n(\ndifference\n,\nshift\n=\nDOWN\n))\nself\n.\nplay\n(\nWrite\n(\nfonts\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nWrite\n(\nslant\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nText\n,\nVGroup\n,\nWrite\n,\nFadeIn\nand\nFadeOut\n.\nText\ncan create text, define fonts, etc. The usage ais clearly reflected in the above examples.\nVGroup\ncan put multiple\nVMobject\ntogether as a whole. In the example, the\n.arrange()\nmethod is called to arrange the sub-mobjects in sequence downward (\nDOWN\n), and the spacing is\nbuff\n.\nWrite\nis an animation that shows similar writing effects.\nFadeIn\nfades the object in, the second parameter indicates the direction of the fade in.\nFadeOut\nfades out the object, the second parameter indicates the direction of the fade out.\nTexTransformExample\n¶\nTexTransformExample\n¶\nclass\nTexTransformExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nto_isolate\n=\n[\n\"B\"\n,\n\"C\"\n,\n\"=\"\n,\n\"(\"\n,\n\")\"\n]\nlines\n=\nVGroup\n(\n# Passing in muliple arguments to Tex will result\n# in the same expression as if those arguments had\n# been joined together, except that the submobject\n# hierarchy of the resulting mobject ensure that the\n# Tex mobject has a subject corresponding to\n# each of these strings.  For example, the Tex mobject\n# below will have 5 subjects, corresponding to the\n# expressions [A^2, +, B^2, =, C^2]\nOldTex\n(\n\"A^2\"\n,\n\"+\"\n,\n\"B^2\"\n,\n\"=\"\n,\n\"C^2\"\n),\n# Likewise here\nOldTex\n(\n\"A^2\"\n,\n\"=\"\n,\n\"C^2\"\n,\n\"-\"\n,\n\"B^2\"\n),\n# Alternatively, you can pass in the keyword argument\n# \"isolate\" with a list of strings that should be out as\n# their own submobject.  So the line below is equivalent\n# to the commented out line below it.\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A^2\"\n,\n*\nto_isolate\n]),\n# OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\nOldTex\n(\n\"A =\n\\\\\nsqrt{(C + B)(C - B)}\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\n)\nlines\n.\narrange\n(\nDOWN\n,\nbuff\n=\nLARGE_BUFF\n)\nfor\nline\nin\nlines\n:\nline\n.\nset_color_by_tex_to_color_map\n({\n\"A\"\n:\nBLUE\n,\n\"B\"\n:\nTEAL\n,\n\"C\"\n:\nGREEN\n,\n})\nplay_kw\n=\n{\n\"run_time\"\n:\n2\n}\nself\n.\nadd\n(\nlines\n[\n0\n])\n# The animation TransformMatchingTex will line up parts\n# of the source and target which have matching tex strings.\n# Here, giving it a little path_arc makes each part sort of\n# rotate into their final positions, which feels appropriate\n# for the idea of rearranging an equation\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n0\n]\n.\ncopy\n(),\nlines\n[\n1\n],\npath_arc\n=\n90\n*\nDEGREES\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# Now, we could try this again on the next line...\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n]),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# ...and this looks nice enough, but since there's no tex\n# in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n# out to nothing while the C and B terms fade in from nothing.\n# If, however, we want the C^2 to go to C, and B^2 to go to B,\n# we can specify that with a key map.\nself\n.\nplay\n(\nFadeOut\n(\nlines\n[\n2\n]))\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n],\nkey_map\n=\n{\n\"C^2\"\n:\n\"C\"\n,\n\"B^2\"\n:\n\"B\"\n,\n}\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# And to finish off, a simple TransformMatchingShapes would work\n# just fine.  But perhaps we want that exponent on A^2 to transform into\n# the square root symbol.  At the moment, lines[2] treats the expression\n# A^2 as a unit, so we might create a new version of the same line which\n# separates out just the A.  This way, when TransformMatchingTex lines up\n# all matching parts, the only mismatch will be between the \"^2\" from\n# new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n# transform_mismatches=True, it will transform this \"^2\" part into\n# the \"\\sqrt\" part.\nnew_line2\n=\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\nnew_line2\n.\nreplace\n(\nlines\n[\n2\n])\nnew_line2\n.\nmatch_style\n(\nlines\n[\n2\n])\nself\n.\nplay\n(\nTransformMatchingTex\n(\nnew_line2\n,\nlines\n[\n3\n],\ntransform_mismatches\n=\nTrue\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n(\n3\n)\nself\n.\nplay\n(\nFadeOut\n(\nlines\n,\nRIGHT\n))\n# Alternatively, if you don't want to think about breaking up\n# the tex strings deliberately, you can TransformMatchingShapes,\n# which will try to line up all pieces of a source mobject with\n# those of a target, regardless of the submobject hierarchy in\n# each one, according to whether those pieces have the same\n# shape (as best it can).\nsource\n=\nText\n(\n\"the morse code\"\n,\nheight\n=\n1\n)\ntarget\n=\nText\n(\n\"here come dots\"\n,\nheight\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\nsource\n))\nself\n.\nwait\n()\nkw\n=\n{\n\"run_time\"\n:\n3\n,\n\"path_arc\"\n:\nPI\n/\n2\n}\nself\n.\nplay\n(\nTransformMatchingShapes\n(\nsource\n,\ntarget\n,\n**\nkw\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nTransformMatchingShapes\n(\ntarget\n,\nsource\n,\n**\nkw\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nTex\n,\nTexText\n,\nTransformMatchingTex\nand\nTransformMatchingShapes\n.\nTex\nuses LaTeX to create mathematical formulas.\nTexText\nuses LaTeX to create text.\nTransformMatchingTeX\nautomatically transforms sub-objects according to the similarities and differences of tex in\nTex\n.\nTransformMatchingShapes\nautomatically transform sub-objects directly based on the similarities and differences of the object point sets.\nUpdatersExample\n¶\nUpdatersExample\n¶\nclass\nUpdatersExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nsquare\n=\nSquare\n()\nsquare\n.\nset_fill\n(\nBLUE_E\n,\n1\n)\n# On all all frames, the constructor Brace(square, UP) will\n# be called, and the mobject brace will set its data to match\n# that of the newly constructed object\nbrace\n=\nalways_redraw\n(\nBrace\n,\nsquare\n,\nUP\n)\ntext\n,\nnumber\n=\nlabel\n=\nVGroup\n(\nText\n(\n\"Width = \"\n),\nDecimalNumber\n(\n0\n,\nshow_ellipsis\n=\nTrue\n,\nnum_decimal_places\n=\n2\n,\ninclude_sign\n=\nTrue\n,\n)\n)\nlabel\n.\narrange\n(\nRIGHT\n)\n# This ensures that the method deicmal.next_to(square)\n# is called on every frame\nalways\n(\nlabel\n.\nnext_to\n,\nbrace\n,\nUP\n)\n# You could also write the following equivalent line\n# label.add_updater(lambda m: m.next_to(brace, UP))\n# If the argument itself might change, you can use f_always,\n# for which the arguments following the initial Mobject method\n# should be functions returning arguments to that method.\n# The following line ensures that decimal.set_value(square.get_y())\n# is called every frame\nf_always\n(\nnumber\n.\nset_value\n,\nsquare\n.\nget_width\n)\n# You could also write the following equivalent line\n# number.add_updater(lambda m: m.set_value(square.get_width()))\nself\n.\nadd\n(\nsquare\n,\nbrace\n,\nlabel\n)\n# Notice that the brace and label track with the square\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nscale\n(\n2\n),\nrate_func\n=\nthere_and_back\n,\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n5\n,\nstretch\n=\nTrue\n),\nrun_time\n=\n3\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# In general, you can alway call Mobject.add_updater, and pass in\n# a function that you want to be called on every frame.  The function\n# should take in either one argument, the mobject, or two arguments,\n# the mobject and the amount of time since the last frame.\nnow\n=\nself\n.\ntime\nw0\n=\nsquare\n.\nget_width\n()\nsquare\n.\nadd_updater\n(\nlambda\nm\n:\nm\n.\nset_width\n(\nw0\n*\nmath\n.\ncos\n(\nself\n.\ntime\n-\nnow\n))\n)\nself\n.\nwait\n(\n4\n*\nPI\n)\nThe new classes and usage in this scene are\nalways_redraw()\n,\nDecimalNumber\n,\n.to_edge()\n,\n.center()\n,\nalways()\n,\nf_always()\n,\n.set_y()\nand\n.add_updater()\n.\nalways_redraw()\nfunction create a new mobject every frame.\nDecimalNumber\nis a variable number, speed it up by breaking it into\nText\ncharacters.\n.to_edge()\nmeans to place the object on the edge of the screen.\n.center()\nmeans to place the object in the center of the screen.\nalways(f,\nx)\nmeans that a certain function (\nf(x)\n) is executed every frame.\nf_always(f,\ng)\nis similar to\nalways\n, executed\nf(g())\nevery frame.\n.set_y()\nmeans to set the ordinate of the object on the screen.\n.add_updater()\nsets an update function for the object. For example:\nmob1.add_updater(lambda\nmob:\nmob.next_to(mob2))\nmeans\nmob1.next_to(mob2)\nis executed every frame.\nCoordinateSystemExample\n¶\nCoordinateSystemExample\n¶\nclass\nCoordinateSystemExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n(\n# x-axis ranges from -1 to 10, with a default step size of 1\nx_range\n=\n(\n-\n1\n,\n10\n),\n# y-axis ranges from -2 to 2 with a step size of 0.5\ny_range\n=\n(\n-\n2\n,\n2\n,\n0.5\n),\n# The axes will be stretched so as to match the specified\n# height and width\nheight\n=\n6\n,\nwidth\n=\n10\n,\n# Axes is made of two NumberLine mobjects.  You can specify\n# their configuration with axis_config\naxis_config\n=\n{\n\"stroke_color\"\n:\nGREY_A\n,\n\"stroke_width\"\n:\n2\n,\n},\n# Alternatively, you can specify configuration for just one\n# of them, like this.\ny_axis_config\n=\n{\n\"include_tip\"\n:\nFalse\n,\n}\n)\n# Keyword arguments of add_coordinate_labels can be used to\n# configure the DecimalNumber mobjects which it creates and\n# adds to the axes\naxes\n.\nadd_coordinate_labels\n(\nfont_size\n=\n20\n,\nnum_decimal_places\n=\n1\n,\n)\nself\n.\nadd\n(\naxes\n)\n# Axes descends from the CoordinateSystem class, meaning\n# you can call call axes.coords_to_point, abbreviated to\n# axes.c2p, to associate a set of coordinates with a point,\n# like so:\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\nc2p\n(\n0\n,\n0\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n5\n,\n0.5\n)))\nself\n.\nwait\n()\n# Similarly, you can call axes.point_to_coords, or axes.p2c\n# print(axes.p2c(dot.get_center()))\n# We can draw lines from the axes to better mark the coordinates\n# of a given point.\n# Here, the always_redraw command means that on each new frame\n# the lines will be redrawn\nh_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_h_line\n(\ndot\n.\nget_left\n()))\nv_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_v_line\n(\ndot\n.\nget_bottom\n()))\nself\n.\nplay\n(\nShowCreation\n(\nh_line\n),\nShowCreation\n(\nv_line\n),\n)\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n-\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n1\n,\n1\n)))\nself\n.\nwait\n()\n# If we tie the dot to a particular set of coordinates, notice\n# that as we move the axes around it respects the coordinate\n# system defined by them.\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\nc2p\n(\n1\n,\n1\n))\nself\n.\nplay\n(\naxes\n.\nanimate\n.\nscale\n(\n0.75\n)\n.\nto_corner\n(\nUL\n),\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nFadeOut\n(\nVGroup\n(\naxes\n,\ndot\n,\nh_line\n,\nv_line\n)))\n# Other coordinate systems you can play around with include\n# ThreeDAxes, NumberPlane, and ComplexPlane.\nGraphExample\n¶\nGraphExample\n¶\nclass\nGraphExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n((\n-\n3\n,\n10\n),\n(\n-\n1\n,\n8\n))\naxes\n.\nadd_coordinate_labels\n()\nself\n.\nplay\n(\nWrite\n(\naxes\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n1\n))\n# Axes.get_graph will return the graph of a function\nsin_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2\n*\nmath\n.\nsin\n(\nx\n),\ncolor\n=\nBLUE\n,\n)\n# By default, it draws it so as to somewhat smoothly interpolate\n# between sampled points (x, f(x)).  If the graph is meant to have\n# a corner, though, you can set use_smoothing to False\nrelu_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\nmax\n(\nx\n,\n0\n),\nuse_smoothing\n=\nFalse\n,\ncolor\n=\nYELLOW\n,\n)\n# For discontinuous functions, you can specify the point of\n# discontinuity so that it does not try to draw over the gap.\nstep_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2.0\nif\nx\n>\n3\nelse\n1.0\n,\ndiscontinuities\n=\n[\n3\n],\ncolor\n=\nGREEN\n,\n)\n# Axes.get_graph_label takes in either a string or a mobject.\n# If it's a string, it treats it as a LaTeX expression.  By default\n# it places the label next to the graph near the right side, and\n# has it match the color of the graph\nsin_label\n=\naxes\n.\nget_graph_label\n(\nsin_graph\n,\n\"\n\\\\\nsin(x)\"\n)\nrelu_label\n=\naxes\n.\nget_graph_label\n(\nrelu_graph\n,\nText\n(\n\"ReLU\"\n))\nstep_label\n=\naxes\n.\nget_graph_label\n(\nstep_graph\n,\nText\n(\n\"Step\"\n),\nx\n=\n4\n)\nself\n.\nplay\n(\nShowCreation\n(\nsin_graph\n),\nFadeIn\n(\nsin_label\n,\nRIGHT\n),\n)\nself\n.\nwait\n(\n2\n)\nself\n.\nplay\n(\nReplacementTransform\n(\nsin_graph\n,\nrelu_graph\n),\nFadeTransform\n(\nsin_label\n,\nrelu_label\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nReplacementTransform\n(\nrelu_graph\n,\nstep_graph\n),\nFadeTransform\n(\nrelu_label\n,\nstep_label\n),\n)\nself\n.\nwait\n()\nparabola\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n0.25\n*\nx\n**\n2\n)\nparabola\n.\nset_stroke\n(\nBLUE\n)\nself\n.\nplay\n(\nFadeOut\n(\nstep_graph\n),\nFadeOut\n(\nstep_label\n),\nShowCreation\n(\nparabola\n)\n)\nself\n.\nwait\n()\n# You can use axes.input_to_graph_point, abbreviated\n# to axes.i2gp, to find a particular point on a graph\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\ni2gp\n(\n2\n,\nparabola\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\n# A value tracker lets us animate a parameter, usually\n# with the intent of having other mobjects update based\n# on the parameter\nx_tracker\n=\nValueTracker\n(\n2\n)\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\ni2gp\n(\nx_tracker\n.\nget_value\n(),\nparabola\n)\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n4\n),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n-\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\nSurfaceExample\n¶\nSurfaceExample\n¶\nclass\nSurfaceExample\n(\nScene\n):\nCONFIG\n=\n{\n\"camera_class\"\n:\nThreeDCamera\n,\n}\ndef\nconstruct\n(\nself\n):\nsurface_text\n=\nText\n(\n\"For 3d scenes, try using surfaces\"\n)\nsurface_text\n.\nfix_in_frame\n()\nsurface_text\n.\nto_edge\n(\nUP\n)\nself\n.\nadd\n(\nsurface_text\n)\nself\n.\nwait\n(\n0.1\n)\ntorus1\n=\nTorus\n(\nr1\n=\n1\n,\nr2\n=\n1\n)\ntorus2\n=\nTorus\n(\nr1\n=\n3\n,\nr2\n=\n1\n)\nsphere\n=\nSphere\n(\nradius\n=\n3\n,\nresolution\n=\ntorus1\n.\nresolution\n)\n# You can texture a surface with up to two images, which will\n# be interpreted as the side towards the light, and away from\n# the light.  These can be either urls, or paths to a local file\n# in whatever you've set as the image directory in\n# the custom_config.yml file\n# day_texture = \"EarthTextureMap\"\n# night_texture = \"NightEarthTextureMap\"\nday_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\nnight_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\nsurfaces\n=\n[\nTexturedSurface\n(\nsurface\n,\nday_texture\n,\nnight_texture\n)\nfor\nsurface\nin\n[\nsphere\n,\ntorus1\n,\ntorus2\n]\n]\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nshift\n(\nIN\n)\nmob\n.\nmesh\n=\nSurfaceMesh\n(\nmob\n)\nmob\n.\nmesh\n.\nset_stroke\n(\nBLUE\n,\n1\n,\nopacity\n=\n0.5\n)\n# Set perspective\nframe\n=\nself\n.\ncamera\n.\nframe\nframe\n.\nset_euler_angles\n(\ntheta\n=-\n30\n*\nDEGREES\n,\nphi\n=\n70\n*\nDEGREES\n,\n)\nsurface\n=\nsurfaces\n[\n0\n]\nself\n.\nplay\n(\nFadeIn\n(\nsurface\n),\nShowCreation\n(\nsurface\n.\nmesh\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n3\n),\n)\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nadd\n(\nmob\n.\nmesh\n)\nsurface\n.\nsave_state\n()\nself\n.\nplay\n(\nRotate\n(\nsurface\n,\nPI\n/\n2\n),\nrun_time\n=\n2\n)\nfor\nmob\nin\nsurfaces\n[\n1\n:]:\nmob\n.\nrotate\n(\nPI\n/\n2\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n1\n]),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n2\n]),\n# Move camera frame during the transition\nframe\n.\nanimate\n.\nincrement_phi\n(\n-\n10\n*\nDEGREES\n),\nframe\n.\nanimate\n.\nincrement_theta\n(\n-\n20\n*\nDEGREES\n),\nrun_time\n=\n3\n)\n# Add ambient rotation\nframe\n.\nadd_updater\n(\nlambda\nm\n,\ndt\n:\nm\n.\nincrement_theta\n(\n-\n0.1\n*\ndt\n))\n# Play around with where the light is\nlight_text\n=\nText\n(\n\"You can move around the light source\"\n)\nlight_text\n.\nmove_to\n(\nsurface_text\n)\nlight_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nsurface_text\n,\nlight_text\n))\nlight\n=\nself\n.\ncamera\n.\nlight_source\nself\n.\nadd\n(\nlight\n)\nlight\n.\nsave_state\n()\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nmove_to\n(\n3\n*\nIN\n),\nrun_time\n=\n5\n)\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nshift\n(\n10\n*\nOUT\n),\nrun_time\n=\n5\n)\ndrag_text\n=\nText\n(\n\"Try moving the mouse while pressing d or s\"\n)\ndrag_text\n.\nmove_to\n(\nlight_text\n)\ndrag_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nlight_text\n,\ndrag_text\n))\nself\n.\nwait\n()\nThis scene shows an example of using a three-dimensional surface, and\nthe related usage has been briefly described in the notes.\n.fix_in_frame()\nmakes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.\nOpeningManimExample\n¶\nOpeningManimExample\n¶\nclass\nOpeningManimExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nintro_words\n=\nText\n(\n\"\"\"\nThe original motivation for manim was to\nbetter illustrate mathematical functions\nas transformations.\n\"\"\"\n)\nintro_words\n.\nto_edge\n(\nUP\n)\nself\n.\nplay\n(\nWrite\n(\nintro_words\n))\nself\n.\nwait\n(\n2\n)\n# Linear transform\ngrid\n=\nNumberPlane\n((\n-\n10\n,\n10\n),\n(\n-\n5\n,\n5\n))\nmatrix\n=\n[[\n1\n,\n1\n],\n[\n0\n,\n1\n]]\nlinear_transform_words\n=\nVGroup\n(\nText\n(\n\"This is what the matrix\"\n),\nIntegerMatrix\n(\nmatrix\n,\ninclude_background_rectangle\n=\nTrue\n),\nText\n(\n\"looks like\"\n)\n)\nlinear_transform_words\n.\narrange\n(\nRIGHT\n)\nlinear_transform_words\n.\nto_edge\n(\nUP\n)\nlinear_transform_words\n.\nset_stroke\n(\nBLACK\n,\n10\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nShowCreation\n(\ngrid\n),\nFadeTransform\n(\nintro_words\n,\nlinear_transform_words\n)\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_matrix\n(\nmatrix\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# Complex map\nc_grid\n=\nComplexPlane\n()\nmoving_c_grid\n=\nc_grid\n.\ncopy\n()\nmoving_c_grid\n.\nprepare_for_nonlinear_transform\n()\nc_grid\n.\nset_stroke\n(\nBLUE_E\n,\n1\n)\nc_grid\n.\nadd_coordinate_labels\n(\nfont_size\n=\n24\n)\ncomplex_map_words\n=\nTexText\n(\n\"\"\"\nOr thinking of the plane as $\n\\\\\nmathds\n{C}\n$,\n\\\\\\\\\nthis is the map $z\n\\\\\nrightarrow z^2$\n\"\"\"\n)\ncomplex_map_words\n.\nto_corner\n(\nUR\n)\ncomplex_map_words\n.\nset_stroke\n(\nBLACK\n,\n5\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nFadeOut\n(\ngrid\n),\nWrite\n(\nc_grid\n,\nrun_time\n=\n3\n),\nFadeIn\n(\nmoving_c_grid\n),\nFadeTransform\n(\nlinear_transform_words\n,\ncomplex_map_words\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nmoving_c_grid\n.\nanimate\n.\napply_complex_function\n(\nlambda\nz\n:\nz\n**\n2\n),\nrun_time\n=\n6\n,\n)\nself\n.\nwait\n(\n2\n)\nThis scene is a comprehensive application of a two-dimensional scene.\nAfter seeing these scenes, you have already understood part of the\nusage of manim. For more examples, see\nthe video code of 3b1b\n.\nContents\nExample Scenes\nInteractiveDevlopment\nAnimatingMethods\nTextExample\nTexTransformExample\nUpdatersExample\nCoordinateSystemExample\nGraphExample\nSurfaceExample\nOpeningManimExample",
    "code_examples": [
      "example_scenes.py",
      "from manimlib import *\n\nclass InteractiveDevelopment(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n\n        # This opens an iPython terminal where you can keep writing\n        # lines as if they were part of this construct method.\n        # In particular, 'square', 'circle' and 'self' will all be\n        # part of the local namespace in that terminal.\n        self.embed()\n\n        # Try copying and pasting some of the lines below into\n        # the interactive shell\n        self.play(ReplacementTransform(square, circle))\n        self.wait()\n        self.play(circle.animate.stretch(4, 0))\n        self.play(Rotate(circle, 90 * DEGREES))\n        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))\n\n        text = Text(\"\"\"\n            In general, using the interactive shell\n            is very helpful when developing new scenes\n        \"\"\")\n        self.play(Write(text))\n\n        # In the interactive shell, you can just type\n        # play, add, remove, clear, wait, save_state and restore,\n        # instead of self.play, self.add, self.remove, etc.\n\n        # To interact with the window, type touch().  You can then\n        # scroll in the window, or zoom by holding down 'z' while scrolling,\n        # and change camera perspective by holding down 'd' while moving\n        # the mouse.  Press 'r' to reset to the standard camera position.\n        # Press 'q' to stop interacting with the window and go back to\n        # typing new commands into the shell.\n\n        # In principle you can customize a scene to be responsive to\n        # mouse and keyboard interactions\n        always(circle.move_to, self.mouse_point)",
      "class AnimatingMethods(Scene):\n    def construct(self):\n        grid = OldTex(r\"\\pi\").get_grid(10, 10, height=4)\n        self.add(grid)\n\n        # You can animate the application of mobject methods with the\n        # \".animate\" syntax:\n        self.play(grid.animate.shift(LEFT))\n\n        # Alternatively, you can use the older syntax by passing the\n        # method and then the arguments to the scene's \"play\" function:\n        self.play(grid.shift, LEFT)\n\n        # Both of those will interpolate between the mobject's initial\n        # state and whatever happens when you apply that method.\n        # For this example, calling grid.shift(LEFT) would shift the\n        # grid one unit to the left, but both of the previous calls to\n        # \"self.play\" animate that motion.\n\n        # The same applies for any method, including those setting colors.\n        self.play(grid.animate.set_color(YELLOW))\n        self.wait()\n        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))\n        self.wait()\n        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))\n        self.wait()\n\n        # The method Mobject.apply_complex_function lets you apply arbitrary\n        # complex functions, treating the points defining the mobject as\n        # complex numbers.\n        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)\n        self.wait()\n\n        # Even more generally, you could apply Mobject.apply_function,\n        # which takes in functions form R^3 to R^3\n        self.play(\n            grid.animate.apply_function(\n                lambda p: [\n                    p[0] + 0.5 * math.sin(p[1]),\n                    p[1] + 0.5 * math.sin(p[0]),\n                    p[2]\n                ]\n            ),\n            run_time=5,\n        )\n        self.wait()",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      "class TextExample(Scene):\n    def construct(self):\n        # To run this scene properly, you should have \"Consolas\" font in your computer\n        # for full usage, you can see https://github.com/3b1b/manim/pull/680\n        text = Text(\"Here is a text\", font=\"Consolas\", font_size=90)\n        difference = Text(\n            \"\"\"\n            The most important difference between Text and TexText is that\\n\n            you can change the font more easily, but can't use the LaTeX grammar\n            \"\"\",\n            font=\"Arial\", font_size=24,\n            # t2c is a dict that you can choose color for different text\n            t2c={\"Text\": BLUE, \"TexText\": BLUE, \"LaTeX\": ORANGE}\n        )\n        VGroup(text, difference).arrange(DOWN, buff=1)\n        self.play(Write(text))\n        self.play(FadeIn(difference, UP))\n        self.wait(3)\n\n        fonts = Text(\n            \"And you can also set the font according to different words\",\n            font=\"Arial\",\n            t2f={\"font\": \"Consolas\", \"words\": \"Consolas\"},\n            t2c={\"font\": BLUE, \"words\": GREEN}\n        )\n        fonts.set_width(FRAME_WIDTH - 1)\n        slant = Text(\n            \"And the same as slant and weight\",\n            font=\"Consolas\",\n            t2s={\"slant\": ITALIC},\n            t2w={\"weight\": BOLD},\n            t2c={\"slant\": ORANGE, \"weight\": RED}\n        )\n        VGroup(fonts, slant).arrange(DOWN, buff=0.8)\n        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))\n        self.play(Write(fonts))\n        self.wait()\n        self.play(Write(slant))\n        self.wait()",
      "class TexTransformExample(Scene):\n    def construct(self):\n        to_isolate = [\"B\", \"C\", \"=\", \"(\", \")\"]\n        lines = VGroup(\n            # Passing in muliple arguments to Tex will result\n            # in the same expression as if those arguments had\n            # been joined together, except that the submobject\n            # hierarchy of the resulting mobject ensure that the\n            # Tex mobject has a subject corresponding to\n            # each of these strings.  For example, the Tex mobject\n            # below will have 5 subjects, corresponding to the\n            # expressions [A^2, +, B^2, =, C^2]\n            OldTex(\"A^2\", \"+\", \"B^2\", \"=\", \"C^2\"),\n            # Likewise here\n            OldTex(\"A^2\", \"=\", \"C^2\", \"-\", \"B^2\"),\n            # Alternatively, you can pass in the keyword argument\n            # \"isolate\" with a list of strings that should be out as\n            # their own submobject.  So the line below is equivalent\n            # to the commented out line below it.\n            OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A^2\", *to_isolate]),\n            # OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\n            OldTex(\"A = \\\\sqrt{(C + B)(C - B)}\", isolate=[\"A\", *to_isolate])\n        )\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        for line in lines:\n            line.set_color_by_tex_to_color_map({\n                \"A\": BLUE,\n                \"B\": TEAL,\n                \"C\": GREEN,\n            })\n\n        play_kw = {\"run_time\": 2}\n        self.add(lines[0])\n        # The animation TransformMatchingTex will line up parts\n        # of the source and target which have matching tex strings.\n        # Here, giving it a little path_arc makes each part sort of\n        # rotate into their final positions, which feels appropriate\n        # for the idea of rearranging an equation\n        self.play(\n            TransformMatchingTex(\n                lines[0].copy(), lines[1],\n                path_arc=90 * DEGREES,\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # Now, we could try this again on the next line...\n        self.play(\n            TransformMatchingTex(lines[1].copy(), lines[2]),\n            **play_kw\n        )\n        self.wait()\n        # ...and this looks nice enough, but since there's no tex\n        # in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n        # out to nothing while the C and B terms fade in from nothing.\n        # If, however, we want the C^2 to go to C, and B^2 to go to B,\n        # we can specify that with a key map.\n        self.play(FadeOut(lines[2]))\n        self.play(\n            TransformMatchingTex(\n                lines[1].copy(), lines[2],\n                key_map={\n                    \"C^2\": \"C\",\n                    \"B^2\": \"B\",\n                }\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # And to finish off, a simple TransformMatchingShapes would work\n        # just fine.  But perhaps we want that exponent on A^2 to transform into\n        # the square root symbol.  At the moment, lines[2] treats the expression\n        # A^2 as a unit, so we might create a new version of the same line which\n        # separates out just the A.  This way, when TransformMatchingTex lines up\n        # all matching parts, the only mismatch will be between the \"^2\" from\n        # new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n        # transform_mismatches=True, it will transform this \"^2\" part into\n        # the \"\\sqrt\" part.\n        new_line2 = OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A\", *to_isolate])\n        new_line2.replace(lines[2])\n        new_line2.match_style(lines[2])\n\n        self.play(\n            TransformMatchingTex(\n                new_line2, lines[3],\n                transform_mismatches=True,\n            ),\n            **play_kw\n        )\n        self.wait(3)\n        self.play(FadeOut(lines, RIGHT))\n\n        # Alternatively, if you don't want to think about breaking up\n        # the tex strings deliberately, you can TransformMatchingShapes,\n        # which will try to line up all pieces of a source mobject with\n        # those of a target, regardless of the submobject hierarchy in\n        # each one, according to whether those pieces have the same\n        # shape (as best it can).\n        source = Text(\"the morse code\", height=1)\n        target = Text(\"here come dots\", height=1)\n\n        self.play(Write(source))\n        self.wait()\n        kw = {\"run_time\": 3, \"path_arc\": PI / 2}\n        self.play(TransformMatchingShapes(source, target, **kw))\n        self.wait()\n        self.play(TransformMatchingShapes(target, source, **kw))\n        self.wait()",
      "TransformMatchingTex",
      "TransformMatchingShapes",
      "TransformMatchingTeX",
      "TransformMatchingShapes",
      "class UpdatersExample(Scene):\n    def construct(self):\n        square = Square()\n        square.set_fill(BLUE_E, 1)\n\n        # On all all frames, the constructor Brace(square, UP) will\n        # be called, and the mobject brace will set its data to match\n        # that of the newly constructed object\n        brace = always_redraw(Brace, square, UP)\n\n        text, number = label = VGroup(\n            Text(\"Width = \"),\n            DecimalNumber(\n                0,\n                show_ellipsis=True,\n                num_decimal_places=2,\n                include_sign=True,\n            )\n        )\n        label.arrange(RIGHT)\n\n        # This ensures that the method deicmal.next_to(square)\n        # is called on every frame\n        always(label.next_to, brace, UP)\n        # You could also write the following equivalent line\n        # label.add_updater(lambda m: m.next_to(brace, UP))\n\n        # If the argument itself might change, you can use f_always,\n        # for which the arguments following the initial Mobject method\n        # should be functions returning arguments to that method.\n        # The following line ensures that decimal.set_value(square.get_y())\n        # is called every frame\n        f_always(number.set_value, square.get_width)\n        # You could also write the following equivalent line\n        # number.add_updater(lambda m: m.set_value(square.get_width()))\n\n        self.add(square, brace, label)\n\n        # Notice that the brace and label track with the square\n        self.play(\n            square.animate.scale(2),\n            rate_func=there_and_back,\n            run_time=2,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(5, stretch=True),\n            run_time=3,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(2),\n            run_time=3\n        )\n        self.wait()\n\n        # In general, you can alway call Mobject.add_updater, and pass in\n        # a function that you want to be called on every frame.  The function\n        # should take in either one argument, the mobject, or two arguments,\n        # the mobject and the amount of time since the last frame.\n        now = self.time\n        w0 = square.get_width()\n        square.add_updater(\n            lambda m: m.set_width(w0 * math.cos(self.time - now))\n        )\n        self.wait(4 * PI)",
      "always_redraw()",
      "DecimalNumber",
      ".add_updater()",
      "always_redraw()",
      "DecimalNumber",
      "always(f, x)",
      "f_always(f, g)",
      ".add_updater()",
      "mob1.add_updater(lambda mob: mob.next_to(mob2))",
      "mob1.next_to(mob2)",
      "class CoordinateSystemExample(Scene):\n    def construct(self):\n        axes = Axes(\n            # x-axis ranges from -1 to 10, with a default step size of 1\n            x_range=(-1, 10),\n            # y-axis ranges from -2 to 2 with a step size of 0.5\n            y_range=(-2, 2, 0.5),\n            # The axes will be stretched so as to match the specified\n            # height and width\n            height=6,\n            width=10,\n            # Axes is made of two NumberLine mobjects.  You can specify\n            # their configuration with axis_config\n            axis_config={\n                \"stroke_color\": GREY_A,\n                \"stroke_width\": 2,\n            },\n            # Alternatively, you can specify configuration for just one\n            # of them, like this.\n            y_axis_config={\n                \"include_tip\": False,\n            }\n        )\n        # Keyword arguments of add_coordinate_labels can be used to\n        # configure the DecimalNumber mobjects which it creates and\n        # adds to the axes\n        axes.add_coordinate_labels(\n            font_size=20,\n            num_decimal_places=1,\n        )\n        self.add(axes)\n\n        # Axes descends from the CoordinateSystem class, meaning\n        # you can call call axes.coords_to_point, abbreviated to\n        # axes.c2p, to associate a set of coordinates with a point,\n        # like so:\n        dot = Dot(color=RED)\n        dot.move_to(axes.c2p(0, 0))\n        self.play(FadeIn(dot, scale=0.5))\n        self.play(dot.animate.move_to(axes.c2p(3, 2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))\n        self.wait()\n\n        # Similarly, you can call axes.point_to_coords, or axes.p2c\n        # print(axes.p2c(dot.get_center()))\n\n        # We can draw lines from the axes to better mark the coordinates\n        # of a given point.\n        # Here, the always_redraw command means that on each new frame\n        # the lines will be redrawn\n        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))\n        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))\n\n        self.play(\n            ShowCreation(h_line),\n            ShowCreation(v_line),\n        )\n        self.play(dot.animate.move_to(axes.c2p(3, -2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(1, 1)))\n        self.wait()\n\n        # If we tie the dot to a particular set of coordinates, notice\n        # that as we move the axes around it respects the coordinate\n        # system defined by them.\n        f_always(dot.move_to, lambda: axes.c2p(1, 1))\n        self.play(\n            axes.animate.scale(0.75).to_corner(UL),\n            run_time=2,\n        )\n        self.wait()\n        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))\n\n        # Other coordinate systems you can play around with include\n        # ThreeDAxes, NumberPlane, and ComplexPlane.",
      "class GraphExample(Scene):\n    def construct(self):\n        axes = Axes((-3, 10), (-1, 8))\n        axes.add_coordinate_labels()\n\n        self.play(Write(axes, lag_ratio=0.01, run_time=1))\n\n        # Axes.get_graph will return the graph of a function\n        sin_graph = axes.get_graph(\n            lambda x: 2 * math.sin(x),\n            color=BLUE,\n        )\n        # By default, it draws it so as to somewhat smoothly interpolate\n        # between sampled points (x, f(x)).  If the graph is meant to have\n        # a corner, though, you can set use_smoothing to False\n        relu_graph = axes.get_graph(\n            lambda x: max(x, 0),\n            use_smoothing=False,\n            color=YELLOW,\n        )\n        # For discontinuous functions, you can specify the point of\n        # discontinuity so that it does not try to draw over the gap.\n        step_graph = axes.get_graph(\n            lambda x: 2.0 if x > 3 else 1.0,\n            discontinuities=[3],\n            color=GREEN,\n        )\n\n        # Axes.get_graph_label takes in either a string or a mobject.\n        # If it's a string, it treats it as a LaTeX expression.  By default\n        # it places the label next to the graph near the right side, and\n        # has it match the color of the graph\n        sin_label = axes.get_graph_label(sin_graph, \"\\\\sin(x)\")\n        relu_label = axes.get_graph_label(relu_graph, Text(\"ReLU\"))\n        step_label = axes.get_graph_label(step_graph, Text(\"Step\"), x=4)\n\n        self.play(\n            ShowCreation(sin_graph),\n            FadeIn(sin_label, RIGHT),\n        )\n        self.wait(2)\n        self.play(\n            ReplacementTransform(sin_graph, relu_graph),\n            FadeTransform(sin_label, relu_label),\n        )\n        self.wait()\n        self.play(\n            ReplacementTransform(relu_graph, step_graph),\n            FadeTransform(relu_label, step_label),\n        )\n        self.wait()\n\n        parabola = axes.get_graph(lambda x: 0.25 * x**2)\n        parabola.set_stroke(BLUE)\n        self.play(\n            FadeOut(step_graph),\n            FadeOut(step_label),\n            ShowCreation(parabola)\n        )\n        self.wait()\n\n        # You can use axes.input_to_graph_point, abbreviated\n        # to axes.i2gp, to find a particular point on a graph\n        dot = Dot(color=RED)\n        dot.move_to(axes.i2gp(2, parabola))\n        self.play(FadeIn(dot, scale=0.5))\n\n        # A value tracker lets us animate a parameter, usually\n        # with the intent of having other mobjects update based\n        # on the parameter\n        x_tracker = ValueTracker(2)\n        f_always(\n            dot.move_to,\n            lambda: axes.i2gp(x_tracker.get_value(), parabola)\n        )\n\n        self.play(x_tracker.animate.set_value(4), run_time=3)\n        self.play(x_tracker.animate.set_value(-2), run_time=3)\n        self.wait()",
      "class SurfaceExample(Scene):\n    CONFIG = {\n        \"camera_class\": ThreeDCamera,\n    }\n\n    def construct(self):\n        surface_text = Text(\"For 3d scenes, try using surfaces\")\n        surface_text.fix_in_frame()\n        surface_text.to_edge(UP)\n        self.add(surface_text)\n        self.wait(0.1)\n\n        torus1 = Torus(r1=1, r2=1)\n        torus2 = Torus(r1=3, r2=1)\n        sphere = Sphere(radius=3, resolution=torus1.resolution)\n        # You can texture a surface with up to two images, which will\n        # be interpreted as the side towards the light, and away from\n        # the light.  These can be either urls, or paths to a local file\n        # in whatever you've set as the image directory in\n        # the custom_config.yml file\n\n        # day_texture = \"EarthTextureMap\"\n        # night_texture = \"NightEarthTextureMap\"\n        day_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\n        night_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\n\n        surfaces = [\n            TexturedSurface(surface, day_texture, night_texture)\n            for surface in [sphere, torus1, torus2]\n        ]\n\n        for mob in surfaces:\n            mob.shift(IN)\n            mob.mesh = SurfaceMesh(mob)\n            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)\n\n        # Set perspective\n        frame = self.camera.frame\n        frame.set_euler_angles(\n            theta=-30 * DEGREES,\n            phi=70 * DEGREES,\n        )\n\n        surface = surfaces[0]\n\n        self.play(\n            FadeIn(surface),\n            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),\n        )\n        for mob in surfaces:\n            mob.add(mob.mesh)\n        surface.save_state()\n        self.play(Rotate(surface, PI / 2), run_time=2)\n        for mob in surfaces[1:]:\n            mob.rotate(PI / 2)\n\n        self.play(\n            Transform(surface, surfaces[1]),\n            run_time=3\n        )\n\n        self.play(\n            Transform(surface, surfaces[2]),\n            # Move camera frame during the transition\n            frame.animate.increment_phi(-10 * DEGREES),\n            frame.animate.increment_theta(-20 * DEGREES),\n            run_time=3\n        )\n        # Add ambient rotation\n        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))\n\n        # Play around with where the light is\n        light_text = Text(\"You can move around the light source\")\n        light_text.move_to(surface_text)\n        light_text.fix_in_frame()\n\n        self.play(FadeTransform(surface_text, light_text))\n        light = self.camera.light_source\n        self.add(light)\n        light.save_state()\n        self.play(light.animate.move_to(3 * IN), run_time=5)\n        self.play(light.animate.shift(10 * OUT), run_time=5)\n\n        drag_text = Text(\"Try moving the mouse while pressing d or s\")\n        drag_text.move_to(light_text)\n        drag_text.fix_in_frame()\n\n        self.play(FadeTransform(light_text, drag_text))\n        self.wait()",
      ".fix_in_frame()",
      "class OpeningManimExample(Scene):\n    def construct(self):\n        intro_words = Text(\"\"\"\n            The original motivation for manim was to\n            better illustrate mathematical functions\n            as transformations.\n        \"\"\")\n        intro_words.to_edge(UP)\n\n        self.play(Write(intro_words))\n        self.wait(2)\n\n        # Linear transform\n        grid = NumberPlane((-10, 10), (-5, 5))\n        matrix = [[1, 1], [0, 1]]\n        linear_transform_words = VGroup(\n            Text(\"This is what the matrix\"),\n            IntegerMatrix(matrix, include_background_rectangle=True),\n            Text(\"looks like\")\n        )\n        linear_transform_words.arrange(RIGHT)\n        linear_transform_words.to_edge(UP)\n        linear_transform_words.set_stroke(BLACK, 10, background=True)\n\n        self.play(\n            ShowCreation(grid),\n            FadeTransform(intro_words, linear_transform_words)\n        )\n        self.wait()\n        self.play(grid.animate.apply_matrix(matrix), run_time=3)\n        self.wait()\n\n        # Complex map\n        c_grid = ComplexPlane()\n        moving_c_grid = c_grid.copy()\n        moving_c_grid.prepare_for_nonlinear_transform()\n        c_grid.set_stroke(BLUE_E, 1)\n        c_grid.add_coordinate_labels(font_size=24)\n        complex_map_words = TexText(\"\"\"\n            Or thinking of the plane as $\\\\mathds{C}$,\\\\\\\\\n            this is the map $z \\\\rightarrow z^2$\n        \"\"\")\n        complex_map_words.to_corner(UR)\n        complex_map_words.set_stroke(BLACK, 5, background=True)\n\n        self.play(\n            FadeOut(grid),\n            Write(c_grid, run_time=3),\n            FadeIn(moving_c_grid),\n            FadeTransform(linear_transform_words, complex_map_words),\n        )\n        self.wait()\n        self.play(\n            moving_c_grid.animate.apply_complex_function(lambda z: z**2),\n            run_time=6,\n        )\n        self.wait(2)"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/structure.html",
      "https://3b1b.github.io/manim/getting_started/whatsnew.html",
      "https://3b1b.github.io/manim/documentation/constants.html",
      "https://3b1b.github.io/manim/documentation/custom_config.html",
      "https://3b1b.github.io/manim/development/changelog.html",
      "https://3b1b.github.io/manim/development/contributing.html",
      "https://3b1b.github.io/manim/development/about.html",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#example-scenes",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevlopment",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevelopment",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#animatingmethods",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#animatingmethods",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevlopment",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#animatingmethods",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample"
    ],
    "scraped_at": 1752428819.5908322
  },
  "https://3b1b.github.io/manim/getting_started/structure.html": {
    "url": "https://3b1b.github.io/manim/getting_started/structure.html",
    "title": "Manim’s structure - manim  documentation",
    "content": "Manim’s structure\n¶\nManim’s directory structure\n¶\nThe manim directory looks very complicated, with a lot of files,\nbut the structure is clear.\nBelow is the directory structure of manim:\nmanimlib/ # manim library\n├── __init__.py\n├── __main__.py\n├── default_config.yml   # Default configuration file\n├── config.py            # Process CLI flags\n├── constants.py         # Defined some constants\n├── extract_scene.py     # Extract and run the scene\n├── shader_wrapper.py    # Shaders' Wrapper for convenient control\n├── window.py            # Playback window\n├── tex_templates/ # Templates preset for LaTeX\n│   ├── tex_templates.tex   # Tex template (will be compiled with latex, default)\n│   └── ctex_templates.tex  # Tex template that support Chinese (will be compiled with xelatex)\n├── camera/\n│   └── camera.py        # Including Camera and CameraFrame\n├── scene/\n│   ├── scene_file_writer.py     # Used to write scene to video file\n│   ├── scene.py                 # The basic Scene class\n│   ├── three_d_scene.py         # Three-dimensional scene\n│   ├── sample_space_scene.py    # Probability related sample space scene\n│   └── vector_space_scene.py    # Vector field scene\n├── animation/\n│   ├── animation.py     # The basic class of animation\n│   ├── composition.py   # Animation group\n│   ├── creation.py      # Animation related to Create\n│   ├── fading.py        # Fade related animation\n│   ├── growing.py       # Animation related to Grow\n│   ├── indication.py    # Some animations for emphasis\n│   ├── movement.py      # Animation related to movement\n│   ├── numbers.py       # Realize changes to DecimalNumber\n│   ├── rotation.py      # Animation related to rotation\n│   ├── specialized.py   # Some uncommon animations for special projects\n│   ├── transform_matching_parts.py # Transform which can automatically match parts\n│   ├── transform.py     # Some Transforms\n│   └── update.py        # Realize update from function\n├── mobject/\n│   ├── mobject.py       # The basic class of all math object\n│   ├── types/ # 4 types of mobject\n│   │   ├── dot_cloud.py            # Dot cloud (an subclass of PMobject)\n│   │   ├── image_mobject.py        # Insert pictures\n│   │   ├── point_cloud_mobject.py  # PMobject (mobject composed of points)\n│   │   ├── surface.py              # ParametricSurface\n│   │   └── vectorized_mobject.py   # VMobject (vectorized mobject)\n│   ├── svg/ # mobject related to svg\n│   │   ├── svg_mobject.py          # SVGMobject\n│   │   ├── brace.py                # Brace\n│   │   ├── drawings.py             # Some special mobject of svg image\n│   │   ├── tex_mobject.py          # Tex and TexText implemented by LaTeX\n│   │   └── text_mobject.py         # Text implemented by manimpango\n│   ├── changing.py             # Dynamically changing mobject\n│   ├── coordinate_systems.py   # coordinate system\n│   ├── frame.py                # mobject related to frame\n│   ├── functions.py            # ParametricFunction\n│   ├── geometry.py             # geometry mobjects\n│   ├── matrix.py               # matrix\n│   ├── mobject_update_utils.py # some defined updater\n│   ├── number_line.py          # Number line\n│   ├── numbers.py              # Numbers that can be changed\n│   ├── probability.py          # mobject related to probability\n│   ├── shape_matchers.py       # mobject adapted to the size of other objects\n│   ├── three_dimensions.py     # Three-dimensional objects\n│   ├── value_tracker.py        # ValueTracker which storage number\n│   └── vector_field.py         # VectorField\n├── once_useful_constructs/  # 3b1b's Common scenes written for some videos\n│   └── ...\n├── shaders/ # GLSL scripts for rendering\n│   ├── simple_vert.glsl    # a simple glsl script for position\n│   ├── insert/ # glsl scripts to be inserted in other glsl scripts\n│   │   ├── NOTE.md   # explain how to insert glsl scripts\n│   │   └── ...       # useful scripts\n│   ├── image/ # glsl for images\n│   │   └── ... # containing shaders for vertex and fragment\n│   ├── quadratic_bezier_fill/ # glsl for the fill of quadratic bezier curve\n│   │   └── ... # containing shaders for vertex, fragment and geometry\n│   ├── quadratic_bezier_stroke/ # glsl for the stroke of quadratic bezier curve\n│   │   └── ... # containing shaders for vertex, fragment and geometry\n│   ├── surface/ # glsl for surfaces\n│   │   └── ... # containing shaders for vertex and fragment\n│   ├── textured_surface/ # glsl for textured_surface\n│   │   └── ... # containing shaders for vertex and fragment\n│   └── true_dot/ # glsl for a dot\n│       └── ... # containing shaders for vertex, fragment and geometry\n└── utils/ # Some useful utility functions\n    ├── bezier.py             # For bezier curve\n    ├── color.py              # For color\n    ├── dict_ops.py           # Functions related to dictionary processing\n    ├── customization.py      # Read from custom_config.yml\n    ├── debug.py              # Utilities for debugging in program\n    ├── directories.py        # Read directories from config file\n    ├── family_ops.py         # Process family members\n    ├── file_ops.py           # Process files and directories\n    ├── images.py             # Read image\n    ├── init_config.py        # Configuration guide\n    ├── iterables.py          # Functions related to list/dictionary processing\n    ├── paths.py              # Curve path\n    ├── rate_functions.py     # Some defined rate_functions\n    ├── simple_functions.py   # Some commonly used functions\n    ├── sounds.py             # Process sounds\n    ├── space_ops.py          # Space coordinate calculation\n    ├── strings.py            # Process strings\n    └── tex_file_writing.py   # Use LaTeX to write strings as svg\nInheritance structure of manim’s classes\n¶\nHere\nis a pdf showed inheritance structure of manim’s classes, large,\nbut basically all classes have included:\nManim execution process\n¶\nContents\nManim’s structure\nManim’s directory structure\nInheritance structure of manim’s classes\nManim execution process",
    "code_examples": [
      "manimlib/ # manim library\n├── __init__.py\n├── __main__.py\n├── default_config.yml   # Default configuration file\n├── config.py            # Process CLI flags\n├── constants.py         # Defined some constants\n├── extract_scene.py     # Extract and run the scene\n├── shader_wrapper.py    # Shaders' Wrapper for convenient control\n├── window.py            # Playback window\n├── tex_templates/ # Templates preset for LaTeX\n│   ├── tex_templates.tex   # Tex template (will be compiled with latex, default)\n│   └── ctex_templates.tex  # Tex template that support Chinese (will be compiled with xelatex)\n├── camera/\n│   └── camera.py        # Including Camera and CameraFrame\n├── scene/\n│   ├── scene_file_writer.py     # Used to write scene to video file\n│   ├── scene.py                 # The basic Scene class\n│   ├── three_d_scene.py         # Three-dimensional scene\n│   ├── sample_space_scene.py    # Probability related sample space scene\n│   └── vector_space_scene.py    # Vector field scene\n├── animation/\n│   ├── animation.py     # The basic class of animation\n│   ├── composition.py   # Animation group\n│   ├── creation.py      # Animation related to Create\n│   ├── fading.py        # Fade related animation\n│   ├── growing.py       # Animation related to Grow\n│   ├── indication.py    # Some animations for emphasis\n│   ├── movement.py      # Animation related to movement\n│   ├── numbers.py       # Realize changes to DecimalNumber\n│   ├── rotation.py      # Animation related to rotation\n│   ├── specialized.py   # Some uncommon animations for special projects\n│   ├── transform_matching_parts.py # Transform which can automatically match parts\n│   ├── transform.py     # Some Transforms\n│   └── update.py        # Realize update from function\n├── mobject/\n│   ├── mobject.py       # The basic class of all math object\n│   ├── types/ # 4 types of mobject\n│   │   ├── dot_cloud.py            # Dot cloud (an subclass of PMobject)\n│   │   ├── image_mobject.py        # Insert pictures\n│   │   ├── point_cloud_mobject.py  # PMobject (mobject composed of points)\n│   │   ├── surface.py              # ParametricSurface\n│   │   └── vectorized_mobject.py   # VMobject (vectorized mobject)\n│   ├── svg/ # mobject related to svg\n│   │   ├── svg_mobject.py          # SVGMobject\n│   │   ├── brace.py                # Brace\n│   │   ├── drawings.py             # Some special mobject of svg image\n│   │   ├── tex_mobject.py          # Tex and TexText implemented by LaTeX\n│   │   └── text_mobject.py         # Text implemented by manimpango\n│   ├── changing.py             # Dynamically changing mobject\n│   ├── coordinate_systems.py   # coordinate system\n│   ├── frame.py                # mobject related to frame\n│   ├── functions.py            # ParametricFunction\n│   ├── geometry.py             # geometry mobjects\n│   ├── matrix.py               # matrix\n│   ├── mobject_update_utils.py # some defined updater\n│   ├── number_line.py          # Number line\n│   ├── numbers.py              # Numbers that can be changed\n│   ├── probability.py          # mobject related to probability\n│   ├── shape_matchers.py       # mobject adapted to the size of other objects\n│   ├── three_dimensions.py     # Three-dimensional objects\n│   ├── value_tracker.py        # ValueTracker which storage number\n│   └── vector_field.py         # VectorField\n├── once_useful_constructs/  # 3b1b's Common scenes written for some videos\n│   └── ...\n├── shaders/ # GLSL scripts for rendering\n│   ├── simple_vert.glsl    # a simple glsl script for position\n│   ├── insert/ # glsl scripts to be inserted in other glsl scripts\n│   │   ├── NOTE.md   # explain how to insert glsl scripts\n│   │   └── ...       # useful scripts\n│   ├── image/ # glsl for images\n│   │   └── ... # containing shaders for vertex and fragment\n│   ├── quadratic_bezier_fill/ # glsl for the fill of quadratic bezier curve\n│   │   └── ... # containing shaders for vertex, fragment and geometry\n│   ├── quadratic_bezier_stroke/ # glsl for the stroke of quadratic bezier curve\n│   │   └── ... # containing shaders for vertex, fragment and geometry\n│   ├── surface/ # glsl for surfaces\n│   │   └── ... # containing shaders for vertex and fragment\n│   ├── textured_surface/ # glsl for textured_surface\n│   │   └── ... # containing shaders for vertex and fragment\n│   └── true_dot/ # glsl for a dot\n│       └── ... # containing shaders for vertex, fragment and geometry\n└── utils/ # Some useful utility functions\n    ├── bezier.py             # For bezier curve\n    ├── color.py              # For color\n    ├── dict_ops.py           # Functions related to dictionary processing\n    ├── customization.py      # Read from custom_config.yml\n    ├── debug.py              # Utilities for debugging in program\n    ├── directories.py        # Read directories from config file\n    ├── family_ops.py         # Process family members\n    ├── file_ops.py           # Process files and directories\n    ├── images.py             # Read image\n    ├── init_config.py        # Configuration guide\n    ├── iterables.py          # Functions related to list/dictionary processing\n    ├── paths.py              # Curve path\n    ├── rate_functions.py     # Some defined rate_functions\n    ├── simple_functions.py   # Some commonly used functions\n    ├── sounds.py             # Process sounds\n    ├── space_ops.py          # Space coordinate calculation\n    ├── strings.py            # Process strings\n    └── tex_file_writing.py   # Use LaTeX to write strings as svg"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/whatsnew.html",
      "https://3b1b.github.io/manim/documentation/constants.html",
      "https://3b1b.github.io/manim/documentation/custom_config.html",
      "https://3b1b.github.io/manim/development/changelog.html",
      "https://3b1b.github.io/manim/development/contributing.html",
      "https://3b1b.github.io/manim/development/about.html",
      "https://3b1b.github.io/manim/getting_started/structure.html#manim-s-structure",
      "https://3b1b.github.io/manim/getting_started/structure.html#manim-s-directory-structure",
      "https://3b1b.github.io/manim/getting_started/structure.html#inheritance-structure-of-manim-s-classes",
      "https://3b1b.github.io/manim/getting_started/structure.html#manim-execution-process",
      "https://3b1b.github.io/manim/getting_started/structure.html#manim-s-directory-structure",
      "https://3b1b.github.io/manim/getting_started/structure.html#inheritance-structure-of-manim-s-classes",
      "https://3b1b.github.io/manim/getting_started/structure.html#manim-execution-process"
    ],
    "scraped_at": 1752428820.7334442
  },
  "https://3b1b.github.io/manim/getting_started/whatsnew.html": {
    "url": "https://3b1b.github.io/manim/getting_started/whatsnew.html",
    "title": "What’s new - manim  documentation",
    "content": "What’s new\n¶\nUsage changes of new version manim\n¶\nThere are many changes in the new version of manim, and here are only the changes that\nmay have an impact at the code writing level.\nSome of the changes here may not have any major impact on the use, and some changes\nthat affect the use are not mentioned below.\nThis document is for reference only, see the source code for details.\nAnimation\nAdded\nFade\nas the parent class of\nFadeIn\nand\nFadeOut\nFadeIn\nand\nFadeOut\ncan be passed in\nshift\nand\nscale\nparameters\nDeleted\nFadeInFrom,\nFadeInFromDown,\nFadeOutAndShift,\nFadeOutAndShiftDown,\nFadeInFromLarge\n, these can be used\nFadeIn,\nFadeOut\nto achieve the same effect more easily\nAdded\nFadeTransform\nto cross fade between two objects, and subclass\nFadeTransformPieces\nAdded\nCountInFrom(decimal_mob,\nsource_number=0)\nto count\ndecimal_mob\nfrom\nsource_number\nto the current value\nRotating\ncan directly pass in\nangle\nand\naxis\nwithout writing keywords\nangle=,\naxis=\nRotate\nhas become a subclass of\nRotating\n, and the distortion effect in\nTransform\nwill not appear\nRemoved\nMoveCar\nanimation\nAdded\nTransformMatchingShapes(mobject,\ntarget_mobject)\nand\nTransformMatchingTex(mobject,\ntarget_mobject)\nCamera\nRemoved all camera classes except\nCamera\n(\nMappingCamera\n,\nMovingCamera\n,\nMultiCamera\n) and all functions in\nThreeDCamera\nImplemented\nCameraFrame\n(as a\nMobject\n)\nCan be called by\nself.camera.frame\nin\nScene\nAll methods of\nMobject\ncan be used, such as\n.shift()\n,\n.scale()\n, etc.\nCall\n.to_default_state()\nto place in the default position\nSet the Euler angles of the camera by\n.set_euler_angles(theta,\nphi,\ngamma)\nSet three single Euler angles by\n.set_theta(theta)\n,\n.set_phi(phi)\n,\n.set_gamma(gamma)\nUse\n.increment_theta(dtheta)\n,\n.increment_phi(dphi)\n,\n.increment_gamma(gamma)\nto increase the three Euler angles by a certain value. Can be used to realize automatic rotation\nself.camera.frame.add_updater(lambda\nmob,\ndt:\nmob.increment_theta(0.1\n*\ndt))\nCamera\nadds a light source, which is a\nPoint\n, which can be called by\nself.camera.light_source\nin\nScene\nto move and so on. The default position is\n(-\n10,\n10,\n10)\nDelete\nContainer\nMobject\nsvg\nrelated\nAdded\nCheckmark\nand\nExmark\nSome unnecessary classes have been removed from\ndrawings.py\nRemoved\nCode\nand\nParagraph\n(by mistake)\nTexMobject\nis renamed to\nTex\n,\nTextMobject\nis renamed to\nTexText\nfont_size\nhas been added to\nTex\n,\nTexText\nand\nText\nTex\nand\nTexText\nadded\nisolate\n, which is a list, which will be automatically split\nMobject\ntypes\nAdded a new class\nSurface\n, which is the parent class of\nParametricSurface\nand\nTexturedSurface\n.\nAdded the group\nSGroup\nfor\nSurface\nAdded\nTexturedSurface(uv_surface,\nimage_file,\ndark_image_file=None)\n, where\nuv_surface\nis a\nSurface\n,\nimage_file\nis the image to be posted, and\ndark_image_file\nis the image to be posted in the dark (default and\nimage_file\nis the same)\nDeleted\nMobject1D\n,\nMobject2D\n,\nPointCloudDot\nAdded\nDotCloud\n(a\nPMobject\n), which has been greatly optimized\nRemoved\nAbstractImageMobject\n,\nImageMobjectFromCamera\nRemoved\nsheen\nfrom\nVMobject\nMobject\nAdded\ngloss\nand\nshadow\n, which are the numbers between\n[0,\n1]\nrespectively. There are four methods of\n.get_gloss()\n,\n.set_gloss(gloss)\n,\n.get_shadow()\n,\n.set_shadow(shadow)\nAdded\n.get_grid(n_rows,\nn_cols)\nto copy into grid\nAdded\n.set_color_by_code(glsl_code)\nto use GLSL code to change the color\nAdded\n.set_color_by_xyz_func(glsl_snippet,\nmin_value=-5.0,\nmax_value=5.0,\ncolormap=\"viridis\")\nto pass in GLSL expression in the form of\nx,y,z\n, the return value should be a floating point number\nCoordinate system (including\nAxes\n,\nThreeDAxes\n,\nNumberPlane\n,\nComplexPlane\n)\nNo longer use\nx_min\n,\nx_max\n,\ny_min\n,\ny_max\n, but use\nx_range\n,\ny_range\nas a\nnp.array()\n, containing three numbers\nnp.array([\nMinimum,\nmaximum,\nstep\nsize])\nAdded the abbreviation\n.i2gp(x,\ngraph)\nof\n.input_to_graph_point(x,\ngraph)\nAdded some functions of the original\nGraphScene\nAdded\n.get_v_line(point)\n,\n.get_h_line(point)\nto return the line from\npoint\nto the two coordinate axes, and specify the line type through the keyword argument of\nline_func\n(default\nDashedLine\n)\nAdded\n.get_graph_label(graph,\nlabel,\nx,\ndirection,\nbuff,\ncolor)\nto return the label added to the image\nAdded\n.get_v_line_to_graph(x,\ngraph)\n,\n.get_h_line_to_graph(x,\ngraph)\nto return the line from the point with the abscissa of\nx\non the\ngraph\nto the two- axis line\nAdded\n.angle_of_tangent(x,\ngraph,\ndx=EPSILON)\n, returns the inclination angle of\ngraph\nat\nx\nAdded\n.slope_of_tangent(x,\ngraph,\ndx=EPSILON)\n, returns the slope of tangent line of\ngraph\nat\nx\nAdded\n.get_tangent_line(x,\ngraph,\nlength=5)\nto return the tangent line of\ngraph\nat\nx\nAdded\n.get_riemann_rectangles(graph,\nx_range,\ndx,\ninput_sample_type,\n...)\nto return Riemann rectangles (a\nVGroup\n)\nThe attribute\nnumber_line_config\nof\nAxes\nis renamed to\naxis_config\nAxes\noriginal\n.get_coordinate_labels(x_values,\ny_values)\nmethod was renamed to\n.add_coordinate_labels(x_values,\ny_values)\n(but it is not added to the screen)\n.add_coordinate_labels(numbers)\nof\nComplexPlane\nwill directly add the coordinates to the screen\nNumberLine\nNo longer use\nx_min\n,\nx_max\n,\ntick_frequency\n, but use\nx_range\n, which is an array containing three numbers\n[min,\nmax,\nstep]\nThe original\nlabel_direction\nattribute changed to the\nline_to_number_direction\nattribute\nReplace\ntip_width\nand\ntip_height\nwith\ntip_config\n(dictionary) attributes\nThe original\nexclude_zero_from_default\nattribute is modified to the\nnumbers_to_exclude\nattribute (default is None)\nThe original\n.add_tick_marks()\nmethod was changed to the\n.add_ticks()\nmethod\nDelete the\n.get_number_mobjects(*numbers)\nmethod, only use the\n.add_numbers(x_values=None,\nexcluding=None)\nmethod\nThree-dimensional objects\nAdded\nSurfaceMesh(uv_surface)\n, pass in a\nSurface\nto generate its uv mesh\nParametricSurface\nno longer uses\nu_min,\nu_max,\nv_min,\nv_max\n, but instead uses\nu_range,\nv_range\n, which is a tuple (\n(min,\nmax)\n), and\nresolution\ncan be set larger, don’t worry Speed ​​issue\nAdded\nTorus\n, controlled by\nr1,\nr2\nkeyword parameters\nAdded\nCylinder\n, controlled by\nheight,\nradius\nkeyword parameters\nAdded\nLine3D\n(extremely thin cylinder), controlled by the\nwidth\nkeyword parameter\nAdded\nDisk3D\n, controlled by\nradius\nkeyword parameter\nAdd\nSquare3D\n, controlled by\nside_length\nkeyword parameter\nImproved\nCube\nand\nPrism\n, the usage remains unchanged\nOther objects\nParametricFunction\nis renamed to\nParametricCurve\n. Instead of using\nt_min,\nt_max,\nstep_size\n, use\nt_range\n, which is an array of three numbers (\n[t_min,\nt_max,\nstep_size]\n).\ndt\nwas renamed to\nepsilon\n. Other usage remains unchanged\nAll\nTipableVMobject\ncan pass in\ntip_length\nto control the style of\ntip\nLine\nadds\n.set_points_by_ends(start,\nend,\nbuff=0,\npath_arc=0)\nmethod\nLine\nadded\n.get_projection(point)\nto return the projection position of\npoint\non a straight line\nArrow\nadds three attributes of\nthickness,\ntip_width_ratio,\ntip_angle\nCubicBezier\nis changed to\na0,\nh0,\nh1,\na1\n, that is, only a third-order Bezier curve is supported\nSquare\ncan be initialized directly by passing in\nside_length\ninstead of using the keyword\nside_length=\nalways_redraw(func,\n*args,\n**kwargs)\nsupports incoming parameters\n*args,\n**kwargs\nThe\ndigit_to_digit_buff\nproperty of\nDecimalNumber\nhas been renamed to\ndigit_buff_per_font_unit\n, and the\n.scale()\nmethod has been improved\nValueTracker\nadds\nvalue_type\nattribute, the default is\nnp.float64\nScene\nRemoved all functions of\nGraphScene\n(moved to\nonce_useful_constructs\n),\nMovingCameraScene\n,\nReconfigurableScene\n,\nSceneFromVideo\n,\nZoomedScene\n, and\nThreeDScene\n. Because these can basically be achieved by adjusting\nCameraFrame\n(\nself.camera.frame\n)\nCurrently\nSampleSpaceScene\nand\nVectorScene\nhave not been changed for the new version, so it is not recommended to use (only\nScene\nis recommended)\nFix the export of gif, just use the\n-i\noption directly\nAdded the\n.interact()\nmethod, during which the mouse and keyboard can be used to continue the interaction, which will be executed by default after the scene ends\nAdded\n.embed()\nmethod, open iPython terminal to enter interactive mode\nAdded\n.save_state()\nmethod to save the current state of the scene\nAdded\n.restore()\nmethod to restore the entire scene to the saved state\nutils\nA series of functions related to second-order Bezier have been added to\nutils/bezier.py\nAdded a function to read color map from\nmatplotlib\nin\nutils/color.py\nAdded a series of related functions for processing folders/custom styles/object families\nresize_array\n,\nresize_preserving_order\n,\nresize_with_interpolation\nthree functions have been added to\nutils/iterables.py\nThe definition of\nsmooth\nis updated in\nutils/rate_functions.py\nclip(a,\nmin_a,\nmax_a)\nfunction has been added to\nutils/simple_functions.py\nSome functions have been improved in\nutils/space_ops.py\n, some functions for space calculation, and functions for processing triangulation have been added\nconstants\nFixed the aspect ratio of the screen to 16:9\nDeleted the old gray series (\nLIGHT_GREY\n,\nGREY\n,\nDARK_GREY\n,\nDARKER_GREY\n), added a new series of gray\nGREY_A\n~\nGREY_E\nContents\nWhat’s new\nUsage changes of new version manim",
    "code_examples": [
      "FadeInFrom, FadeInFromDown, FadeOutAndShift, FadeOutAndShiftDown, FadeInFromLarge",
      "FadeIn, FadeOut",
      "FadeTransform",
      "FadeTransformPieces",
      "CountInFrom(decimal_mob, source_number=0)",
      "decimal_mob",
      "source_number",
      "angle=, axis=",
      "TransformMatchingShapes(mobject, target_mobject)",
      "TransformMatchingTex(mobject, target_mobject)",
      "MappingCamera",
      "MovingCamera",
      "MultiCamera",
      "ThreeDCamera",
      "CameraFrame",
      "self.camera.frame",
      ".to_default_state()",
      ".set_euler_angles(theta, phi, gamma)",
      ".set_theta(theta)",
      ".set_phi(phi)",
      ".set_gamma(gamma)",
      ".increment_theta(dtheta)",
      ".increment_phi(dphi)",
      ".increment_gamma(gamma)",
      "self.camera.frame.add_updater(lambda mob, dt: mob.increment_theta(0.1 * dt))",
      "self.camera.light_source",
      "(- 10, 10, 10)",
      "drawings.py",
      "TextMobject",
      "ParametricSurface",
      "TexturedSurface",
      "TexturedSurface(uv_surface, image_file, dark_image_file=None)",
      "dark_image_file",
      "PointCloudDot",
      "AbstractImageMobject",
      "ImageMobjectFromCamera",
      ".get_gloss()",
      ".set_gloss(gloss)",
      ".get_shadow()",
      ".set_shadow(shadow)",
      ".get_grid(n_rows, n_cols)",
      ".set_color_by_code(glsl_code)",
      ".set_color_by_xyz_func(glsl_snippet, min_value=-5.0, max_value=5.0, colormap=\"viridis\")",
      "NumberPlane",
      "ComplexPlane",
      "np.array([ Minimum, maximum, step size])",
      ".i2gp(x, graph)",
      ".input_to_graph_point(x, graph)",
      ".get_v_line(point)",
      ".get_h_line(point)",
      ".get_graph_label(graph, label, x, direction, buff, color)",
      ".get_v_line_to_graph(x, graph)",
      ".get_h_line_to_graph(x, graph)",
      ".angle_of_tangent(x, graph, dx=EPSILON)",
      ".slope_of_tangent(x, graph, dx=EPSILON)",
      ".get_tangent_line(x, graph, length=5)",
      ".get_riemann_rectangles(graph, x_range, dx, input_sample_type, ...)",
      "number_line_config",
      "axis_config",
      ".get_coordinate_labels(x_values, y_values)",
      ".add_coordinate_labels(x_values, y_values)",
      ".add_coordinate_labels(numbers)",
      "ComplexPlane",
      "tick_frequency",
      "[min, max, step]",
      "label_direction",
      "line_to_number_direction",
      "exclude_zero_from_default",
      "numbers_to_exclude",
      ".add_tick_marks()",
      ".add_ticks()",
      ".get_number_mobjects(*numbers)",
      ".add_numbers(x_values=None, excluding=None)",
      "SurfaceMesh(uv_surface)",
      "ParametricSurface",
      "u_min, u_max, v_min, v_max",
      "u_range, v_range",
      "height, radius",
      "side_length",
      "ParametricFunction",
      "ParametricCurve",
      "t_min, t_max, step_size",
      "[t_min, t_max, step_size]",
      "TipableVMobject",
      ".set_points_by_ends(start, end, buff=0, path_arc=0)",
      ".get_projection(point)",
      "thickness, tip_width_ratio, tip_angle",
      "CubicBezier",
      "a0, h0, h1, a1",
      "side_length",
      "side_length=",
      "always_redraw(func, *args, **kwargs)",
      "*args, **kwargs",
      "digit_to_digit_buff",
      "DecimalNumber",
      "digit_buff_per_font_unit",
      "ValueTracker",
      "once_useful_constructs",
      "MovingCameraScene",
      "ReconfigurableScene",
      "SceneFromVideo",
      "ZoomedScene",
      "ThreeDScene",
      "CameraFrame",
      "self.camera.frame",
      "SampleSpaceScene",
      "VectorScene",
      ".interact()",
      ".save_state()",
      "utils/bezier.py",
      "utils/color.py",
      "resize_array",
      "resize_preserving_order",
      "resize_with_interpolation",
      "utils/iterables.py",
      "utils/rate_functions.py",
      "clip(a, min_a, max_a)",
      "utils/simple_functions.py",
      "utils/space_ops.py",
      "DARKER_GREY"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/documentation/constants.html",
      "https://3b1b.github.io/manim/documentation/custom_config.html",
      "https://3b1b.github.io/manim/development/changelog.html",
      "https://3b1b.github.io/manim/development/contributing.html",
      "https://3b1b.github.io/manim/development/about.html",
      "https://3b1b.github.io/manim/getting_started/whatsnew.html#what-s-new",
      "https://3b1b.github.io/manim/getting_started/whatsnew.html#usage-changes-of-new-version-manim",
      "https://3b1b.github.io/manim/getting_started/whatsnew.html#usage-changes-of-new-version-manim"
    ],
    "scraped_at": 1752428821.861579
  },
  "https://3b1b.github.io/manim/documentation/constants.html": {
    "url": "https://3b1b.github.io/manim/documentation/constants.html",
    "title": "constants - manim  documentation",
    "content": "constants\n¶\nThe\nconstants.py\nin the\nmanimlib\nfolder defines the constants\nneeded when running manim. Some constants are not explained here because\nthey are only used inside manim.\nFrame and pixel shape\n¶\nASPECT_RATIO\n=\n16.0\n/\n9.0\nFRAME_HEIGHT\n=\n8.0\nFRAME_WIDTH\n=\nFRAME_HEIGHT\n*\nASPECT_RATIO\nFRAME_Y_RADIUS\n=\nFRAME_HEIGHT\n/\n2\nFRAME_X_RADIUS\n=\nFRAME_WIDTH\n/\n2\nDEFAULT_PIXEL_HEIGHT\n=\n1080\nDEFAULT_PIXEL_WIDTH\n=\n1920\nDEFAULT_FPS\n=\n30\nBuffs\n¶\nSMALL_BUFF\n=\n0.1\nMED_SMALL_BUFF\n=\n0.25\nMED_LARGE_BUFF\n=\n0.5\nLARGE_BUFF\n=\n1\nDEFAULT_MOBJECT_TO_EDGE_BUFFER\n=\nMED_LARGE_BUFF\n# Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER\n=\nMED_SMALL_BUFF\n# Distance between objects\nRun times\n¶\nDEFAULT_POINTWISE_FUNCTION_RUN_TIME\n=\n3.0\nDEFAULT_WAIT_TIME\n=\n1.0\nCoordinates\n¶\nmanim uses three-dimensional coordinates and uses the type of\nndarray\nORIGIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n0.\n))\nUP\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nDOWN\n=\nnp\n.\narray\n((\n0.\n,\n-\n1.\n,\n0.\n))\nRIGHT\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nLEFT\n=\nnp\n.\narray\n((\n-\n1.\n,\n0.\n,\n0.\n))\nIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n-\n1.\n))\nOUT\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\nX_AXIS\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nY_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nZ_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\n# Useful abbreviations for diagonals\nUL\n=\nUP\n+\nLEFT\nUR\n=\nUP\n+\nRIGHT\nDL\n=\nDOWN\n+\nLEFT\nDR\n=\nDOWN\n+\nRIGHT\nTOP\n=\nFRAME_Y_RADIUS\n*\nUP\nBOTTOM\n=\nFRAME_Y_RADIUS\n*\nDOWN\nLEFT_SIDE\n=\nFRAME_X_RADIUS\n*\nLEFT\nRIGHT_SIDE\n=\nFRAME_X_RADIUS\n*\nRIGHT\nMathematical constant\n¶\nPI\n=\nnp\n.\npi\nTAU\n=\n2\n*\nPI\nDEGREES\n=\nTAU\n/\n360\nText\n¶\nNORMAL\n=\n\"NORMAL\"\nITALIC\n=\n\"ITALIC\"\nOBLIQUE\n=\n\"OBLIQUE\"\nBOLD\n=\n\"BOLD\"\nStroke width\n¶\nDEFAULT_STROKE_WIDTH\n=\n4\nColours\n¶\nHere are the preview of default colours. (Modified from\nelteoremadebeethoven\n)\nBLUE\nBLUE_E\nBLUE_D\nBLUE_C\nBLUE_B\nBLUE_A\nTEAL\nTEAL_E\nTEAL_D\nTEAL_C\nTEAL_B\nTEAL_A\nGREEN\nGREEN_E\nGREEN_D\nGREEN_C\nGREEN_B\nGREEN_A\nYELLOW\nYELLOW_E\nYELLOW_D\nYELLOW_C\nYELLOW_B\nYELLOW_A\nGOLD\nGOLD_E\nGOLD_D\nGOLD_C\nGOLD_B\nGOLD_A\nRED\nRED_E\nRED_D\nRED_C\nRED_B\nRED_A\nMAROON\nMAROON_E\nMAROON_D\nMAROON_C\nMAROON_B\nMAROON_A\nPURPLE\nPURPLE_E\nPURPLE_D\nPURPLE_C\nPURPLE_B\nPURPLE_A\nGREY\nGREY_E\nGREY_D\nGREY_C\nGREY_B\nGREY_A\nOthers\nWHITE\nBLACK\nGREY_BROWN\nDARK_BROWN\nLIGHT_BROWN\nPINK\nLIGHT_PINK\nGREEN_SCREEN\nORANGE\nContents\nconstants\nFrame and pixel shape\nBuffs\nRun times\nCoordinates\nMathematical constant\nText\nStroke width\nColours",
    "code_examples": [
      "constants.py",
      "ASPECT_RATIO = 16.0 / 9.0\nFRAME_HEIGHT = 8.0\nFRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO\nFRAME_Y_RADIUS = FRAME_HEIGHT / 2\nFRAME_X_RADIUS = FRAME_WIDTH / 2\n\nDEFAULT_PIXEL_HEIGHT = 1080\nDEFAULT_PIXEL_WIDTH = 1920\nDEFAULT_FPS = 30",
      "SMALL_BUFF = 0.1\nMED_SMALL_BUFF = 0.25\nMED_LARGE_BUFF = 0.5\nLARGE_BUFF = 1\n\nDEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects",
      "DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0\nDEFAULT_WAIT_TIME = 1.0",
      "ORIGIN = np.array((0., 0., 0.))\nUP = np.array((0., 1., 0.))\nDOWN = np.array((0., -1., 0.))\nRIGHT = np.array((1., 0., 0.))\nLEFT = np.array((-1., 0., 0.))\nIN = np.array((0., 0., -1.))\nOUT = np.array((0., 0., 1.))\nX_AXIS = np.array((1., 0., 0.))\nY_AXIS = np.array((0., 1., 0.))\nZ_AXIS = np.array((0., 0., 1.))\n\n# Useful abbreviations for diagonals\nUL = UP + LEFT\nUR = UP + RIGHT\nDL = DOWN + LEFT\nDR = DOWN + RIGHT\n\nTOP = FRAME_Y_RADIUS * UP\nBOTTOM = FRAME_Y_RADIUS * DOWN\nLEFT_SIDE = FRAME_X_RADIUS * LEFT\nRIGHT_SIDE = FRAME_X_RADIUS * RIGHT",
      "PI = np.pi\nTAU = 2 * PI\nDEGREES = TAU / 360",
      "NORMAL = \"NORMAL\"\nITALIC = \"ITALIC\"\nOBLIQUE = \"OBLIQUE\"\nBOLD = \"BOLD\"",
      "DEFAULT_STROKE_WIDTH = 4"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/documentation/custom_config.html",
      "https://3b1b.github.io/manim/development/changelog.html",
      "https://3b1b.github.io/manim/development/contributing.html",
      "https://3b1b.github.io/manim/development/about.html",
      "https://3b1b.github.io/manim/documentation/constants.html#constants",
      "https://3b1b.github.io/manim/documentation/constants.html#frame-and-pixel-shape",
      "https://3b1b.github.io/manim/documentation/constants.html#buffs",
      "https://3b1b.github.io/manim/documentation/constants.html#run-times",
      "https://3b1b.github.io/manim/documentation/constants.html#coordinates",
      "https://3b1b.github.io/manim/documentation/constants.html#mathematical-constant",
      "https://3b1b.github.io/manim/documentation/constants.html#text",
      "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
      "https://3b1b.github.io/manim/documentation/constants.html#colours",
      "https://3b1b.github.io/manim/documentation/constants.html#frame-and-pixel-shape",
      "https://3b1b.github.io/manim/documentation/constants.html#buffs",
      "https://3b1b.github.io/manim/documentation/constants.html#run-times",
      "https://3b1b.github.io/manim/documentation/constants.html#coordinates",
      "https://3b1b.github.io/manim/documentation/constants.html#mathematical-constant",
      "https://3b1b.github.io/manim/documentation/constants.html#text",
      "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
      "https://3b1b.github.io/manim/documentation/constants.html#colours"
    ],
    "scraped_at": 1752428823.005497
  },
  "https://3b1b.github.io/manim/documentation/custom_config.html": {
    "url": "https://3b1b.github.io/manim/documentation/custom_config.html",
    "title": "custom_config - manim  documentation",
    "content": "custom_config\n¶\ndirectories\n¶\nmirror_module_path\n(\nTrue\nor\nFalse\n) Whether to create a folder named the name of the\nrunning file under the\noutput\npath, and save the output (\nimages/\nor\nvideos/\n) in it.\noutput\nOutput file path, the videos will be saved in the\nvideos/\nfolder under it,\nand the pictures will be saved in the\nimages/\nfolder under it.\nFor example, if you set\noutput\nto\n\"/.../manim/output\"\nand\nmirror_module_path\nto\nFalse\n, then you exported\nScene1\nin the code\nfile and saved the last frame, then the final directory structure will be like:\nmanim/\n    ├── manimlib/\n    │   ├── animation/\n    │   ├── ...\n    │   ├── default_config.yml\n    │   └── window.py\n    ├── output/\n    │   ├── images\n│   │   └── Scene1.png\n│   └── videos\n│       └── Scene1.mp4\n├── code.py\n    └── custom_config.yml\nBut if you set\nmirror_module_path\nto\nTrue\n, the directory structure will be:\nmanim/\n    ├── manimlib/\n    │   ├── animation/\n    │   ├── ...\n    │   ├── default_config.yml\n    │   └── window.py\n    ├── output/\n│   └── code/\n│       ├── images\n    │       │   └── Scene1.png\n    │       └── videos\n    │           └── Scene1.mp4\n    ├── code.py\n    └── custom_config.yml\nraster_images\nThe directory for storing raster images to be used in the code (including\n.jpg\n,\n.jpeg\n,\n.png\nand\n.gif\n), which will be read by\nImageMobject\n.\nvector_images\nThe directory for storing vector images to be used in the code (including\n.svg\nand\n.xdv\n), which will be read by\nSVGMobject\n.\nsounds\nThe directory for storing sound files to be used in\nScene.add_sound()\n(\nincluding\n.wav\nand\n.mp3\n).\ntemporary_storage\nThe directory for storing temporarily generated cache files, including\nTex\ncache,\nText\ncache and storage of object points.\ntex\n¶\nexecutable\nThe executable program used to compile LaTeX (\nlatex\nor\nxelatex\n-no-pdf\nis recommended)\ntemplate_file\nLaTeX template used, in\nmanimlib/tex_templates\nintermediate_filetype\nThe type of intermediate vector file generated after compilation (\ndvi\nif\nlatex\nis used,\nxdv\nif\nxelatex\nis used)\ntext_to_replace\nThe text to be replaced in the template (needn’t to change)\nuniversal_import_line\n¶\nImport line that need to execute when entering interactive mode directly.\nstyle\n¶\nfont\nDefault font of Text\ntext_alignment\nDefault text alignment for LaTeX\nbackground_color\nDefault background color\nwindow_position\n¶\nThe relative position of the playback window on the display (two characters,\nthe first character means upper(U) / middle(O) / lower(D), the second character\nmeans left(L) / middle(O) / right(R)).\nwindow_monitor\n¶\nThe number of the monitor you want the preview window to pop up on. (default is 0)\nfull_screen\n¶\nWhether open the window in full screen. (default is false)\nbreak_into_partial_movies\n¶\nIf this is set to\nTrue\n, then many small files will be written corresponding\nto each\nScene.play\nand\nScene.wait\ncall, and these files will then be combined\nto form the full scene.\nSometimes video-editing is made easier when working with the broken up scene, which\neffectively has cuts at all the places you might want.\ncamera_resolutions\n¶\nExport resolutions\nlow\nLow resolutions (default is 480p)\nmedium\nMedium resolutions (default is 720p)\nhigh\nHigh resolutions (default is 1080p)\nultra_high\nUltra high resolutions (default is 4K)\ndefault_resolutions\nDefault resolutions (one of the above four, default is high)\nfps\n¶\nExport frame rate. (default is 30)\nContents\ncustom_config\ndirectories\ntex\nuniversal_import_line\nstyle\nwindow_position\nwindow_monitor\nfull_screen\nbreak_into_partial_movies\ncamera_resolutions\nfps",
    "code_examples": [
      "directories",
      "mirror_module_path",
      "\"/.../manim/output\"",
      "mirror_module_path",
      "manim/\n    ├── manimlib/\n    │   ├── animation/\n    │   ├── ...\n    │   ├── default_config.yml\n    │   └── window.py\n    ├── output/\n    │   ├── images\n    │   │   └── Scene1.png\n    │   └── videos\n    │       └── Scene1.mp4\n    ├── code.py\n    └── custom_config.yml",
      "mirror_module_path",
      "manim/\n    ├── manimlib/\n    │   ├── animation/\n    │   ├── ...\n    │   ├── default_config.yml\n    │   └── window.py\n    ├── output/\n    │   └── code/\n    │       ├── images\n    │       │   └── Scene1.png\n    │       └── videos\n    │           └── Scene1.mp4\n    ├── code.py\n    └── custom_config.yml",
      "raster_images",
      "ImageMobject",
      "vector_images",
      "Scene.add_sound()",
      "temporary_storage",
      "xelatex -no-pdf",
      "template_file",
      "manimlib/tex_templates",
      "intermediate_filetype",
      "text_to_replace",
      "universal_import_line",
      "text_alignment",
      "background_color",
      "window_position",
      "window_monitor",
      "full_screen",
      "break_into_partial_movies",
      "camera_resolutions",
      "default_resolutions",
      "directories",
      "universal_import_line",
      "window_position",
      "window_monitor",
      "full_screen",
      "break_into_partial_movies",
      "camera_resolutions"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/development/changelog.html",
      "https://3b1b.github.io/manim/development/contributing.html",
      "https://3b1b.github.io/manim/development/about.html",
      "https://3b1b.github.io/manim/documentation/custom_config.html#custom-config",
      "https://3b1b.github.io/manim/documentation/custom_config.html#directories",
      "https://3b1b.github.io/manim/documentation/custom_config.html#tex",
      "https://3b1b.github.io/manim/documentation/custom_config.html#universal-import-line",
      "https://3b1b.github.io/manim/documentation/custom_config.html#style",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-position",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-monitor",
      "https://3b1b.github.io/manim/documentation/custom_config.html#full-screen",
      "https://3b1b.github.io/manim/documentation/custom_config.html#break-into-partial-movies",
      "https://3b1b.github.io/manim/documentation/custom_config.html#camera-resolutions",
      "https://3b1b.github.io/manim/documentation/custom_config.html#fps",
      "https://3b1b.github.io/manim/documentation/custom_config.html#directories",
      "https://3b1b.github.io/manim/documentation/custom_config.html#tex",
      "https://3b1b.github.io/manim/documentation/custom_config.html#universal-import-line",
      "https://3b1b.github.io/manim/documentation/custom_config.html#style",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-position",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-monitor",
      "https://3b1b.github.io/manim/documentation/custom_config.html#full-screen",
      "https://3b1b.github.io/manim/documentation/custom_config.html#break-into-partial-movies",
      "https://3b1b.github.io/manim/documentation/custom_config.html#camera-resolutions",
      "https://3b1b.github.io/manim/documentation/custom_config.html#fps"
    ],
    "scraped_at": 1752428824.1485848
  },
  "https://3b1b.github.io/manim/development/changelog.html": {
    "url": "https://3b1b.github.io/manim/development/changelog.html",
    "title": "Changelog - manim  documentation",
    "content": "Changelog\n¶\nUnreleased\n¶\nBreaking Changes\n¶\nAdded\nInteractiveScene\n(\n#1794\n)\nFixed bugs\n¶\nFixed\nImageMobject\nby overriding\nset_color\nmethod (\n#1791\n)\nFixed bug with trying to close window during embed (\n#1796\n)\nFixed animating\nMobject.restore\nbug (\n#1796\n)\nFixed\nInteractiveScene.refresh_selection_highlight\n(\n#1802\n)\nFixed\nVMobject.match_style\n(\n#1821\n)\nNew Features\n¶\nAdded specific euler angle getters (\n#1794\n)\nAdded start angle option to\nCircle\n(\n#1794\n)\nAdded\nMobject.is_touching\n(\n#1794\n)\nAdded\nMobject.get_highlight\n(\n#1794\n)\nAllowed for saving and loading mobjects from file (\n#1794\n)\nAdded\nMobject.get_all_corners\n(\n#1794\n)\nAdded\nScene.id_to_mobject\nand\nScene.ids_to_group\n(\n#1794\n)\nAdded\nScene.save_mobject\nand\nScene.load_mobject\nto allow for saving and loading mobjects from file at the Scene level (\n#1794\n)\nAdded\nInteractiveScene\n(\n#1794\n)\nAdded\nVHighlight\n(\n#1794\n)\nAllowed for sweeping selection (\n#1796\n)\nAllowed stretched-resizing (\n#1796\n)\nAdded cursor location label (\n#1796\n)\nAdded\nMobject.deserialize\n(\n#1796\n)\nAdded undo and redo stacks for scene (\n#1796\n)\nAdded\nMobject.looks_identical\n(\n#1802\n)\nAdded equality for\nShaderWrapper\n(\n#1802\n)\nAdded\nMobject.get_ancestors\n(\n#1802\n)\nAdded smarter default radius to\nPolygon.round_corners\n(\n#1802\n)\nAdded checkpoints to\nScene\n(\n#1821\n)\nAdded\ncrosshair\nto\nInteractiveScene\n(\n#1821\n)\nAdded\nSceneState\n(\n#1821\n)\nAdded\ntime_span\noption to\nAnimation\n(\n#1821\n)\nAdded\nMobject.arrange_to_fit_dim\n(\n#1821\n)\nAdded\nDecimalNumber.get_tex\n(\n#1821\n)\nRefactor\n¶\nUpdated parent updater status when adding updaters (\n#1794\n)\nAdded case for zero vectors on\nangle_between_vectors\n(\n#1794\n)\nRefactored\nMobject.clear_updaters\n(\n#1794\n)\nChanged the way changing-vs-static mobjects are tracked (more details see\n#1794\n)\nRefactored\nMobject.is_point_touching\n(\n#1794\n)\nRefactored\nMobject.make_movable\nand\nMobject.set_animating_status\nto recurse over family (\n#1794\n)\nRefactored\nAnimationGroup\n(\n#1794\n)\nRefactored\nScene.save_state\nand\nScene.restore\n(\n#1794\n)\nAdded\nMANIM_COLORS\n(\n#1794\n)\nChanged default transparent background codec to be prores (\n#1794\n)\nSimplified\nMobject.copy\n(\n#1794\n)\nRefactored\nStringMobject\nand relevant classes (\n#1795\n)\nUpdates to copying based on pickle serializing (\n#1796 <https://github.com/3b1b/manim/commit/fe3e10acd29a3dd6f8b485c0e36ead819f2d937b>\n)\nRemoved\nrefresh_shader_wrapper_id\nfrom\nMobject.become\n(\n#1796\n)\nRefactored\nScene.embed\nto play nicely with gui interactions (\n#1796\n)\nMade\nBlankScene\ninherit from\nInteractiveScene\n(\n#1796\n)\nUpdated behavior of -e flag to take in (optional) strings as inputs (\n#1796\n)\nRefactor -e flag (\n#1796\n)\nReverted to original copying scheme (\n#1796\n)\nRenamed\nMobject.is_movable\nto\nMobject.interaction_allowed\n(\n#1796\n)\nRefreshed static mobjects on undo’s and redo’s (\n#1796\n)\nFactored out event handling (\n#1796\n)\nRemoved\nMobject.interaction_allowed\n, in favor of using\n_is_animating\nfor multiple purposes (\n#1796\n)\nMoved Command + z and Command + shift + z behavior to Scene (\n#1797\n)\nSlight copy refactor (\n#1797\n)\nWhen scene saves state, have it only copy mobjects which have changed (\n#1802\n)\nCleaned up\nScene.remove\nfunction (\n#1802\n)\nSpeed-ups to\nMobject.copy\n(\n#1802\n)\nSlight speed-up to\nInteractiveScene.gather_selection\n(\n#1802\n)\nOnly leave wait notes in presenter mode (\n#1802\n)\nRefactored\nremove_list_redundancies\nand\nlist_update\n(\n#1821\n)\nMatch updaters in\nMobject.become\n(\n#1821\n)\nDon’t show animation progress bar by default (\n#1821\n)\nHandle quitting during scene more gracefully (\n#1821\n)\nMade\nselection_highlight\nrefresh with an updater (\n#1821\n)\nRefactored\nanims_from_play_args\nto\nprepare_animations\nwhich deprecating old style\nself.play(mob.method,\n...)\n(\n#1821\n)\nMade presenter mode hold before first play call (\n#1821\n)\nUpdate frame on all play calls when skipping animations, so as to provide a rapid preview during scene loading (\n#1821\n)\nRenamed frame_rate to fps (\n#1821\n)\nLet default text alignment be decided in default_config (\n#1821\n)\nDependencies\n¶\nAdded dependency on\npyperclip\n(\n#1794\n)\nv1.6.1\n¶\nFixed bugs\n¶\nFixed the bug of\nMTex\nwith multi-line tex string (\n#1785\n)\nFixed\ninterpolate\n(\n#1788\n)\nFixed\nImageMobject\n(\n#1791\n)\nRefactor\n¶\nAdded\n\\overset\nas a special string in\nTex\n(\n#1783\n)\nAdded\nouter_interpolate\nto perform interpolation using\nnp.outer\non arrays (\n#1788\n)\nv1.6.0\n¶\nBreaking changes\n¶\nPython 3.6 is no longer supported\n(\n#1736\n)\nFixed bugs\n¶\nFixed the width of riemann rectangles (\n#1762\n)\nBug fixed in cases where empty array is passed to shader (\n#1764\n)\nFixed\nAddTextWordByWord\n(\n#1772\n)\nFixed\nControlsExample\n(\n#1781\n)\nNew features\n¶\nAdded more functions to\nText\n(details:\n#1751\n)\nAllowed\ninterpolate\nto work on an array of alpha values (\n#1764\n)\nAllowed\nNumberline.number_to_point\nand\nCoordinateSystem.coords_to_point\nto work on an array of inputs (\n#1764\n)\nAdded a basic\nPrismify\nto turn a flat\nVMobject\ninto something with depth (\n#1764\n)\nAdded\nGlowDots\n, analogous to\nGlowDot\n(\n#1764\n)\nAdded\nTransformMatchingStrings\nwhich is compatible with\nText\nand\nMTex\n(\n#1772\n)\nAdded support for\nsubstring\nand\ncase_sensitive\nparameters for\nLabelledString.get_parts_by_string\n(\n#1780\n)\nRefactor\n¶\nAdded type hints (\n#1736\n)\nSpecifid UTF-8 encoding for tex files (\n#1748\n)\nRefactored\nText\nwith the latest manimpango (\n#1751\n)\nReorganized getters for\nParametricCurve\n(\n#1757\n)\nRefactored\nCameraFrame\nto use\nscipy.spatial.transform.Rotation\n(\n#1764\n)\nRefactored rotation methods to use\nscipy.spatial.transform.Rotation\n(\n#1764\n)\nUsed\nstroke_color\nto init\nArrow\n(\n#1764\n)\nRefactored\nMobject.set_rgba_array_by_color\n(\n#1764\n)\nMade panning more sensitive to mouse movements (\n#1764\n)\nAdded loading progress for large SVGs (\n#1766\n)\nAdded getter/setter of\nfield_of_view\nfor\nCameraFrame\n(\n#1770\n)\nRenamed\nfocal_distance\nto\nfocal_dist_to_height\nand added getter/setter (\n#1770\n)\nAdded getter and setter for\nVMobject.joint_type\n(\n#1770\n)\nRefactored\nVCube\n(\n#1770\n)\nRefactored\nPrism\nto receive\nwidth\nheight\ndepth\ninstead of\ndimensions\n(\n#1770\n)\nRefactored\nText\n,\nMarkupText\nand\nMTex\nbased on\nLabelledString\n(\n#1772\n)\nRefactored\nLabelledString\nand relevant classes (\n#1779\n)\nv1.5.0\n¶\nFixed bugs\n¶\nBug fix for the case of calling\nWrite\non a null object (\n#1740\n)\nNew features\n¶\nAdded\nTransformMatchingMTex\n(\n#1725\n)\nAdded\nImplicitFunction\n(\n#1727\n)\nAdded\nPolyline\n(\n#1731\n)\nAllowed\nMobject.set_points\nto take in an empty list, and added\nMobject.add_point\n(\n#1739\n)\nAdded\nScene.refresh_locked_data\n(\n#1739\n)\nAdded presenter mode to scenes with\n-p\noption (\n#1739\nand\n#1742\n)\nAllowed for an embed by hitting\nctrl+shift+e\nduring interaction (\n#1739\nand\n#1746\n)\nAdded\nMobject.set_min_width/height/depth\n(\n#1739\n)\nAllowed\nMobject.match_coord/x/y/z\nto take in a point (\n#1739\n)\nAdded\ntext_config\nto\nDecimalNumber\n(\n#1744\n)\nRefactor\n¶\nRefactored\nMTex\n(\n#1725\n)\nRefactored\nSVGMobject\nwith svgelements (\n#1731\n)\nMade sure\nParametricCurve\nhas at least one point (\n#1739\n)\nSet default to no tips on\nAxes\n(\n#1739\n)\nStopped displaying when writing tex string is happening (\n#1739\n)\nReorganize inheriting order and refactor SVGMobject (\n#1745\n)\nDependencies\n¶\nAdded dependency on\nisosurfaces\n(\n#1727\n)\nRemoved dependency on\nargparse\nsince it’s a built-in module (\n#1728\n)\nRemoved dependency on\npyreadline\n(\n#1728\n)\nRemoved dependency on\ncssselect2\n(\n#1731\n)\nAdded dependency on\nsvgelements\n(\n#1731\n)\nv1.4.1\n¶\nFixed bugs\n¶\nTemporarily fixed boolean operations’ bug  (\n#1724\n)\nImport\nIterable\nfrom\ncollections.abc\ninstead of\ncollections\nwhich is deprecated since python 3.9 (\nd2e0811\n)\nv1.4.0\n¶\nFixed bugs\n¶\nTemporarily fixed\nLightbulb\n(\nf1996f8\n)\nFixed some bugs of\nSVGMobject\n(\n#1712\n)\nFixed some bugs of SVG path string parser (\n#1717\n)\nFixed some bugs of\nMTex\n(\n#1720\n)\nNew features\n¶\nAdded option to add ticks on x-axis in\nBarChart\n(\n#1694\n)\nAdded\nlable_buff\nconfig parameter for\nBrace\n(\n#1704\n)\nAdded support for\nrotate\nskewX\nskewY\ntransform in SVG  (\n#1712\n)\nAdded style support to\nSVGMobject\n(\n#1717\n)\nAdded parser to <style> element of SVG  (\n#1719\n)\nAdded support for <line> element in\nSVGMobject\n(\n#1719\n)\nRefactor\n¶\nUsed\nFFMPEG_BIN\ninstead of\n\"ffmpeg\"\nfor sound incorporation (\n5aa8d15\n)\nDecorated\nCoordinateSystem.get_axes\nand\n.get_all_ranges\nas abstract method  (\n#1709\n)\nRefactored SVG path string parser (\n#1712\n)\nAllowed\nMobject.scale\nto receive iterable\nscale_factor\n(\n#1712\n)\nRefactored\nMTex\n(\n#1716\n)\nImproved config helper (\nmanimgl\n--config\n) (\n#1721\n)\nRefactored\nMTex\n(\n#1723\n)\nDependencies\n¶\nAdded dependency on python package\ncssselect2\n(\n#1719\n)\nv1.3.0\n¶\nFixed bugs\n¶\nFixed\nMobject.stretch_to_fit_depth\n(\n#1653\n)\nFixed the bug of rotating camera (\n#1655\n)\nFixed\nSurfaceMesh\nto be evenly spaced (\nc73d507\n)\nFixed\nangle_between_vectors\nadd\nrotation_between_vectors\n(\n82bd02d\n)\nFixed\nVMobject.fade\n(\na717314\n)\nFixed\nangle_between_vectors\n(\nfbc329d\n)\nFixed bug in\nShowSubmobjectsOneByOne\n(\nbcd0990\n)\nFixed bug in\nTransformMatchingParts\n(\n7023548\n)\nNew features\n¶\nAdded CLI flag\n--log-level\nto specify log level (\ne10f850\n)\nAdded operations (\n+\nand\n*\n) for\nMobject\n(\n#1667\n)\nAdded 4 boolean operations for\nVMobject\nin\nmanimlib/mobject/boolean_ops.py\n(\n#1675\n)\nUnion(*vmobjects,\n**kwargs)\nDifference(subject,\nclip,\n**kwargs)\nIntersection(*vmobjects,\n**kwargs)\nExclusion(*vmobjects,\n**kwargs)\nAdded reflectiveness (\n81c3ae3\n)\nEnabled\nglow_factor\non\nDotCloud\n(\n2c7689e\n)\nAdded option\n-e\nto insert embed line from the command line (\nd065e19\n)\nImproved\npoint_from_proportion\nto account for arc length (\n0e78027\n)\nAdded shortcut\nset_backstroke\nfor setting black background stroke (\n781a993\n)\nAdded\nSuface.always_sort_to_camera\n(\n0b898a5\n)\nAdded getter methods for specific euler angles (\ne899604\n)\nHade\nrotation_between_vectors\nhandle identical/similar vectors (\n407c53f\n)\nAdded\nMobject.insert_submobject\nmethod (\n49743da\n)\nCreated single progress display for full scene render (\n9dd1f47\n)\nAdded\nCircle.get_radius\n(\n264f7b1\n)\nAdded\nDodecahedron\n(\n83841ae\n)\nAdded\nGlowDot\n(\na1d5147\n)\nAdded\nMTex\n, see\n#1678\nfor details (\n#1678\n)\nRefactor\n¶\nRefactored support for command\nA\nin path of SVG  (\n#1662\n)\nRefactored\nSingleStringTex.balance_braces\n(\n#1662\n)\nSlight tweaks to how saturation_factor works on newton-fractal (\n8b454fb\n)\nMade it possible to set full screen preview as a default (\n317a5d6\n)\nUsed\nquick_point_from_proportion\nfor graph points (\ne764da3\n)\nMade sure\nLine.set_length\nreturns self (\nd2182b9\n)\nBetter align\nSurfaceMesh\nto the corresponding surface polygons (\neea3c6b\n)\nMatch\nfix_in_frame\nstatus for\nFlashAround\nmobject (\nee1594a\n)\nMade sure\nMobject.is_fixed_in_frame\nstays updated with uniforms (\nba23fbe\n)\nMade sure\nskip_animations\nand\nstart_at_animation_number\nplay well together (\n98b0d26\n)\nUpdated progress display for full scene render (\nf8e6e7d\n)\nVectorizedPoint\nshould call\n__init__\nfor both super classes (\n8f1dfab\n)\nUsed array copy when checking need for refreshing triangulation (\n758f329\n)\nDependencies\n¶\nAdded dependency on python package\nskia-pathops\n(\n#1675\n)\nv1.2.0\n¶\nFixed bugs\n¶\nFixed\nput_start_and_end_on\nin 3D (\n#1592\n)\nFixed\nDecimalNumber\n’s scaling issue (\n#1601\n)\nFixed bug with common range array used for all coordinate systems (\n56df154\n)\nFixed\nCoordinateSystem\ninit bug (\n8645894\n)\nFixed bug for single-valued\nValueTracker\n(\n0dc096b\n)\nFixed bug with SVG rectangles (\n54ad355\n)\nFixed\nDotCloud.set_radii\n(\nd45ea28\n)\nTemporarily fixed bug for\nPMobject\narray resizing (\nb543cc0\n)\nFixed\nmatch_style\n(\n5f878a2\n)\nFixed negative\npath_arc\ncase (\n719c81d\n)\nFixed bug with\nCoordinateSystem.get_lines_parallel_to_axis\n(\nc726eb7\n)\nFixed\nComplexPlane\n-i display bug (\n7732d2f\n)\nNew features\n¶\nSupported the elliptical arc command\nA\nfor\nSVGMobject\n(\n#1598\n)\nAdded\nFlashyFadeIn\n(\n#1607\n)\nSave triangulation  (\n#1607\n)\nAdded new\nCode\nmobject (\n#1625\n)\nAdd warnings and use rich to display log (\n#1637\n)\nAdded\nVCube\n(\nbd356da\n)\nSupported\nValueTracker\nto track vectors (\n6d72893\n)\nAdded\nset_max_width\n,\nset_max_height\n,\nset_max_depth\nto\nMobject\n(\n3bb8f3f\n)\nAdded\nTracgTail\n(\na35dd5a\n)\nAdded\nScene.point_to_mobject\n(\nacba13f\n)\nAdded poly_fractal shader (\nf84b8a6\n)\nAdded kwargs to\nTipableVMobject.set_length\n(\nb24ba19\n)\nAdded\nMobject.replicate\n(\n17c2772\n)\nAdded mandelbrot_fractal shader (\n33fa76d\n)\nSaved state before each embed (\nf22a341\n)\nAllowed releasing of Textures (\ne10a752\n)\nConsolidated and renamed newton_fractal shader (\n14fbed7\n)\nHade\nImageMoject\nremember the filepath to the Image (\n6cdbe0d\n)\nRefactor\n¶\nChanged back to simpler\nMobject.scale\nimplementation (\n#1601\n)\nSimplified\nSquare\n(\nb667db2\n)\nRemoved unused parameter\ntriangulation_locked\n(\n40290ad\n)\nReimplemented\nArrow\n(\n8647a64\n)\nUsed\nmake_approximately_smooth\nfor\nset_points_smoothly\nby default (\nd8378d8\n)\nRefactored to call\n_handle_scale_side_effects\nafter scaling takes place (\n7b4199c\n)\nRefactored to only call\nthrow_error_if_no_points\nonce for\nget_start_and_end\n(\n7356a36\n)\nMade sure framerate is 30 for previewed scenes (\n0787c4f\n)\nPushed\npixel_coords_to_space_coords\nto\nWindow\n(\nc635f19\n)\nRefactored to pass tuples and not arrays to uniforms (\nd5a88d0\n)\nRefactored to copy uniform arrays in\nMobject.copy\n(\n9483f26\n)\nAdded\nbounding_box\nas exceptional key to point_cloud mobject (\ned1fc4d\n)\nMade sure stroke width is always a float (\n329d2c6\n)\nv1.1.0\n¶\nFixed bugs\n¶\nFixed the bug of\nresize_with_interpolation()\nin the case of\nlength=0\nFixed the bug of\n__init__\nin\nElbow\nIf chosen monitor is not available, choose one that does exist\nMake sure mobject data gets unlocked after animations\nFixed a bug for off-center vector fields\nHad\nMobject.match_points\nreturn self\nFixed chaining animation in example scenes\nFixed the default color of tip\nFixed a typo in\nShowPassingFlashWithThinningStrokeWidth\nFixed the default size of\nText\nFixed a missing import line in\nmobject.py\nFixed the bug in ControlsExample\nMake sure frame is added to the scene when initialization\nFixed zooming directions\nRewrote\nearclip_triangulation\nto fix triangulation\nAllowed sound_file_name to be taken in without extensions\nNew features\n¶\nAdded\nVShowPassingFlash\nAdded\nCOLORMAP_3B1B\nAdded some methods to coordinate system to access all axes ranges\nget_origin()\nget_all_ranges()\nAdded\nset_color_by_rgba_func()\nUpdated\nVectorField\nand\nStreamLines\nAllow\n3b1b_colormap\nas an option for\nget_colormap_list()\nReturn\nstroke_width\nas 1d array\nAdded\nget_parts_by_text()\nUse Text not TexText for Brace\nUpdate to Cross to make it default to variable stroke width\nAdded\nFlashAround\nand\nFlashUnder\nAllowed configuration in\nBrace.get_text\nAdded\nreorient()\nfor quicker changes to frame angle\nAdded\nunits\nto\nset_euler_angles()\nAllowed any\nVMobject\nto be passed into\nTransformMatchingTex\nRemoved double brace convention in\nTex\nand\nTexText\nAdded support for debugger launch\nAdded CLI flag\n--config_file\nto load configuration file manually\nAdded\ntip_style\nto\ntip_config\nAdded\nMarkupText\nTake in\nu_range\nand\nv_range\nas arguments to\nParametricSurface\nAdded\nTrueDot\nContents\nChangelog\nUnreleased\nBreaking Changes\nFixed bugs\nNew Features\nRefactor\nDependencies\nv1.6.1\nFixed bugs\nRefactor\nv1.6.0\nBreaking changes\nFixed bugs\nNew features\nRefactor\nv1.5.0\nFixed bugs\nNew features\nRefactor\nDependencies\nv1.4.1\nFixed bugs\nv1.4.0\nFixed bugs\nNew features\nRefactor\nDependencies\nv1.3.0\nFixed bugs\nNew features\nRefactor\nDependencies\nv1.2.0\nFixed bugs\nNew features\nRefactor\nv1.1.0\nFixed bugs\nNew features",
    "code_examples": [
      "InteractiveScene",
      "ImageMobject",
      "Mobject.restore",
      "InteractiveScene.refresh_selection_highlight",
      "VMobject.match_style",
      "Mobject.is_touching",
      "Mobject.get_highlight",
      "Mobject.get_all_corners",
      "Scene.id_to_mobject",
      "Scene.ids_to_group",
      "Scene.save_mobject",
      "Scene.load_mobject",
      "InteractiveScene",
      "Mobject.deserialize",
      "Mobject.looks_identical",
      "ShaderWrapper",
      "Mobject.get_ancestors",
      "Polygon.round_corners",
      "InteractiveScene",
      "Mobject.arrange_to_fit_dim",
      "DecimalNumber.get_tex",
      "angle_between_vectors",
      "Mobject.clear_updaters",
      "Mobject.is_point_touching",
      "Mobject.make_movable",
      "Mobject.set_animating_status",
      "AnimationGroup",
      "Scene.save_state",
      "Scene.restore",
      "MANIM_COLORS",
      "Mobject.copy",
      "StringMobject",
      "refresh_shader_wrapper_id",
      "Mobject.become",
      "Scene.embed",
      "InteractiveScene",
      "Mobject.is_movable",
      "Mobject.interaction_allowed",
      "Mobject.interaction_allowed",
      "_is_animating",
      "Scene.remove",
      "Mobject.copy",
      "InteractiveScene.gather_selection",
      "remove_list_redundancies",
      "list_update",
      "Mobject.become",
      "selection_highlight",
      "anims_from_play_args",
      "prepare_animations",
      "self.play(mob.method, ...)",
      "interpolate",
      "ImageMobject",
      "outer_interpolate",
      "AddTextWordByWord",
      "ControlsExample",
      "interpolate",
      "Numberline.number_to_point",
      "CoordinateSystem.coords_to_point",
      "TransformMatchingStrings",
      "case_sensitive",
      "LabelledString.get_parts_by_string",
      "ParametricCurve",
      "CameraFrame",
      "scipy.spatial.transform.Rotation",
      "scipy.spatial.transform.Rotation",
      "stroke_color",
      "Mobject.set_rgba_array_by_color",
      "field_of_view",
      "CameraFrame",
      "focal_distance",
      "focal_dist_to_height",
      "VMobject.joint_type",
      "width height depth",
      "LabelledString",
      "LabelledString",
      "TransformMatchingMTex",
      "ImplicitFunction",
      "Mobject.set_points",
      "Mobject.add_point",
      "Scene.refresh_locked_data",
      "ctrl+shift+e",
      "Mobject.set_min_width/height/depth",
      "Mobject.match_coord/x/y/z",
      "text_config",
      "DecimalNumber",
      "ParametricCurve",
      "isosurfaces",
      "svgelements",
      "collections.abc",
      "collections",
      "rotate skewX skewY",
      "CoordinateSystem.get_axes",
      ".get_all_ranges",
      "Mobject.scale",
      "scale_factor",
      "manimgl --config",
      "Mobject.stretch_to_fit_depth",
      "SurfaceMesh",
      "angle_between_vectors",
      "rotation_between_vectors",
      "VMobject.fade",
      "angle_between_vectors",
      "ShowSubmobjectsOneByOne",
      "TransformMatchingParts",
      "--log-level",
      "manimlib/mobject/boolean_ops.py",
      "Union(*vmobjects, **kwargs)",
      "Difference(subject, clip, **kwargs)",
      "Intersection(*vmobjects, **kwargs)",
      "Exclusion(*vmobjects, **kwargs)",
      "glow_factor",
      "point_from_proportion",
      "set_backstroke",
      "Suface.always_sort_to_camera",
      "rotation_between_vectors",
      "Mobject.insert_submobject",
      "Circle.get_radius",
      "Dodecahedron",
      "SingleStringTex.balance_braces",
      "quick_point_from_proportion",
      "Line.set_length",
      "SurfaceMesh",
      "fix_in_frame",
      "FlashAround",
      "Mobject.is_fixed_in_frame",
      "skip_animations",
      "start_at_animation_number",
      "VectorizedPoint",
      "put_start_and_end_on",
      "DecimalNumber",
      "CoordinateSystem",
      "ValueTracker",
      "DotCloud.set_radii",
      "match_style",
      "CoordinateSystem.get_lines_parallel_to_axis",
      "ComplexPlane",
      "FlashyFadeIn",
      "ValueTracker",
      "set_max_width",
      "set_max_height",
      "set_max_depth",
      "Scene.point_to_mobject",
      "TipableVMobject.set_length",
      "Mobject.replicate",
      "ImageMoject",
      "Mobject.scale",
      "triangulation_locked",
      "make_approximately_smooth",
      "set_points_smoothly",
      "_handle_scale_side_effects",
      "throw_error_if_no_points",
      "get_start_and_end",
      "pixel_coords_to_space_coords",
      "Mobject.copy",
      "bounding_box",
      "resize_with_interpolation()",
      "Mobject.match_points",
      "ShowPassingFlashWithThinningStrokeWidth",
      "earclip_triangulation",
      "VShowPassingFlash",
      "COLORMAP_3B1B",
      "get_origin()",
      "get_all_ranges()",
      "set_color_by_rgba_func()",
      "VectorField",
      "StreamLines",
      "3b1b_colormap",
      "get_colormap_list()",
      "stroke_width",
      "get_parts_by_text()",
      "FlashAround",
      "Brace.get_text",
      "set_euler_angles()",
      "TransformMatchingTex",
      "--config_file",
      "ParametricSurface"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/development/contributing.html",
      "https://3b1b.github.io/manim/development/about.html",
      "https://3b1b.github.io/manim/development/changelog.html#changelog",
      "https://3b1b.github.io/manim/development/changelog.html#unreleased",
      "https://3b1b.github.io/manim/development/changelog.html#breaking-changes",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs",
      "https://3b1b.github.io/manim/development/changelog.html#new-features",
      "https://3b1b.github.io/manim/development/changelog.html#refactor",
      "https://3b1b.github.io/manim/development/changelog.html#dependencies",
      "https://3b1b.github.io/manim/development/changelog.html#v1-6-1",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs-1",
      "https://3b1b.github.io/manim/development/changelog.html#refactor-1",
      "https://3b1b.github.io/manim/development/changelog.html#v1-6-0",
      "https://3b1b.github.io/manim/development/changelog.html#breaking-changes-1",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs-2",
      "https://3b1b.github.io/manim/development/changelog.html#new-features-1",
      "https://3b1b.github.io/manim/development/changelog.html#refactor-2",
      "https://3b1b.github.io/manim/development/changelog.html#v1-5-0",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs-3",
      "https://3b1b.github.io/manim/development/changelog.html#new-features-2",
      "https://3b1b.github.io/manim/development/changelog.html#refactor-3",
      "https://3b1b.github.io/manim/development/changelog.html#dependencies-1",
      "https://3b1b.github.io/manim/development/changelog.html#v1-4-1",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs-4",
      "https://3b1b.github.io/manim/development/changelog.html#v1-4-0",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs-5",
      "https://3b1b.github.io/manim/development/changelog.html#new-features-3",
      "https://3b1b.github.io/manim/development/changelog.html#refactor-4",
      "https://3b1b.github.io/manim/development/changelog.html#dependencies-2",
      "https://3b1b.github.io/manim/development/changelog.html#v1-3-0",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs-6",
      "https://3b1b.github.io/manim/development/changelog.html#new-features-4",
      "https://3b1b.github.io/manim/development/changelog.html#refactor-5",
      "https://3b1b.github.io/manim/development/changelog.html#dependencies-3",
      "https://3b1b.github.io/manim/development/changelog.html#v1-2-0",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs-7",
      "https://3b1b.github.io/manim/development/changelog.html#new-features-5",
      "https://3b1b.github.io/manim/development/changelog.html#refactor-6",
      "https://3b1b.github.io/manim/development/changelog.html#v1-1-0",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs-8",
      "https://3b1b.github.io/manim/development/changelog.html#new-features-6",
      "https://3b1b.github.io/manim/development/changelog.html#unreleased",
      "https://3b1b.github.io/manim/development/changelog.html#breaking-changes",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs",
      "https://3b1b.github.io/manim/development/changelog.html#new-features",
      "https://3b1b.github.io/manim/development/changelog.html#refactor",
      "https://3b1b.github.io/manim/development/changelog.html#dependencies",
      "https://3b1b.github.io/manim/development/changelog.html#v1-6-1",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs-1",
      "https://3b1b.github.io/manim/development/changelog.html#refactor-1",
      "https://3b1b.github.io/manim/development/changelog.html#v1-6-0",
      "https://3b1b.github.io/manim/development/changelog.html#breaking-changes-1",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs-2",
      "https://3b1b.github.io/manim/development/changelog.html#new-features-1",
      "https://3b1b.github.io/manim/development/changelog.html#refactor-2",
      "https://3b1b.github.io/manim/development/changelog.html#v1-5-0",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs-3",
      "https://3b1b.github.io/manim/development/changelog.html#new-features-2",
      "https://3b1b.github.io/manim/development/changelog.html#refactor-3",
      "https://3b1b.github.io/manim/development/changelog.html#dependencies-1",
      "https://3b1b.github.io/manim/development/changelog.html#v1-4-1",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs-4",
      "https://3b1b.github.io/manim/development/changelog.html#v1-4-0",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs-5",
      "https://3b1b.github.io/manim/development/changelog.html#new-features-3",
      "https://3b1b.github.io/manim/development/changelog.html#refactor-4",
      "https://3b1b.github.io/manim/development/changelog.html#dependencies-2",
      "https://3b1b.github.io/manim/development/changelog.html#v1-3-0",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs-6",
      "https://3b1b.github.io/manim/development/changelog.html#new-features-4",
      "https://3b1b.github.io/manim/development/changelog.html#refactor-5",
      "https://3b1b.github.io/manim/development/changelog.html#dependencies-3",
      "https://3b1b.github.io/manim/development/changelog.html#v1-2-0",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs-7",
      "https://3b1b.github.io/manim/development/changelog.html#new-features-5",
      "https://3b1b.github.io/manim/development/changelog.html#refactor-6",
      "https://3b1b.github.io/manim/development/changelog.html#v1-1-0",
      "https://3b1b.github.io/manim/development/changelog.html#fixed-bugs-8",
      "https://3b1b.github.io/manim/development/changelog.html#new-features-6"
    ],
    "scraped_at": 1752428825.320111
  },
  "https://3b1b.github.io/manim/development/contributing.html": {
    "url": "https://3b1b.github.io/manim/development/contributing.html",
    "title": "Contributing - manim  documentation",
    "content": "Contributing\n¶\nAccept any contribution you make :)\nContribute to the manim source code\n:\nPlease fork to your own repository and make changes, submit a pull request, and fill in\nthe motivation for the change following the instructions in the template. We will check\nyour pull request in detail (this usually takes a while, please be patient)\nContribute to the documentation\n:\nAlso submit a pull request and write down the main changes.\nIf you find a bug in the code\n:\nPlease open an issue and fill in the found problem and your environment according\nto the template. (But please note that if you think this problem is just a problem\nof yourself, rather than a problem of source code, it is recommended that you ask a\nquestion in the\nQ&A category\nof the discussion page)\nYou are welcome to share the content you made with manim\n:\nPost it in the\nshow and tell category\nof the discussion page.\nYou are also welcome to share some of your suggestions and ideas\n:\nPost them in the\nideas category\nof the discussion page.\nHow to build this documentation\n¶\nClone the 3b1b/manim repository\ngit\nclone\nhttps://github.com/3b1b/manim.git\n# or your own repo\n# git clone https://github.com/<your user name>/manim.git\ncd\nmanim\nInstall python package dependencies\npip\ninstall\n-r\ndocs/requirements.txt\nGo to the\ndocs/\nfolder and build\ncd\ndocs/\nmake\nhtml\nThe output document is located in\ndocs/build/html/\nContents\nContributing\nHow to build this documentation",
    "code_examples": [
      "git clone https://github.com/3b1b/manim.git\n# or your own repo\n# git clone https://github.com/<your user name>/manim.git\ncd manim",
      "pip install -r docs/requirements.txt",
      "cd docs/\nmake html",
      "docs/build/html/"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/development/about.html",
      "https://3b1b.github.io/manim/development/contributing.html#contributing",
      "https://3b1b.github.io/manim/development/contributing.html#how-to-build-this-documentation",
      "https://3b1b.github.io/manim/development/contributing.html#how-to-build-this-documentation"
    ],
    "scraped_at": 1752428826.444602
  },
  "https://3b1b.github.io/manim/development/about.html": {
    "url": "https://3b1b.github.io/manim/development/about.html",
    "title": "About - manim  documentation",
    "content": "About\n¶\nAbout Manim\n¶\nManim is an animation engine for explanatory math videos.\nYou can use it to make math videos (or other fields) like 3Blue1Brown.\nThere are mainly two versions here:\n3b1b/manim\n: Maintained by Grant Sanderson of 3Blue1Brown.\nUsing OpenGL and its GLSL language to use GPU for rendering. It has higher efficiency,\nfaster rendering speed, and supports real-time rendering and interaction.\nManimCommunity/manim\n: Maintained by Manim Community Dev Team.\nUsing multiple backend rendering. There is better documentation and\na more open contribution community.\nAbout this documentation\n¶\nThis documentation is based on the version in\n3b1b/manim\n.\nCreated by\nTonyCrane\n(“鹤翔万里” in Chinese) and in production.\nAmong them, the\nmanim_example_ext\nextension for Sphinx refers to\nthe documentation of ManimCommunity\n.\nIf you want to contribute to manim or this document, please see:\nContributing\nContents\nAbout\nAbout Manim\nAbout this documentation",
    "code_examples": [
      "manim_example_ext"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/development/about.html#about",
      "https://3b1b.github.io/manim/development/about.html#about-manim",
      "https://3b1b.github.io/manim/development/about.html#about-this-documentation",
      "https://3b1b.github.io/manim/development/about.html#about-manim",
      "https://3b1b.github.io/manim/development/about.html#about-this-documentation"
    ],
    "scraped_at": 1752428827.557405
  },
  "https://3b1b.github.io/manim/#manim-s-documentation": {
    "url": "https://3b1b.github.io/manim/#manim-s-documentation",
    "title": "Home - manim  documentation",
    "content": "Manim’s documentation\n¶\nManim is an animation engine for explanatory math videos. It’s used to create precise animations programmatically, as seen in the videos\nat\n3Blue1Brown\n.\nAnd here is a Chinese version of this documentation:\nhttps://docs.manim.org.cn/\nGetting Started\nInstallation\nInstall FFmpeg\nInstall FFmpeg Windows\n# Install FFmepeg Linux\n# Install FFmpeg MacOS\nDirectly\nDirectly (Windows)\nFor Anaconda\nQuick Start\nMake an image\nAdd animations\nEnable interaction\nYou succeeded!\nCLI flags and configuration\nCommand Line Interface\ncustom_config\nExample Scenes\nInteractiveDevlopment\nAnimatingMethods\nTextExample\nTexTransformExample\nUpdatersExample\nCoordinateSystemExample\nGraphExample\nSurfaceExample\nOpeningManimExample\nManim’s structure\nManim’s directory structure\nInheritance structure of manim’s classes\nManim execution process\nWhat’s new\nUsage changes of new version manim\nDocumentation\nconstants\nFrame and pixel shape\nBuffs\nRun times\nCoordinates\nMathematical constant\nText\nStroke width\nColours\ncustom_config\ndirectories\ntex\nuniversal_import_line\nstyle\nwindow_position\nwindow_monitor\nfull_screen\nbreak_into_partial_movies\ncamera_resolutions\nfps\nDevelopment\nChangelog\nUnreleased\nv1.6.1\nv1.6.0\nv1.5.0\nv1.4.1\nv1.4.0\nv1.3.0\nv1.2.0\nv1.1.0\nContributing\nHow to build this documentation\nAbout\nAbout Manim\nAbout this documentation",
    "code_examples": [
      "directories",
      "universal_import_line",
      "window_position",
      "window_monitor",
      "full_screen",
      "break_into_partial_movies",
      "camera_resolutions"
    ],
    "links": [
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmepeg-linux",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-macos",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#make-an-image",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#add-animations",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#enable-interaction",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#you-succeeded",
      "https://3b1b.github.io/manim/getting_started/configuration.html#command-line-interface",
      "https://3b1b.github.io/manim/getting_started/configuration.html#custom-config",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevlopment",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#animatingmethods",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/structure.html#manim-s-directory-structure",
      "https://3b1b.github.io/manim/getting_started/structure.html#inheritance-structure-of-manim-s-classes",
      "https://3b1b.github.io/manim/getting_started/structure.html#manim-execution-process",
      "https://3b1b.github.io/manim/getting_started/whatsnew.html#usage-changes-of-new-version-manim",
      "https://3b1b.github.io/manim/documentation/constants.html#frame-and-pixel-shape",
      "https://3b1b.github.io/manim/documentation/constants.html#buffs",
      "https://3b1b.github.io/manim/documentation/constants.html#run-times",
      "https://3b1b.github.io/manim/documentation/constants.html#coordinates",
      "https://3b1b.github.io/manim/documentation/constants.html#mathematical-constant",
      "https://3b1b.github.io/manim/documentation/constants.html#text",
      "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
      "https://3b1b.github.io/manim/documentation/constants.html#colours",
      "https://3b1b.github.io/manim/documentation/custom_config.html#directories",
      "https://3b1b.github.io/manim/documentation/custom_config.html#tex",
      "https://3b1b.github.io/manim/documentation/custom_config.html#universal-import-line",
      "https://3b1b.github.io/manim/documentation/custom_config.html#style",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-position",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-monitor",
      "https://3b1b.github.io/manim/documentation/custom_config.html#full-screen",
      "https://3b1b.github.io/manim/documentation/custom_config.html#break-into-partial-movies",
      "https://3b1b.github.io/manim/documentation/custom_config.html#camera-resolutions",
      "https://3b1b.github.io/manim/documentation/custom_config.html#fps",
      "https://3b1b.github.io/manim/development/changelog.html#unreleased",
      "https://3b1b.github.io/manim/development/changelog.html#v1-6-1",
      "https://3b1b.github.io/manim/development/changelog.html#v1-6-0",
      "https://3b1b.github.io/manim/development/changelog.html#v1-5-0",
      "https://3b1b.github.io/manim/development/changelog.html#v1-4-1",
      "https://3b1b.github.io/manim/development/changelog.html#v1-4-0",
      "https://3b1b.github.io/manim/development/changelog.html#v1-3-0",
      "https://3b1b.github.io/manim/development/changelog.html#v1-2-0",
      "https://3b1b.github.io/manim/development/changelog.html#v1-1-0",
      "https://3b1b.github.io/manim/development/contributing.html#how-to-build-this-documentation",
      "https://3b1b.github.io/manim/development/about.html#about-manim",
      "https://3b1b.github.io/manim/development/about.html#about-this-documentation"
    ],
    "scraped_at": 1752428828.58561
  },
  "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg": {
    "url": "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg",
    "title": "Installation - manim  documentation",
    "content": "Installation\n¶\nManim runs on Python 3.7 or higher.\nSystem requirements are：\nFFmpeg\nOpenGL\n(included in python package\nPyOpenGL\n)\nLaTeX\n(optional, if you want to use LaTeX)\nPango\n(only for Linux)\nInstall FFmpeg\n¶\nInstall FFmpeg Windows\n¶\nchoco install ffmpeg\n# Install FFmepeg Linux\n¶\n$\nsudo\napt\nupdate\n$\nsudo\napt\ninstall\nffmpeg\n$\nffmpeg\n-version\n# Install FFmpeg MacOS\n¶\nDownload This ZIP file\n`\nhttps://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full\n.7z`(if the link is not working download this zip file from there original website)\nDirectly\n¶\n# Install manimgl\npip\ninstall\nmanimgl\n# Try it out\nmanimgl\nIf you want to hack on manimlib itself, clone this repository and in\nthat directory execute:\n# Install python requirements\npip\ninstall\n-e\n.\n# Try it out\nmanimgl\nexample_scenes.py\nOpeningManimExample\n# or\nmanim-render\nexample_scenes.py\nOpeningManimExample\nIf you run the above command and no error message appears,\nthen you have successfully installed all the environments required by manim.\nDirectly (Windows)\n¶\nInstall\nFFmpeg\n, and make sure that its path is in the PATH environment variable.\nInstall a LaTeX distribution.\nTeXLive-full\nis recommended.\nInstall the remaining Python packages.\ngit\nclone\nhttps://github.com/3b1b/manim.git\ncd\nmanim\npip\ninstall\n-e\n.\nmanimgl\nexample_scenes.py\nOpeningManimExample\nFor Anaconda\n¶\nInstall FFmpeg and LaTeX as above.\nCreate a conda environment using\ngit\nclone\nhttps://github.com/3b1b/manim.git\ncd\nmanim\nconda\ncreate\n-n\nmanim\npython\n=\n3\n.8\nconda\nactivate\nmanim\npip\ninstall\n-e\n.\nContents\nInstallation\nInstall FFmpeg\nInstall FFmpeg Windows\n# Install FFmepeg Linux\n# Install FFmpeg MacOS\nDirectly\nDirectly (Windows)\nFor Anaconda",
    "code_examples": [
      "choco install ffmpeg",
      "$ sudo apt update\n$ sudo apt install ffmpeg\n$ ffmpeg -version",
      "# Install manimgl\npip install manimgl\n\n# Try it out\nmanimgl",
      "# Install python requirements\npip install -e .\n\n# Try it out\nmanimgl example_scenes.py OpeningManimExample\n# or\nmanim-render example_scenes.py OpeningManimExample",
      "git clone https://github.com/3b1b/manim.git\ncd manim\npip install -e .\nmanimgl example_scenes.py OpeningManimExample",
      "git clone https://github.com/3b1b/manim.git\ncd manim\nconda create -n manim python=3.8\nconda activate manim\npip install -e ."
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/installation.html#installation",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmepeg-linux",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-macos",
      "https://3b1b.github.io/manim/getting_started/installation.html#system-message-1",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmepeg-linux",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-macos",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda"
    ],
    "scraped_at": 1752428829.622567
  },
  "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-windows": {
    "url": "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-windows",
    "title": "Installation - manim  documentation",
    "content": "Installation\n¶\nManim runs on Python 3.7 or higher.\nSystem requirements are：\nFFmpeg\nOpenGL\n(included in python package\nPyOpenGL\n)\nLaTeX\n(optional, if you want to use LaTeX)\nPango\n(only for Linux)\nInstall FFmpeg\n¶\nInstall FFmpeg Windows\n¶\nchoco install ffmpeg\n# Install FFmepeg Linux\n¶\n$\nsudo\napt\nupdate\n$\nsudo\napt\ninstall\nffmpeg\n$\nffmpeg\n-version\n# Install FFmpeg MacOS\n¶\nDownload This ZIP file\n`\nhttps://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full\n.7z`(if the link is not working download this zip file from there original website)\nDirectly\n¶\n# Install manimgl\npip\ninstall\nmanimgl\n# Try it out\nmanimgl\nIf you want to hack on manimlib itself, clone this repository and in\nthat directory execute:\n# Install python requirements\npip\ninstall\n-e\n.\n# Try it out\nmanimgl\nexample_scenes.py\nOpeningManimExample\n# or\nmanim-render\nexample_scenes.py\nOpeningManimExample\nIf you run the above command and no error message appears,\nthen you have successfully installed all the environments required by manim.\nDirectly (Windows)\n¶\nInstall\nFFmpeg\n, and make sure that its path is in the PATH environment variable.\nInstall a LaTeX distribution.\nTeXLive-full\nis recommended.\nInstall the remaining Python packages.\ngit\nclone\nhttps://github.com/3b1b/manim.git\ncd\nmanim\npip\ninstall\n-e\n.\nmanimgl\nexample_scenes.py\nOpeningManimExample\nFor Anaconda\n¶\nInstall FFmpeg and LaTeX as above.\nCreate a conda environment using\ngit\nclone\nhttps://github.com/3b1b/manim.git\ncd\nmanim\nconda\ncreate\n-n\nmanim\npython\n=\n3\n.8\nconda\nactivate\nmanim\npip\ninstall\n-e\n.\nContents\nInstallation\nInstall FFmpeg\nInstall FFmpeg Windows\n# Install FFmepeg Linux\n# Install FFmpeg MacOS\nDirectly\nDirectly (Windows)\nFor Anaconda",
    "code_examples": [
      "choco install ffmpeg",
      "$ sudo apt update\n$ sudo apt install ffmpeg\n$ ffmpeg -version",
      "# Install manimgl\npip install manimgl\n\n# Try it out\nmanimgl",
      "# Install python requirements\npip install -e .\n\n# Try it out\nmanimgl example_scenes.py OpeningManimExample\n# or\nmanim-render example_scenes.py OpeningManimExample",
      "git clone https://github.com/3b1b/manim.git\ncd manim\npip install -e .\nmanimgl example_scenes.py OpeningManimExample",
      "git clone https://github.com/3b1b/manim.git\ncd manim\nconda create -n manim python=3.8\nconda activate manim\npip install -e ."
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/installation.html#installation",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmepeg-linux",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-macos",
      "https://3b1b.github.io/manim/getting_started/installation.html#system-message-1",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmepeg-linux",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-macos",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda"
    ],
    "scraped_at": 1752428830.6488478
  },
  "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmepeg-linux": {
    "url": "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmepeg-linux",
    "title": "Installation - manim  documentation",
    "content": "Installation\n¶\nManim runs on Python 3.7 or higher.\nSystem requirements are：\nFFmpeg\nOpenGL\n(included in python package\nPyOpenGL\n)\nLaTeX\n(optional, if you want to use LaTeX)\nPango\n(only for Linux)\nInstall FFmpeg\n¶\nInstall FFmpeg Windows\n¶\nchoco install ffmpeg\n# Install FFmepeg Linux\n¶\n$\nsudo\napt\nupdate\n$\nsudo\napt\ninstall\nffmpeg\n$\nffmpeg\n-version\n# Install FFmpeg MacOS\n¶\nDownload This ZIP file\n`\nhttps://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full\n.7z`(if the link is not working download this zip file from there original website)\nDirectly\n¶\n# Install manimgl\npip\ninstall\nmanimgl\n# Try it out\nmanimgl\nIf you want to hack on manimlib itself, clone this repository and in\nthat directory execute:\n# Install python requirements\npip\ninstall\n-e\n.\n# Try it out\nmanimgl\nexample_scenes.py\nOpeningManimExample\n# or\nmanim-render\nexample_scenes.py\nOpeningManimExample\nIf you run the above command and no error message appears,\nthen you have successfully installed all the environments required by manim.\nDirectly (Windows)\n¶\nInstall\nFFmpeg\n, and make sure that its path is in the PATH environment variable.\nInstall a LaTeX distribution.\nTeXLive-full\nis recommended.\nInstall the remaining Python packages.\ngit\nclone\nhttps://github.com/3b1b/manim.git\ncd\nmanim\npip\ninstall\n-e\n.\nmanimgl\nexample_scenes.py\nOpeningManimExample\nFor Anaconda\n¶\nInstall FFmpeg and LaTeX as above.\nCreate a conda environment using\ngit\nclone\nhttps://github.com/3b1b/manim.git\ncd\nmanim\nconda\ncreate\n-n\nmanim\npython\n=\n3\n.8\nconda\nactivate\nmanim\npip\ninstall\n-e\n.\nContents\nInstallation\nInstall FFmpeg\nInstall FFmpeg Windows\n# Install FFmepeg Linux\n# Install FFmpeg MacOS\nDirectly\nDirectly (Windows)\nFor Anaconda",
    "code_examples": [
      "choco install ffmpeg",
      "$ sudo apt update\n$ sudo apt install ffmpeg\n$ ffmpeg -version",
      "# Install manimgl\npip install manimgl\n\n# Try it out\nmanimgl",
      "# Install python requirements\npip install -e .\n\n# Try it out\nmanimgl example_scenes.py OpeningManimExample\n# or\nmanim-render example_scenes.py OpeningManimExample",
      "git clone https://github.com/3b1b/manim.git\ncd manim\npip install -e .\nmanimgl example_scenes.py OpeningManimExample",
      "git clone https://github.com/3b1b/manim.git\ncd manim\nconda create -n manim python=3.8\nconda activate manim\npip install -e ."
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/installation.html#installation",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-macos",
      "https://3b1b.github.io/manim/getting_started/installation.html#system-message-1",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda",
      "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-macos",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda"
    ],
    "scraped_at": 1752428831.6756852
  },
  "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-macos": {
    "url": "https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-macos",
    "title": "Installation - manim  documentation",
    "content": "Installation\n¶\nManim runs on Python 3.7 or higher.\nSystem requirements are：\nFFmpeg\nOpenGL\n(included in python package\nPyOpenGL\n)\nLaTeX\n(optional, if you want to use LaTeX)\nPango\n(only for Linux)\nInstall FFmpeg\n¶\nInstall FFmpeg Windows\n¶\nchoco install ffmpeg\n# Install FFmepeg Linux\n¶\n$\nsudo\napt\nupdate\n$\nsudo\napt\ninstall\nffmpeg\n$\nffmpeg\n-version\n# Install FFmpeg MacOS\n¶\nDownload This ZIP file\n`\nhttps://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full\n.7z`(if the link is not working download this zip file from there original website)\nDirectly\n¶\n# Install manimgl\npip\ninstall\nmanimgl\n# Try it out\nmanimgl\nIf you want to hack on manimlib itself, clone this repository and in\nthat directory execute:\n# Install python requirements\npip\ninstall\n-e\n.\n# Try it out\nmanimgl\nexample_scenes.py\nOpeningManimExample\n# or\nmanim-render\nexample_scenes.py\nOpeningManimExample\nIf you run the above command and no error message appears,\nthen you have successfully installed all the environments required by manim.\nDirectly (Windows)\n¶\nInstall\nFFmpeg\n, and make sure that its path is in the PATH environment variable.\nInstall a LaTeX distribution.\nTeXLive-full\nis recommended.\nInstall the remaining Python packages.\ngit\nclone\nhttps://github.com/3b1b/manim.git\ncd\nmanim\npip\ninstall\n-e\n.\nmanimgl\nexample_scenes.py\nOpeningManimExample\nFor Anaconda\n¶\nInstall FFmpeg and LaTeX as above.\nCreate a conda environment using\ngit\nclone\nhttps://github.com/3b1b/manim.git\ncd\nmanim\nconda\ncreate\n-n\nmanim\npython\n=\n3\n.8\nconda\nactivate\nmanim\npip\ninstall\n-e\n.\nContents\nInstallation\nInstall FFmpeg\nInstall FFmpeg Windows\n# Install FFmepeg Linux\n# Install FFmpeg MacOS\nDirectly\nDirectly (Windows)\nFor Anaconda",
    "code_examples": [
      "choco install ffmpeg",
      "$ sudo apt update\n$ sudo apt install ffmpeg\n$ ffmpeg -version",
      "# Install manimgl\npip install manimgl\n\n# Try it out\nmanimgl",
      "# Install python requirements\npip install -e .\n\n# Try it out\nmanimgl example_scenes.py OpeningManimExample\n# or\nmanim-render example_scenes.py OpeningManimExample",
      "git clone https://github.com/3b1b/manim.git\ncd manim\npip install -e .\nmanimgl example_scenes.py OpeningManimExample",
      "git clone https://github.com/3b1b/manim.git\ncd manim\nconda create -n manim python=3.8\nconda activate manim\npip install -e ."
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/installation.html#installation",
      "https://3b1b.github.io/manim/getting_started/installation.html#system-message-1",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda"
    ],
    "scraped_at": 1752428832.701781
  },
  "https://3b1b.github.io/manim/getting_started/installation.html#directly": {
    "url": "https://3b1b.github.io/manim/getting_started/installation.html#directly",
    "title": "Installation - manim  documentation",
    "content": "Installation\n¶\nManim runs on Python 3.7 or higher.\nSystem requirements are：\nFFmpeg\nOpenGL\n(included in python package\nPyOpenGL\n)\nLaTeX\n(optional, if you want to use LaTeX)\nPango\n(only for Linux)\nInstall FFmpeg\n¶\nInstall FFmpeg Windows\n¶\nchoco install ffmpeg\n# Install FFmepeg Linux\n¶\n$\nsudo\napt\nupdate\n$\nsudo\napt\ninstall\nffmpeg\n$\nffmpeg\n-version\n# Install FFmpeg MacOS\n¶\nDownload This ZIP file\n`\nhttps://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full\n.7z`(if the link is not working download this zip file from there original website)\nDirectly\n¶\n# Install manimgl\npip\ninstall\nmanimgl\n# Try it out\nmanimgl\nIf you want to hack on manimlib itself, clone this repository and in\nthat directory execute:\n# Install python requirements\npip\ninstall\n-e\n.\n# Try it out\nmanimgl\nexample_scenes.py\nOpeningManimExample\n# or\nmanim-render\nexample_scenes.py\nOpeningManimExample\nIf you run the above command and no error message appears,\nthen you have successfully installed all the environments required by manim.\nDirectly (Windows)\n¶\nInstall\nFFmpeg\n, and make sure that its path is in the PATH environment variable.\nInstall a LaTeX distribution.\nTeXLive-full\nis recommended.\nInstall the remaining Python packages.\ngit\nclone\nhttps://github.com/3b1b/manim.git\ncd\nmanim\npip\ninstall\n-e\n.\nmanimgl\nexample_scenes.py\nOpeningManimExample\nFor Anaconda\n¶\nInstall FFmpeg and LaTeX as above.\nCreate a conda environment using\ngit\nclone\nhttps://github.com/3b1b/manim.git\ncd\nmanim\nconda\ncreate\n-n\nmanim\npython\n=\n3\n.8\nconda\nactivate\nmanim\npip\ninstall\n-e\n.\nContents\nInstallation\nInstall FFmpeg\nInstall FFmpeg Windows\n# Install FFmepeg Linux\n# Install FFmpeg MacOS\nDirectly\nDirectly (Windows)\nFor Anaconda",
    "code_examples": [
      "choco install ffmpeg",
      "$ sudo apt update\n$ sudo apt install ffmpeg\n$ ffmpeg -version",
      "# Install manimgl\npip install manimgl\n\n# Try it out\nmanimgl",
      "# Install python requirements\npip install -e .\n\n# Try it out\nmanimgl example_scenes.py OpeningManimExample\n# or\nmanim-render example_scenes.py OpeningManimExample",
      "git clone https://github.com/3b1b/manim.git\ncd manim\npip install -e .\nmanimgl example_scenes.py OpeningManimExample",
      "git clone https://github.com/3b1b/manim.git\ncd manim\nconda create -n manim python=3.8\nconda activate manim\npip install -e ."
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/installation.html#installation",
      "https://3b1b.github.io/manim/getting_started/installation.html#system-message-1",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda",
      "https://3b1b.github.io/manim/getting_started/installation.html#directly-windows",
      "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda"
    ],
    "scraped_at": 1752428833.730089
  },
  "https://3b1b.github.io/manim/getting_started/installation.html#directly-windows": {
    "url": "https://3b1b.github.io/manim/getting_started/installation.html#directly-windows",
    "title": "Installation - manim  documentation",
    "content": "Installation\n¶\nManim runs on Python 3.7 or higher.\nSystem requirements are：\nFFmpeg\nOpenGL\n(included in python package\nPyOpenGL\n)\nLaTeX\n(optional, if you want to use LaTeX)\nPango\n(only for Linux)\nInstall FFmpeg\n¶\nInstall FFmpeg Windows\n¶\nchoco install ffmpeg\n# Install FFmepeg Linux\n¶\n$\nsudo\napt\nupdate\n$\nsudo\napt\ninstall\nffmpeg\n$\nffmpeg\n-version\n# Install FFmpeg MacOS\n¶\nDownload This ZIP file\n`\nhttps://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full\n.7z`(if the link is not working download this zip file from there original website)\nDirectly\n¶\n# Install manimgl\npip\ninstall\nmanimgl\n# Try it out\nmanimgl\nIf you want to hack on manimlib itself, clone this repository and in\nthat directory execute:\n# Install python requirements\npip\ninstall\n-e\n.\n# Try it out\nmanimgl\nexample_scenes.py\nOpeningManimExample\n# or\nmanim-render\nexample_scenes.py\nOpeningManimExample\nIf you run the above command and no error message appears,\nthen you have successfully installed all the environments required by manim.\nDirectly (Windows)\n¶\nInstall\nFFmpeg\n, and make sure that its path is in the PATH environment variable.\nInstall a LaTeX distribution.\nTeXLive-full\nis recommended.\nInstall the remaining Python packages.\ngit\nclone\nhttps://github.com/3b1b/manim.git\ncd\nmanim\npip\ninstall\n-e\n.\nmanimgl\nexample_scenes.py\nOpeningManimExample\nFor Anaconda\n¶\nInstall FFmpeg and LaTeX as above.\nCreate a conda environment using\ngit\nclone\nhttps://github.com/3b1b/manim.git\ncd\nmanim\nconda\ncreate\n-n\nmanim\npython\n=\n3\n.8\nconda\nactivate\nmanim\npip\ninstall\n-e\n.\nContents\nInstallation\nInstall FFmpeg\nInstall FFmpeg Windows\n# Install FFmepeg Linux\n# Install FFmpeg MacOS\nDirectly\nDirectly (Windows)\nFor Anaconda",
    "code_examples": [
      "choco install ffmpeg",
      "$ sudo apt update\n$ sudo apt install ffmpeg\n$ ffmpeg -version",
      "# Install manimgl\npip install manimgl\n\n# Try it out\nmanimgl",
      "# Install python requirements\npip install -e .\n\n# Try it out\nmanimgl example_scenes.py OpeningManimExample\n# or\nmanim-render example_scenes.py OpeningManimExample",
      "git clone https://github.com/3b1b/manim.git\ncd manim\npip install -e .\nmanimgl example_scenes.py OpeningManimExample",
      "git clone https://github.com/3b1b/manim.git\ncd manim\nconda create -n manim python=3.8\nconda activate manim\npip install -e ."
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/installation.html#installation",
      "https://3b1b.github.io/manim/getting_started/installation.html#system-message-1",
      "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda",
      "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda"
    ],
    "scraped_at": 1752428834.752358
  },
  "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda": {
    "url": "https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda",
    "title": "Installation - manim  documentation",
    "content": "Installation\n¶\nManim runs on Python 3.7 or higher.\nSystem requirements are：\nFFmpeg\nOpenGL\n(included in python package\nPyOpenGL\n)\nLaTeX\n(optional, if you want to use LaTeX)\nPango\n(only for Linux)\nInstall FFmpeg\n¶\nInstall FFmpeg Windows\n¶\nchoco install ffmpeg\n# Install FFmepeg Linux\n¶\n$\nsudo\napt\nupdate\n$\nsudo\napt\ninstall\nffmpeg\n$\nffmpeg\n-version\n# Install FFmpeg MacOS\n¶\nDownload This ZIP file\n`\nhttps://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full\n.7z`(if the link is not working download this zip file from there original website)\nDirectly\n¶\n# Install manimgl\npip\ninstall\nmanimgl\n# Try it out\nmanimgl\nIf you want to hack on manimlib itself, clone this repository and in\nthat directory execute:\n# Install python requirements\npip\ninstall\n-e\n.\n# Try it out\nmanimgl\nexample_scenes.py\nOpeningManimExample\n# or\nmanim-render\nexample_scenes.py\nOpeningManimExample\nIf you run the above command and no error message appears,\nthen you have successfully installed all the environments required by manim.\nDirectly (Windows)\n¶\nInstall\nFFmpeg\n, and make sure that its path is in the PATH environment variable.\nInstall a LaTeX distribution.\nTeXLive-full\nis recommended.\nInstall the remaining Python packages.\ngit\nclone\nhttps://github.com/3b1b/manim.git\ncd\nmanim\npip\ninstall\n-e\n.\nmanimgl\nexample_scenes.py\nOpeningManimExample\nFor Anaconda\n¶\nInstall FFmpeg and LaTeX as above.\nCreate a conda environment using\ngit\nclone\nhttps://github.com/3b1b/manim.git\ncd\nmanim\nconda\ncreate\n-n\nmanim\npython\n=\n3\n.8\nconda\nactivate\nmanim\npip\ninstall\n-e\n.\nContents\nInstallation\nInstall FFmpeg\nInstall FFmpeg Windows\n# Install FFmepeg Linux\n# Install FFmpeg MacOS\nDirectly\nDirectly (Windows)\nFor Anaconda",
    "code_examples": [
      "choco install ffmpeg",
      "$ sudo apt update\n$ sudo apt install ffmpeg\n$ ffmpeg -version",
      "# Install manimgl\npip install manimgl\n\n# Try it out\nmanimgl",
      "# Install python requirements\npip install -e .\n\n# Try it out\nmanimgl example_scenes.py OpeningManimExample\n# or\nmanim-render example_scenes.py OpeningManimExample",
      "git clone https://github.com/3b1b/manim.git\ncd manim\npip install -e .\nmanimgl example_scenes.py OpeningManimExample",
      "git clone https://github.com/3b1b/manim.git\ncd manim\nconda create -n manim python=3.8\nconda activate manim\npip install -e ."
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/installation.html#installation",
      "https://3b1b.github.io/manim/getting_started/installation.html#system-message-1"
    ],
    "scraped_at": 1752428835.783485
  },
  "https://3b1b.github.io/manim/getting_started/quickstart.html#make-an-image": {
    "url": "https://3b1b.github.io/manim/getting_started/quickstart.html#make-an-image",
    "title": "Quick Start - manim  documentation",
    "content": "Quick Start\n¶\nAfter installing the manim environment according to the instructions on the\nInstallation\npage, you can try to make a scene yourself from scratch.\nFirst, create a new\n.py\nfile (such as\nstart.py\n) according to the following\ndirectory structure:\nmanim/\n├── manimlib/\n│   ├── animation/\n│   ├── ...\n│   ├── default_config.yml\n│   └── window.py\n├── custom_config.yml\n└── start.py\nAnd paste the following code (I will explain the function of each line in detail later):\n1\n2\n3\n4\n5\n6\n7\n8\n9\nfrom\nmanimlib\nimport\n*\nclass\nSquareToCircle\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nself\n.\nadd\n(\ncircle\n)\nAnd run this command:\nmanimgl\nstart.py\nSquareToCircle\nA window will pop up on the screen. And then you can :\nscroll the middle mouse button to move the screen up and down\nhold down the\nz\non the keyboard while scrolling the middle mouse button to zoom the screen\nhold down the\ns\nkey on the keyboard and move the mouse to pan the screen\nhold down the\nd\nkey on the keyboard and move the mouse to change the three-dimensional perspective.\nFinally, you can close the window and exit the program by pressing\nq\n.\nRun this command again:\nmanimgl\nstart.py\nSquareToCircle\n-os\nAt this time, no window will pop up. When the program is finished, this rendered\nimage will be automatically opened (saved in the subdirectory\nimages/\nof the same\nlevel directory of\nstart.py\nby default):\nMake an image\n¶\nNext, let’s take a detailed look at what each row does.\nLine 1\n:\nfrom\nmanimlib\nimport\n*\nThis will import all the classes that may be used when using manim.\nLine 3\n:\nclass\nSquareToCircle\n(\nScene\n):\nCreate a\nScene\nsubclass\nSquareToCircle\n, which will be\nthe scene you write and render.\nLine 4\n:\ndef\nconstruct\n(\nself\n):\nWrite the\nconstruct()\nmethod, the content of which will determine\nhow to create the mobjects in the screen and what operations need to be performed.\nLine 5\n:\ncircle\n=\nCircle\n()\nCreate a circle (an instance of the\nCircle\nclass), called\ncircle\nLine 6~7\n:\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nSet the circle style by calling the circle’s method.\nThe\n.set_fill()\nmethod sets the fill color of this circle to blue (\nBLUE\n, defined in\nconstants\n), and the fill transparency to 0.5.\nThe\n.set_stroke()\nmethod sets the stroke color of this circle to dark blue (\nBLUE_E\n, defined in\nconstants\n), and the stroke width to 4.\nLine 9\n:\nself\n.\nadd\n(\ncircle\n)\nAdd this circle to the screen through the\n.add()\nmethod of\nScene\n.\nAdd animations\n¶\nLet’s change some codes and add some animations to make videos instead of just pictures.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nfrom\nmanimlib\nimport\n*\nclass\nSquareToCircle\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nsquare\n=\nSquare\n()\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nself\n.\nwait\n()\nRun this command this time:\nmanimgl\nstart.py\nSquareToCircle\nThe pop-up window will play animations of drawing a square and transforming\nit into a circle. If you want to save this video, run:\nmanimgl\nstart.py\nSquareToCircle\n-o\nThis time there will be no pop-up window, but the video file (saved in the subdirectory\nvideos/\nof the same level directory of\nstart.py\nby default) will be automatically\nopened after the operation is over:\nLet’s take a look at the code this time. The first 7 lines are the same as the previous\nones, and the 8th line is similar to the 5th line, which creates an instance of the\nSquare\nclass and named it\nsquare\n.\nLine 10\n:\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nAn animation is played through\nScene\n’s\n.play()\nmethod.\nShowCreation\nis an animation that shows the process of creating a given mobject.\nself.play(ShowCreation(square))\nis to play the animation of creating\nsquare\n.\nLine 11\n:\nself\n.\nwait\n()\nUse\nScene\n’s\n.wait()\nmethod to pause (default 1s), you can pass in\nparameters to indicate the pause time (for example,\nself.wait(3)\nmeans pause for 3s).\nLine 12\n:\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nPlay the animation that transforms\nsquare\ninto\ncircle\n.\nReplacementTransform(A,\nB)\nmeans to transform A into B’s pattern and replace A with B.\nLine 13\n: Same as line 11, pause for 1s.\nEnable interaction\n¶\nInteraction is a new feature of the new version. You can add the following line\nat the end of the code to enable interaction:\nself\n.\nembed\n()\nThen run\nmanimgl\nstart.py\nSquareToCircle\n.\nAfter the previous animation is executed, the ipython terminal will be opened on\nthe command line. After that, you can continue to write code in it, and the statement\nyou entered will be executed immediately after pressing\nEnter\n.\nFor example: input the following lines (without comment lines) into it respectively\n(\nself.play\ncan be abbreviated as\nplay\nin this mode):\n# Stretched 4 times in the vertical direction\nplay\n(\ncircle\n.\nanimate\n.\nstretch\n(\n4\n,\ndim\n=\n0\n))\n# Rotate the ellipse 90°\nplay\n(\nRotate\n(\ncircle\n,\nTAU\n/\n4\n))\n# Move 2 units to the right and shrink to 1/4 of the original\nplay\n(\ncircle\n.\nanimate\n.\nshift\n(\n2\n*\nRIGHT\n),\ncircle\n.\nanimate\n.\nscale\n(\n0.25\n))\n# Insert 10 curves into circle for non-linear transformation (no animation will play)\ncircle\n.\ninsert_n_curves\n(\n10\n)\n# Apply a complex transformation of f(z)=z^2 to all points on the circle\nplay\n(\ncircle\n.\nanimate\n.\napply_complex_function\n(\nlambda\nz\n:\nz\n**\n2\n))\n# Close the window and exit the program\nexit\n()\nYou will get an animation similar to the following:\nIf you want to enter the interactive mode directly, you don’t have to write an\nempty scene containing only\nself.embed()\n, you can directly run the following command\n(this will enter the ipython terminal while the window pops up):\nmanimgl\nYou succeeded!\n¶\nAfter reading the above content, you already know how to use manim.\nBelow you can see some examples, in the\nExample Scenes\npage.\nBut before that, you’d better have a look at the\nCLI flags and configuration\nof manim.\nContents\nQuick Start\nMake an image\nAdd animations\nEnable interaction\nYou succeeded!",
    "code_examples": [
      "manim/\n├── manimlib/\n│   ├── animation/\n│   ├── ...\n│   ├── default_config.yml\n│   └── window.py\n├── custom_config.yml\n└── start.py",
      "1\n2\n3\n4\n5\n6\n7\n8\n9",
      "from manimlib import *\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n\n        self.add(circle)",
      "manimgl start.py SquareToCircle",
      "manimgl start.py SquareToCircle -os",
      "from manimlib import *",
      "class SquareToCircle(Scene):",
      "SquareToCircle",
      "def construct(self):",
      "construct()",
      "circle = Circle()",
      "circle.set_fill(BLUE, opacity=0.5)\ncircle.set_stroke(BLUE_E, width=4)",
      ".set_fill()",
      ".set_stroke()",
      "self.add(circle)",
      "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13",
      "from manimlib import *\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n        self.play(ReplacementTransform(square, circle))\n        self.wait()",
      "manimgl start.py SquareToCircle",
      "manimgl start.py SquareToCircle -o",
      "self.play(ShowCreation(square))",
      "ShowCreation",
      "self.play(ShowCreation(square))",
      "self.wait()",
      "self.wait(3)",
      "self.play(ReplacementTransform(square, circle))",
      "ReplacementTransform(A, B)",
      "self.embed()",
      "manimgl start.py SquareToCircle",
      "# Stretched 4 times in the vertical direction\nplay(circle.animate.stretch(4, dim=0))\n# Rotate the ellipse 90°\nplay(Rotate(circle, TAU / 4))\n# Move 2 units to the right and shrink to 1/4 of the original\nplay(circle.animate.shift(2 * RIGHT), circle.animate.scale(0.25))\n# Insert 10 curves into circle for non-linear transformation (no animation will play)\ncircle.insert_n_curves(10)\n# Apply a complex transformation of f(z)=z^2 to all points on the circle\nplay(circle.animate.apply_complex_function(lambda z: z**2))\n# Close the window and exit the program\nexit()",
      "self.embed()"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#quick-start",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#add-animations",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#enable-interaction",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#you-succeeded",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#add-animations",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#enable-interaction",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#you-succeeded"
    ],
    "scraped_at": 1752428836.820968
  },
  "https://3b1b.github.io/manim/getting_started/quickstart.html#add-animations": {
    "url": "https://3b1b.github.io/manim/getting_started/quickstart.html#add-animations",
    "title": "Quick Start - manim  documentation",
    "content": "Quick Start\n¶\nAfter installing the manim environment according to the instructions on the\nInstallation\npage, you can try to make a scene yourself from scratch.\nFirst, create a new\n.py\nfile (such as\nstart.py\n) according to the following\ndirectory structure:\nmanim/\n├── manimlib/\n│   ├── animation/\n│   ├── ...\n│   ├── default_config.yml\n│   └── window.py\n├── custom_config.yml\n└── start.py\nAnd paste the following code (I will explain the function of each line in detail later):\n1\n2\n3\n4\n5\n6\n7\n8\n9\nfrom\nmanimlib\nimport\n*\nclass\nSquareToCircle\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nself\n.\nadd\n(\ncircle\n)\nAnd run this command:\nmanimgl\nstart.py\nSquareToCircle\nA window will pop up on the screen. And then you can :\nscroll the middle mouse button to move the screen up and down\nhold down the\nz\non the keyboard while scrolling the middle mouse button to zoom the screen\nhold down the\ns\nkey on the keyboard and move the mouse to pan the screen\nhold down the\nd\nkey on the keyboard and move the mouse to change the three-dimensional perspective.\nFinally, you can close the window and exit the program by pressing\nq\n.\nRun this command again:\nmanimgl\nstart.py\nSquareToCircle\n-os\nAt this time, no window will pop up. When the program is finished, this rendered\nimage will be automatically opened (saved in the subdirectory\nimages/\nof the same\nlevel directory of\nstart.py\nby default):\nMake an image\n¶\nNext, let’s take a detailed look at what each row does.\nLine 1\n:\nfrom\nmanimlib\nimport\n*\nThis will import all the classes that may be used when using manim.\nLine 3\n:\nclass\nSquareToCircle\n(\nScene\n):\nCreate a\nScene\nsubclass\nSquareToCircle\n, which will be\nthe scene you write and render.\nLine 4\n:\ndef\nconstruct\n(\nself\n):\nWrite the\nconstruct()\nmethod, the content of which will determine\nhow to create the mobjects in the screen and what operations need to be performed.\nLine 5\n:\ncircle\n=\nCircle\n()\nCreate a circle (an instance of the\nCircle\nclass), called\ncircle\nLine 6~7\n:\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nSet the circle style by calling the circle’s method.\nThe\n.set_fill()\nmethod sets the fill color of this circle to blue (\nBLUE\n, defined in\nconstants\n), and the fill transparency to 0.5.\nThe\n.set_stroke()\nmethod sets the stroke color of this circle to dark blue (\nBLUE_E\n, defined in\nconstants\n), and the stroke width to 4.\nLine 9\n:\nself\n.\nadd\n(\ncircle\n)\nAdd this circle to the screen through the\n.add()\nmethod of\nScene\n.\nAdd animations\n¶\nLet’s change some codes and add some animations to make videos instead of just pictures.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nfrom\nmanimlib\nimport\n*\nclass\nSquareToCircle\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nsquare\n=\nSquare\n()\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nself\n.\nwait\n()\nRun this command this time:\nmanimgl\nstart.py\nSquareToCircle\nThe pop-up window will play animations of drawing a square and transforming\nit into a circle. If you want to save this video, run:\nmanimgl\nstart.py\nSquareToCircle\n-o\nThis time there will be no pop-up window, but the video file (saved in the subdirectory\nvideos/\nof the same level directory of\nstart.py\nby default) will be automatically\nopened after the operation is over:\nLet’s take a look at the code this time. The first 7 lines are the same as the previous\nones, and the 8th line is similar to the 5th line, which creates an instance of the\nSquare\nclass and named it\nsquare\n.\nLine 10\n:\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nAn animation is played through\nScene\n’s\n.play()\nmethod.\nShowCreation\nis an animation that shows the process of creating a given mobject.\nself.play(ShowCreation(square))\nis to play the animation of creating\nsquare\n.\nLine 11\n:\nself\n.\nwait\n()\nUse\nScene\n’s\n.wait()\nmethod to pause (default 1s), you can pass in\nparameters to indicate the pause time (for example,\nself.wait(3)\nmeans pause for 3s).\nLine 12\n:\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nPlay the animation that transforms\nsquare\ninto\ncircle\n.\nReplacementTransform(A,\nB)\nmeans to transform A into B’s pattern and replace A with B.\nLine 13\n: Same as line 11, pause for 1s.\nEnable interaction\n¶\nInteraction is a new feature of the new version. You can add the following line\nat the end of the code to enable interaction:\nself\n.\nembed\n()\nThen run\nmanimgl\nstart.py\nSquareToCircle\n.\nAfter the previous animation is executed, the ipython terminal will be opened on\nthe command line. After that, you can continue to write code in it, and the statement\nyou entered will be executed immediately after pressing\nEnter\n.\nFor example: input the following lines (without comment lines) into it respectively\n(\nself.play\ncan be abbreviated as\nplay\nin this mode):\n# Stretched 4 times in the vertical direction\nplay\n(\ncircle\n.\nanimate\n.\nstretch\n(\n4\n,\ndim\n=\n0\n))\n# Rotate the ellipse 90°\nplay\n(\nRotate\n(\ncircle\n,\nTAU\n/\n4\n))\n# Move 2 units to the right and shrink to 1/4 of the original\nplay\n(\ncircle\n.\nanimate\n.\nshift\n(\n2\n*\nRIGHT\n),\ncircle\n.\nanimate\n.\nscale\n(\n0.25\n))\n# Insert 10 curves into circle for non-linear transformation (no animation will play)\ncircle\n.\ninsert_n_curves\n(\n10\n)\n# Apply a complex transformation of f(z)=z^2 to all points on the circle\nplay\n(\ncircle\n.\nanimate\n.\napply_complex_function\n(\nlambda\nz\n:\nz\n**\n2\n))\n# Close the window and exit the program\nexit\n()\nYou will get an animation similar to the following:\nIf you want to enter the interactive mode directly, you don’t have to write an\nempty scene containing only\nself.embed()\n, you can directly run the following command\n(this will enter the ipython terminal while the window pops up):\nmanimgl\nYou succeeded!\n¶\nAfter reading the above content, you already know how to use manim.\nBelow you can see some examples, in the\nExample Scenes\npage.\nBut before that, you’d better have a look at the\nCLI flags and configuration\nof manim.\nContents\nQuick Start\nMake an image\nAdd animations\nEnable interaction\nYou succeeded!",
    "code_examples": [
      "manim/\n├── manimlib/\n│   ├── animation/\n│   ├── ...\n│   ├── default_config.yml\n│   └── window.py\n├── custom_config.yml\n└── start.py",
      "1\n2\n3\n4\n5\n6\n7\n8\n9",
      "from manimlib import *\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n\n        self.add(circle)",
      "manimgl start.py SquareToCircle",
      "manimgl start.py SquareToCircle -os",
      "from manimlib import *",
      "class SquareToCircle(Scene):",
      "SquareToCircle",
      "def construct(self):",
      "construct()",
      "circle = Circle()",
      "circle.set_fill(BLUE, opacity=0.5)\ncircle.set_stroke(BLUE_E, width=4)",
      ".set_fill()",
      ".set_stroke()",
      "self.add(circle)",
      "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13",
      "from manimlib import *\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n        self.play(ReplacementTransform(square, circle))\n        self.wait()",
      "manimgl start.py SquareToCircle",
      "manimgl start.py SquareToCircle -o",
      "self.play(ShowCreation(square))",
      "ShowCreation",
      "self.play(ShowCreation(square))",
      "self.wait()",
      "self.wait(3)",
      "self.play(ReplacementTransform(square, circle))",
      "ReplacementTransform(A, B)",
      "self.embed()",
      "manimgl start.py SquareToCircle",
      "# Stretched 4 times in the vertical direction\nplay(circle.animate.stretch(4, dim=0))\n# Rotate the ellipse 90°\nplay(Rotate(circle, TAU / 4))\n# Move 2 units to the right and shrink to 1/4 of the original\nplay(circle.animate.shift(2 * RIGHT), circle.animate.scale(0.25))\n# Insert 10 curves into circle for non-linear transformation (no animation will play)\ncircle.insert_n_curves(10)\n# Apply a complex transformation of f(z)=z^2 to all points on the circle\nplay(circle.animate.apply_complex_function(lambda z: z**2))\n# Close the window and exit the program\nexit()",
      "self.embed()"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#quick-start",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#enable-interaction",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#you-succeeded",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#enable-interaction",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#you-succeeded"
    ],
    "scraped_at": 1752428837.856435
  },
  "https://3b1b.github.io/manim/getting_started/quickstart.html#enable-interaction": {
    "url": "https://3b1b.github.io/manim/getting_started/quickstart.html#enable-interaction",
    "title": "Quick Start - manim  documentation",
    "content": "Quick Start\n¶\nAfter installing the manim environment according to the instructions on the\nInstallation\npage, you can try to make a scene yourself from scratch.\nFirst, create a new\n.py\nfile (such as\nstart.py\n) according to the following\ndirectory structure:\nmanim/\n├── manimlib/\n│   ├── animation/\n│   ├── ...\n│   ├── default_config.yml\n│   └── window.py\n├── custom_config.yml\n└── start.py\nAnd paste the following code (I will explain the function of each line in detail later):\n1\n2\n3\n4\n5\n6\n7\n8\n9\nfrom\nmanimlib\nimport\n*\nclass\nSquareToCircle\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nself\n.\nadd\n(\ncircle\n)\nAnd run this command:\nmanimgl\nstart.py\nSquareToCircle\nA window will pop up on the screen. And then you can :\nscroll the middle mouse button to move the screen up and down\nhold down the\nz\non the keyboard while scrolling the middle mouse button to zoom the screen\nhold down the\ns\nkey on the keyboard and move the mouse to pan the screen\nhold down the\nd\nkey on the keyboard and move the mouse to change the three-dimensional perspective.\nFinally, you can close the window and exit the program by pressing\nq\n.\nRun this command again:\nmanimgl\nstart.py\nSquareToCircle\n-os\nAt this time, no window will pop up. When the program is finished, this rendered\nimage will be automatically opened (saved in the subdirectory\nimages/\nof the same\nlevel directory of\nstart.py\nby default):\nMake an image\n¶\nNext, let’s take a detailed look at what each row does.\nLine 1\n:\nfrom\nmanimlib\nimport\n*\nThis will import all the classes that may be used when using manim.\nLine 3\n:\nclass\nSquareToCircle\n(\nScene\n):\nCreate a\nScene\nsubclass\nSquareToCircle\n, which will be\nthe scene you write and render.\nLine 4\n:\ndef\nconstruct\n(\nself\n):\nWrite the\nconstruct()\nmethod, the content of which will determine\nhow to create the mobjects in the screen and what operations need to be performed.\nLine 5\n:\ncircle\n=\nCircle\n()\nCreate a circle (an instance of the\nCircle\nclass), called\ncircle\nLine 6~7\n:\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nSet the circle style by calling the circle’s method.\nThe\n.set_fill()\nmethod sets the fill color of this circle to blue (\nBLUE\n, defined in\nconstants\n), and the fill transparency to 0.5.\nThe\n.set_stroke()\nmethod sets the stroke color of this circle to dark blue (\nBLUE_E\n, defined in\nconstants\n), and the stroke width to 4.\nLine 9\n:\nself\n.\nadd\n(\ncircle\n)\nAdd this circle to the screen through the\n.add()\nmethod of\nScene\n.\nAdd animations\n¶\nLet’s change some codes and add some animations to make videos instead of just pictures.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nfrom\nmanimlib\nimport\n*\nclass\nSquareToCircle\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nsquare\n=\nSquare\n()\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nself\n.\nwait\n()\nRun this command this time:\nmanimgl\nstart.py\nSquareToCircle\nThe pop-up window will play animations of drawing a square and transforming\nit into a circle. If you want to save this video, run:\nmanimgl\nstart.py\nSquareToCircle\n-o\nThis time there will be no pop-up window, but the video file (saved in the subdirectory\nvideos/\nof the same level directory of\nstart.py\nby default) will be automatically\nopened after the operation is over:\nLet’s take a look at the code this time. The first 7 lines are the same as the previous\nones, and the 8th line is similar to the 5th line, which creates an instance of the\nSquare\nclass and named it\nsquare\n.\nLine 10\n:\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nAn animation is played through\nScene\n’s\n.play()\nmethod.\nShowCreation\nis an animation that shows the process of creating a given mobject.\nself.play(ShowCreation(square))\nis to play the animation of creating\nsquare\n.\nLine 11\n:\nself\n.\nwait\n()\nUse\nScene\n’s\n.wait()\nmethod to pause (default 1s), you can pass in\nparameters to indicate the pause time (for example,\nself.wait(3)\nmeans pause for 3s).\nLine 12\n:\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nPlay the animation that transforms\nsquare\ninto\ncircle\n.\nReplacementTransform(A,\nB)\nmeans to transform A into B’s pattern and replace A with B.\nLine 13\n: Same as line 11, pause for 1s.\nEnable interaction\n¶\nInteraction is a new feature of the new version. You can add the following line\nat the end of the code to enable interaction:\nself\n.\nembed\n()\nThen run\nmanimgl\nstart.py\nSquareToCircle\n.\nAfter the previous animation is executed, the ipython terminal will be opened on\nthe command line. After that, you can continue to write code in it, and the statement\nyou entered will be executed immediately after pressing\nEnter\n.\nFor example: input the following lines (without comment lines) into it respectively\n(\nself.play\ncan be abbreviated as\nplay\nin this mode):\n# Stretched 4 times in the vertical direction\nplay\n(\ncircle\n.\nanimate\n.\nstretch\n(\n4\n,\ndim\n=\n0\n))\n# Rotate the ellipse 90°\nplay\n(\nRotate\n(\ncircle\n,\nTAU\n/\n4\n))\n# Move 2 units to the right and shrink to 1/4 of the original\nplay\n(\ncircle\n.\nanimate\n.\nshift\n(\n2\n*\nRIGHT\n),\ncircle\n.\nanimate\n.\nscale\n(\n0.25\n))\n# Insert 10 curves into circle for non-linear transformation (no animation will play)\ncircle\n.\ninsert_n_curves\n(\n10\n)\n# Apply a complex transformation of f(z)=z^2 to all points on the circle\nplay\n(\ncircle\n.\nanimate\n.\napply_complex_function\n(\nlambda\nz\n:\nz\n**\n2\n))\n# Close the window and exit the program\nexit\n()\nYou will get an animation similar to the following:\nIf you want to enter the interactive mode directly, you don’t have to write an\nempty scene containing only\nself.embed()\n, you can directly run the following command\n(this will enter the ipython terminal while the window pops up):\nmanimgl\nYou succeeded!\n¶\nAfter reading the above content, you already know how to use manim.\nBelow you can see some examples, in the\nExample Scenes\npage.\nBut before that, you’d better have a look at the\nCLI flags and configuration\nof manim.\nContents\nQuick Start\nMake an image\nAdd animations\nEnable interaction\nYou succeeded!",
    "code_examples": [
      "manim/\n├── manimlib/\n│   ├── animation/\n│   ├── ...\n│   ├── default_config.yml\n│   └── window.py\n├── custom_config.yml\n└── start.py",
      "1\n2\n3\n4\n5\n6\n7\n8\n9",
      "from manimlib import *\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n\n        self.add(circle)",
      "manimgl start.py SquareToCircle",
      "manimgl start.py SquareToCircle -os",
      "from manimlib import *",
      "class SquareToCircle(Scene):",
      "SquareToCircle",
      "def construct(self):",
      "construct()",
      "circle = Circle()",
      "circle.set_fill(BLUE, opacity=0.5)\ncircle.set_stroke(BLUE_E, width=4)",
      ".set_fill()",
      ".set_stroke()",
      "self.add(circle)",
      "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13",
      "from manimlib import *\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n        self.play(ReplacementTransform(square, circle))\n        self.wait()",
      "manimgl start.py SquareToCircle",
      "manimgl start.py SquareToCircle -o",
      "self.play(ShowCreation(square))",
      "ShowCreation",
      "self.play(ShowCreation(square))",
      "self.wait()",
      "self.wait(3)",
      "self.play(ReplacementTransform(square, circle))",
      "ReplacementTransform(A, B)",
      "self.embed()",
      "manimgl start.py SquareToCircle",
      "# Stretched 4 times in the vertical direction\nplay(circle.animate.stretch(4, dim=0))\n# Rotate the ellipse 90°\nplay(Rotate(circle, TAU / 4))\n# Move 2 units to the right and shrink to 1/4 of the original\nplay(circle.animate.shift(2 * RIGHT), circle.animate.scale(0.25))\n# Insert 10 curves into circle for non-linear transformation (no animation will play)\ncircle.insert_n_curves(10)\n# Apply a complex transformation of f(z)=z^2 to all points on the circle\nplay(circle.animate.apply_complex_function(lambda z: z**2))\n# Close the window and exit the program\nexit()",
      "self.embed()"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#quick-start",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#you-succeeded",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#you-succeeded"
    ],
    "scraped_at": 1752428838.902793
  },
  "https://3b1b.github.io/manim/getting_started/quickstart.html#you-succeeded": {
    "url": "https://3b1b.github.io/manim/getting_started/quickstart.html#you-succeeded",
    "title": "Quick Start - manim  documentation",
    "content": "Quick Start\n¶\nAfter installing the manim environment according to the instructions on the\nInstallation\npage, you can try to make a scene yourself from scratch.\nFirst, create a new\n.py\nfile (such as\nstart.py\n) according to the following\ndirectory structure:\nmanim/\n├── manimlib/\n│   ├── animation/\n│   ├── ...\n│   ├── default_config.yml\n│   └── window.py\n├── custom_config.yml\n└── start.py\nAnd paste the following code (I will explain the function of each line in detail later):\n1\n2\n3\n4\n5\n6\n7\n8\n9\nfrom\nmanimlib\nimport\n*\nclass\nSquareToCircle\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nself\n.\nadd\n(\ncircle\n)\nAnd run this command:\nmanimgl\nstart.py\nSquareToCircle\nA window will pop up on the screen. And then you can :\nscroll the middle mouse button to move the screen up and down\nhold down the\nz\non the keyboard while scrolling the middle mouse button to zoom the screen\nhold down the\ns\nkey on the keyboard and move the mouse to pan the screen\nhold down the\nd\nkey on the keyboard and move the mouse to change the three-dimensional perspective.\nFinally, you can close the window and exit the program by pressing\nq\n.\nRun this command again:\nmanimgl\nstart.py\nSquareToCircle\n-os\nAt this time, no window will pop up. When the program is finished, this rendered\nimage will be automatically opened (saved in the subdirectory\nimages/\nof the same\nlevel directory of\nstart.py\nby default):\nMake an image\n¶\nNext, let’s take a detailed look at what each row does.\nLine 1\n:\nfrom\nmanimlib\nimport\n*\nThis will import all the classes that may be used when using manim.\nLine 3\n:\nclass\nSquareToCircle\n(\nScene\n):\nCreate a\nScene\nsubclass\nSquareToCircle\n, which will be\nthe scene you write and render.\nLine 4\n:\ndef\nconstruct\n(\nself\n):\nWrite the\nconstruct()\nmethod, the content of which will determine\nhow to create the mobjects in the screen and what operations need to be performed.\nLine 5\n:\ncircle\n=\nCircle\n()\nCreate a circle (an instance of the\nCircle\nclass), called\ncircle\nLine 6~7\n:\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nSet the circle style by calling the circle’s method.\nThe\n.set_fill()\nmethod sets the fill color of this circle to blue (\nBLUE\n, defined in\nconstants\n), and the fill transparency to 0.5.\nThe\n.set_stroke()\nmethod sets the stroke color of this circle to dark blue (\nBLUE_E\n, defined in\nconstants\n), and the stroke width to 4.\nLine 9\n:\nself\n.\nadd\n(\ncircle\n)\nAdd this circle to the screen through the\n.add()\nmethod of\nScene\n.\nAdd animations\n¶\nLet’s change some codes and add some animations to make videos instead of just pictures.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nfrom\nmanimlib\nimport\n*\nclass\nSquareToCircle\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nsquare\n=\nSquare\n()\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nself\n.\nwait\n()\nRun this command this time:\nmanimgl\nstart.py\nSquareToCircle\nThe pop-up window will play animations of drawing a square and transforming\nit into a circle. If you want to save this video, run:\nmanimgl\nstart.py\nSquareToCircle\n-o\nThis time there will be no pop-up window, but the video file (saved in the subdirectory\nvideos/\nof the same level directory of\nstart.py\nby default) will be automatically\nopened after the operation is over:\nLet’s take a look at the code this time. The first 7 lines are the same as the previous\nones, and the 8th line is similar to the 5th line, which creates an instance of the\nSquare\nclass and named it\nsquare\n.\nLine 10\n:\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nAn animation is played through\nScene\n’s\n.play()\nmethod.\nShowCreation\nis an animation that shows the process of creating a given mobject.\nself.play(ShowCreation(square))\nis to play the animation of creating\nsquare\n.\nLine 11\n:\nself\n.\nwait\n()\nUse\nScene\n’s\n.wait()\nmethod to pause (default 1s), you can pass in\nparameters to indicate the pause time (for example,\nself.wait(3)\nmeans pause for 3s).\nLine 12\n:\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nPlay the animation that transforms\nsquare\ninto\ncircle\n.\nReplacementTransform(A,\nB)\nmeans to transform A into B’s pattern and replace A with B.\nLine 13\n: Same as line 11, pause for 1s.\nEnable interaction\n¶\nInteraction is a new feature of the new version. You can add the following line\nat the end of the code to enable interaction:\nself\n.\nembed\n()\nThen run\nmanimgl\nstart.py\nSquareToCircle\n.\nAfter the previous animation is executed, the ipython terminal will be opened on\nthe command line. After that, you can continue to write code in it, and the statement\nyou entered will be executed immediately after pressing\nEnter\n.\nFor example: input the following lines (without comment lines) into it respectively\n(\nself.play\ncan be abbreviated as\nplay\nin this mode):\n# Stretched 4 times in the vertical direction\nplay\n(\ncircle\n.\nanimate\n.\nstretch\n(\n4\n,\ndim\n=\n0\n))\n# Rotate the ellipse 90°\nplay\n(\nRotate\n(\ncircle\n,\nTAU\n/\n4\n))\n# Move 2 units to the right and shrink to 1/4 of the original\nplay\n(\ncircle\n.\nanimate\n.\nshift\n(\n2\n*\nRIGHT\n),\ncircle\n.\nanimate\n.\nscale\n(\n0.25\n))\n# Insert 10 curves into circle for non-linear transformation (no animation will play)\ncircle\n.\ninsert_n_curves\n(\n10\n)\n# Apply a complex transformation of f(z)=z^2 to all points on the circle\nplay\n(\ncircle\n.\nanimate\n.\napply_complex_function\n(\nlambda\nz\n:\nz\n**\n2\n))\n# Close the window and exit the program\nexit\n()\nYou will get an animation similar to the following:\nIf you want to enter the interactive mode directly, you don’t have to write an\nempty scene containing only\nself.embed()\n, you can directly run the following command\n(this will enter the ipython terminal while the window pops up):\nmanimgl\nYou succeeded!\n¶\nAfter reading the above content, you already know how to use manim.\nBelow you can see some examples, in the\nExample Scenes\npage.\nBut before that, you’d better have a look at the\nCLI flags and configuration\nof manim.\nContents\nQuick Start\nMake an image\nAdd animations\nEnable interaction\nYou succeeded!",
    "code_examples": [
      "manim/\n├── manimlib/\n│   ├── animation/\n│   ├── ...\n│   ├── default_config.yml\n│   └── window.py\n├── custom_config.yml\n└── start.py",
      "1\n2\n3\n4\n5\n6\n7\n8\n9",
      "from manimlib import *\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n\n        self.add(circle)",
      "manimgl start.py SquareToCircle",
      "manimgl start.py SquareToCircle -os",
      "from manimlib import *",
      "class SquareToCircle(Scene):",
      "SquareToCircle",
      "def construct(self):",
      "construct()",
      "circle = Circle()",
      "circle.set_fill(BLUE, opacity=0.5)\ncircle.set_stroke(BLUE_E, width=4)",
      ".set_fill()",
      ".set_stroke()",
      "self.add(circle)",
      "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13",
      "from manimlib import *\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n        self.play(ReplacementTransform(square, circle))\n        self.wait()",
      "manimgl start.py SquareToCircle",
      "manimgl start.py SquareToCircle -o",
      "self.play(ShowCreation(square))",
      "ShowCreation",
      "self.play(ShowCreation(square))",
      "self.wait()",
      "self.wait(3)",
      "self.play(ReplacementTransform(square, circle))",
      "ReplacementTransform(A, B)",
      "self.embed()",
      "manimgl start.py SquareToCircle",
      "# Stretched 4 times in the vertical direction\nplay(circle.animate.stretch(4, dim=0))\n# Rotate the ellipse 90°\nplay(Rotate(circle, TAU / 4))\n# Move 2 units to the right and shrink to 1/4 of the original\nplay(circle.animate.shift(2 * RIGHT), circle.animate.scale(0.25))\n# Insert 10 curves into circle for non-linear transformation (no animation will play)\ncircle.insert_n_curves(10)\n# Apply a complex transformation of f(z)=z^2 to all points on the circle\nplay(circle.animate.apply_complex_function(lambda z: z**2))\n# Close the window and exit the program\nexit()",
      "self.embed()"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/quickstart.html#quick-start"
    ],
    "scraped_at": 1752428839.937922
  },
  "https://3b1b.github.io/manim/getting_started/configuration.html#command-line-interface": {
    "url": "https://3b1b.github.io/manim/getting_started/configuration.html#command-line-interface",
    "title": "CLI flags and configuration - manim  documentation",
    "content": "CLI flags and configuration\n¶\nCommand Line Interface\n¶\nTo run manim, you need to enter the directory at the same level as\nmanimlib/\nand enter the command in the following format into terminal:\nmanimgl\n<code>.py\n<Scene>\n<flags>\n# or\nmanim-render\n<code>.py\n<Scene>\n<flags>\n<code>.py\n: The python file you wrote. Needs to be at the same level as\nmanimlib/\n, otherwise you need to use an absolute path or a relative path.\n<Scene>\n: The scene you want to render here. If it is not written or written incorrectly, it will list all for you to choose. And if there is only one\nScene\nin the file, this class will be rendered directly.\n<flags>\n: CLI flags.\nSome useful flags\n¶\n-w\nto write the scene to a file.\n-o\nto write the scene to a file and open the result.\n-s\nto skip to the end and just show the final frame.\n-so\nwill save the final frame to an image and show it.\n-n\n<number>\nto skip ahead to the\nn\n’th animation of a scene.\n-f\nto make the playback window fullscreen.\nAll supported flags\n¶\nflag\nabbr\nfunction\n--help\n-h\nShow the help message and exit\n--version\n-v\nDisplay the version of manimgl\n--write_file\n-w\nRender the scene as a movie file\n--skip_animations\n-s\nSkip to the last frame\n--low_quality\n-l\nRender at a low quality (for faster rendering)\n--medium_quality\n-m\nRender at a medium quality\n--hd\nRender at a 1080p quality\n--uhd\nRender at a 4k quality\n--full_screen\n-f\nShow window in full screen\n--presenter_mode\n-p\nScene will stay paused during wait calls until space bar or right arrow is hit, like a slide show\n--save_pngs\n-g\nSave each frame as a png\n--gif\n-i\nSave the video as gif\n--transparent\n-t\nRender to a movie file with an alpha channel\n--quiet\n-q\n--write_all\n-a\nWrite all the scenes from a file\n--open\n-o\nAutomatically open the saved file once its done\n--finder\nShow the output file in finder\n--config\nGuide for automatic configuration\n--file_name\nFILE_NAME\nName for the movie or image file\n--start_at_animation_number\nSTART_AT_ANIMATION_NUMBER\n-n\nStart rendering not from the first animation, but from another, specified by its index. If you passing two comma separated values, e.g. “3,6”, it will end the rendering at the second value.\n--embed\n[EMBED]\n-e\nCreates a new file where the line\nself.embed\nis inserted into the Scenes construct method. If a string is passed in, the line will be inserted below the last line of code including that string.\n--resolution\nRESOLUTION\n-r\nResolution, passed as “WxH”, e.g. “1920x1080”\n--fps\nFPS\nFrame rate, as an integer\n--color\nCOLOR\n-c\nBackground color\n--leave_progress_bars\nLeave progress bars displayed in terminal\n--video_dir\nVIDEO_DIR\nDirectory to write video\n--config_file\nCONFIG_FILE\nPath to the custom configuration file\n--log-level\nLOG_LEVEL\nLevel of messages to Display, can be DEBUG / INFO / WARNING / ERROR / CRITICAL\ncustom_config\n¶\nIn order to perform more configuration (about directories, etc.) and permanently\nchange the default value (you don’t have to add flags to the command every time),\nyou can modify\ncustom_config.yml\n. The meaning of each option is in\npage\ncustom_config\n.\nYou can also use different\ncustom_config.yml\nfor different directories, such as\nfollowing the directory structure:\nmanim/\n├── manimlib/\n│   ├── animation/\n│   ├── ...\n│   ├── default_config.yml\n│   └── window.py\n├── project/\n│   ├── code.py\n│   └── custom_config.yml\n└── custom_config.yml\nWhen you enter the\nproject/\nfolder and run\nmanimgl\ncode.py\n<Scene>\n,\nit will overwrite\nmanim/default_config.yml\nwith\ncustom_config.yml\nin the\nproject\nfolder.\nAlternatively, you can use\n--config_file\nflag in CLI to specify configuration file manually.\nmanimgl\nproject/code.py\n--config_file\n/path/to/custom_config.yml\nContents\nCLI flags and configuration\nCommand Line Interface\nSome useful flags\nAll supported flags\ncustom_config",
    "code_examples": [
      "manimgl <code>.py <Scene> <flags>\n# or\nmanim-render <code>.py <Scene> <flags>",
      "-n <number>",
      "--write_file",
      "--skip_animations",
      "--low_quality",
      "--medium_quality",
      "--full_screen",
      "--presenter_mode",
      "--save_pngs",
      "--transparent",
      "--write_all",
      "--file_name FILE_NAME",
      "--start_at_animation_number START_AT_ANIMATION_NUMBER",
      "--embed [EMBED]",
      "--resolution RESOLUTION",
      "--color COLOR",
      "--leave_progress_bars",
      "--video_dir VIDEO_DIR",
      "--config_file CONFIG_FILE",
      "--log-level LOG_LEVEL",
      "custom_config.yml",
      "custom_config.yml",
      "manim/\n├── manimlib/\n│   ├── animation/\n│   ├── ...\n│   ├── default_config.yml\n│   └── window.py\n├── project/\n│   ├── code.py\n│   └── custom_config.yml\n└── custom_config.yml",
      "manimgl code.py <Scene>",
      "manim/default_config.yml",
      "custom_config.yml",
      "--config_file",
      "manimgl project/code.py --config_file /path/to/custom_config.yml"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/configuration.html#cli-flags-and-configuration",
      "https://3b1b.github.io/manim/getting_started/configuration.html#some-useful-flags",
      "https://3b1b.github.io/manim/getting_started/configuration.html#all-supported-flags",
      "https://3b1b.github.io/manim/getting_started/configuration.html#custom-config",
      "https://3b1b.github.io/manim/getting_started/configuration.html#some-useful-flags",
      "https://3b1b.github.io/manim/getting_started/configuration.html#all-supported-flags",
      "https://3b1b.github.io/manim/getting_started/configuration.html#custom-config"
    ],
    "scraped_at": 1752428841.1576169
  },
  "https://3b1b.github.io/manim/getting_started/configuration.html#custom-config": {
    "url": "https://3b1b.github.io/manim/getting_started/configuration.html#custom-config",
    "title": "CLI flags and configuration - manim  documentation",
    "content": "CLI flags and configuration\n¶\nCommand Line Interface\n¶\nTo run manim, you need to enter the directory at the same level as\nmanimlib/\nand enter the command in the following format into terminal:\nmanimgl\n<code>.py\n<Scene>\n<flags>\n# or\nmanim-render\n<code>.py\n<Scene>\n<flags>\n<code>.py\n: The python file you wrote. Needs to be at the same level as\nmanimlib/\n, otherwise you need to use an absolute path or a relative path.\n<Scene>\n: The scene you want to render here. If it is not written or written incorrectly, it will list all for you to choose. And if there is only one\nScene\nin the file, this class will be rendered directly.\n<flags>\n: CLI flags.\nSome useful flags\n¶\n-w\nto write the scene to a file.\n-o\nto write the scene to a file and open the result.\n-s\nto skip to the end and just show the final frame.\n-so\nwill save the final frame to an image and show it.\n-n\n<number>\nto skip ahead to the\nn\n’th animation of a scene.\n-f\nto make the playback window fullscreen.\nAll supported flags\n¶\nflag\nabbr\nfunction\n--help\n-h\nShow the help message and exit\n--version\n-v\nDisplay the version of manimgl\n--write_file\n-w\nRender the scene as a movie file\n--skip_animations\n-s\nSkip to the last frame\n--low_quality\n-l\nRender at a low quality (for faster rendering)\n--medium_quality\n-m\nRender at a medium quality\n--hd\nRender at a 1080p quality\n--uhd\nRender at a 4k quality\n--full_screen\n-f\nShow window in full screen\n--presenter_mode\n-p\nScene will stay paused during wait calls until space bar or right arrow is hit, like a slide show\n--save_pngs\n-g\nSave each frame as a png\n--gif\n-i\nSave the video as gif\n--transparent\n-t\nRender to a movie file with an alpha channel\n--quiet\n-q\n--write_all\n-a\nWrite all the scenes from a file\n--open\n-o\nAutomatically open the saved file once its done\n--finder\nShow the output file in finder\n--config\nGuide for automatic configuration\n--file_name\nFILE_NAME\nName for the movie or image file\n--start_at_animation_number\nSTART_AT_ANIMATION_NUMBER\n-n\nStart rendering not from the first animation, but from another, specified by its index. If you passing two comma separated values, e.g. “3,6”, it will end the rendering at the second value.\n--embed\n[EMBED]\n-e\nCreates a new file where the line\nself.embed\nis inserted into the Scenes construct method. If a string is passed in, the line will be inserted below the last line of code including that string.\n--resolution\nRESOLUTION\n-r\nResolution, passed as “WxH”, e.g. “1920x1080”\n--fps\nFPS\nFrame rate, as an integer\n--color\nCOLOR\n-c\nBackground color\n--leave_progress_bars\nLeave progress bars displayed in terminal\n--video_dir\nVIDEO_DIR\nDirectory to write video\n--config_file\nCONFIG_FILE\nPath to the custom configuration file\n--log-level\nLOG_LEVEL\nLevel of messages to Display, can be DEBUG / INFO / WARNING / ERROR / CRITICAL\ncustom_config\n¶\nIn order to perform more configuration (about directories, etc.) and permanently\nchange the default value (you don’t have to add flags to the command every time),\nyou can modify\ncustom_config.yml\n. The meaning of each option is in\npage\ncustom_config\n.\nYou can also use different\ncustom_config.yml\nfor different directories, such as\nfollowing the directory structure:\nmanim/\n├── manimlib/\n│   ├── animation/\n│   ├── ...\n│   ├── default_config.yml\n│   └── window.py\n├── project/\n│   ├── code.py\n│   └── custom_config.yml\n└── custom_config.yml\nWhen you enter the\nproject/\nfolder and run\nmanimgl\ncode.py\n<Scene>\n,\nit will overwrite\nmanim/default_config.yml\nwith\ncustom_config.yml\nin the\nproject\nfolder.\nAlternatively, you can use\n--config_file\nflag in CLI to specify configuration file manually.\nmanimgl\nproject/code.py\n--config_file\n/path/to/custom_config.yml\nContents\nCLI flags and configuration\nCommand Line Interface\nSome useful flags\nAll supported flags\ncustom_config",
    "code_examples": [
      "manimgl <code>.py <Scene> <flags>\n# or\nmanim-render <code>.py <Scene> <flags>",
      "-n <number>",
      "--write_file",
      "--skip_animations",
      "--low_quality",
      "--medium_quality",
      "--full_screen",
      "--presenter_mode",
      "--save_pngs",
      "--transparent",
      "--write_all",
      "--file_name FILE_NAME",
      "--start_at_animation_number START_AT_ANIMATION_NUMBER",
      "--embed [EMBED]",
      "--resolution RESOLUTION",
      "--color COLOR",
      "--leave_progress_bars",
      "--video_dir VIDEO_DIR",
      "--config_file CONFIG_FILE",
      "--log-level LOG_LEVEL",
      "custom_config.yml",
      "custom_config.yml",
      "manim/\n├── manimlib/\n│   ├── animation/\n│   ├── ...\n│   ├── default_config.yml\n│   └── window.py\n├── project/\n│   ├── code.py\n│   └── custom_config.yml\n└── custom_config.yml",
      "manimgl code.py <Scene>",
      "manim/default_config.yml",
      "custom_config.yml",
      "--config_file",
      "manimgl project/code.py --config_file /path/to/custom_config.yml"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/configuration.html#cli-flags-and-configuration",
      "https://3b1b.github.io/manim/getting_started/configuration.html#some-useful-flags",
      "https://3b1b.github.io/manim/getting_started/configuration.html#all-supported-flags",
      "https://3b1b.github.io/manim/getting_started/configuration.html#some-useful-flags",
      "https://3b1b.github.io/manim/getting_started/configuration.html#all-supported-flags"
    ],
    "scraped_at": 1752428842.187222
  },
  "https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevlopment": {
    "url": "https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevlopment",
    "title": "Example Scenes - manim  documentation",
    "content": "Example Scenes\n¶\nAfter understanding the previous knowledge, we can understand more scenes.\nMany example scenes are given in\nexample_scenes.py\n, let’s start with\nthe simplest and one by one.\nInteractiveDevlopment\n¶\nInteractiveDevelopment\n¶\nfrom\nmanimlib\nimport\n*\nclass\nInteractiveDevelopment\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nsquare\n=\nSquare\n()\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nself\n.\nwait\n()\n# This opens an iPython terminal where you can keep writing\n# lines as if they were part of this construct method.\n# In particular, 'square', 'circle' and 'self' will all be\n# part of the local namespace in that terminal.\nself\n.\nembed\n()\n# Try copying and pasting some of the lines below into\n# the interactive shell\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nstretch\n(\n4\n,\n0\n))\nself\n.\nplay\n(\nRotate\n(\ncircle\n,\n90\n*\nDEGREES\n))\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nshift\n(\n2\n*\nRIGHT\n)\n.\nscale\n(\n0.25\n))\ntext\n=\nText\n(\n\"\"\"\nIn general, using the interactive shell\nis very helpful when developing new scenes\n\"\"\"\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\n# In the interactive shell, you can just type\n# play, add, remove, clear, wait, save_state and restore,\n# instead of self.play, self.add, self.remove, etc.\n# To interact with the window, type touch().  You can then\n# scroll in the window, or zoom by holding down 'z' while scrolling,\n# and change camera perspective by holding down 'd' while moving\n# the mouse.  Press 'r' to reset to the standard camera position.\n# Press 'q' to stop interacting with the window and go back to\n# typing new commands into the shell.\n# In principle you can customize a scene to be responsive to\n# mouse and keyboard interactions\nalways\n(\ncircle\n.\nmove_to\n,\nself\n.\nmouse_point\n)\nThis scene is similar to what we wrote in\nQuick Start\n.\nAnd how to interact has been written in the comments.\nNo more explanation here.\nAnimatingMethods\n¶\nAnimatingMethods\n¶\nclass\nAnimatingMethods\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ngrid\n=\nOldTex\n(\nr\n\"\\pi\"\n)\n.\nget_grid\n(\n10\n,\n10\n,\nheight\n=\n4\n)\nself\n.\nadd\n(\ngrid\n)\n# You can animate the application of mobject methods with the\n# \".animate\" syntax:\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nshift\n(\nLEFT\n))\n# Alternatively, you can use the older syntax by passing the\n# method and then the arguments to the scene's \"play\" function:\nself\n.\nplay\n(\ngrid\n.\nshift\n,\nLEFT\n)\n# Both of those will interpolate between the mobject's initial\n# state and whatever happens when you apply that method.\n# For this example, calling grid.shift(LEFT) would shift the\n# grid one unit to the left, but both of the previous calls to\n# \"self.play\" animate that motion.\n# The same applies for any method, including those setting colors.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_color\n(\nYELLOW\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_submobject_colors_by_gradient\n(\nBLUE\n,\nGREEN\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_height\n(\nTAU\n-\nMED_SMALL_BUFF\n))\nself\n.\nwait\n()\n# The method Mobject.apply_complex_function lets you apply arbitrary\n# complex functions, treating the points defining the mobject as\n# complex numbers.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_complex_function\n(\nnp\n.\nexp\n),\nrun_time\n=\n5\n)\nself\n.\nwait\n()\n# Even more generally, you could apply Mobject.apply_function,\n# which takes in functions form R^3 to R^3\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_function\n(\nlambda\np\n:\n[\np\n[\n0\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n1\n]),\np\n[\n1\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n0\n]),\np\n[\n2\n]\n]\n),\nrun_time\n=\n5\n,\n)\nself\n.\nwait\n()\nThe new usage in this scene is\n.get_grid()\nand\nself.play(mob.animate.method(args))\n.\n.get_grid()\nmethod will return a new mobject containing multiple copies of this one arranged in a grid.\nself.play(mob.animate.method(args))\nanimates the method, and the details are in the comments above.\nTextExample\n¶\nTextExample\n¶\nclass\nTextExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\n# To run this scene properly, you should have \"Consolas\" font in your computer\n# for full usage, you can see https://github.com/3b1b/manim/pull/680\ntext\n=\nText\n(\n\"Here is a text\"\n,\nfont\n=\n\"Consolas\"\n,\nfont_size\n=\n90\n)\ndifference\n=\nText\n(\n\"\"\"\nThe most important difference between Text and TexText is that\\n\nyou can change the font more easily, but can't use the LaTeX grammar\n\"\"\"\n,\nfont\n=\n\"Arial\"\n,\nfont_size\n=\n24\n,\n# t2c is a dict that you can choose color for different text\nt2c\n=\n{\n\"Text\"\n:\nBLUE\n,\n\"TexText\"\n:\nBLUE\n,\n\"LaTeX\"\n:\nORANGE\n}\n)\nVGroup\n(\ntext\n,\ndifference\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\nself\n.\nplay\n(\nFadeIn\n(\ndifference\n,\nUP\n))\nself\n.\nwait\n(\n3\n)\nfonts\n=\nText\n(\n\"And you can also set the font according to different words\"\n,\nfont\n=\n\"Arial\"\n,\nt2f\n=\n{\n\"font\"\n:\n\"Consolas\"\n,\n\"words\"\n:\n\"Consolas\"\n},\nt2c\n=\n{\n\"font\"\n:\nBLUE\n,\n\"words\"\n:\nGREEN\n}\n)\nfonts\n.\nset_width\n(\nFRAME_WIDTH\n-\n1\n)\nslant\n=\nText\n(\n\"And the same as slant and weight\"\n,\nfont\n=\n\"Consolas\"\n,\nt2s\n=\n{\n\"slant\"\n:\nITALIC\n},\nt2w\n=\n{\n\"weight\"\n:\nBOLD\n},\nt2c\n=\n{\n\"slant\"\n:\nORANGE\n,\n\"weight\"\n:\nRED\n}\n)\nVGroup\n(\nfonts\n,\nslant\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n0.8\n)\nself\n.\nplay\n(\nFadeOut\n(\ntext\n),\nFadeOut\n(\ndifference\n,\nshift\n=\nDOWN\n))\nself\n.\nplay\n(\nWrite\n(\nfonts\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nWrite\n(\nslant\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nText\n,\nVGroup\n,\nWrite\n,\nFadeIn\nand\nFadeOut\n.\nText\ncan create text, define fonts, etc. The usage ais clearly reflected in the above examples.\nVGroup\ncan put multiple\nVMobject\ntogether as a whole. In the example, the\n.arrange()\nmethod is called to arrange the sub-mobjects in sequence downward (\nDOWN\n), and the spacing is\nbuff\n.\nWrite\nis an animation that shows similar writing effects.\nFadeIn\nfades the object in, the second parameter indicates the direction of the fade in.\nFadeOut\nfades out the object, the second parameter indicates the direction of the fade out.\nTexTransformExample\n¶\nTexTransformExample\n¶\nclass\nTexTransformExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nto_isolate\n=\n[\n\"B\"\n,\n\"C\"\n,\n\"=\"\n,\n\"(\"\n,\n\")\"\n]\nlines\n=\nVGroup\n(\n# Passing in muliple arguments to Tex will result\n# in the same expression as if those arguments had\n# been joined together, except that the submobject\n# hierarchy of the resulting mobject ensure that the\n# Tex mobject has a subject corresponding to\n# each of these strings.  For example, the Tex mobject\n# below will have 5 subjects, corresponding to the\n# expressions [A^2, +, B^2, =, C^2]\nOldTex\n(\n\"A^2\"\n,\n\"+\"\n,\n\"B^2\"\n,\n\"=\"\n,\n\"C^2\"\n),\n# Likewise here\nOldTex\n(\n\"A^2\"\n,\n\"=\"\n,\n\"C^2\"\n,\n\"-\"\n,\n\"B^2\"\n),\n# Alternatively, you can pass in the keyword argument\n# \"isolate\" with a list of strings that should be out as\n# their own submobject.  So the line below is equivalent\n# to the commented out line below it.\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A^2\"\n,\n*\nto_isolate\n]),\n# OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\nOldTex\n(\n\"A =\n\\\\\nsqrt{(C + B)(C - B)}\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\n)\nlines\n.\narrange\n(\nDOWN\n,\nbuff\n=\nLARGE_BUFF\n)\nfor\nline\nin\nlines\n:\nline\n.\nset_color_by_tex_to_color_map\n({\n\"A\"\n:\nBLUE\n,\n\"B\"\n:\nTEAL\n,\n\"C\"\n:\nGREEN\n,\n})\nplay_kw\n=\n{\n\"run_time\"\n:\n2\n}\nself\n.\nadd\n(\nlines\n[\n0\n])\n# The animation TransformMatchingTex will line up parts\n# of the source and target which have matching tex strings.\n# Here, giving it a little path_arc makes each part sort of\n# rotate into their final positions, which feels appropriate\n# for the idea of rearranging an equation\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n0\n]\n.\ncopy\n(),\nlines\n[\n1\n],\npath_arc\n=\n90\n*\nDEGREES\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# Now, we could try this again on the next line...\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n]),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# ...and this looks nice enough, but since there's no tex\n# in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n# out to nothing while the C and B terms fade in from nothing.\n# If, however, we want the C^2 to go to C, and B^2 to go to B,\n# we can specify that with a key map.\nself\n.\nplay\n(\nFadeOut\n(\nlines\n[\n2\n]))\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n],\nkey_map\n=\n{\n\"C^2\"\n:\n\"C\"\n,\n\"B^2\"\n:\n\"B\"\n,\n}\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# And to finish off, a simple TransformMatchingShapes would work\n# just fine.  But perhaps we want that exponent on A^2 to transform into\n# the square root symbol.  At the moment, lines[2] treats the expression\n# A^2 as a unit, so we might create a new version of the same line which\n# separates out just the A.  This way, when TransformMatchingTex lines up\n# all matching parts, the only mismatch will be between the \"^2\" from\n# new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n# transform_mismatches=True, it will transform this \"^2\" part into\n# the \"\\sqrt\" part.\nnew_line2\n=\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\nnew_line2\n.\nreplace\n(\nlines\n[\n2\n])\nnew_line2\n.\nmatch_style\n(\nlines\n[\n2\n])\nself\n.\nplay\n(\nTransformMatchingTex\n(\nnew_line2\n,\nlines\n[\n3\n],\ntransform_mismatches\n=\nTrue\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n(\n3\n)\nself\n.\nplay\n(\nFadeOut\n(\nlines\n,\nRIGHT\n))\n# Alternatively, if you don't want to think about breaking up\n# the tex strings deliberately, you can TransformMatchingShapes,\n# which will try to line up all pieces of a source mobject with\n# those of a target, regardless of the submobject hierarchy in\n# each one, according to whether those pieces have the same\n# shape (as best it can).\nsource\n=\nText\n(\n\"the morse code\"\n,\nheight\n=\n1\n)\ntarget\n=\nText\n(\n\"here come dots\"\n,\nheight\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\nsource\n))\nself\n.\nwait\n()\nkw\n=\n{\n\"run_time\"\n:\n3\n,\n\"path_arc\"\n:\nPI\n/\n2\n}\nself\n.\nplay\n(\nTransformMatchingShapes\n(\nsource\n,\ntarget\n,\n**\nkw\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nTransformMatchingShapes\n(\ntarget\n,\nsource\n,\n**\nkw\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nTex\n,\nTexText\n,\nTransformMatchingTex\nand\nTransformMatchingShapes\n.\nTex\nuses LaTeX to create mathematical formulas.\nTexText\nuses LaTeX to create text.\nTransformMatchingTeX\nautomatically transforms sub-objects according to the similarities and differences of tex in\nTex\n.\nTransformMatchingShapes\nautomatically transform sub-objects directly based on the similarities and differences of the object point sets.\nUpdatersExample\n¶\nUpdatersExample\n¶\nclass\nUpdatersExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nsquare\n=\nSquare\n()\nsquare\n.\nset_fill\n(\nBLUE_E\n,\n1\n)\n# On all all frames, the constructor Brace(square, UP) will\n# be called, and the mobject brace will set its data to match\n# that of the newly constructed object\nbrace\n=\nalways_redraw\n(\nBrace\n,\nsquare\n,\nUP\n)\ntext\n,\nnumber\n=\nlabel\n=\nVGroup\n(\nText\n(\n\"Width = \"\n),\nDecimalNumber\n(\n0\n,\nshow_ellipsis\n=\nTrue\n,\nnum_decimal_places\n=\n2\n,\ninclude_sign\n=\nTrue\n,\n)\n)\nlabel\n.\narrange\n(\nRIGHT\n)\n# This ensures that the method deicmal.next_to(square)\n# is called on every frame\nalways\n(\nlabel\n.\nnext_to\n,\nbrace\n,\nUP\n)\n# You could also write the following equivalent line\n# label.add_updater(lambda m: m.next_to(brace, UP))\n# If the argument itself might change, you can use f_always,\n# for which the arguments following the initial Mobject method\n# should be functions returning arguments to that method.\n# The following line ensures that decimal.set_value(square.get_y())\n# is called every frame\nf_always\n(\nnumber\n.\nset_value\n,\nsquare\n.\nget_width\n)\n# You could also write the following equivalent line\n# number.add_updater(lambda m: m.set_value(square.get_width()))\nself\n.\nadd\n(\nsquare\n,\nbrace\n,\nlabel\n)\n# Notice that the brace and label track with the square\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nscale\n(\n2\n),\nrate_func\n=\nthere_and_back\n,\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n5\n,\nstretch\n=\nTrue\n),\nrun_time\n=\n3\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# In general, you can alway call Mobject.add_updater, and pass in\n# a function that you want to be called on every frame.  The function\n# should take in either one argument, the mobject, or two arguments,\n# the mobject and the amount of time since the last frame.\nnow\n=\nself\n.\ntime\nw0\n=\nsquare\n.\nget_width\n()\nsquare\n.\nadd_updater\n(\nlambda\nm\n:\nm\n.\nset_width\n(\nw0\n*\nmath\n.\ncos\n(\nself\n.\ntime\n-\nnow\n))\n)\nself\n.\nwait\n(\n4\n*\nPI\n)\nThe new classes and usage in this scene are\nalways_redraw()\n,\nDecimalNumber\n,\n.to_edge()\n,\n.center()\n,\nalways()\n,\nf_always()\n,\n.set_y()\nand\n.add_updater()\n.\nalways_redraw()\nfunction create a new mobject every frame.\nDecimalNumber\nis a variable number, speed it up by breaking it into\nText\ncharacters.\n.to_edge()\nmeans to place the object on the edge of the screen.\n.center()\nmeans to place the object in the center of the screen.\nalways(f,\nx)\nmeans that a certain function (\nf(x)\n) is executed every frame.\nf_always(f,\ng)\nis similar to\nalways\n, executed\nf(g())\nevery frame.\n.set_y()\nmeans to set the ordinate of the object on the screen.\n.add_updater()\nsets an update function for the object. For example:\nmob1.add_updater(lambda\nmob:\nmob.next_to(mob2))\nmeans\nmob1.next_to(mob2)\nis executed every frame.\nCoordinateSystemExample\n¶\nCoordinateSystemExample\n¶\nclass\nCoordinateSystemExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n(\n# x-axis ranges from -1 to 10, with a default step size of 1\nx_range\n=\n(\n-\n1\n,\n10\n),\n# y-axis ranges from -2 to 2 with a step size of 0.5\ny_range\n=\n(\n-\n2\n,\n2\n,\n0.5\n),\n# The axes will be stretched so as to match the specified\n# height and width\nheight\n=\n6\n,\nwidth\n=\n10\n,\n# Axes is made of two NumberLine mobjects.  You can specify\n# their configuration with axis_config\naxis_config\n=\n{\n\"stroke_color\"\n:\nGREY_A\n,\n\"stroke_width\"\n:\n2\n,\n},\n# Alternatively, you can specify configuration for just one\n# of them, like this.\ny_axis_config\n=\n{\n\"include_tip\"\n:\nFalse\n,\n}\n)\n# Keyword arguments of add_coordinate_labels can be used to\n# configure the DecimalNumber mobjects which it creates and\n# adds to the axes\naxes\n.\nadd_coordinate_labels\n(\nfont_size\n=\n20\n,\nnum_decimal_places\n=\n1\n,\n)\nself\n.\nadd\n(\naxes\n)\n# Axes descends from the CoordinateSystem class, meaning\n# you can call call axes.coords_to_point, abbreviated to\n# axes.c2p, to associate a set of coordinates with a point,\n# like so:\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\nc2p\n(\n0\n,\n0\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n5\n,\n0.5\n)))\nself\n.\nwait\n()\n# Similarly, you can call axes.point_to_coords, or axes.p2c\n# print(axes.p2c(dot.get_center()))\n# We can draw lines from the axes to better mark the coordinates\n# of a given point.\n# Here, the always_redraw command means that on each new frame\n# the lines will be redrawn\nh_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_h_line\n(\ndot\n.\nget_left\n()))\nv_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_v_line\n(\ndot\n.\nget_bottom\n()))\nself\n.\nplay\n(\nShowCreation\n(\nh_line\n),\nShowCreation\n(\nv_line\n),\n)\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n-\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n1\n,\n1\n)))\nself\n.\nwait\n()\n# If we tie the dot to a particular set of coordinates, notice\n# that as we move the axes around it respects the coordinate\n# system defined by them.\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\nc2p\n(\n1\n,\n1\n))\nself\n.\nplay\n(\naxes\n.\nanimate\n.\nscale\n(\n0.75\n)\n.\nto_corner\n(\nUL\n),\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nFadeOut\n(\nVGroup\n(\naxes\n,\ndot\n,\nh_line\n,\nv_line\n)))\n# Other coordinate systems you can play around with include\n# ThreeDAxes, NumberPlane, and ComplexPlane.\nGraphExample\n¶\nGraphExample\n¶\nclass\nGraphExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n((\n-\n3\n,\n10\n),\n(\n-\n1\n,\n8\n))\naxes\n.\nadd_coordinate_labels\n()\nself\n.\nplay\n(\nWrite\n(\naxes\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n1\n))\n# Axes.get_graph will return the graph of a function\nsin_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2\n*\nmath\n.\nsin\n(\nx\n),\ncolor\n=\nBLUE\n,\n)\n# By default, it draws it so as to somewhat smoothly interpolate\n# between sampled points (x, f(x)).  If the graph is meant to have\n# a corner, though, you can set use_smoothing to False\nrelu_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\nmax\n(\nx\n,\n0\n),\nuse_smoothing\n=\nFalse\n,\ncolor\n=\nYELLOW\n,\n)\n# For discontinuous functions, you can specify the point of\n# discontinuity so that it does not try to draw over the gap.\nstep_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2.0\nif\nx\n>\n3\nelse\n1.0\n,\ndiscontinuities\n=\n[\n3\n],\ncolor\n=\nGREEN\n,\n)\n# Axes.get_graph_label takes in either a string or a mobject.\n# If it's a string, it treats it as a LaTeX expression.  By default\n# it places the label next to the graph near the right side, and\n# has it match the color of the graph\nsin_label\n=\naxes\n.\nget_graph_label\n(\nsin_graph\n,\n\"\n\\\\\nsin(x)\"\n)\nrelu_label\n=\naxes\n.\nget_graph_label\n(\nrelu_graph\n,\nText\n(\n\"ReLU\"\n))\nstep_label\n=\naxes\n.\nget_graph_label\n(\nstep_graph\n,\nText\n(\n\"Step\"\n),\nx\n=\n4\n)\nself\n.\nplay\n(\nShowCreation\n(\nsin_graph\n),\nFadeIn\n(\nsin_label\n,\nRIGHT\n),\n)\nself\n.\nwait\n(\n2\n)\nself\n.\nplay\n(\nReplacementTransform\n(\nsin_graph\n,\nrelu_graph\n),\nFadeTransform\n(\nsin_label\n,\nrelu_label\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nReplacementTransform\n(\nrelu_graph\n,\nstep_graph\n),\nFadeTransform\n(\nrelu_label\n,\nstep_label\n),\n)\nself\n.\nwait\n()\nparabola\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n0.25\n*\nx\n**\n2\n)\nparabola\n.\nset_stroke\n(\nBLUE\n)\nself\n.\nplay\n(\nFadeOut\n(\nstep_graph\n),\nFadeOut\n(\nstep_label\n),\nShowCreation\n(\nparabola\n)\n)\nself\n.\nwait\n()\n# You can use axes.input_to_graph_point, abbreviated\n# to axes.i2gp, to find a particular point on a graph\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\ni2gp\n(\n2\n,\nparabola\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\n# A value tracker lets us animate a parameter, usually\n# with the intent of having other mobjects update based\n# on the parameter\nx_tracker\n=\nValueTracker\n(\n2\n)\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\ni2gp\n(\nx_tracker\n.\nget_value\n(),\nparabola\n)\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n4\n),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n-\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\nSurfaceExample\n¶\nSurfaceExample\n¶\nclass\nSurfaceExample\n(\nScene\n):\nCONFIG\n=\n{\n\"camera_class\"\n:\nThreeDCamera\n,\n}\ndef\nconstruct\n(\nself\n):\nsurface_text\n=\nText\n(\n\"For 3d scenes, try using surfaces\"\n)\nsurface_text\n.\nfix_in_frame\n()\nsurface_text\n.\nto_edge\n(\nUP\n)\nself\n.\nadd\n(\nsurface_text\n)\nself\n.\nwait\n(\n0.1\n)\ntorus1\n=\nTorus\n(\nr1\n=\n1\n,\nr2\n=\n1\n)\ntorus2\n=\nTorus\n(\nr1\n=\n3\n,\nr2\n=\n1\n)\nsphere\n=\nSphere\n(\nradius\n=\n3\n,\nresolution\n=\ntorus1\n.\nresolution\n)\n# You can texture a surface with up to two images, which will\n# be interpreted as the side towards the light, and away from\n# the light.  These can be either urls, or paths to a local file\n# in whatever you've set as the image directory in\n# the custom_config.yml file\n# day_texture = \"EarthTextureMap\"\n# night_texture = \"NightEarthTextureMap\"\nday_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\nnight_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\nsurfaces\n=\n[\nTexturedSurface\n(\nsurface\n,\nday_texture\n,\nnight_texture\n)\nfor\nsurface\nin\n[\nsphere\n,\ntorus1\n,\ntorus2\n]\n]\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nshift\n(\nIN\n)\nmob\n.\nmesh\n=\nSurfaceMesh\n(\nmob\n)\nmob\n.\nmesh\n.\nset_stroke\n(\nBLUE\n,\n1\n,\nopacity\n=\n0.5\n)\n# Set perspective\nframe\n=\nself\n.\ncamera\n.\nframe\nframe\n.\nset_euler_angles\n(\ntheta\n=-\n30\n*\nDEGREES\n,\nphi\n=\n70\n*\nDEGREES\n,\n)\nsurface\n=\nsurfaces\n[\n0\n]\nself\n.\nplay\n(\nFadeIn\n(\nsurface\n),\nShowCreation\n(\nsurface\n.\nmesh\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n3\n),\n)\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nadd\n(\nmob\n.\nmesh\n)\nsurface\n.\nsave_state\n()\nself\n.\nplay\n(\nRotate\n(\nsurface\n,\nPI\n/\n2\n),\nrun_time\n=\n2\n)\nfor\nmob\nin\nsurfaces\n[\n1\n:]:\nmob\n.\nrotate\n(\nPI\n/\n2\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n1\n]),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n2\n]),\n# Move camera frame during the transition\nframe\n.\nanimate\n.\nincrement_phi\n(\n-\n10\n*\nDEGREES\n),\nframe\n.\nanimate\n.\nincrement_theta\n(\n-\n20\n*\nDEGREES\n),\nrun_time\n=\n3\n)\n# Add ambient rotation\nframe\n.\nadd_updater\n(\nlambda\nm\n,\ndt\n:\nm\n.\nincrement_theta\n(\n-\n0.1\n*\ndt\n))\n# Play around with where the light is\nlight_text\n=\nText\n(\n\"You can move around the light source\"\n)\nlight_text\n.\nmove_to\n(\nsurface_text\n)\nlight_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nsurface_text\n,\nlight_text\n))\nlight\n=\nself\n.\ncamera\n.\nlight_source\nself\n.\nadd\n(\nlight\n)\nlight\n.\nsave_state\n()\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nmove_to\n(\n3\n*\nIN\n),\nrun_time\n=\n5\n)\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nshift\n(\n10\n*\nOUT\n),\nrun_time\n=\n5\n)\ndrag_text\n=\nText\n(\n\"Try moving the mouse while pressing d or s\"\n)\ndrag_text\n.\nmove_to\n(\nlight_text\n)\ndrag_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nlight_text\n,\ndrag_text\n))\nself\n.\nwait\n()\nThis scene shows an example of using a three-dimensional surface, and\nthe related usage has been briefly described in the notes.\n.fix_in_frame()\nmakes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.\nOpeningManimExample\n¶\nOpeningManimExample\n¶\nclass\nOpeningManimExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nintro_words\n=\nText\n(\n\"\"\"\nThe original motivation for manim was to\nbetter illustrate mathematical functions\nas transformations.\n\"\"\"\n)\nintro_words\n.\nto_edge\n(\nUP\n)\nself\n.\nplay\n(\nWrite\n(\nintro_words\n))\nself\n.\nwait\n(\n2\n)\n# Linear transform\ngrid\n=\nNumberPlane\n((\n-\n10\n,\n10\n),\n(\n-\n5\n,\n5\n))\nmatrix\n=\n[[\n1\n,\n1\n],\n[\n0\n,\n1\n]]\nlinear_transform_words\n=\nVGroup\n(\nText\n(\n\"This is what the matrix\"\n),\nIntegerMatrix\n(\nmatrix\n,\ninclude_background_rectangle\n=\nTrue\n),\nText\n(\n\"looks like\"\n)\n)\nlinear_transform_words\n.\narrange\n(\nRIGHT\n)\nlinear_transform_words\n.\nto_edge\n(\nUP\n)\nlinear_transform_words\n.\nset_stroke\n(\nBLACK\n,\n10\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nShowCreation\n(\ngrid\n),\nFadeTransform\n(\nintro_words\n,\nlinear_transform_words\n)\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_matrix\n(\nmatrix\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# Complex map\nc_grid\n=\nComplexPlane\n()\nmoving_c_grid\n=\nc_grid\n.\ncopy\n()\nmoving_c_grid\n.\nprepare_for_nonlinear_transform\n()\nc_grid\n.\nset_stroke\n(\nBLUE_E\n,\n1\n)\nc_grid\n.\nadd_coordinate_labels\n(\nfont_size\n=\n24\n)\ncomplex_map_words\n=\nTexText\n(\n\"\"\"\nOr thinking of the plane as $\n\\\\\nmathds\n{C}\n$,\n\\\\\\\\\nthis is the map $z\n\\\\\nrightarrow z^2$\n\"\"\"\n)\ncomplex_map_words\n.\nto_corner\n(\nUR\n)\ncomplex_map_words\n.\nset_stroke\n(\nBLACK\n,\n5\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nFadeOut\n(\ngrid\n),\nWrite\n(\nc_grid\n,\nrun_time\n=\n3\n),\nFadeIn\n(\nmoving_c_grid\n),\nFadeTransform\n(\nlinear_transform_words\n,\ncomplex_map_words\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nmoving_c_grid\n.\nanimate\n.\napply_complex_function\n(\nlambda\nz\n:\nz\n**\n2\n),\nrun_time\n=\n6\n,\n)\nself\n.\nwait\n(\n2\n)\nThis scene is a comprehensive application of a two-dimensional scene.\nAfter seeing these scenes, you have already understood part of the\nusage of manim. For more examples, see\nthe video code of 3b1b\n.\nContents\nExample Scenes\nInteractiveDevlopment\nAnimatingMethods\nTextExample\nTexTransformExample\nUpdatersExample\nCoordinateSystemExample\nGraphExample\nSurfaceExample\nOpeningManimExample",
    "code_examples": [
      "example_scenes.py",
      "from manimlib import *\n\nclass InteractiveDevelopment(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n\n        # This opens an iPython terminal where you can keep writing\n        # lines as if they were part of this construct method.\n        # In particular, 'square', 'circle' and 'self' will all be\n        # part of the local namespace in that terminal.\n        self.embed()\n\n        # Try copying and pasting some of the lines below into\n        # the interactive shell\n        self.play(ReplacementTransform(square, circle))\n        self.wait()\n        self.play(circle.animate.stretch(4, 0))\n        self.play(Rotate(circle, 90 * DEGREES))\n        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))\n\n        text = Text(\"\"\"\n            In general, using the interactive shell\n            is very helpful when developing new scenes\n        \"\"\")\n        self.play(Write(text))\n\n        # In the interactive shell, you can just type\n        # play, add, remove, clear, wait, save_state and restore,\n        # instead of self.play, self.add, self.remove, etc.\n\n        # To interact with the window, type touch().  You can then\n        # scroll in the window, or zoom by holding down 'z' while scrolling,\n        # and change camera perspective by holding down 'd' while moving\n        # the mouse.  Press 'r' to reset to the standard camera position.\n        # Press 'q' to stop interacting with the window and go back to\n        # typing new commands into the shell.\n\n        # In principle you can customize a scene to be responsive to\n        # mouse and keyboard interactions\n        always(circle.move_to, self.mouse_point)",
      "class AnimatingMethods(Scene):\n    def construct(self):\n        grid = OldTex(r\"\\pi\").get_grid(10, 10, height=4)\n        self.add(grid)\n\n        # You can animate the application of mobject methods with the\n        # \".animate\" syntax:\n        self.play(grid.animate.shift(LEFT))\n\n        # Alternatively, you can use the older syntax by passing the\n        # method and then the arguments to the scene's \"play\" function:\n        self.play(grid.shift, LEFT)\n\n        # Both of those will interpolate between the mobject's initial\n        # state and whatever happens when you apply that method.\n        # For this example, calling grid.shift(LEFT) would shift the\n        # grid one unit to the left, but both of the previous calls to\n        # \"self.play\" animate that motion.\n\n        # The same applies for any method, including those setting colors.\n        self.play(grid.animate.set_color(YELLOW))\n        self.wait()\n        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))\n        self.wait()\n        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))\n        self.wait()\n\n        # The method Mobject.apply_complex_function lets you apply arbitrary\n        # complex functions, treating the points defining the mobject as\n        # complex numbers.\n        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)\n        self.wait()\n\n        # Even more generally, you could apply Mobject.apply_function,\n        # which takes in functions form R^3 to R^3\n        self.play(\n            grid.animate.apply_function(\n                lambda p: [\n                    p[0] + 0.5 * math.sin(p[1]),\n                    p[1] + 0.5 * math.sin(p[0]),\n                    p[2]\n                ]\n            ),\n            run_time=5,\n        )\n        self.wait()",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      "class TextExample(Scene):\n    def construct(self):\n        # To run this scene properly, you should have \"Consolas\" font in your computer\n        # for full usage, you can see https://github.com/3b1b/manim/pull/680\n        text = Text(\"Here is a text\", font=\"Consolas\", font_size=90)\n        difference = Text(\n            \"\"\"\n            The most important difference between Text and TexText is that\\n\n            you can change the font more easily, but can't use the LaTeX grammar\n            \"\"\",\n            font=\"Arial\", font_size=24,\n            # t2c is a dict that you can choose color for different text\n            t2c={\"Text\": BLUE, \"TexText\": BLUE, \"LaTeX\": ORANGE}\n        )\n        VGroup(text, difference).arrange(DOWN, buff=1)\n        self.play(Write(text))\n        self.play(FadeIn(difference, UP))\n        self.wait(3)\n\n        fonts = Text(\n            \"And you can also set the font according to different words\",\n            font=\"Arial\",\n            t2f={\"font\": \"Consolas\", \"words\": \"Consolas\"},\n            t2c={\"font\": BLUE, \"words\": GREEN}\n        )\n        fonts.set_width(FRAME_WIDTH - 1)\n        slant = Text(\n            \"And the same as slant and weight\",\n            font=\"Consolas\",\n            t2s={\"slant\": ITALIC},\n            t2w={\"weight\": BOLD},\n            t2c={\"slant\": ORANGE, \"weight\": RED}\n        )\n        VGroup(fonts, slant).arrange(DOWN, buff=0.8)\n        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))\n        self.play(Write(fonts))\n        self.wait()\n        self.play(Write(slant))\n        self.wait()",
      "class TexTransformExample(Scene):\n    def construct(self):\n        to_isolate = [\"B\", \"C\", \"=\", \"(\", \")\"]\n        lines = VGroup(\n            # Passing in muliple arguments to Tex will result\n            # in the same expression as if those arguments had\n            # been joined together, except that the submobject\n            # hierarchy of the resulting mobject ensure that the\n            # Tex mobject has a subject corresponding to\n            # each of these strings.  For example, the Tex mobject\n            # below will have 5 subjects, corresponding to the\n            # expressions [A^2, +, B^2, =, C^2]\n            OldTex(\"A^2\", \"+\", \"B^2\", \"=\", \"C^2\"),\n            # Likewise here\n            OldTex(\"A^2\", \"=\", \"C^2\", \"-\", \"B^2\"),\n            # Alternatively, you can pass in the keyword argument\n            # \"isolate\" with a list of strings that should be out as\n            # their own submobject.  So the line below is equivalent\n            # to the commented out line below it.\n            OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A^2\", *to_isolate]),\n            # OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\n            OldTex(\"A = \\\\sqrt{(C + B)(C - B)}\", isolate=[\"A\", *to_isolate])\n        )\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        for line in lines:\n            line.set_color_by_tex_to_color_map({\n                \"A\": BLUE,\n                \"B\": TEAL,\n                \"C\": GREEN,\n            })\n\n        play_kw = {\"run_time\": 2}\n        self.add(lines[0])\n        # The animation TransformMatchingTex will line up parts\n        # of the source and target which have matching tex strings.\n        # Here, giving it a little path_arc makes each part sort of\n        # rotate into their final positions, which feels appropriate\n        # for the idea of rearranging an equation\n        self.play(\n            TransformMatchingTex(\n                lines[0].copy(), lines[1],\n                path_arc=90 * DEGREES,\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # Now, we could try this again on the next line...\n        self.play(\n            TransformMatchingTex(lines[1].copy(), lines[2]),\n            **play_kw\n        )\n        self.wait()\n        # ...and this looks nice enough, but since there's no tex\n        # in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n        # out to nothing while the C and B terms fade in from nothing.\n        # If, however, we want the C^2 to go to C, and B^2 to go to B,\n        # we can specify that with a key map.\n        self.play(FadeOut(lines[2]))\n        self.play(\n            TransformMatchingTex(\n                lines[1].copy(), lines[2],\n                key_map={\n                    \"C^2\": \"C\",\n                    \"B^2\": \"B\",\n                }\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # And to finish off, a simple TransformMatchingShapes would work\n        # just fine.  But perhaps we want that exponent on A^2 to transform into\n        # the square root symbol.  At the moment, lines[2] treats the expression\n        # A^2 as a unit, so we might create a new version of the same line which\n        # separates out just the A.  This way, when TransformMatchingTex lines up\n        # all matching parts, the only mismatch will be between the \"^2\" from\n        # new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n        # transform_mismatches=True, it will transform this \"^2\" part into\n        # the \"\\sqrt\" part.\n        new_line2 = OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A\", *to_isolate])\n        new_line2.replace(lines[2])\n        new_line2.match_style(lines[2])\n\n        self.play(\n            TransformMatchingTex(\n                new_line2, lines[3],\n                transform_mismatches=True,\n            ),\n            **play_kw\n        )\n        self.wait(3)\n        self.play(FadeOut(lines, RIGHT))\n\n        # Alternatively, if you don't want to think about breaking up\n        # the tex strings deliberately, you can TransformMatchingShapes,\n        # which will try to line up all pieces of a source mobject with\n        # those of a target, regardless of the submobject hierarchy in\n        # each one, according to whether those pieces have the same\n        # shape (as best it can).\n        source = Text(\"the morse code\", height=1)\n        target = Text(\"here come dots\", height=1)\n\n        self.play(Write(source))\n        self.wait()\n        kw = {\"run_time\": 3, \"path_arc\": PI / 2}\n        self.play(TransformMatchingShapes(source, target, **kw))\n        self.wait()\n        self.play(TransformMatchingShapes(target, source, **kw))\n        self.wait()",
      "TransformMatchingTex",
      "TransformMatchingShapes",
      "TransformMatchingTeX",
      "TransformMatchingShapes",
      "class UpdatersExample(Scene):\n    def construct(self):\n        square = Square()\n        square.set_fill(BLUE_E, 1)\n\n        # On all all frames, the constructor Brace(square, UP) will\n        # be called, and the mobject brace will set its data to match\n        # that of the newly constructed object\n        brace = always_redraw(Brace, square, UP)\n\n        text, number = label = VGroup(\n            Text(\"Width = \"),\n            DecimalNumber(\n                0,\n                show_ellipsis=True,\n                num_decimal_places=2,\n                include_sign=True,\n            )\n        )\n        label.arrange(RIGHT)\n\n        # This ensures that the method deicmal.next_to(square)\n        # is called on every frame\n        always(label.next_to, brace, UP)\n        # You could also write the following equivalent line\n        # label.add_updater(lambda m: m.next_to(brace, UP))\n\n        # If the argument itself might change, you can use f_always,\n        # for which the arguments following the initial Mobject method\n        # should be functions returning arguments to that method.\n        # The following line ensures that decimal.set_value(square.get_y())\n        # is called every frame\n        f_always(number.set_value, square.get_width)\n        # You could also write the following equivalent line\n        # number.add_updater(lambda m: m.set_value(square.get_width()))\n\n        self.add(square, brace, label)\n\n        # Notice that the brace and label track with the square\n        self.play(\n            square.animate.scale(2),\n            rate_func=there_and_back,\n            run_time=2,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(5, stretch=True),\n            run_time=3,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(2),\n            run_time=3\n        )\n        self.wait()\n\n        # In general, you can alway call Mobject.add_updater, and pass in\n        # a function that you want to be called on every frame.  The function\n        # should take in either one argument, the mobject, or two arguments,\n        # the mobject and the amount of time since the last frame.\n        now = self.time\n        w0 = square.get_width()\n        square.add_updater(\n            lambda m: m.set_width(w0 * math.cos(self.time - now))\n        )\n        self.wait(4 * PI)",
      "always_redraw()",
      "DecimalNumber",
      ".add_updater()",
      "always_redraw()",
      "DecimalNumber",
      "always(f, x)",
      "f_always(f, g)",
      ".add_updater()",
      "mob1.add_updater(lambda mob: mob.next_to(mob2))",
      "mob1.next_to(mob2)",
      "class CoordinateSystemExample(Scene):\n    def construct(self):\n        axes = Axes(\n            # x-axis ranges from -1 to 10, with a default step size of 1\n            x_range=(-1, 10),\n            # y-axis ranges from -2 to 2 with a step size of 0.5\n            y_range=(-2, 2, 0.5),\n            # The axes will be stretched so as to match the specified\n            # height and width\n            height=6,\n            width=10,\n            # Axes is made of two NumberLine mobjects.  You can specify\n            # their configuration with axis_config\n            axis_config={\n                \"stroke_color\": GREY_A,\n                \"stroke_width\": 2,\n            },\n            # Alternatively, you can specify configuration for just one\n            # of them, like this.\n            y_axis_config={\n                \"include_tip\": False,\n            }\n        )\n        # Keyword arguments of add_coordinate_labels can be used to\n        # configure the DecimalNumber mobjects which it creates and\n        # adds to the axes\n        axes.add_coordinate_labels(\n            font_size=20,\n            num_decimal_places=1,\n        )\n        self.add(axes)\n\n        # Axes descends from the CoordinateSystem class, meaning\n        # you can call call axes.coords_to_point, abbreviated to\n        # axes.c2p, to associate a set of coordinates with a point,\n        # like so:\n        dot = Dot(color=RED)\n        dot.move_to(axes.c2p(0, 0))\n        self.play(FadeIn(dot, scale=0.5))\n        self.play(dot.animate.move_to(axes.c2p(3, 2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))\n        self.wait()\n\n        # Similarly, you can call axes.point_to_coords, or axes.p2c\n        # print(axes.p2c(dot.get_center()))\n\n        # We can draw lines from the axes to better mark the coordinates\n        # of a given point.\n        # Here, the always_redraw command means that on each new frame\n        # the lines will be redrawn\n        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))\n        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))\n\n        self.play(\n            ShowCreation(h_line),\n            ShowCreation(v_line),\n        )\n        self.play(dot.animate.move_to(axes.c2p(3, -2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(1, 1)))\n        self.wait()\n\n        # If we tie the dot to a particular set of coordinates, notice\n        # that as we move the axes around it respects the coordinate\n        # system defined by them.\n        f_always(dot.move_to, lambda: axes.c2p(1, 1))\n        self.play(\n            axes.animate.scale(0.75).to_corner(UL),\n            run_time=2,\n        )\n        self.wait()\n        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))\n\n        # Other coordinate systems you can play around with include\n        # ThreeDAxes, NumberPlane, and ComplexPlane.",
      "class GraphExample(Scene):\n    def construct(self):\n        axes = Axes((-3, 10), (-1, 8))\n        axes.add_coordinate_labels()\n\n        self.play(Write(axes, lag_ratio=0.01, run_time=1))\n\n        # Axes.get_graph will return the graph of a function\n        sin_graph = axes.get_graph(\n            lambda x: 2 * math.sin(x),\n            color=BLUE,\n        )\n        # By default, it draws it so as to somewhat smoothly interpolate\n        # between sampled points (x, f(x)).  If the graph is meant to have\n        # a corner, though, you can set use_smoothing to False\n        relu_graph = axes.get_graph(\n            lambda x: max(x, 0),\n            use_smoothing=False,\n            color=YELLOW,\n        )\n        # For discontinuous functions, you can specify the point of\n        # discontinuity so that it does not try to draw over the gap.\n        step_graph = axes.get_graph(\n            lambda x: 2.0 if x > 3 else 1.0,\n            discontinuities=[3],\n            color=GREEN,\n        )\n\n        # Axes.get_graph_label takes in either a string or a mobject.\n        # If it's a string, it treats it as a LaTeX expression.  By default\n        # it places the label next to the graph near the right side, and\n        # has it match the color of the graph\n        sin_label = axes.get_graph_label(sin_graph, \"\\\\sin(x)\")\n        relu_label = axes.get_graph_label(relu_graph, Text(\"ReLU\"))\n        step_label = axes.get_graph_label(step_graph, Text(\"Step\"), x=4)\n\n        self.play(\n            ShowCreation(sin_graph),\n            FadeIn(sin_label, RIGHT),\n        )\n        self.wait(2)\n        self.play(\n            ReplacementTransform(sin_graph, relu_graph),\n            FadeTransform(sin_label, relu_label),\n        )\n        self.wait()\n        self.play(\n            ReplacementTransform(relu_graph, step_graph),\n            FadeTransform(relu_label, step_label),\n        )\n        self.wait()\n\n        parabola = axes.get_graph(lambda x: 0.25 * x**2)\n        parabola.set_stroke(BLUE)\n        self.play(\n            FadeOut(step_graph),\n            FadeOut(step_label),\n            ShowCreation(parabola)\n        )\n        self.wait()\n\n        # You can use axes.input_to_graph_point, abbreviated\n        # to axes.i2gp, to find a particular point on a graph\n        dot = Dot(color=RED)\n        dot.move_to(axes.i2gp(2, parabola))\n        self.play(FadeIn(dot, scale=0.5))\n\n        # A value tracker lets us animate a parameter, usually\n        # with the intent of having other mobjects update based\n        # on the parameter\n        x_tracker = ValueTracker(2)\n        f_always(\n            dot.move_to,\n            lambda: axes.i2gp(x_tracker.get_value(), parabola)\n        )\n\n        self.play(x_tracker.animate.set_value(4), run_time=3)\n        self.play(x_tracker.animate.set_value(-2), run_time=3)\n        self.wait()",
      "class SurfaceExample(Scene):\n    CONFIG = {\n        \"camera_class\": ThreeDCamera,\n    }\n\n    def construct(self):\n        surface_text = Text(\"For 3d scenes, try using surfaces\")\n        surface_text.fix_in_frame()\n        surface_text.to_edge(UP)\n        self.add(surface_text)\n        self.wait(0.1)\n\n        torus1 = Torus(r1=1, r2=1)\n        torus2 = Torus(r1=3, r2=1)\n        sphere = Sphere(radius=3, resolution=torus1.resolution)\n        # You can texture a surface with up to two images, which will\n        # be interpreted as the side towards the light, and away from\n        # the light.  These can be either urls, or paths to a local file\n        # in whatever you've set as the image directory in\n        # the custom_config.yml file\n\n        # day_texture = \"EarthTextureMap\"\n        # night_texture = \"NightEarthTextureMap\"\n        day_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\n        night_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\n\n        surfaces = [\n            TexturedSurface(surface, day_texture, night_texture)\n            for surface in [sphere, torus1, torus2]\n        ]\n\n        for mob in surfaces:\n            mob.shift(IN)\n            mob.mesh = SurfaceMesh(mob)\n            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)\n\n        # Set perspective\n        frame = self.camera.frame\n        frame.set_euler_angles(\n            theta=-30 * DEGREES,\n            phi=70 * DEGREES,\n        )\n\n        surface = surfaces[0]\n\n        self.play(\n            FadeIn(surface),\n            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),\n        )\n        for mob in surfaces:\n            mob.add(mob.mesh)\n        surface.save_state()\n        self.play(Rotate(surface, PI / 2), run_time=2)\n        for mob in surfaces[1:]:\n            mob.rotate(PI / 2)\n\n        self.play(\n            Transform(surface, surfaces[1]),\n            run_time=3\n        )\n\n        self.play(\n            Transform(surface, surfaces[2]),\n            # Move camera frame during the transition\n            frame.animate.increment_phi(-10 * DEGREES),\n            frame.animate.increment_theta(-20 * DEGREES),\n            run_time=3\n        )\n        # Add ambient rotation\n        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))\n\n        # Play around with where the light is\n        light_text = Text(\"You can move around the light source\")\n        light_text.move_to(surface_text)\n        light_text.fix_in_frame()\n\n        self.play(FadeTransform(surface_text, light_text))\n        light = self.camera.light_source\n        self.add(light)\n        light.save_state()\n        self.play(light.animate.move_to(3 * IN), run_time=5)\n        self.play(light.animate.shift(10 * OUT), run_time=5)\n\n        drag_text = Text(\"Try moving the mouse while pressing d or s\")\n        drag_text.move_to(light_text)\n        drag_text.fix_in_frame()\n\n        self.play(FadeTransform(light_text, drag_text))\n        self.wait()",
      ".fix_in_frame()",
      "class OpeningManimExample(Scene):\n    def construct(self):\n        intro_words = Text(\"\"\"\n            The original motivation for manim was to\n            better illustrate mathematical functions\n            as transformations.\n        \"\"\")\n        intro_words.to_edge(UP)\n\n        self.play(Write(intro_words))\n        self.wait(2)\n\n        # Linear transform\n        grid = NumberPlane((-10, 10), (-5, 5))\n        matrix = [[1, 1], [0, 1]]\n        linear_transform_words = VGroup(\n            Text(\"This is what the matrix\"),\n            IntegerMatrix(matrix, include_background_rectangle=True),\n            Text(\"looks like\")\n        )\n        linear_transform_words.arrange(RIGHT)\n        linear_transform_words.to_edge(UP)\n        linear_transform_words.set_stroke(BLACK, 10, background=True)\n\n        self.play(\n            ShowCreation(grid),\n            FadeTransform(intro_words, linear_transform_words)\n        )\n        self.wait()\n        self.play(grid.animate.apply_matrix(matrix), run_time=3)\n        self.wait()\n\n        # Complex map\n        c_grid = ComplexPlane()\n        moving_c_grid = c_grid.copy()\n        moving_c_grid.prepare_for_nonlinear_transform()\n        c_grid.set_stroke(BLUE_E, 1)\n        c_grid.add_coordinate_labels(font_size=24)\n        complex_map_words = TexText(\"\"\"\n            Or thinking of the plane as $\\\\mathds{C}$,\\\\\\\\\n            this is the map $z \\\\rightarrow z^2$\n        \"\"\")\n        complex_map_words.to_corner(UR)\n        complex_map_words.set_stroke(BLACK, 5, background=True)\n\n        self.play(\n            FadeOut(grid),\n            Write(c_grid, run_time=3),\n            FadeIn(moving_c_grid),\n            FadeTransform(linear_transform_words, complex_map_words),\n        )\n        self.wait()\n        self.play(\n            moving_c_grid.animate.apply_complex_function(lambda z: z**2),\n            run_time=6,\n        )\n        self.wait(2)"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#example-scenes",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevelopment",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#animatingmethods",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#animatingmethods",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#animatingmethods",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample"
    ],
    "scraped_at": 1752428843.266143
  },
  "https://3b1b.github.io/manim/getting_started/example_scenes.html#animatingmethods": {
    "url": "https://3b1b.github.io/manim/getting_started/example_scenes.html#animatingmethods",
    "title": "Example Scenes - manim  documentation",
    "content": "Example Scenes\n¶\nAfter understanding the previous knowledge, we can understand more scenes.\nMany example scenes are given in\nexample_scenes.py\n, let’s start with\nthe simplest and one by one.\nInteractiveDevlopment\n¶\nInteractiveDevelopment\n¶\nfrom\nmanimlib\nimport\n*\nclass\nInteractiveDevelopment\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nsquare\n=\nSquare\n()\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nself\n.\nwait\n()\n# This opens an iPython terminal where you can keep writing\n# lines as if they were part of this construct method.\n# In particular, 'square', 'circle' and 'self' will all be\n# part of the local namespace in that terminal.\nself\n.\nembed\n()\n# Try copying and pasting some of the lines below into\n# the interactive shell\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nstretch\n(\n4\n,\n0\n))\nself\n.\nplay\n(\nRotate\n(\ncircle\n,\n90\n*\nDEGREES\n))\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nshift\n(\n2\n*\nRIGHT\n)\n.\nscale\n(\n0.25\n))\ntext\n=\nText\n(\n\"\"\"\nIn general, using the interactive shell\nis very helpful when developing new scenes\n\"\"\"\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\n# In the interactive shell, you can just type\n# play, add, remove, clear, wait, save_state and restore,\n# instead of self.play, self.add, self.remove, etc.\n# To interact with the window, type touch().  You can then\n# scroll in the window, or zoom by holding down 'z' while scrolling,\n# and change camera perspective by holding down 'd' while moving\n# the mouse.  Press 'r' to reset to the standard camera position.\n# Press 'q' to stop interacting with the window and go back to\n# typing new commands into the shell.\n# In principle you can customize a scene to be responsive to\n# mouse and keyboard interactions\nalways\n(\ncircle\n.\nmove_to\n,\nself\n.\nmouse_point\n)\nThis scene is similar to what we wrote in\nQuick Start\n.\nAnd how to interact has been written in the comments.\nNo more explanation here.\nAnimatingMethods\n¶\nAnimatingMethods\n¶\nclass\nAnimatingMethods\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ngrid\n=\nOldTex\n(\nr\n\"\\pi\"\n)\n.\nget_grid\n(\n10\n,\n10\n,\nheight\n=\n4\n)\nself\n.\nadd\n(\ngrid\n)\n# You can animate the application of mobject methods with the\n# \".animate\" syntax:\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nshift\n(\nLEFT\n))\n# Alternatively, you can use the older syntax by passing the\n# method and then the arguments to the scene's \"play\" function:\nself\n.\nplay\n(\ngrid\n.\nshift\n,\nLEFT\n)\n# Both of those will interpolate between the mobject's initial\n# state and whatever happens when you apply that method.\n# For this example, calling grid.shift(LEFT) would shift the\n# grid one unit to the left, but both of the previous calls to\n# \"self.play\" animate that motion.\n# The same applies for any method, including those setting colors.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_color\n(\nYELLOW\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_submobject_colors_by_gradient\n(\nBLUE\n,\nGREEN\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_height\n(\nTAU\n-\nMED_SMALL_BUFF\n))\nself\n.\nwait\n()\n# The method Mobject.apply_complex_function lets you apply arbitrary\n# complex functions, treating the points defining the mobject as\n# complex numbers.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_complex_function\n(\nnp\n.\nexp\n),\nrun_time\n=\n5\n)\nself\n.\nwait\n()\n# Even more generally, you could apply Mobject.apply_function,\n# which takes in functions form R^3 to R^3\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_function\n(\nlambda\np\n:\n[\np\n[\n0\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n1\n]),\np\n[\n1\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n0\n]),\np\n[\n2\n]\n]\n),\nrun_time\n=\n5\n,\n)\nself\n.\nwait\n()\nThe new usage in this scene is\n.get_grid()\nand\nself.play(mob.animate.method(args))\n.\n.get_grid()\nmethod will return a new mobject containing multiple copies of this one arranged in a grid.\nself.play(mob.animate.method(args))\nanimates the method, and the details are in the comments above.\nTextExample\n¶\nTextExample\n¶\nclass\nTextExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\n# To run this scene properly, you should have \"Consolas\" font in your computer\n# for full usage, you can see https://github.com/3b1b/manim/pull/680\ntext\n=\nText\n(\n\"Here is a text\"\n,\nfont\n=\n\"Consolas\"\n,\nfont_size\n=\n90\n)\ndifference\n=\nText\n(\n\"\"\"\nThe most important difference between Text and TexText is that\\n\nyou can change the font more easily, but can't use the LaTeX grammar\n\"\"\"\n,\nfont\n=\n\"Arial\"\n,\nfont_size\n=\n24\n,\n# t2c is a dict that you can choose color for different text\nt2c\n=\n{\n\"Text\"\n:\nBLUE\n,\n\"TexText\"\n:\nBLUE\n,\n\"LaTeX\"\n:\nORANGE\n}\n)\nVGroup\n(\ntext\n,\ndifference\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\nself\n.\nplay\n(\nFadeIn\n(\ndifference\n,\nUP\n))\nself\n.\nwait\n(\n3\n)\nfonts\n=\nText\n(\n\"And you can also set the font according to different words\"\n,\nfont\n=\n\"Arial\"\n,\nt2f\n=\n{\n\"font\"\n:\n\"Consolas\"\n,\n\"words\"\n:\n\"Consolas\"\n},\nt2c\n=\n{\n\"font\"\n:\nBLUE\n,\n\"words\"\n:\nGREEN\n}\n)\nfonts\n.\nset_width\n(\nFRAME_WIDTH\n-\n1\n)\nslant\n=\nText\n(\n\"And the same as slant and weight\"\n,\nfont\n=\n\"Consolas\"\n,\nt2s\n=\n{\n\"slant\"\n:\nITALIC\n},\nt2w\n=\n{\n\"weight\"\n:\nBOLD\n},\nt2c\n=\n{\n\"slant\"\n:\nORANGE\n,\n\"weight\"\n:\nRED\n}\n)\nVGroup\n(\nfonts\n,\nslant\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n0.8\n)\nself\n.\nplay\n(\nFadeOut\n(\ntext\n),\nFadeOut\n(\ndifference\n,\nshift\n=\nDOWN\n))\nself\n.\nplay\n(\nWrite\n(\nfonts\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nWrite\n(\nslant\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nText\n,\nVGroup\n,\nWrite\n,\nFadeIn\nand\nFadeOut\n.\nText\ncan create text, define fonts, etc. The usage ais clearly reflected in the above examples.\nVGroup\ncan put multiple\nVMobject\ntogether as a whole. In the example, the\n.arrange()\nmethod is called to arrange the sub-mobjects in sequence downward (\nDOWN\n), and the spacing is\nbuff\n.\nWrite\nis an animation that shows similar writing effects.\nFadeIn\nfades the object in, the second parameter indicates the direction of the fade in.\nFadeOut\nfades out the object, the second parameter indicates the direction of the fade out.\nTexTransformExample\n¶\nTexTransformExample\n¶\nclass\nTexTransformExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nto_isolate\n=\n[\n\"B\"\n,\n\"C\"\n,\n\"=\"\n,\n\"(\"\n,\n\")\"\n]\nlines\n=\nVGroup\n(\n# Passing in muliple arguments to Tex will result\n# in the same expression as if those arguments had\n# been joined together, except that the submobject\n# hierarchy of the resulting mobject ensure that the\n# Tex mobject has a subject corresponding to\n# each of these strings.  For example, the Tex mobject\n# below will have 5 subjects, corresponding to the\n# expressions [A^2, +, B^2, =, C^2]\nOldTex\n(\n\"A^2\"\n,\n\"+\"\n,\n\"B^2\"\n,\n\"=\"\n,\n\"C^2\"\n),\n# Likewise here\nOldTex\n(\n\"A^2\"\n,\n\"=\"\n,\n\"C^2\"\n,\n\"-\"\n,\n\"B^2\"\n),\n# Alternatively, you can pass in the keyword argument\n# \"isolate\" with a list of strings that should be out as\n# their own submobject.  So the line below is equivalent\n# to the commented out line below it.\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A^2\"\n,\n*\nto_isolate\n]),\n# OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\nOldTex\n(\n\"A =\n\\\\\nsqrt{(C + B)(C - B)}\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\n)\nlines\n.\narrange\n(\nDOWN\n,\nbuff\n=\nLARGE_BUFF\n)\nfor\nline\nin\nlines\n:\nline\n.\nset_color_by_tex_to_color_map\n({\n\"A\"\n:\nBLUE\n,\n\"B\"\n:\nTEAL\n,\n\"C\"\n:\nGREEN\n,\n})\nplay_kw\n=\n{\n\"run_time\"\n:\n2\n}\nself\n.\nadd\n(\nlines\n[\n0\n])\n# The animation TransformMatchingTex will line up parts\n# of the source and target which have matching tex strings.\n# Here, giving it a little path_arc makes each part sort of\n# rotate into their final positions, which feels appropriate\n# for the idea of rearranging an equation\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n0\n]\n.\ncopy\n(),\nlines\n[\n1\n],\npath_arc\n=\n90\n*\nDEGREES\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# Now, we could try this again on the next line...\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n]),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# ...and this looks nice enough, but since there's no tex\n# in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n# out to nothing while the C and B terms fade in from nothing.\n# If, however, we want the C^2 to go to C, and B^2 to go to B,\n# we can specify that with a key map.\nself\n.\nplay\n(\nFadeOut\n(\nlines\n[\n2\n]))\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n],\nkey_map\n=\n{\n\"C^2\"\n:\n\"C\"\n,\n\"B^2\"\n:\n\"B\"\n,\n}\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# And to finish off, a simple TransformMatchingShapes would work\n# just fine.  But perhaps we want that exponent on A^2 to transform into\n# the square root symbol.  At the moment, lines[2] treats the expression\n# A^2 as a unit, so we might create a new version of the same line which\n# separates out just the A.  This way, when TransformMatchingTex lines up\n# all matching parts, the only mismatch will be between the \"^2\" from\n# new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n# transform_mismatches=True, it will transform this \"^2\" part into\n# the \"\\sqrt\" part.\nnew_line2\n=\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\nnew_line2\n.\nreplace\n(\nlines\n[\n2\n])\nnew_line2\n.\nmatch_style\n(\nlines\n[\n2\n])\nself\n.\nplay\n(\nTransformMatchingTex\n(\nnew_line2\n,\nlines\n[\n3\n],\ntransform_mismatches\n=\nTrue\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n(\n3\n)\nself\n.\nplay\n(\nFadeOut\n(\nlines\n,\nRIGHT\n))\n# Alternatively, if you don't want to think about breaking up\n# the tex strings deliberately, you can TransformMatchingShapes,\n# which will try to line up all pieces of a source mobject with\n# those of a target, regardless of the submobject hierarchy in\n# each one, according to whether those pieces have the same\n# shape (as best it can).\nsource\n=\nText\n(\n\"the morse code\"\n,\nheight\n=\n1\n)\ntarget\n=\nText\n(\n\"here come dots\"\n,\nheight\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\nsource\n))\nself\n.\nwait\n()\nkw\n=\n{\n\"run_time\"\n:\n3\n,\n\"path_arc\"\n:\nPI\n/\n2\n}\nself\n.\nplay\n(\nTransformMatchingShapes\n(\nsource\n,\ntarget\n,\n**\nkw\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nTransformMatchingShapes\n(\ntarget\n,\nsource\n,\n**\nkw\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nTex\n,\nTexText\n,\nTransformMatchingTex\nand\nTransformMatchingShapes\n.\nTex\nuses LaTeX to create mathematical formulas.\nTexText\nuses LaTeX to create text.\nTransformMatchingTeX\nautomatically transforms sub-objects according to the similarities and differences of tex in\nTex\n.\nTransformMatchingShapes\nautomatically transform sub-objects directly based on the similarities and differences of the object point sets.\nUpdatersExample\n¶\nUpdatersExample\n¶\nclass\nUpdatersExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nsquare\n=\nSquare\n()\nsquare\n.\nset_fill\n(\nBLUE_E\n,\n1\n)\n# On all all frames, the constructor Brace(square, UP) will\n# be called, and the mobject brace will set its data to match\n# that of the newly constructed object\nbrace\n=\nalways_redraw\n(\nBrace\n,\nsquare\n,\nUP\n)\ntext\n,\nnumber\n=\nlabel\n=\nVGroup\n(\nText\n(\n\"Width = \"\n),\nDecimalNumber\n(\n0\n,\nshow_ellipsis\n=\nTrue\n,\nnum_decimal_places\n=\n2\n,\ninclude_sign\n=\nTrue\n,\n)\n)\nlabel\n.\narrange\n(\nRIGHT\n)\n# This ensures that the method deicmal.next_to(square)\n# is called on every frame\nalways\n(\nlabel\n.\nnext_to\n,\nbrace\n,\nUP\n)\n# You could also write the following equivalent line\n# label.add_updater(lambda m: m.next_to(brace, UP))\n# If the argument itself might change, you can use f_always,\n# for which the arguments following the initial Mobject method\n# should be functions returning arguments to that method.\n# The following line ensures that decimal.set_value(square.get_y())\n# is called every frame\nf_always\n(\nnumber\n.\nset_value\n,\nsquare\n.\nget_width\n)\n# You could also write the following equivalent line\n# number.add_updater(lambda m: m.set_value(square.get_width()))\nself\n.\nadd\n(\nsquare\n,\nbrace\n,\nlabel\n)\n# Notice that the brace and label track with the square\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nscale\n(\n2\n),\nrate_func\n=\nthere_and_back\n,\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n5\n,\nstretch\n=\nTrue\n),\nrun_time\n=\n3\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# In general, you can alway call Mobject.add_updater, and pass in\n# a function that you want to be called on every frame.  The function\n# should take in either one argument, the mobject, or two arguments,\n# the mobject and the amount of time since the last frame.\nnow\n=\nself\n.\ntime\nw0\n=\nsquare\n.\nget_width\n()\nsquare\n.\nadd_updater\n(\nlambda\nm\n:\nm\n.\nset_width\n(\nw0\n*\nmath\n.\ncos\n(\nself\n.\ntime\n-\nnow\n))\n)\nself\n.\nwait\n(\n4\n*\nPI\n)\nThe new classes and usage in this scene are\nalways_redraw()\n,\nDecimalNumber\n,\n.to_edge()\n,\n.center()\n,\nalways()\n,\nf_always()\n,\n.set_y()\nand\n.add_updater()\n.\nalways_redraw()\nfunction create a new mobject every frame.\nDecimalNumber\nis a variable number, speed it up by breaking it into\nText\ncharacters.\n.to_edge()\nmeans to place the object on the edge of the screen.\n.center()\nmeans to place the object in the center of the screen.\nalways(f,\nx)\nmeans that a certain function (\nf(x)\n) is executed every frame.\nf_always(f,\ng)\nis similar to\nalways\n, executed\nf(g())\nevery frame.\n.set_y()\nmeans to set the ordinate of the object on the screen.\n.add_updater()\nsets an update function for the object. For example:\nmob1.add_updater(lambda\nmob:\nmob.next_to(mob2))\nmeans\nmob1.next_to(mob2)\nis executed every frame.\nCoordinateSystemExample\n¶\nCoordinateSystemExample\n¶\nclass\nCoordinateSystemExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n(\n# x-axis ranges from -1 to 10, with a default step size of 1\nx_range\n=\n(\n-\n1\n,\n10\n),\n# y-axis ranges from -2 to 2 with a step size of 0.5\ny_range\n=\n(\n-\n2\n,\n2\n,\n0.5\n),\n# The axes will be stretched so as to match the specified\n# height and width\nheight\n=\n6\n,\nwidth\n=\n10\n,\n# Axes is made of two NumberLine mobjects.  You can specify\n# their configuration with axis_config\naxis_config\n=\n{\n\"stroke_color\"\n:\nGREY_A\n,\n\"stroke_width\"\n:\n2\n,\n},\n# Alternatively, you can specify configuration for just one\n# of them, like this.\ny_axis_config\n=\n{\n\"include_tip\"\n:\nFalse\n,\n}\n)\n# Keyword arguments of add_coordinate_labels can be used to\n# configure the DecimalNumber mobjects which it creates and\n# adds to the axes\naxes\n.\nadd_coordinate_labels\n(\nfont_size\n=\n20\n,\nnum_decimal_places\n=\n1\n,\n)\nself\n.\nadd\n(\naxes\n)\n# Axes descends from the CoordinateSystem class, meaning\n# you can call call axes.coords_to_point, abbreviated to\n# axes.c2p, to associate a set of coordinates with a point,\n# like so:\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\nc2p\n(\n0\n,\n0\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n5\n,\n0.5\n)))\nself\n.\nwait\n()\n# Similarly, you can call axes.point_to_coords, or axes.p2c\n# print(axes.p2c(dot.get_center()))\n# We can draw lines from the axes to better mark the coordinates\n# of a given point.\n# Here, the always_redraw command means that on each new frame\n# the lines will be redrawn\nh_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_h_line\n(\ndot\n.\nget_left\n()))\nv_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_v_line\n(\ndot\n.\nget_bottom\n()))\nself\n.\nplay\n(\nShowCreation\n(\nh_line\n),\nShowCreation\n(\nv_line\n),\n)\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n-\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n1\n,\n1\n)))\nself\n.\nwait\n()\n# If we tie the dot to a particular set of coordinates, notice\n# that as we move the axes around it respects the coordinate\n# system defined by them.\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\nc2p\n(\n1\n,\n1\n))\nself\n.\nplay\n(\naxes\n.\nanimate\n.\nscale\n(\n0.75\n)\n.\nto_corner\n(\nUL\n),\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nFadeOut\n(\nVGroup\n(\naxes\n,\ndot\n,\nh_line\n,\nv_line\n)))\n# Other coordinate systems you can play around with include\n# ThreeDAxes, NumberPlane, and ComplexPlane.\nGraphExample\n¶\nGraphExample\n¶\nclass\nGraphExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n((\n-\n3\n,\n10\n),\n(\n-\n1\n,\n8\n))\naxes\n.\nadd_coordinate_labels\n()\nself\n.\nplay\n(\nWrite\n(\naxes\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n1\n))\n# Axes.get_graph will return the graph of a function\nsin_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2\n*\nmath\n.\nsin\n(\nx\n),\ncolor\n=\nBLUE\n,\n)\n# By default, it draws it so as to somewhat smoothly interpolate\n# between sampled points (x, f(x)).  If the graph is meant to have\n# a corner, though, you can set use_smoothing to False\nrelu_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\nmax\n(\nx\n,\n0\n),\nuse_smoothing\n=\nFalse\n,\ncolor\n=\nYELLOW\n,\n)\n# For discontinuous functions, you can specify the point of\n# discontinuity so that it does not try to draw over the gap.\nstep_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2.0\nif\nx\n>\n3\nelse\n1.0\n,\ndiscontinuities\n=\n[\n3\n],\ncolor\n=\nGREEN\n,\n)\n# Axes.get_graph_label takes in either a string or a mobject.\n# If it's a string, it treats it as a LaTeX expression.  By default\n# it places the label next to the graph near the right side, and\n# has it match the color of the graph\nsin_label\n=\naxes\n.\nget_graph_label\n(\nsin_graph\n,\n\"\n\\\\\nsin(x)\"\n)\nrelu_label\n=\naxes\n.\nget_graph_label\n(\nrelu_graph\n,\nText\n(\n\"ReLU\"\n))\nstep_label\n=\naxes\n.\nget_graph_label\n(\nstep_graph\n,\nText\n(\n\"Step\"\n),\nx\n=\n4\n)\nself\n.\nplay\n(\nShowCreation\n(\nsin_graph\n),\nFadeIn\n(\nsin_label\n,\nRIGHT\n),\n)\nself\n.\nwait\n(\n2\n)\nself\n.\nplay\n(\nReplacementTransform\n(\nsin_graph\n,\nrelu_graph\n),\nFadeTransform\n(\nsin_label\n,\nrelu_label\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nReplacementTransform\n(\nrelu_graph\n,\nstep_graph\n),\nFadeTransform\n(\nrelu_label\n,\nstep_label\n),\n)\nself\n.\nwait\n()\nparabola\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n0.25\n*\nx\n**\n2\n)\nparabola\n.\nset_stroke\n(\nBLUE\n)\nself\n.\nplay\n(\nFadeOut\n(\nstep_graph\n),\nFadeOut\n(\nstep_label\n),\nShowCreation\n(\nparabola\n)\n)\nself\n.\nwait\n()\n# You can use axes.input_to_graph_point, abbreviated\n# to axes.i2gp, to find a particular point on a graph\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\ni2gp\n(\n2\n,\nparabola\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\n# A value tracker lets us animate a parameter, usually\n# with the intent of having other mobjects update based\n# on the parameter\nx_tracker\n=\nValueTracker\n(\n2\n)\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\ni2gp\n(\nx_tracker\n.\nget_value\n(),\nparabola\n)\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n4\n),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n-\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\nSurfaceExample\n¶\nSurfaceExample\n¶\nclass\nSurfaceExample\n(\nScene\n):\nCONFIG\n=\n{\n\"camera_class\"\n:\nThreeDCamera\n,\n}\ndef\nconstruct\n(\nself\n):\nsurface_text\n=\nText\n(\n\"For 3d scenes, try using surfaces\"\n)\nsurface_text\n.\nfix_in_frame\n()\nsurface_text\n.\nto_edge\n(\nUP\n)\nself\n.\nadd\n(\nsurface_text\n)\nself\n.\nwait\n(\n0.1\n)\ntorus1\n=\nTorus\n(\nr1\n=\n1\n,\nr2\n=\n1\n)\ntorus2\n=\nTorus\n(\nr1\n=\n3\n,\nr2\n=\n1\n)\nsphere\n=\nSphere\n(\nradius\n=\n3\n,\nresolution\n=\ntorus1\n.\nresolution\n)\n# You can texture a surface with up to two images, which will\n# be interpreted as the side towards the light, and away from\n# the light.  These can be either urls, or paths to a local file\n# in whatever you've set as the image directory in\n# the custom_config.yml file\n# day_texture = \"EarthTextureMap\"\n# night_texture = \"NightEarthTextureMap\"\nday_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\nnight_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\nsurfaces\n=\n[\nTexturedSurface\n(\nsurface\n,\nday_texture\n,\nnight_texture\n)\nfor\nsurface\nin\n[\nsphere\n,\ntorus1\n,\ntorus2\n]\n]\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nshift\n(\nIN\n)\nmob\n.\nmesh\n=\nSurfaceMesh\n(\nmob\n)\nmob\n.\nmesh\n.\nset_stroke\n(\nBLUE\n,\n1\n,\nopacity\n=\n0.5\n)\n# Set perspective\nframe\n=\nself\n.\ncamera\n.\nframe\nframe\n.\nset_euler_angles\n(\ntheta\n=-\n30\n*\nDEGREES\n,\nphi\n=\n70\n*\nDEGREES\n,\n)\nsurface\n=\nsurfaces\n[\n0\n]\nself\n.\nplay\n(\nFadeIn\n(\nsurface\n),\nShowCreation\n(\nsurface\n.\nmesh\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n3\n),\n)\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nadd\n(\nmob\n.\nmesh\n)\nsurface\n.\nsave_state\n()\nself\n.\nplay\n(\nRotate\n(\nsurface\n,\nPI\n/\n2\n),\nrun_time\n=\n2\n)\nfor\nmob\nin\nsurfaces\n[\n1\n:]:\nmob\n.\nrotate\n(\nPI\n/\n2\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n1\n]),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n2\n]),\n# Move camera frame during the transition\nframe\n.\nanimate\n.\nincrement_phi\n(\n-\n10\n*\nDEGREES\n),\nframe\n.\nanimate\n.\nincrement_theta\n(\n-\n20\n*\nDEGREES\n),\nrun_time\n=\n3\n)\n# Add ambient rotation\nframe\n.\nadd_updater\n(\nlambda\nm\n,\ndt\n:\nm\n.\nincrement_theta\n(\n-\n0.1\n*\ndt\n))\n# Play around with where the light is\nlight_text\n=\nText\n(\n\"You can move around the light source\"\n)\nlight_text\n.\nmove_to\n(\nsurface_text\n)\nlight_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nsurface_text\n,\nlight_text\n))\nlight\n=\nself\n.\ncamera\n.\nlight_source\nself\n.\nadd\n(\nlight\n)\nlight\n.\nsave_state\n()\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nmove_to\n(\n3\n*\nIN\n),\nrun_time\n=\n5\n)\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nshift\n(\n10\n*\nOUT\n),\nrun_time\n=\n5\n)\ndrag_text\n=\nText\n(\n\"Try moving the mouse while pressing d or s\"\n)\ndrag_text\n.\nmove_to\n(\nlight_text\n)\ndrag_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nlight_text\n,\ndrag_text\n))\nself\n.\nwait\n()\nThis scene shows an example of using a three-dimensional surface, and\nthe related usage has been briefly described in the notes.\n.fix_in_frame()\nmakes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.\nOpeningManimExample\n¶\nOpeningManimExample\n¶\nclass\nOpeningManimExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nintro_words\n=\nText\n(\n\"\"\"\nThe original motivation for manim was to\nbetter illustrate mathematical functions\nas transformations.\n\"\"\"\n)\nintro_words\n.\nto_edge\n(\nUP\n)\nself\n.\nplay\n(\nWrite\n(\nintro_words\n))\nself\n.\nwait\n(\n2\n)\n# Linear transform\ngrid\n=\nNumberPlane\n((\n-\n10\n,\n10\n),\n(\n-\n5\n,\n5\n))\nmatrix\n=\n[[\n1\n,\n1\n],\n[\n0\n,\n1\n]]\nlinear_transform_words\n=\nVGroup\n(\nText\n(\n\"This is what the matrix\"\n),\nIntegerMatrix\n(\nmatrix\n,\ninclude_background_rectangle\n=\nTrue\n),\nText\n(\n\"looks like\"\n)\n)\nlinear_transform_words\n.\narrange\n(\nRIGHT\n)\nlinear_transform_words\n.\nto_edge\n(\nUP\n)\nlinear_transform_words\n.\nset_stroke\n(\nBLACK\n,\n10\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nShowCreation\n(\ngrid\n),\nFadeTransform\n(\nintro_words\n,\nlinear_transform_words\n)\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_matrix\n(\nmatrix\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# Complex map\nc_grid\n=\nComplexPlane\n()\nmoving_c_grid\n=\nc_grid\n.\ncopy\n()\nmoving_c_grid\n.\nprepare_for_nonlinear_transform\n()\nc_grid\n.\nset_stroke\n(\nBLUE_E\n,\n1\n)\nc_grid\n.\nadd_coordinate_labels\n(\nfont_size\n=\n24\n)\ncomplex_map_words\n=\nTexText\n(\n\"\"\"\nOr thinking of the plane as $\n\\\\\nmathds\n{C}\n$,\n\\\\\\\\\nthis is the map $z\n\\\\\nrightarrow z^2$\n\"\"\"\n)\ncomplex_map_words\n.\nto_corner\n(\nUR\n)\ncomplex_map_words\n.\nset_stroke\n(\nBLACK\n,\n5\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nFadeOut\n(\ngrid\n),\nWrite\n(\nc_grid\n,\nrun_time\n=\n3\n),\nFadeIn\n(\nmoving_c_grid\n),\nFadeTransform\n(\nlinear_transform_words\n,\ncomplex_map_words\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nmoving_c_grid\n.\nanimate\n.\napply_complex_function\n(\nlambda\nz\n:\nz\n**\n2\n),\nrun_time\n=\n6\n,\n)\nself\n.\nwait\n(\n2\n)\nThis scene is a comprehensive application of a two-dimensional scene.\nAfter seeing these scenes, you have already understood part of the\nusage of manim. For more examples, see\nthe video code of 3b1b\n.\nContents\nExample Scenes\nInteractiveDevlopment\nAnimatingMethods\nTextExample\nTexTransformExample\nUpdatersExample\nCoordinateSystemExample\nGraphExample\nSurfaceExample\nOpeningManimExample",
    "code_examples": [
      "example_scenes.py",
      "from manimlib import *\n\nclass InteractiveDevelopment(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n\n        # This opens an iPython terminal where you can keep writing\n        # lines as if they were part of this construct method.\n        # In particular, 'square', 'circle' and 'self' will all be\n        # part of the local namespace in that terminal.\n        self.embed()\n\n        # Try copying and pasting some of the lines below into\n        # the interactive shell\n        self.play(ReplacementTransform(square, circle))\n        self.wait()\n        self.play(circle.animate.stretch(4, 0))\n        self.play(Rotate(circle, 90 * DEGREES))\n        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))\n\n        text = Text(\"\"\"\n            In general, using the interactive shell\n            is very helpful when developing new scenes\n        \"\"\")\n        self.play(Write(text))\n\n        # In the interactive shell, you can just type\n        # play, add, remove, clear, wait, save_state and restore,\n        # instead of self.play, self.add, self.remove, etc.\n\n        # To interact with the window, type touch().  You can then\n        # scroll in the window, or zoom by holding down 'z' while scrolling,\n        # and change camera perspective by holding down 'd' while moving\n        # the mouse.  Press 'r' to reset to the standard camera position.\n        # Press 'q' to stop interacting with the window and go back to\n        # typing new commands into the shell.\n\n        # In principle you can customize a scene to be responsive to\n        # mouse and keyboard interactions\n        always(circle.move_to, self.mouse_point)",
      "class AnimatingMethods(Scene):\n    def construct(self):\n        grid = OldTex(r\"\\pi\").get_grid(10, 10, height=4)\n        self.add(grid)\n\n        # You can animate the application of mobject methods with the\n        # \".animate\" syntax:\n        self.play(grid.animate.shift(LEFT))\n\n        # Alternatively, you can use the older syntax by passing the\n        # method and then the arguments to the scene's \"play\" function:\n        self.play(grid.shift, LEFT)\n\n        # Both of those will interpolate between the mobject's initial\n        # state and whatever happens when you apply that method.\n        # For this example, calling grid.shift(LEFT) would shift the\n        # grid one unit to the left, but both of the previous calls to\n        # \"self.play\" animate that motion.\n\n        # The same applies for any method, including those setting colors.\n        self.play(grid.animate.set_color(YELLOW))\n        self.wait()\n        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))\n        self.wait()\n        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))\n        self.wait()\n\n        # The method Mobject.apply_complex_function lets you apply arbitrary\n        # complex functions, treating the points defining the mobject as\n        # complex numbers.\n        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)\n        self.wait()\n\n        # Even more generally, you could apply Mobject.apply_function,\n        # which takes in functions form R^3 to R^3\n        self.play(\n            grid.animate.apply_function(\n                lambda p: [\n                    p[0] + 0.5 * math.sin(p[1]),\n                    p[1] + 0.5 * math.sin(p[0]),\n                    p[2]\n                ]\n            ),\n            run_time=5,\n        )\n        self.wait()",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      "class TextExample(Scene):\n    def construct(self):\n        # To run this scene properly, you should have \"Consolas\" font in your computer\n        # for full usage, you can see https://github.com/3b1b/manim/pull/680\n        text = Text(\"Here is a text\", font=\"Consolas\", font_size=90)\n        difference = Text(\n            \"\"\"\n            The most important difference between Text and TexText is that\\n\n            you can change the font more easily, but can't use the LaTeX grammar\n            \"\"\",\n            font=\"Arial\", font_size=24,\n            # t2c is a dict that you can choose color for different text\n            t2c={\"Text\": BLUE, \"TexText\": BLUE, \"LaTeX\": ORANGE}\n        )\n        VGroup(text, difference).arrange(DOWN, buff=1)\n        self.play(Write(text))\n        self.play(FadeIn(difference, UP))\n        self.wait(3)\n\n        fonts = Text(\n            \"And you can also set the font according to different words\",\n            font=\"Arial\",\n            t2f={\"font\": \"Consolas\", \"words\": \"Consolas\"},\n            t2c={\"font\": BLUE, \"words\": GREEN}\n        )\n        fonts.set_width(FRAME_WIDTH - 1)\n        slant = Text(\n            \"And the same as slant and weight\",\n            font=\"Consolas\",\n            t2s={\"slant\": ITALIC},\n            t2w={\"weight\": BOLD},\n            t2c={\"slant\": ORANGE, \"weight\": RED}\n        )\n        VGroup(fonts, slant).arrange(DOWN, buff=0.8)\n        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))\n        self.play(Write(fonts))\n        self.wait()\n        self.play(Write(slant))\n        self.wait()",
      "class TexTransformExample(Scene):\n    def construct(self):\n        to_isolate = [\"B\", \"C\", \"=\", \"(\", \")\"]\n        lines = VGroup(\n            # Passing in muliple arguments to Tex will result\n            # in the same expression as if those arguments had\n            # been joined together, except that the submobject\n            # hierarchy of the resulting mobject ensure that the\n            # Tex mobject has a subject corresponding to\n            # each of these strings.  For example, the Tex mobject\n            # below will have 5 subjects, corresponding to the\n            # expressions [A^2, +, B^2, =, C^2]\n            OldTex(\"A^2\", \"+\", \"B^2\", \"=\", \"C^2\"),\n            # Likewise here\n            OldTex(\"A^2\", \"=\", \"C^2\", \"-\", \"B^2\"),\n            # Alternatively, you can pass in the keyword argument\n            # \"isolate\" with a list of strings that should be out as\n            # their own submobject.  So the line below is equivalent\n            # to the commented out line below it.\n            OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A^2\", *to_isolate]),\n            # OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\n            OldTex(\"A = \\\\sqrt{(C + B)(C - B)}\", isolate=[\"A\", *to_isolate])\n        )\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        for line in lines:\n            line.set_color_by_tex_to_color_map({\n                \"A\": BLUE,\n                \"B\": TEAL,\n                \"C\": GREEN,\n            })\n\n        play_kw = {\"run_time\": 2}\n        self.add(lines[0])\n        # The animation TransformMatchingTex will line up parts\n        # of the source and target which have matching tex strings.\n        # Here, giving it a little path_arc makes each part sort of\n        # rotate into their final positions, which feels appropriate\n        # for the idea of rearranging an equation\n        self.play(\n            TransformMatchingTex(\n                lines[0].copy(), lines[1],\n                path_arc=90 * DEGREES,\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # Now, we could try this again on the next line...\n        self.play(\n            TransformMatchingTex(lines[1].copy(), lines[2]),\n            **play_kw\n        )\n        self.wait()\n        # ...and this looks nice enough, but since there's no tex\n        # in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n        # out to nothing while the C and B terms fade in from nothing.\n        # If, however, we want the C^2 to go to C, and B^2 to go to B,\n        # we can specify that with a key map.\n        self.play(FadeOut(lines[2]))\n        self.play(\n            TransformMatchingTex(\n                lines[1].copy(), lines[2],\n                key_map={\n                    \"C^2\": \"C\",\n                    \"B^2\": \"B\",\n                }\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # And to finish off, a simple TransformMatchingShapes would work\n        # just fine.  But perhaps we want that exponent on A^2 to transform into\n        # the square root symbol.  At the moment, lines[2] treats the expression\n        # A^2 as a unit, so we might create a new version of the same line which\n        # separates out just the A.  This way, when TransformMatchingTex lines up\n        # all matching parts, the only mismatch will be between the \"^2\" from\n        # new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n        # transform_mismatches=True, it will transform this \"^2\" part into\n        # the \"\\sqrt\" part.\n        new_line2 = OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A\", *to_isolate])\n        new_line2.replace(lines[2])\n        new_line2.match_style(lines[2])\n\n        self.play(\n            TransformMatchingTex(\n                new_line2, lines[3],\n                transform_mismatches=True,\n            ),\n            **play_kw\n        )\n        self.wait(3)\n        self.play(FadeOut(lines, RIGHT))\n\n        # Alternatively, if you don't want to think about breaking up\n        # the tex strings deliberately, you can TransformMatchingShapes,\n        # which will try to line up all pieces of a source mobject with\n        # those of a target, regardless of the submobject hierarchy in\n        # each one, according to whether those pieces have the same\n        # shape (as best it can).\n        source = Text(\"the morse code\", height=1)\n        target = Text(\"here come dots\", height=1)\n\n        self.play(Write(source))\n        self.wait()\n        kw = {\"run_time\": 3, \"path_arc\": PI / 2}\n        self.play(TransformMatchingShapes(source, target, **kw))\n        self.wait()\n        self.play(TransformMatchingShapes(target, source, **kw))\n        self.wait()",
      "TransformMatchingTex",
      "TransformMatchingShapes",
      "TransformMatchingTeX",
      "TransformMatchingShapes",
      "class UpdatersExample(Scene):\n    def construct(self):\n        square = Square()\n        square.set_fill(BLUE_E, 1)\n\n        # On all all frames, the constructor Brace(square, UP) will\n        # be called, and the mobject brace will set its data to match\n        # that of the newly constructed object\n        brace = always_redraw(Brace, square, UP)\n\n        text, number = label = VGroup(\n            Text(\"Width = \"),\n            DecimalNumber(\n                0,\n                show_ellipsis=True,\n                num_decimal_places=2,\n                include_sign=True,\n            )\n        )\n        label.arrange(RIGHT)\n\n        # This ensures that the method deicmal.next_to(square)\n        # is called on every frame\n        always(label.next_to, brace, UP)\n        # You could also write the following equivalent line\n        # label.add_updater(lambda m: m.next_to(brace, UP))\n\n        # If the argument itself might change, you can use f_always,\n        # for which the arguments following the initial Mobject method\n        # should be functions returning arguments to that method.\n        # The following line ensures that decimal.set_value(square.get_y())\n        # is called every frame\n        f_always(number.set_value, square.get_width)\n        # You could also write the following equivalent line\n        # number.add_updater(lambda m: m.set_value(square.get_width()))\n\n        self.add(square, brace, label)\n\n        # Notice that the brace and label track with the square\n        self.play(\n            square.animate.scale(2),\n            rate_func=there_and_back,\n            run_time=2,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(5, stretch=True),\n            run_time=3,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(2),\n            run_time=3\n        )\n        self.wait()\n\n        # In general, you can alway call Mobject.add_updater, and pass in\n        # a function that you want to be called on every frame.  The function\n        # should take in either one argument, the mobject, or two arguments,\n        # the mobject and the amount of time since the last frame.\n        now = self.time\n        w0 = square.get_width()\n        square.add_updater(\n            lambda m: m.set_width(w0 * math.cos(self.time - now))\n        )\n        self.wait(4 * PI)",
      "always_redraw()",
      "DecimalNumber",
      ".add_updater()",
      "always_redraw()",
      "DecimalNumber",
      "always(f, x)",
      "f_always(f, g)",
      ".add_updater()",
      "mob1.add_updater(lambda mob: mob.next_to(mob2))",
      "mob1.next_to(mob2)",
      "class CoordinateSystemExample(Scene):\n    def construct(self):\n        axes = Axes(\n            # x-axis ranges from -1 to 10, with a default step size of 1\n            x_range=(-1, 10),\n            # y-axis ranges from -2 to 2 with a step size of 0.5\n            y_range=(-2, 2, 0.5),\n            # The axes will be stretched so as to match the specified\n            # height and width\n            height=6,\n            width=10,\n            # Axes is made of two NumberLine mobjects.  You can specify\n            # their configuration with axis_config\n            axis_config={\n                \"stroke_color\": GREY_A,\n                \"stroke_width\": 2,\n            },\n            # Alternatively, you can specify configuration for just one\n            # of them, like this.\n            y_axis_config={\n                \"include_tip\": False,\n            }\n        )\n        # Keyword arguments of add_coordinate_labels can be used to\n        # configure the DecimalNumber mobjects which it creates and\n        # adds to the axes\n        axes.add_coordinate_labels(\n            font_size=20,\n            num_decimal_places=1,\n        )\n        self.add(axes)\n\n        # Axes descends from the CoordinateSystem class, meaning\n        # you can call call axes.coords_to_point, abbreviated to\n        # axes.c2p, to associate a set of coordinates with a point,\n        # like so:\n        dot = Dot(color=RED)\n        dot.move_to(axes.c2p(0, 0))\n        self.play(FadeIn(dot, scale=0.5))\n        self.play(dot.animate.move_to(axes.c2p(3, 2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))\n        self.wait()\n\n        # Similarly, you can call axes.point_to_coords, or axes.p2c\n        # print(axes.p2c(dot.get_center()))\n\n        # We can draw lines from the axes to better mark the coordinates\n        # of a given point.\n        # Here, the always_redraw command means that on each new frame\n        # the lines will be redrawn\n        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))\n        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))\n\n        self.play(\n            ShowCreation(h_line),\n            ShowCreation(v_line),\n        )\n        self.play(dot.animate.move_to(axes.c2p(3, -2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(1, 1)))\n        self.wait()\n\n        # If we tie the dot to a particular set of coordinates, notice\n        # that as we move the axes around it respects the coordinate\n        # system defined by them.\n        f_always(dot.move_to, lambda: axes.c2p(1, 1))\n        self.play(\n            axes.animate.scale(0.75).to_corner(UL),\n            run_time=2,\n        )\n        self.wait()\n        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))\n\n        # Other coordinate systems you can play around with include\n        # ThreeDAxes, NumberPlane, and ComplexPlane.",
      "class GraphExample(Scene):\n    def construct(self):\n        axes = Axes((-3, 10), (-1, 8))\n        axes.add_coordinate_labels()\n\n        self.play(Write(axes, lag_ratio=0.01, run_time=1))\n\n        # Axes.get_graph will return the graph of a function\n        sin_graph = axes.get_graph(\n            lambda x: 2 * math.sin(x),\n            color=BLUE,\n        )\n        # By default, it draws it so as to somewhat smoothly interpolate\n        # between sampled points (x, f(x)).  If the graph is meant to have\n        # a corner, though, you can set use_smoothing to False\n        relu_graph = axes.get_graph(\n            lambda x: max(x, 0),\n            use_smoothing=False,\n            color=YELLOW,\n        )\n        # For discontinuous functions, you can specify the point of\n        # discontinuity so that it does not try to draw over the gap.\n        step_graph = axes.get_graph(\n            lambda x: 2.0 if x > 3 else 1.0,\n            discontinuities=[3],\n            color=GREEN,\n        )\n\n        # Axes.get_graph_label takes in either a string or a mobject.\n        # If it's a string, it treats it as a LaTeX expression.  By default\n        # it places the label next to the graph near the right side, and\n        # has it match the color of the graph\n        sin_label = axes.get_graph_label(sin_graph, \"\\\\sin(x)\")\n        relu_label = axes.get_graph_label(relu_graph, Text(\"ReLU\"))\n        step_label = axes.get_graph_label(step_graph, Text(\"Step\"), x=4)\n\n        self.play(\n            ShowCreation(sin_graph),\n            FadeIn(sin_label, RIGHT),\n        )\n        self.wait(2)\n        self.play(\n            ReplacementTransform(sin_graph, relu_graph),\n            FadeTransform(sin_label, relu_label),\n        )\n        self.wait()\n        self.play(\n            ReplacementTransform(relu_graph, step_graph),\n            FadeTransform(relu_label, step_label),\n        )\n        self.wait()\n\n        parabola = axes.get_graph(lambda x: 0.25 * x**2)\n        parabola.set_stroke(BLUE)\n        self.play(\n            FadeOut(step_graph),\n            FadeOut(step_label),\n            ShowCreation(parabola)\n        )\n        self.wait()\n\n        # You can use axes.input_to_graph_point, abbreviated\n        # to axes.i2gp, to find a particular point on a graph\n        dot = Dot(color=RED)\n        dot.move_to(axes.i2gp(2, parabola))\n        self.play(FadeIn(dot, scale=0.5))\n\n        # A value tracker lets us animate a parameter, usually\n        # with the intent of having other mobjects update based\n        # on the parameter\n        x_tracker = ValueTracker(2)\n        f_always(\n            dot.move_to,\n            lambda: axes.i2gp(x_tracker.get_value(), parabola)\n        )\n\n        self.play(x_tracker.animate.set_value(4), run_time=3)\n        self.play(x_tracker.animate.set_value(-2), run_time=3)\n        self.wait()",
      "class SurfaceExample(Scene):\n    CONFIG = {\n        \"camera_class\": ThreeDCamera,\n    }\n\n    def construct(self):\n        surface_text = Text(\"For 3d scenes, try using surfaces\")\n        surface_text.fix_in_frame()\n        surface_text.to_edge(UP)\n        self.add(surface_text)\n        self.wait(0.1)\n\n        torus1 = Torus(r1=1, r2=1)\n        torus2 = Torus(r1=3, r2=1)\n        sphere = Sphere(radius=3, resolution=torus1.resolution)\n        # You can texture a surface with up to two images, which will\n        # be interpreted as the side towards the light, and away from\n        # the light.  These can be either urls, or paths to a local file\n        # in whatever you've set as the image directory in\n        # the custom_config.yml file\n\n        # day_texture = \"EarthTextureMap\"\n        # night_texture = \"NightEarthTextureMap\"\n        day_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\n        night_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\n\n        surfaces = [\n            TexturedSurface(surface, day_texture, night_texture)\n            for surface in [sphere, torus1, torus2]\n        ]\n\n        for mob in surfaces:\n            mob.shift(IN)\n            mob.mesh = SurfaceMesh(mob)\n            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)\n\n        # Set perspective\n        frame = self.camera.frame\n        frame.set_euler_angles(\n            theta=-30 * DEGREES,\n            phi=70 * DEGREES,\n        )\n\n        surface = surfaces[0]\n\n        self.play(\n            FadeIn(surface),\n            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),\n        )\n        for mob in surfaces:\n            mob.add(mob.mesh)\n        surface.save_state()\n        self.play(Rotate(surface, PI / 2), run_time=2)\n        for mob in surfaces[1:]:\n            mob.rotate(PI / 2)\n\n        self.play(\n            Transform(surface, surfaces[1]),\n            run_time=3\n        )\n\n        self.play(\n            Transform(surface, surfaces[2]),\n            # Move camera frame during the transition\n            frame.animate.increment_phi(-10 * DEGREES),\n            frame.animate.increment_theta(-20 * DEGREES),\n            run_time=3\n        )\n        # Add ambient rotation\n        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))\n\n        # Play around with where the light is\n        light_text = Text(\"You can move around the light source\")\n        light_text.move_to(surface_text)\n        light_text.fix_in_frame()\n\n        self.play(FadeTransform(surface_text, light_text))\n        light = self.camera.light_source\n        self.add(light)\n        light.save_state()\n        self.play(light.animate.move_to(3 * IN), run_time=5)\n        self.play(light.animate.shift(10 * OUT), run_time=5)\n\n        drag_text = Text(\"Try moving the mouse while pressing d or s\")\n        drag_text.move_to(light_text)\n        drag_text.fix_in_frame()\n\n        self.play(FadeTransform(light_text, drag_text))\n        self.wait()",
      ".fix_in_frame()",
      "class OpeningManimExample(Scene):\n    def construct(self):\n        intro_words = Text(\"\"\"\n            The original motivation for manim was to\n            better illustrate mathematical functions\n            as transformations.\n        \"\"\")\n        intro_words.to_edge(UP)\n\n        self.play(Write(intro_words))\n        self.wait(2)\n\n        # Linear transform\n        grid = NumberPlane((-10, 10), (-5, 5))\n        matrix = [[1, 1], [0, 1]]\n        linear_transform_words = VGroup(\n            Text(\"This is what the matrix\"),\n            IntegerMatrix(matrix, include_background_rectangle=True),\n            Text(\"looks like\")\n        )\n        linear_transform_words.arrange(RIGHT)\n        linear_transform_words.to_edge(UP)\n        linear_transform_words.set_stroke(BLACK, 10, background=True)\n\n        self.play(\n            ShowCreation(grid),\n            FadeTransform(intro_words, linear_transform_words)\n        )\n        self.wait()\n        self.play(grid.animate.apply_matrix(matrix), run_time=3)\n        self.wait()\n\n        # Complex map\n        c_grid = ComplexPlane()\n        moving_c_grid = c_grid.copy()\n        moving_c_grid.prepare_for_nonlinear_transform()\n        c_grid.set_stroke(BLUE_E, 1)\n        c_grid.add_coordinate_labels(font_size=24)\n        complex_map_words = TexText(\"\"\"\n            Or thinking of the plane as $\\\\mathds{C}$,\\\\\\\\\n            this is the map $z \\\\rightarrow z^2$\n        \"\"\")\n        complex_map_words.to_corner(UR)\n        complex_map_words.set_stroke(BLACK, 5, background=True)\n\n        self.play(\n            FadeOut(grid),\n            Write(c_grid, run_time=3),\n            FadeIn(moving_c_grid),\n            FadeTransform(linear_transform_words, complex_map_words),\n        )\n        self.wait()\n        self.play(\n            moving_c_grid.animate.apply_complex_function(lambda z: z**2),\n            run_time=6,\n        )\n        self.wait(2)"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#example-scenes",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevelopment",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample"
    ],
    "scraped_at": 1752428844.3294358
  },
  "https://3b1b.github.io/manim/getting_started/example_scenes.html#textexample": {
    "url": "https://3b1b.github.io/manim/getting_started/example_scenes.html#textexample",
    "title": "Example Scenes - manim  documentation",
    "content": "Example Scenes\n¶\nAfter understanding the previous knowledge, we can understand more scenes.\nMany example scenes are given in\nexample_scenes.py\n, let’s start with\nthe simplest and one by one.\nInteractiveDevlopment\n¶\nInteractiveDevelopment\n¶\nfrom\nmanimlib\nimport\n*\nclass\nInteractiveDevelopment\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nsquare\n=\nSquare\n()\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nself\n.\nwait\n()\n# This opens an iPython terminal where you can keep writing\n# lines as if they were part of this construct method.\n# In particular, 'square', 'circle' and 'self' will all be\n# part of the local namespace in that terminal.\nself\n.\nembed\n()\n# Try copying and pasting some of the lines below into\n# the interactive shell\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nstretch\n(\n4\n,\n0\n))\nself\n.\nplay\n(\nRotate\n(\ncircle\n,\n90\n*\nDEGREES\n))\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nshift\n(\n2\n*\nRIGHT\n)\n.\nscale\n(\n0.25\n))\ntext\n=\nText\n(\n\"\"\"\nIn general, using the interactive shell\nis very helpful when developing new scenes\n\"\"\"\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\n# In the interactive shell, you can just type\n# play, add, remove, clear, wait, save_state and restore,\n# instead of self.play, self.add, self.remove, etc.\n# To interact with the window, type touch().  You can then\n# scroll in the window, or zoom by holding down 'z' while scrolling,\n# and change camera perspective by holding down 'd' while moving\n# the mouse.  Press 'r' to reset to the standard camera position.\n# Press 'q' to stop interacting with the window and go back to\n# typing new commands into the shell.\n# In principle you can customize a scene to be responsive to\n# mouse and keyboard interactions\nalways\n(\ncircle\n.\nmove_to\n,\nself\n.\nmouse_point\n)\nThis scene is similar to what we wrote in\nQuick Start\n.\nAnd how to interact has been written in the comments.\nNo more explanation here.\nAnimatingMethods\n¶\nAnimatingMethods\n¶\nclass\nAnimatingMethods\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ngrid\n=\nOldTex\n(\nr\n\"\\pi\"\n)\n.\nget_grid\n(\n10\n,\n10\n,\nheight\n=\n4\n)\nself\n.\nadd\n(\ngrid\n)\n# You can animate the application of mobject methods with the\n# \".animate\" syntax:\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nshift\n(\nLEFT\n))\n# Alternatively, you can use the older syntax by passing the\n# method and then the arguments to the scene's \"play\" function:\nself\n.\nplay\n(\ngrid\n.\nshift\n,\nLEFT\n)\n# Both of those will interpolate between the mobject's initial\n# state and whatever happens when you apply that method.\n# For this example, calling grid.shift(LEFT) would shift the\n# grid one unit to the left, but both of the previous calls to\n# \"self.play\" animate that motion.\n# The same applies for any method, including those setting colors.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_color\n(\nYELLOW\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_submobject_colors_by_gradient\n(\nBLUE\n,\nGREEN\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_height\n(\nTAU\n-\nMED_SMALL_BUFF\n))\nself\n.\nwait\n()\n# The method Mobject.apply_complex_function lets you apply arbitrary\n# complex functions, treating the points defining the mobject as\n# complex numbers.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_complex_function\n(\nnp\n.\nexp\n),\nrun_time\n=\n5\n)\nself\n.\nwait\n()\n# Even more generally, you could apply Mobject.apply_function,\n# which takes in functions form R^3 to R^3\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_function\n(\nlambda\np\n:\n[\np\n[\n0\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n1\n]),\np\n[\n1\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n0\n]),\np\n[\n2\n]\n]\n),\nrun_time\n=\n5\n,\n)\nself\n.\nwait\n()\nThe new usage in this scene is\n.get_grid()\nand\nself.play(mob.animate.method(args))\n.\n.get_grid()\nmethod will return a new mobject containing multiple copies of this one arranged in a grid.\nself.play(mob.animate.method(args))\nanimates the method, and the details are in the comments above.\nTextExample\n¶\nTextExample\n¶\nclass\nTextExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\n# To run this scene properly, you should have \"Consolas\" font in your computer\n# for full usage, you can see https://github.com/3b1b/manim/pull/680\ntext\n=\nText\n(\n\"Here is a text\"\n,\nfont\n=\n\"Consolas\"\n,\nfont_size\n=\n90\n)\ndifference\n=\nText\n(\n\"\"\"\nThe most important difference between Text and TexText is that\\n\nyou can change the font more easily, but can't use the LaTeX grammar\n\"\"\"\n,\nfont\n=\n\"Arial\"\n,\nfont_size\n=\n24\n,\n# t2c is a dict that you can choose color for different text\nt2c\n=\n{\n\"Text\"\n:\nBLUE\n,\n\"TexText\"\n:\nBLUE\n,\n\"LaTeX\"\n:\nORANGE\n}\n)\nVGroup\n(\ntext\n,\ndifference\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\nself\n.\nplay\n(\nFadeIn\n(\ndifference\n,\nUP\n))\nself\n.\nwait\n(\n3\n)\nfonts\n=\nText\n(\n\"And you can also set the font according to different words\"\n,\nfont\n=\n\"Arial\"\n,\nt2f\n=\n{\n\"font\"\n:\n\"Consolas\"\n,\n\"words\"\n:\n\"Consolas\"\n},\nt2c\n=\n{\n\"font\"\n:\nBLUE\n,\n\"words\"\n:\nGREEN\n}\n)\nfonts\n.\nset_width\n(\nFRAME_WIDTH\n-\n1\n)\nslant\n=\nText\n(\n\"And the same as slant and weight\"\n,\nfont\n=\n\"Consolas\"\n,\nt2s\n=\n{\n\"slant\"\n:\nITALIC\n},\nt2w\n=\n{\n\"weight\"\n:\nBOLD\n},\nt2c\n=\n{\n\"slant\"\n:\nORANGE\n,\n\"weight\"\n:\nRED\n}\n)\nVGroup\n(\nfonts\n,\nslant\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n0.8\n)\nself\n.\nplay\n(\nFadeOut\n(\ntext\n),\nFadeOut\n(\ndifference\n,\nshift\n=\nDOWN\n))\nself\n.\nplay\n(\nWrite\n(\nfonts\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nWrite\n(\nslant\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nText\n,\nVGroup\n,\nWrite\n,\nFadeIn\nand\nFadeOut\n.\nText\ncan create text, define fonts, etc. The usage ais clearly reflected in the above examples.\nVGroup\ncan put multiple\nVMobject\ntogether as a whole. In the example, the\n.arrange()\nmethod is called to arrange the sub-mobjects in sequence downward (\nDOWN\n), and the spacing is\nbuff\n.\nWrite\nis an animation that shows similar writing effects.\nFadeIn\nfades the object in, the second parameter indicates the direction of the fade in.\nFadeOut\nfades out the object, the second parameter indicates the direction of the fade out.\nTexTransformExample\n¶\nTexTransformExample\n¶\nclass\nTexTransformExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nto_isolate\n=\n[\n\"B\"\n,\n\"C\"\n,\n\"=\"\n,\n\"(\"\n,\n\")\"\n]\nlines\n=\nVGroup\n(\n# Passing in muliple arguments to Tex will result\n# in the same expression as if those arguments had\n# been joined together, except that the submobject\n# hierarchy of the resulting mobject ensure that the\n# Tex mobject has a subject corresponding to\n# each of these strings.  For example, the Tex mobject\n# below will have 5 subjects, corresponding to the\n# expressions [A^2, +, B^2, =, C^2]\nOldTex\n(\n\"A^2\"\n,\n\"+\"\n,\n\"B^2\"\n,\n\"=\"\n,\n\"C^2\"\n),\n# Likewise here\nOldTex\n(\n\"A^2\"\n,\n\"=\"\n,\n\"C^2\"\n,\n\"-\"\n,\n\"B^2\"\n),\n# Alternatively, you can pass in the keyword argument\n# \"isolate\" with a list of strings that should be out as\n# their own submobject.  So the line below is equivalent\n# to the commented out line below it.\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A^2\"\n,\n*\nto_isolate\n]),\n# OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\nOldTex\n(\n\"A =\n\\\\\nsqrt{(C + B)(C - B)}\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\n)\nlines\n.\narrange\n(\nDOWN\n,\nbuff\n=\nLARGE_BUFF\n)\nfor\nline\nin\nlines\n:\nline\n.\nset_color_by_tex_to_color_map\n({\n\"A\"\n:\nBLUE\n,\n\"B\"\n:\nTEAL\n,\n\"C\"\n:\nGREEN\n,\n})\nplay_kw\n=\n{\n\"run_time\"\n:\n2\n}\nself\n.\nadd\n(\nlines\n[\n0\n])\n# The animation TransformMatchingTex will line up parts\n# of the source and target which have matching tex strings.\n# Here, giving it a little path_arc makes each part sort of\n# rotate into their final positions, which feels appropriate\n# for the idea of rearranging an equation\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n0\n]\n.\ncopy\n(),\nlines\n[\n1\n],\npath_arc\n=\n90\n*\nDEGREES\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# Now, we could try this again on the next line...\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n]),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# ...and this looks nice enough, but since there's no tex\n# in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n# out to nothing while the C and B terms fade in from nothing.\n# If, however, we want the C^2 to go to C, and B^2 to go to B,\n# we can specify that with a key map.\nself\n.\nplay\n(\nFadeOut\n(\nlines\n[\n2\n]))\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n],\nkey_map\n=\n{\n\"C^2\"\n:\n\"C\"\n,\n\"B^2\"\n:\n\"B\"\n,\n}\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# And to finish off, a simple TransformMatchingShapes would work\n# just fine.  But perhaps we want that exponent on A^2 to transform into\n# the square root symbol.  At the moment, lines[2] treats the expression\n# A^2 as a unit, so we might create a new version of the same line which\n# separates out just the A.  This way, when TransformMatchingTex lines up\n# all matching parts, the only mismatch will be between the \"^2\" from\n# new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n# transform_mismatches=True, it will transform this \"^2\" part into\n# the \"\\sqrt\" part.\nnew_line2\n=\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\nnew_line2\n.\nreplace\n(\nlines\n[\n2\n])\nnew_line2\n.\nmatch_style\n(\nlines\n[\n2\n])\nself\n.\nplay\n(\nTransformMatchingTex\n(\nnew_line2\n,\nlines\n[\n3\n],\ntransform_mismatches\n=\nTrue\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n(\n3\n)\nself\n.\nplay\n(\nFadeOut\n(\nlines\n,\nRIGHT\n))\n# Alternatively, if you don't want to think about breaking up\n# the tex strings deliberately, you can TransformMatchingShapes,\n# which will try to line up all pieces of a source mobject with\n# those of a target, regardless of the submobject hierarchy in\n# each one, according to whether those pieces have the same\n# shape (as best it can).\nsource\n=\nText\n(\n\"the morse code\"\n,\nheight\n=\n1\n)\ntarget\n=\nText\n(\n\"here come dots\"\n,\nheight\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\nsource\n))\nself\n.\nwait\n()\nkw\n=\n{\n\"run_time\"\n:\n3\n,\n\"path_arc\"\n:\nPI\n/\n2\n}\nself\n.\nplay\n(\nTransformMatchingShapes\n(\nsource\n,\ntarget\n,\n**\nkw\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nTransformMatchingShapes\n(\ntarget\n,\nsource\n,\n**\nkw\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nTex\n,\nTexText\n,\nTransformMatchingTex\nand\nTransformMatchingShapes\n.\nTex\nuses LaTeX to create mathematical formulas.\nTexText\nuses LaTeX to create text.\nTransformMatchingTeX\nautomatically transforms sub-objects according to the similarities and differences of tex in\nTex\n.\nTransformMatchingShapes\nautomatically transform sub-objects directly based on the similarities and differences of the object point sets.\nUpdatersExample\n¶\nUpdatersExample\n¶\nclass\nUpdatersExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nsquare\n=\nSquare\n()\nsquare\n.\nset_fill\n(\nBLUE_E\n,\n1\n)\n# On all all frames, the constructor Brace(square, UP) will\n# be called, and the mobject brace will set its data to match\n# that of the newly constructed object\nbrace\n=\nalways_redraw\n(\nBrace\n,\nsquare\n,\nUP\n)\ntext\n,\nnumber\n=\nlabel\n=\nVGroup\n(\nText\n(\n\"Width = \"\n),\nDecimalNumber\n(\n0\n,\nshow_ellipsis\n=\nTrue\n,\nnum_decimal_places\n=\n2\n,\ninclude_sign\n=\nTrue\n,\n)\n)\nlabel\n.\narrange\n(\nRIGHT\n)\n# This ensures that the method deicmal.next_to(square)\n# is called on every frame\nalways\n(\nlabel\n.\nnext_to\n,\nbrace\n,\nUP\n)\n# You could also write the following equivalent line\n# label.add_updater(lambda m: m.next_to(brace, UP))\n# If the argument itself might change, you can use f_always,\n# for which the arguments following the initial Mobject method\n# should be functions returning arguments to that method.\n# The following line ensures that decimal.set_value(square.get_y())\n# is called every frame\nf_always\n(\nnumber\n.\nset_value\n,\nsquare\n.\nget_width\n)\n# You could also write the following equivalent line\n# number.add_updater(lambda m: m.set_value(square.get_width()))\nself\n.\nadd\n(\nsquare\n,\nbrace\n,\nlabel\n)\n# Notice that the brace and label track with the square\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nscale\n(\n2\n),\nrate_func\n=\nthere_and_back\n,\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n5\n,\nstretch\n=\nTrue\n),\nrun_time\n=\n3\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# In general, you can alway call Mobject.add_updater, and pass in\n# a function that you want to be called on every frame.  The function\n# should take in either one argument, the mobject, or two arguments,\n# the mobject and the amount of time since the last frame.\nnow\n=\nself\n.\ntime\nw0\n=\nsquare\n.\nget_width\n()\nsquare\n.\nadd_updater\n(\nlambda\nm\n:\nm\n.\nset_width\n(\nw0\n*\nmath\n.\ncos\n(\nself\n.\ntime\n-\nnow\n))\n)\nself\n.\nwait\n(\n4\n*\nPI\n)\nThe new classes and usage in this scene are\nalways_redraw()\n,\nDecimalNumber\n,\n.to_edge()\n,\n.center()\n,\nalways()\n,\nf_always()\n,\n.set_y()\nand\n.add_updater()\n.\nalways_redraw()\nfunction create a new mobject every frame.\nDecimalNumber\nis a variable number, speed it up by breaking it into\nText\ncharacters.\n.to_edge()\nmeans to place the object on the edge of the screen.\n.center()\nmeans to place the object in the center of the screen.\nalways(f,\nx)\nmeans that a certain function (\nf(x)\n) is executed every frame.\nf_always(f,\ng)\nis similar to\nalways\n, executed\nf(g())\nevery frame.\n.set_y()\nmeans to set the ordinate of the object on the screen.\n.add_updater()\nsets an update function for the object. For example:\nmob1.add_updater(lambda\nmob:\nmob.next_to(mob2))\nmeans\nmob1.next_to(mob2)\nis executed every frame.\nCoordinateSystemExample\n¶\nCoordinateSystemExample\n¶\nclass\nCoordinateSystemExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n(\n# x-axis ranges from -1 to 10, with a default step size of 1\nx_range\n=\n(\n-\n1\n,\n10\n),\n# y-axis ranges from -2 to 2 with a step size of 0.5\ny_range\n=\n(\n-\n2\n,\n2\n,\n0.5\n),\n# The axes will be stretched so as to match the specified\n# height and width\nheight\n=\n6\n,\nwidth\n=\n10\n,\n# Axes is made of two NumberLine mobjects.  You can specify\n# their configuration with axis_config\naxis_config\n=\n{\n\"stroke_color\"\n:\nGREY_A\n,\n\"stroke_width\"\n:\n2\n,\n},\n# Alternatively, you can specify configuration for just one\n# of them, like this.\ny_axis_config\n=\n{\n\"include_tip\"\n:\nFalse\n,\n}\n)\n# Keyword arguments of add_coordinate_labels can be used to\n# configure the DecimalNumber mobjects which it creates and\n# adds to the axes\naxes\n.\nadd_coordinate_labels\n(\nfont_size\n=\n20\n,\nnum_decimal_places\n=\n1\n,\n)\nself\n.\nadd\n(\naxes\n)\n# Axes descends from the CoordinateSystem class, meaning\n# you can call call axes.coords_to_point, abbreviated to\n# axes.c2p, to associate a set of coordinates with a point,\n# like so:\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\nc2p\n(\n0\n,\n0\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n5\n,\n0.5\n)))\nself\n.\nwait\n()\n# Similarly, you can call axes.point_to_coords, or axes.p2c\n# print(axes.p2c(dot.get_center()))\n# We can draw lines from the axes to better mark the coordinates\n# of a given point.\n# Here, the always_redraw command means that on each new frame\n# the lines will be redrawn\nh_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_h_line\n(\ndot\n.\nget_left\n()))\nv_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_v_line\n(\ndot\n.\nget_bottom\n()))\nself\n.\nplay\n(\nShowCreation\n(\nh_line\n),\nShowCreation\n(\nv_line\n),\n)\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n-\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n1\n,\n1\n)))\nself\n.\nwait\n()\n# If we tie the dot to a particular set of coordinates, notice\n# that as we move the axes around it respects the coordinate\n# system defined by them.\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\nc2p\n(\n1\n,\n1\n))\nself\n.\nplay\n(\naxes\n.\nanimate\n.\nscale\n(\n0.75\n)\n.\nto_corner\n(\nUL\n),\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nFadeOut\n(\nVGroup\n(\naxes\n,\ndot\n,\nh_line\n,\nv_line\n)))\n# Other coordinate systems you can play around with include\n# ThreeDAxes, NumberPlane, and ComplexPlane.\nGraphExample\n¶\nGraphExample\n¶\nclass\nGraphExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n((\n-\n3\n,\n10\n),\n(\n-\n1\n,\n8\n))\naxes\n.\nadd_coordinate_labels\n()\nself\n.\nplay\n(\nWrite\n(\naxes\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n1\n))\n# Axes.get_graph will return the graph of a function\nsin_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2\n*\nmath\n.\nsin\n(\nx\n),\ncolor\n=\nBLUE\n,\n)\n# By default, it draws it so as to somewhat smoothly interpolate\n# between sampled points (x, f(x)).  If the graph is meant to have\n# a corner, though, you can set use_smoothing to False\nrelu_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\nmax\n(\nx\n,\n0\n),\nuse_smoothing\n=\nFalse\n,\ncolor\n=\nYELLOW\n,\n)\n# For discontinuous functions, you can specify the point of\n# discontinuity so that it does not try to draw over the gap.\nstep_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2.0\nif\nx\n>\n3\nelse\n1.0\n,\ndiscontinuities\n=\n[\n3\n],\ncolor\n=\nGREEN\n,\n)\n# Axes.get_graph_label takes in either a string or a mobject.\n# If it's a string, it treats it as a LaTeX expression.  By default\n# it places the label next to the graph near the right side, and\n# has it match the color of the graph\nsin_label\n=\naxes\n.\nget_graph_label\n(\nsin_graph\n,\n\"\n\\\\\nsin(x)\"\n)\nrelu_label\n=\naxes\n.\nget_graph_label\n(\nrelu_graph\n,\nText\n(\n\"ReLU\"\n))\nstep_label\n=\naxes\n.\nget_graph_label\n(\nstep_graph\n,\nText\n(\n\"Step\"\n),\nx\n=\n4\n)\nself\n.\nplay\n(\nShowCreation\n(\nsin_graph\n),\nFadeIn\n(\nsin_label\n,\nRIGHT\n),\n)\nself\n.\nwait\n(\n2\n)\nself\n.\nplay\n(\nReplacementTransform\n(\nsin_graph\n,\nrelu_graph\n),\nFadeTransform\n(\nsin_label\n,\nrelu_label\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nReplacementTransform\n(\nrelu_graph\n,\nstep_graph\n),\nFadeTransform\n(\nrelu_label\n,\nstep_label\n),\n)\nself\n.\nwait\n()\nparabola\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n0.25\n*\nx\n**\n2\n)\nparabola\n.\nset_stroke\n(\nBLUE\n)\nself\n.\nplay\n(\nFadeOut\n(\nstep_graph\n),\nFadeOut\n(\nstep_label\n),\nShowCreation\n(\nparabola\n)\n)\nself\n.\nwait\n()\n# You can use axes.input_to_graph_point, abbreviated\n# to axes.i2gp, to find a particular point on a graph\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\ni2gp\n(\n2\n,\nparabola\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\n# A value tracker lets us animate a parameter, usually\n# with the intent of having other mobjects update based\n# on the parameter\nx_tracker\n=\nValueTracker\n(\n2\n)\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\ni2gp\n(\nx_tracker\n.\nget_value\n(),\nparabola\n)\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n4\n),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n-\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\nSurfaceExample\n¶\nSurfaceExample\n¶\nclass\nSurfaceExample\n(\nScene\n):\nCONFIG\n=\n{\n\"camera_class\"\n:\nThreeDCamera\n,\n}\ndef\nconstruct\n(\nself\n):\nsurface_text\n=\nText\n(\n\"For 3d scenes, try using surfaces\"\n)\nsurface_text\n.\nfix_in_frame\n()\nsurface_text\n.\nto_edge\n(\nUP\n)\nself\n.\nadd\n(\nsurface_text\n)\nself\n.\nwait\n(\n0.1\n)\ntorus1\n=\nTorus\n(\nr1\n=\n1\n,\nr2\n=\n1\n)\ntorus2\n=\nTorus\n(\nr1\n=\n3\n,\nr2\n=\n1\n)\nsphere\n=\nSphere\n(\nradius\n=\n3\n,\nresolution\n=\ntorus1\n.\nresolution\n)\n# You can texture a surface with up to two images, which will\n# be interpreted as the side towards the light, and away from\n# the light.  These can be either urls, or paths to a local file\n# in whatever you've set as the image directory in\n# the custom_config.yml file\n# day_texture = \"EarthTextureMap\"\n# night_texture = \"NightEarthTextureMap\"\nday_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\nnight_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\nsurfaces\n=\n[\nTexturedSurface\n(\nsurface\n,\nday_texture\n,\nnight_texture\n)\nfor\nsurface\nin\n[\nsphere\n,\ntorus1\n,\ntorus2\n]\n]\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nshift\n(\nIN\n)\nmob\n.\nmesh\n=\nSurfaceMesh\n(\nmob\n)\nmob\n.\nmesh\n.\nset_stroke\n(\nBLUE\n,\n1\n,\nopacity\n=\n0.5\n)\n# Set perspective\nframe\n=\nself\n.\ncamera\n.\nframe\nframe\n.\nset_euler_angles\n(\ntheta\n=-\n30\n*\nDEGREES\n,\nphi\n=\n70\n*\nDEGREES\n,\n)\nsurface\n=\nsurfaces\n[\n0\n]\nself\n.\nplay\n(\nFadeIn\n(\nsurface\n),\nShowCreation\n(\nsurface\n.\nmesh\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n3\n),\n)\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nadd\n(\nmob\n.\nmesh\n)\nsurface\n.\nsave_state\n()\nself\n.\nplay\n(\nRotate\n(\nsurface\n,\nPI\n/\n2\n),\nrun_time\n=\n2\n)\nfor\nmob\nin\nsurfaces\n[\n1\n:]:\nmob\n.\nrotate\n(\nPI\n/\n2\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n1\n]),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n2\n]),\n# Move camera frame during the transition\nframe\n.\nanimate\n.\nincrement_phi\n(\n-\n10\n*\nDEGREES\n),\nframe\n.\nanimate\n.\nincrement_theta\n(\n-\n20\n*\nDEGREES\n),\nrun_time\n=\n3\n)\n# Add ambient rotation\nframe\n.\nadd_updater\n(\nlambda\nm\n,\ndt\n:\nm\n.\nincrement_theta\n(\n-\n0.1\n*\ndt\n))\n# Play around with where the light is\nlight_text\n=\nText\n(\n\"You can move around the light source\"\n)\nlight_text\n.\nmove_to\n(\nsurface_text\n)\nlight_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nsurface_text\n,\nlight_text\n))\nlight\n=\nself\n.\ncamera\n.\nlight_source\nself\n.\nadd\n(\nlight\n)\nlight\n.\nsave_state\n()\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nmove_to\n(\n3\n*\nIN\n),\nrun_time\n=\n5\n)\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nshift\n(\n10\n*\nOUT\n),\nrun_time\n=\n5\n)\ndrag_text\n=\nText\n(\n\"Try moving the mouse while pressing d or s\"\n)\ndrag_text\n.\nmove_to\n(\nlight_text\n)\ndrag_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nlight_text\n,\ndrag_text\n))\nself\n.\nwait\n()\nThis scene shows an example of using a three-dimensional surface, and\nthe related usage has been briefly described in the notes.\n.fix_in_frame()\nmakes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.\nOpeningManimExample\n¶\nOpeningManimExample\n¶\nclass\nOpeningManimExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nintro_words\n=\nText\n(\n\"\"\"\nThe original motivation for manim was to\nbetter illustrate mathematical functions\nas transformations.\n\"\"\"\n)\nintro_words\n.\nto_edge\n(\nUP\n)\nself\n.\nplay\n(\nWrite\n(\nintro_words\n))\nself\n.\nwait\n(\n2\n)\n# Linear transform\ngrid\n=\nNumberPlane\n((\n-\n10\n,\n10\n),\n(\n-\n5\n,\n5\n))\nmatrix\n=\n[[\n1\n,\n1\n],\n[\n0\n,\n1\n]]\nlinear_transform_words\n=\nVGroup\n(\nText\n(\n\"This is what the matrix\"\n),\nIntegerMatrix\n(\nmatrix\n,\ninclude_background_rectangle\n=\nTrue\n),\nText\n(\n\"looks like\"\n)\n)\nlinear_transform_words\n.\narrange\n(\nRIGHT\n)\nlinear_transform_words\n.\nto_edge\n(\nUP\n)\nlinear_transform_words\n.\nset_stroke\n(\nBLACK\n,\n10\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nShowCreation\n(\ngrid\n),\nFadeTransform\n(\nintro_words\n,\nlinear_transform_words\n)\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_matrix\n(\nmatrix\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# Complex map\nc_grid\n=\nComplexPlane\n()\nmoving_c_grid\n=\nc_grid\n.\ncopy\n()\nmoving_c_grid\n.\nprepare_for_nonlinear_transform\n()\nc_grid\n.\nset_stroke\n(\nBLUE_E\n,\n1\n)\nc_grid\n.\nadd_coordinate_labels\n(\nfont_size\n=\n24\n)\ncomplex_map_words\n=\nTexText\n(\n\"\"\"\nOr thinking of the plane as $\n\\\\\nmathds\n{C}\n$,\n\\\\\\\\\nthis is the map $z\n\\\\\nrightarrow z^2$\n\"\"\"\n)\ncomplex_map_words\n.\nto_corner\n(\nUR\n)\ncomplex_map_words\n.\nset_stroke\n(\nBLACK\n,\n5\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nFadeOut\n(\ngrid\n),\nWrite\n(\nc_grid\n,\nrun_time\n=\n3\n),\nFadeIn\n(\nmoving_c_grid\n),\nFadeTransform\n(\nlinear_transform_words\n,\ncomplex_map_words\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nmoving_c_grid\n.\nanimate\n.\napply_complex_function\n(\nlambda\nz\n:\nz\n**\n2\n),\nrun_time\n=\n6\n,\n)\nself\n.\nwait\n(\n2\n)\nThis scene is a comprehensive application of a two-dimensional scene.\nAfter seeing these scenes, you have already understood part of the\nusage of manim. For more examples, see\nthe video code of 3b1b\n.\nContents\nExample Scenes\nInteractiveDevlopment\nAnimatingMethods\nTextExample\nTexTransformExample\nUpdatersExample\nCoordinateSystemExample\nGraphExample\nSurfaceExample\nOpeningManimExample",
    "code_examples": [
      "example_scenes.py",
      "from manimlib import *\n\nclass InteractiveDevelopment(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n\n        # This opens an iPython terminal where you can keep writing\n        # lines as if they were part of this construct method.\n        # In particular, 'square', 'circle' and 'self' will all be\n        # part of the local namespace in that terminal.\n        self.embed()\n\n        # Try copying and pasting some of the lines below into\n        # the interactive shell\n        self.play(ReplacementTransform(square, circle))\n        self.wait()\n        self.play(circle.animate.stretch(4, 0))\n        self.play(Rotate(circle, 90 * DEGREES))\n        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))\n\n        text = Text(\"\"\"\n            In general, using the interactive shell\n            is very helpful when developing new scenes\n        \"\"\")\n        self.play(Write(text))\n\n        # In the interactive shell, you can just type\n        # play, add, remove, clear, wait, save_state and restore,\n        # instead of self.play, self.add, self.remove, etc.\n\n        # To interact with the window, type touch().  You can then\n        # scroll in the window, or zoom by holding down 'z' while scrolling,\n        # and change camera perspective by holding down 'd' while moving\n        # the mouse.  Press 'r' to reset to the standard camera position.\n        # Press 'q' to stop interacting with the window and go back to\n        # typing new commands into the shell.\n\n        # In principle you can customize a scene to be responsive to\n        # mouse and keyboard interactions\n        always(circle.move_to, self.mouse_point)",
      "class AnimatingMethods(Scene):\n    def construct(self):\n        grid = OldTex(r\"\\pi\").get_grid(10, 10, height=4)\n        self.add(grid)\n\n        # You can animate the application of mobject methods with the\n        # \".animate\" syntax:\n        self.play(grid.animate.shift(LEFT))\n\n        # Alternatively, you can use the older syntax by passing the\n        # method and then the arguments to the scene's \"play\" function:\n        self.play(grid.shift, LEFT)\n\n        # Both of those will interpolate between the mobject's initial\n        # state and whatever happens when you apply that method.\n        # For this example, calling grid.shift(LEFT) would shift the\n        # grid one unit to the left, but both of the previous calls to\n        # \"self.play\" animate that motion.\n\n        # The same applies for any method, including those setting colors.\n        self.play(grid.animate.set_color(YELLOW))\n        self.wait()\n        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))\n        self.wait()\n        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))\n        self.wait()\n\n        # The method Mobject.apply_complex_function lets you apply arbitrary\n        # complex functions, treating the points defining the mobject as\n        # complex numbers.\n        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)\n        self.wait()\n\n        # Even more generally, you could apply Mobject.apply_function,\n        # which takes in functions form R^3 to R^3\n        self.play(\n            grid.animate.apply_function(\n                lambda p: [\n                    p[0] + 0.5 * math.sin(p[1]),\n                    p[1] + 0.5 * math.sin(p[0]),\n                    p[2]\n                ]\n            ),\n            run_time=5,\n        )\n        self.wait()",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      "class TextExample(Scene):\n    def construct(self):\n        # To run this scene properly, you should have \"Consolas\" font in your computer\n        # for full usage, you can see https://github.com/3b1b/manim/pull/680\n        text = Text(\"Here is a text\", font=\"Consolas\", font_size=90)\n        difference = Text(\n            \"\"\"\n            The most important difference between Text and TexText is that\\n\n            you can change the font more easily, but can't use the LaTeX grammar\n            \"\"\",\n            font=\"Arial\", font_size=24,\n            # t2c is a dict that you can choose color for different text\n            t2c={\"Text\": BLUE, \"TexText\": BLUE, \"LaTeX\": ORANGE}\n        )\n        VGroup(text, difference).arrange(DOWN, buff=1)\n        self.play(Write(text))\n        self.play(FadeIn(difference, UP))\n        self.wait(3)\n\n        fonts = Text(\n            \"And you can also set the font according to different words\",\n            font=\"Arial\",\n            t2f={\"font\": \"Consolas\", \"words\": \"Consolas\"},\n            t2c={\"font\": BLUE, \"words\": GREEN}\n        )\n        fonts.set_width(FRAME_WIDTH - 1)\n        slant = Text(\n            \"And the same as slant and weight\",\n            font=\"Consolas\",\n            t2s={\"slant\": ITALIC},\n            t2w={\"weight\": BOLD},\n            t2c={\"slant\": ORANGE, \"weight\": RED}\n        )\n        VGroup(fonts, slant).arrange(DOWN, buff=0.8)\n        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))\n        self.play(Write(fonts))\n        self.wait()\n        self.play(Write(slant))\n        self.wait()",
      "class TexTransformExample(Scene):\n    def construct(self):\n        to_isolate = [\"B\", \"C\", \"=\", \"(\", \")\"]\n        lines = VGroup(\n            # Passing in muliple arguments to Tex will result\n            # in the same expression as if those arguments had\n            # been joined together, except that the submobject\n            # hierarchy of the resulting mobject ensure that the\n            # Tex mobject has a subject corresponding to\n            # each of these strings.  For example, the Tex mobject\n            # below will have 5 subjects, corresponding to the\n            # expressions [A^2, +, B^2, =, C^2]\n            OldTex(\"A^2\", \"+\", \"B^2\", \"=\", \"C^2\"),\n            # Likewise here\n            OldTex(\"A^2\", \"=\", \"C^2\", \"-\", \"B^2\"),\n            # Alternatively, you can pass in the keyword argument\n            # \"isolate\" with a list of strings that should be out as\n            # their own submobject.  So the line below is equivalent\n            # to the commented out line below it.\n            OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A^2\", *to_isolate]),\n            # OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\n            OldTex(\"A = \\\\sqrt{(C + B)(C - B)}\", isolate=[\"A\", *to_isolate])\n        )\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        for line in lines:\n            line.set_color_by_tex_to_color_map({\n                \"A\": BLUE,\n                \"B\": TEAL,\n                \"C\": GREEN,\n            })\n\n        play_kw = {\"run_time\": 2}\n        self.add(lines[0])\n        # The animation TransformMatchingTex will line up parts\n        # of the source and target which have matching tex strings.\n        # Here, giving it a little path_arc makes each part sort of\n        # rotate into their final positions, which feels appropriate\n        # for the idea of rearranging an equation\n        self.play(\n            TransformMatchingTex(\n                lines[0].copy(), lines[1],\n                path_arc=90 * DEGREES,\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # Now, we could try this again on the next line...\n        self.play(\n            TransformMatchingTex(lines[1].copy(), lines[2]),\n            **play_kw\n        )\n        self.wait()\n        # ...and this looks nice enough, but since there's no tex\n        # in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n        # out to nothing while the C and B terms fade in from nothing.\n        # If, however, we want the C^2 to go to C, and B^2 to go to B,\n        # we can specify that with a key map.\n        self.play(FadeOut(lines[2]))\n        self.play(\n            TransformMatchingTex(\n                lines[1].copy(), lines[2],\n                key_map={\n                    \"C^2\": \"C\",\n                    \"B^2\": \"B\",\n                }\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # And to finish off, a simple TransformMatchingShapes would work\n        # just fine.  But perhaps we want that exponent on A^2 to transform into\n        # the square root symbol.  At the moment, lines[2] treats the expression\n        # A^2 as a unit, so we might create a new version of the same line which\n        # separates out just the A.  This way, when TransformMatchingTex lines up\n        # all matching parts, the only mismatch will be between the \"^2\" from\n        # new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n        # transform_mismatches=True, it will transform this \"^2\" part into\n        # the \"\\sqrt\" part.\n        new_line2 = OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A\", *to_isolate])\n        new_line2.replace(lines[2])\n        new_line2.match_style(lines[2])\n\n        self.play(\n            TransformMatchingTex(\n                new_line2, lines[3],\n                transform_mismatches=True,\n            ),\n            **play_kw\n        )\n        self.wait(3)\n        self.play(FadeOut(lines, RIGHT))\n\n        # Alternatively, if you don't want to think about breaking up\n        # the tex strings deliberately, you can TransformMatchingShapes,\n        # which will try to line up all pieces of a source mobject with\n        # those of a target, regardless of the submobject hierarchy in\n        # each one, according to whether those pieces have the same\n        # shape (as best it can).\n        source = Text(\"the morse code\", height=1)\n        target = Text(\"here come dots\", height=1)\n\n        self.play(Write(source))\n        self.wait()\n        kw = {\"run_time\": 3, \"path_arc\": PI / 2}\n        self.play(TransformMatchingShapes(source, target, **kw))\n        self.wait()\n        self.play(TransformMatchingShapes(target, source, **kw))\n        self.wait()",
      "TransformMatchingTex",
      "TransformMatchingShapes",
      "TransformMatchingTeX",
      "TransformMatchingShapes",
      "class UpdatersExample(Scene):\n    def construct(self):\n        square = Square()\n        square.set_fill(BLUE_E, 1)\n\n        # On all all frames, the constructor Brace(square, UP) will\n        # be called, and the mobject brace will set its data to match\n        # that of the newly constructed object\n        brace = always_redraw(Brace, square, UP)\n\n        text, number = label = VGroup(\n            Text(\"Width = \"),\n            DecimalNumber(\n                0,\n                show_ellipsis=True,\n                num_decimal_places=2,\n                include_sign=True,\n            )\n        )\n        label.arrange(RIGHT)\n\n        # This ensures that the method deicmal.next_to(square)\n        # is called on every frame\n        always(label.next_to, brace, UP)\n        # You could also write the following equivalent line\n        # label.add_updater(lambda m: m.next_to(brace, UP))\n\n        # If the argument itself might change, you can use f_always,\n        # for which the arguments following the initial Mobject method\n        # should be functions returning arguments to that method.\n        # The following line ensures that decimal.set_value(square.get_y())\n        # is called every frame\n        f_always(number.set_value, square.get_width)\n        # You could also write the following equivalent line\n        # number.add_updater(lambda m: m.set_value(square.get_width()))\n\n        self.add(square, brace, label)\n\n        # Notice that the brace and label track with the square\n        self.play(\n            square.animate.scale(2),\n            rate_func=there_and_back,\n            run_time=2,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(5, stretch=True),\n            run_time=3,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(2),\n            run_time=3\n        )\n        self.wait()\n\n        # In general, you can alway call Mobject.add_updater, and pass in\n        # a function that you want to be called on every frame.  The function\n        # should take in either one argument, the mobject, or two arguments,\n        # the mobject and the amount of time since the last frame.\n        now = self.time\n        w0 = square.get_width()\n        square.add_updater(\n            lambda m: m.set_width(w0 * math.cos(self.time - now))\n        )\n        self.wait(4 * PI)",
      "always_redraw()",
      "DecimalNumber",
      ".add_updater()",
      "always_redraw()",
      "DecimalNumber",
      "always(f, x)",
      "f_always(f, g)",
      ".add_updater()",
      "mob1.add_updater(lambda mob: mob.next_to(mob2))",
      "mob1.next_to(mob2)",
      "class CoordinateSystemExample(Scene):\n    def construct(self):\n        axes = Axes(\n            # x-axis ranges from -1 to 10, with a default step size of 1\n            x_range=(-1, 10),\n            # y-axis ranges from -2 to 2 with a step size of 0.5\n            y_range=(-2, 2, 0.5),\n            # The axes will be stretched so as to match the specified\n            # height and width\n            height=6,\n            width=10,\n            # Axes is made of two NumberLine mobjects.  You can specify\n            # their configuration with axis_config\n            axis_config={\n                \"stroke_color\": GREY_A,\n                \"stroke_width\": 2,\n            },\n            # Alternatively, you can specify configuration for just one\n            # of them, like this.\n            y_axis_config={\n                \"include_tip\": False,\n            }\n        )\n        # Keyword arguments of add_coordinate_labels can be used to\n        # configure the DecimalNumber mobjects which it creates and\n        # adds to the axes\n        axes.add_coordinate_labels(\n            font_size=20,\n            num_decimal_places=1,\n        )\n        self.add(axes)\n\n        # Axes descends from the CoordinateSystem class, meaning\n        # you can call call axes.coords_to_point, abbreviated to\n        # axes.c2p, to associate a set of coordinates with a point,\n        # like so:\n        dot = Dot(color=RED)\n        dot.move_to(axes.c2p(0, 0))\n        self.play(FadeIn(dot, scale=0.5))\n        self.play(dot.animate.move_to(axes.c2p(3, 2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))\n        self.wait()\n\n        # Similarly, you can call axes.point_to_coords, or axes.p2c\n        # print(axes.p2c(dot.get_center()))\n\n        # We can draw lines from the axes to better mark the coordinates\n        # of a given point.\n        # Here, the always_redraw command means that on each new frame\n        # the lines will be redrawn\n        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))\n        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))\n\n        self.play(\n            ShowCreation(h_line),\n            ShowCreation(v_line),\n        )\n        self.play(dot.animate.move_to(axes.c2p(3, -2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(1, 1)))\n        self.wait()\n\n        # If we tie the dot to a particular set of coordinates, notice\n        # that as we move the axes around it respects the coordinate\n        # system defined by them.\n        f_always(dot.move_to, lambda: axes.c2p(1, 1))\n        self.play(\n            axes.animate.scale(0.75).to_corner(UL),\n            run_time=2,\n        )\n        self.wait()\n        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))\n\n        # Other coordinate systems you can play around with include\n        # ThreeDAxes, NumberPlane, and ComplexPlane.",
      "class GraphExample(Scene):\n    def construct(self):\n        axes = Axes((-3, 10), (-1, 8))\n        axes.add_coordinate_labels()\n\n        self.play(Write(axes, lag_ratio=0.01, run_time=1))\n\n        # Axes.get_graph will return the graph of a function\n        sin_graph = axes.get_graph(\n            lambda x: 2 * math.sin(x),\n            color=BLUE,\n        )\n        # By default, it draws it so as to somewhat smoothly interpolate\n        # between sampled points (x, f(x)).  If the graph is meant to have\n        # a corner, though, you can set use_smoothing to False\n        relu_graph = axes.get_graph(\n            lambda x: max(x, 0),\n            use_smoothing=False,\n            color=YELLOW,\n        )\n        # For discontinuous functions, you can specify the point of\n        # discontinuity so that it does not try to draw over the gap.\n        step_graph = axes.get_graph(\n            lambda x: 2.0 if x > 3 else 1.0,\n            discontinuities=[3],\n            color=GREEN,\n        )\n\n        # Axes.get_graph_label takes in either a string or a mobject.\n        # If it's a string, it treats it as a LaTeX expression.  By default\n        # it places the label next to the graph near the right side, and\n        # has it match the color of the graph\n        sin_label = axes.get_graph_label(sin_graph, \"\\\\sin(x)\")\n        relu_label = axes.get_graph_label(relu_graph, Text(\"ReLU\"))\n        step_label = axes.get_graph_label(step_graph, Text(\"Step\"), x=4)\n\n        self.play(\n            ShowCreation(sin_graph),\n            FadeIn(sin_label, RIGHT),\n        )\n        self.wait(2)\n        self.play(\n            ReplacementTransform(sin_graph, relu_graph),\n            FadeTransform(sin_label, relu_label),\n        )\n        self.wait()\n        self.play(\n            ReplacementTransform(relu_graph, step_graph),\n            FadeTransform(relu_label, step_label),\n        )\n        self.wait()\n\n        parabola = axes.get_graph(lambda x: 0.25 * x**2)\n        parabola.set_stroke(BLUE)\n        self.play(\n            FadeOut(step_graph),\n            FadeOut(step_label),\n            ShowCreation(parabola)\n        )\n        self.wait()\n\n        # You can use axes.input_to_graph_point, abbreviated\n        # to axes.i2gp, to find a particular point on a graph\n        dot = Dot(color=RED)\n        dot.move_to(axes.i2gp(2, parabola))\n        self.play(FadeIn(dot, scale=0.5))\n\n        # A value tracker lets us animate a parameter, usually\n        # with the intent of having other mobjects update based\n        # on the parameter\n        x_tracker = ValueTracker(2)\n        f_always(\n            dot.move_to,\n            lambda: axes.i2gp(x_tracker.get_value(), parabola)\n        )\n\n        self.play(x_tracker.animate.set_value(4), run_time=3)\n        self.play(x_tracker.animate.set_value(-2), run_time=3)\n        self.wait()",
      "class SurfaceExample(Scene):\n    CONFIG = {\n        \"camera_class\": ThreeDCamera,\n    }\n\n    def construct(self):\n        surface_text = Text(\"For 3d scenes, try using surfaces\")\n        surface_text.fix_in_frame()\n        surface_text.to_edge(UP)\n        self.add(surface_text)\n        self.wait(0.1)\n\n        torus1 = Torus(r1=1, r2=1)\n        torus2 = Torus(r1=3, r2=1)\n        sphere = Sphere(radius=3, resolution=torus1.resolution)\n        # You can texture a surface with up to two images, which will\n        # be interpreted as the side towards the light, and away from\n        # the light.  These can be either urls, or paths to a local file\n        # in whatever you've set as the image directory in\n        # the custom_config.yml file\n\n        # day_texture = \"EarthTextureMap\"\n        # night_texture = \"NightEarthTextureMap\"\n        day_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\n        night_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\n\n        surfaces = [\n            TexturedSurface(surface, day_texture, night_texture)\n            for surface in [sphere, torus1, torus2]\n        ]\n\n        for mob in surfaces:\n            mob.shift(IN)\n            mob.mesh = SurfaceMesh(mob)\n            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)\n\n        # Set perspective\n        frame = self.camera.frame\n        frame.set_euler_angles(\n            theta=-30 * DEGREES,\n            phi=70 * DEGREES,\n        )\n\n        surface = surfaces[0]\n\n        self.play(\n            FadeIn(surface),\n            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),\n        )\n        for mob in surfaces:\n            mob.add(mob.mesh)\n        surface.save_state()\n        self.play(Rotate(surface, PI / 2), run_time=2)\n        for mob in surfaces[1:]:\n            mob.rotate(PI / 2)\n\n        self.play(\n            Transform(surface, surfaces[1]),\n            run_time=3\n        )\n\n        self.play(\n            Transform(surface, surfaces[2]),\n            # Move camera frame during the transition\n            frame.animate.increment_phi(-10 * DEGREES),\n            frame.animate.increment_theta(-20 * DEGREES),\n            run_time=3\n        )\n        # Add ambient rotation\n        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))\n\n        # Play around with where the light is\n        light_text = Text(\"You can move around the light source\")\n        light_text.move_to(surface_text)\n        light_text.fix_in_frame()\n\n        self.play(FadeTransform(surface_text, light_text))\n        light = self.camera.light_source\n        self.add(light)\n        light.save_state()\n        self.play(light.animate.move_to(3 * IN), run_time=5)\n        self.play(light.animate.shift(10 * OUT), run_time=5)\n\n        drag_text = Text(\"Try moving the mouse while pressing d or s\")\n        drag_text.move_to(light_text)\n        drag_text.fix_in_frame()\n\n        self.play(FadeTransform(light_text, drag_text))\n        self.wait()",
      ".fix_in_frame()",
      "class OpeningManimExample(Scene):\n    def construct(self):\n        intro_words = Text(\"\"\"\n            The original motivation for manim was to\n            better illustrate mathematical functions\n            as transformations.\n        \"\"\")\n        intro_words.to_edge(UP)\n\n        self.play(Write(intro_words))\n        self.wait(2)\n\n        # Linear transform\n        grid = NumberPlane((-10, 10), (-5, 5))\n        matrix = [[1, 1], [0, 1]]\n        linear_transform_words = VGroup(\n            Text(\"This is what the matrix\"),\n            IntegerMatrix(matrix, include_background_rectangle=True),\n            Text(\"looks like\")\n        )\n        linear_transform_words.arrange(RIGHT)\n        linear_transform_words.to_edge(UP)\n        linear_transform_words.set_stroke(BLACK, 10, background=True)\n\n        self.play(\n            ShowCreation(grid),\n            FadeTransform(intro_words, linear_transform_words)\n        )\n        self.wait()\n        self.play(grid.animate.apply_matrix(matrix), run_time=3)\n        self.wait()\n\n        # Complex map\n        c_grid = ComplexPlane()\n        moving_c_grid = c_grid.copy()\n        moving_c_grid.prepare_for_nonlinear_transform()\n        c_grid.set_stroke(BLUE_E, 1)\n        c_grid.add_coordinate_labels(font_size=24)\n        complex_map_words = TexText(\"\"\"\n            Or thinking of the plane as $\\\\mathds{C}$,\\\\\\\\\n            this is the map $z \\\\rightarrow z^2$\n        \"\"\")\n        complex_map_words.to_corner(UR)\n        complex_map_words.set_stroke(BLACK, 5, background=True)\n\n        self.play(\n            FadeOut(grid),\n            Write(c_grid, run_time=3),\n            FadeIn(moving_c_grid),\n            FadeTransform(linear_transform_words, complex_map_words),\n        )\n        self.wait()\n        self.play(\n            moving_c_grid.animate.apply_complex_function(lambda z: z**2),\n            run_time=6,\n        )\n        self.wait(2)"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#example-scenes",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevelopment",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample"
    ],
    "scraped_at": 1752428845.405428
  },
  "https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample": {
    "url": "https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample",
    "title": "Example Scenes - manim  documentation",
    "content": "Example Scenes\n¶\nAfter understanding the previous knowledge, we can understand more scenes.\nMany example scenes are given in\nexample_scenes.py\n, let’s start with\nthe simplest and one by one.\nInteractiveDevlopment\n¶\nInteractiveDevelopment\n¶\nfrom\nmanimlib\nimport\n*\nclass\nInteractiveDevelopment\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nsquare\n=\nSquare\n()\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nself\n.\nwait\n()\n# This opens an iPython terminal where you can keep writing\n# lines as if they were part of this construct method.\n# In particular, 'square', 'circle' and 'self' will all be\n# part of the local namespace in that terminal.\nself\n.\nembed\n()\n# Try copying and pasting some of the lines below into\n# the interactive shell\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nstretch\n(\n4\n,\n0\n))\nself\n.\nplay\n(\nRotate\n(\ncircle\n,\n90\n*\nDEGREES\n))\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nshift\n(\n2\n*\nRIGHT\n)\n.\nscale\n(\n0.25\n))\ntext\n=\nText\n(\n\"\"\"\nIn general, using the interactive shell\nis very helpful when developing new scenes\n\"\"\"\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\n# In the interactive shell, you can just type\n# play, add, remove, clear, wait, save_state and restore,\n# instead of self.play, self.add, self.remove, etc.\n# To interact with the window, type touch().  You can then\n# scroll in the window, or zoom by holding down 'z' while scrolling,\n# and change camera perspective by holding down 'd' while moving\n# the mouse.  Press 'r' to reset to the standard camera position.\n# Press 'q' to stop interacting with the window and go back to\n# typing new commands into the shell.\n# In principle you can customize a scene to be responsive to\n# mouse and keyboard interactions\nalways\n(\ncircle\n.\nmove_to\n,\nself\n.\nmouse_point\n)\nThis scene is similar to what we wrote in\nQuick Start\n.\nAnd how to interact has been written in the comments.\nNo more explanation here.\nAnimatingMethods\n¶\nAnimatingMethods\n¶\nclass\nAnimatingMethods\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ngrid\n=\nOldTex\n(\nr\n\"\\pi\"\n)\n.\nget_grid\n(\n10\n,\n10\n,\nheight\n=\n4\n)\nself\n.\nadd\n(\ngrid\n)\n# You can animate the application of mobject methods with the\n# \".animate\" syntax:\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nshift\n(\nLEFT\n))\n# Alternatively, you can use the older syntax by passing the\n# method and then the arguments to the scene's \"play\" function:\nself\n.\nplay\n(\ngrid\n.\nshift\n,\nLEFT\n)\n# Both of those will interpolate between the mobject's initial\n# state and whatever happens when you apply that method.\n# For this example, calling grid.shift(LEFT) would shift the\n# grid one unit to the left, but both of the previous calls to\n# \"self.play\" animate that motion.\n# The same applies for any method, including those setting colors.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_color\n(\nYELLOW\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_submobject_colors_by_gradient\n(\nBLUE\n,\nGREEN\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_height\n(\nTAU\n-\nMED_SMALL_BUFF\n))\nself\n.\nwait\n()\n# The method Mobject.apply_complex_function lets you apply arbitrary\n# complex functions, treating the points defining the mobject as\n# complex numbers.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_complex_function\n(\nnp\n.\nexp\n),\nrun_time\n=\n5\n)\nself\n.\nwait\n()\n# Even more generally, you could apply Mobject.apply_function,\n# which takes in functions form R^3 to R^3\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_function\n(\nlambda\np\n:\n[\np\n[\n0\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n1\n]),\np\n[\n1\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n0\n]),\np\n[\n2\n]\n]\n),\nrun_time\n=\n5\n,\n)\nself\n.\nwait\n()\nThe new usage in this scene is\n.get_grid()\nand\nself.play(mob.animate.method(args))\n.\n.get_grid()\nmethod will return a new mobject containing multiple copies of this one arranged in a grid.\nself.play(mob.animate.method(args))\nanimates the method, and the details are in the comments above.\nTextExample\n¶\nTextExample\n¶\nclass\nTextExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\n# To run this scene properly, you should have \"Consolas\" font in your computer\n# for full usage, you can see https://github.com/3b1b/manim/pull/680\ntext\n=\nText\n(\n\"Here is a text\"\n,\nfont\n=\n\"Consolas\"\n,\nfont_size\n=\n90\n)\ndifference\n=\nText\n(\n\"\"\"\nThe most important difference between Text and TexText is that\\n\nyou can change the font more easily, but can't use the LaTeX grammar\n\"\"\"\n,\nfont\n=\n\"Arial\"\n,\nfont_size\n=\n24\n,\n# t2c is a dict that you can choose color for different text\nt2c\n=\n{\n\"Text\"\n:\nBLUE\n,\n\"TexText\"\n:\nBLUE\n,\n\"LaTeX\"\n:\nORANGE\n}\n)\nVGroup\n(\ntext\n,\ndifference\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\nself\n.\nplay\n(\nFadeIn\n(\ndifference\n,\nUP\n))\nself\n.\nwait\n(\n3\n)\nfonts\n=\nText\n(\n\"And you can also set the font according to different words\"\n,\nfont\n=\n\"Arial\"\n,\nt2f\n=\n{\n\"font\"\n:\n\"Consolas\"\n,\n\"words\"\n:\n\"Consolas\"\n},\nt2c\n=\n{\n\"font\"\n:\nBLUE\n,\n\"words\"\n:\nGREEN\n}\n)\nfonts\n.\nset_width\n(\nFRAME_WIDTH\n-\n1\n)\nslant\n=\nText\n(\n\"And the same as slant and weight\"\n,\nfont\n=\n\"Consolas\"\n,\nt2s\n=\n{\n\"slant\"\n:\nITALIC\n},\nt2w\n=\n{\n\"weight\"\n:\nBOLD\n},\nt2c\n=\n{\n\"slant\"\n:\nORANGE\n,\n\"weight\"\n:\nRED\n}\n)\nVGroup\n(\nfonts\n,\nslant\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n0.8\n)\nself\n.\nplay\n(\nFadeOut\n(\ntext\n),\nFadeOut\n(\ndifference\n,\nshift\n=\nDOWN\n))\nself\n.\nplay\n(\nWrite\n(\nfonts\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nWrite\n(\nslant\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nText\n,\nVGroup\n,\nWrite\n,\nFadeIn\nand\nFadeOut\n.\nText\ncan create text, define fonts, etc. The usage ais clearly reflected in the above examples.\nVGroup\ncan put multiple\nVMobject\ntogether as a whole. In the example, the\n.arrange()\nmethod is called to arrange the sub-mobjects in sequence downward (\nDOWN\n), and the spacing is\nbuff\n.\nWrite\nis an animation that shows similar writing effects.\nFadeIn\nfades the object in, the second parameter indicates the direction of the fade in.\nFadeOut\nfades out the object, the second parameter indicates the direction of the fade out.\nTexTransformExample\n¶\nTexTransformExample\n¶\nclass\nTexTransformExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nto_isolate\n=\n[\n\"B\"\n,\n\"C\"\n,\n\"=\"\n,\n\"(\"\n,\n\")\"\n]\nlines\n=\nVGroup\n(\n# Passing in muliple arguments to Tex will result\n# in the same expression as if those arguments had\n# been joined together, except that the submobject\n# hierarchy of the resulting mobject ensure that the\n# Tex mobject has a subject corresponding to\n# each of these strings.  For example, the Tex mobject\n# below will have 5 subjects, corresponding to the\n# expressions [A^2, +, B^2, =, C^2]\nOldTex\n(\n\"A^2\"\n,\n\"+\"\n,\n\"B^2\"\n,\n\"=\"\n,\n\"C^2\"\n),\n# Likewise here\nOldTex\n(\n\"A^2\"\n,\n\"=\"\n,\n\"C^2\"\n,\n\"-\"\n,\n\"B^2\"\n),\n# Alternatively, you can pass in the keyword argument\n# \"isolate\" with a list of strings that should be out as\n# their own submobject.  So the line below is equivalent\n# to the commented out line below it.\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A^2\"\n,\n*\nto_isolate\n]),\n# OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\nOldTex\n(\n\"A =\n\\\\\nsqrt{(C + B)(C - B)}\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\n)\nlines\n.\narrange\n(\nDOWN\n,\nbuff\n=\nLARGE_BUFF\n)\nfor\nline\nin\nlines\n:\nline\n.\nset_color_by_tex_to_color_map\n({\n\"A\"\n:\nBLUE\n,\n\"B\"\n:\nTEAL\n,\n\"C\"\n:\nGREEN\n,\n})\nplay_kw\n=\n{\n\"run_time\"\n:\n2\n}\nself\n.\nadd\n(\nlines\n[\n0\n])\n# The animation TransformMatchingTex will line up parts\n# of the source and target which have matching tex strings.\n# Here, giving it a little path_arc makes each part sort of\n# rotate into their final positions, which feels appropriate\n# for the idea of rearranging an equation\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n0\n]\n.\ncopy\n(),\nlines\n[\n1\n],\npath_arc\n=\n90\n*\nDEGREES\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# Now, we could try this again on the next line...\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n]),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# ...and this looks nice enough, but since there's no tex\n# in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n# out to nothing while the C and B terms fade in from nothing.\n# If, however, we want the C^2 to go to C, and B^2 to go to B,\n# we can specify that with a key map.\nself\n.\nplay\n(\nFadeOut\n(\nlines\n[\n2\n]))\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n],\nkey_map\n=\n{\n\"C^2\"\n:\n\"C\"\n,\n\"B^2\"\n:\n\"B\"\n,\n}\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# And to finish off, a simple TransformMatchingShapes would work\n# just fine.  But perhaps we want that exponent on A^2 to transform into\n# the square root symbol.  At the moment, lines[2] treats the expression\n# A^2 as a unit, so we might create a new version of the same line which\n# separates out just the A.  This way, when TransformMatchingTex lines up\n# all matching parts, the only mismatch will be between the \"^2\" from\n# new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n# transform_mismatches=True, it will transform this \"^2\" part into\n# the \"\\sqrt\" part.\nnew_line2\n=\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\nnew_line2\n.\nreplace\n(\nlines\n[\n2\n])\nnew_line2\n.\nmatch_style\n(\nlines\n[\n2\n])\nself\n.\nplay\n(\nTransformMatchingTex\n(\nnew_line2\n,\nlines\n[\n3\n],\ntransform_mismatches\n=\nTrue\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n(\n3\n)\nself\n.\nplay\n(\nFadeOut\n(\nlines\n,\nRIGHT\n))\n# Alternatively, if you don't want to think about breaking up\n# the tex strings deliberately, you can TransformMatchingShapes,\n# which will try to line up all pieces of a source mobject with\n# those of a target, regardless of the submobject hierarchy in\n# each one, according to whether those pieces have the same\n# shape (as best it can).\nsource\n=\nText\n(\n\"the morse code\"\n,\nheight\n=\n1\n)\ntarget\n=\nText\n(\n\"here come dots\"\n,\nheight\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\nsource\n))\nself\n.\nwait\n()\nkw\n=\n{\n\"run_time\"\n:\n3\n,\n\"path_arc\"\n:\nPI\n/\n2\n}\nself\n.\nplay\n(\nTransformMatchingShapes\n(\nsource\n,\ntarget\n,\n**\nkw\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nTransformMatchingShapes\n(\ntarget\n,\nsource\n,\n**\nkw\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nTex\n,\nTexText\n,\nTransformMatchingTex\nand\nTransformMatchingShapes\n.\nTex\nuses LaTeX to create mathematical formulas.\nTexText\nuses LaTeX to create text.\nTransformMatchingTeX\nautomatically transforms sub-objects according to the similarities and differences of tex in\nTex\n.\nTransformMatchingShapes\nautomatically transform sub-objects directly based on the similarities and differences of the object point sets.\nUpdatersExample\n¶\nUpdatersExample\n¶\nclass\nUpdatersExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nsquare\n=\nSquare\n()\nsquare\n.\nset_fill\n(\nBLUE_E\n,\n1\n)\n# On all all frames, the constructor Brace(square, UP) will\n# be called, and the mobject brace will set its data to match\n# that of the newly constructed object\nbrace\n=\nalways_redraw\n(\nBrace\n,\nsquare\n,\nUP\n)\ntext\n,\nnumber\n=\nlabel\n=\nVGroup\n(\nText\n(\n\"Width = \"\n),\nDecimalNumber\n(\n0\n,\nshow_ellipsis\n=\nTrue\n,\nnum_decimal_places\n=\n2\n,\ninclude_sign\n=\nTrue\n,\n)\n)\nlabel\n.\narrange\n(\nRIGHT\n)\n# This ensures that the method deicmal.next_to(square)\n# is called on every frame\nalways\n(\nlabel\n.\nnext_to\n,\nbrace\n,\nUP\n)\n# You could also write the following equivalent line\n# label.add_updater(lambda m: m.next_to(brace, UP))\n# If the argument itself might change, you can use f_always,\n# for which the arguments following the initial Mobject method\n# should be functions returning arguments to that method.\n# The following line ensures that decimal.set_value(square.get_y())\n# is called every frame\nf_always\n(\nnumber\n.\nset_value\n,\nsquare\n.\nget_width\n)\n# You could also write the following equivalent line\n# number.add_updater(lambda m: m.set_value(square.get_width()))\nself\n.\nadd\n(\nsquare\n,\nbrace\n,\nlabel\n)\n# Notice that the brace and label track with the square\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nscale\n(\n2\n),\nrate_func\n=\nthere_and_back\n,\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n5\n,\nstretch\n=\nTrue\n),\nrun_time\n=\n3\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# In general, you can alway call Mobject.add_updater, and pass in\n# a function that you want to be called on every frame.  The function\n# should take in either one argument, the mobject, or two arguments,\n# the mobject and the amount of time since the last frame.\nnow\n=\nself\n.\ntime\nw0\n=\nsquare\n.\nget_width\n()\nsquare\n.\nadd_updater\n(\nlambda\nm\n:\nm\n.\nset_width\n(\nw0\n*\nmath\n.\ncos\n(\nself\n.\ntime\n-\nnow\n))\n)\nself\n.\nwait\n(\n4\n*\nPI\n)\nThe new classes and usage in this scene are\nalways_redraw()\n,\nDecimalNumber\n,\n.to_edge()\n,\n.center()\n,\nalways()\n,\nf_always()\n,\n.set_y()\nand\n.add_updater()\n.\nalways_redraw()\nfunction create a new mobject every frame.\nDecimalNumber\nis a variable number, speed it up by breaking it into\nText\ncharacters.\n.to_edge()\nmeans to place the object on the edge of the screen.\n.center()\nmeans to place the object in the center of the screen.\nalways(f,\nx)\nmeans that a certain function (\nf(x)\n) is executed every frame.\nf_always(f,\ng)\nis similar to\nalways\n, executed\nf(g())\nevery frame.\n.set_y()\nmeans to set the ordinate of the object on the screen.\n.add_updater()\nsets an update function for the object. For example:\nmob1.add_updater(lambda\nmob:\nmob.next_to(mob2))\nmeans\nmob1.next_to(mob2)\nis executed every frame.\nCoordinateSystemExample\n¶\nCoordinateSystemExample\n¶\nclass\nCoordinateSystemExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n(\n# x-axis ranges from -1 to 10, with a default step size of 1\nx_range\n=\n(\n-\n1\n,\n10\n),\n# y-axis ranges from -2 to 2 with a step size of 0.5\ny_range\n=\n(\n-\n2\n,\n2\n,\n0.5\n),\n# The axes will be stretched so as to match the specified\n# height and width\nheight\n=\n6\n,\nwidth\n=\n10\n,\n# Axes is made of two NumberLine mobjects.  You can specify\n# their configuration with axis_config\naxis_config\n=\n{\n\"stroke_color\"\n:\nGREY_A\n,\n\"stroke_width\"\n:\n2\n,\n},\n# Alternatively, you can specify configuration for just one\n# of them, like this.\ny_axis_config\n=\n{\n\"include_tip\"\n:\nFalse\n,\n}\n)\n# Keyword arguments of add_coordinate_labels can be used to\n# configure the DecimalNumber mobjects which it creates and\n# adds to the axes\naxes\n.\nadd_coordinate_labels\n(\nfont_size\n=\n20\n,\nnum_decimal_places\n=\n1\n,\n)\nself\n.\nadd\n(\naxes\n)\n# Axes descends from the CoordinateSystem class, meaning\n# you can call call axes.coords_to_point, abbreviated to\n# axes.c2p, to associate a set of coordinates with a point,\n# like so:\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\nc2p\n(\n0\n,\n0\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n5\n,\n0.5\n)))\nself\n.\nwait\n()\n# Similarly, you can call axes.point_to_coords, or axes.p2c\n# print(axes.p2c(dot.get_center()))\n# We can draw lines from the axes to better mark the coordinates\n# of a given point.\n# Here, the always_redraw command means that on each new frame\n# the lines will be redrawn\nh_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_h_line\n(\ndot\n.\nget_left\n()))\nv_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_v_line\n(\ndot\n.\nget_bottom\n()))\nself\n.\nplay\n(\nShowCreation\n(\nh_line\n),\nShowCreation\n(\nv_line\n),\n)\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n-\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n1\n,\n1\n)))\nself\n.\nwait\n()\n# If we tie the dot to a particular set of coordinates, notice\n# that as we move the axes around it respects the coordinate\n# system defined by them.\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\nc2p\n(\n1\n,\n1\n))\nself\n.\nplay\n(\naxes\n.\nanimate\n.\nscale\n(\n0.75\n)\n.\nto_corner\n(\nUL\n),\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nFadeOut\n(\nVGroup\n(\naxes\n,\ndot\n,\nh_line\n,\nv_line\n)))\n# Other coordinate systems you can play around with include\n# ThreeDAxes, NumberPlane, and ComplexPlane.\nGraphExample\n¶\nGraphExample\n¶\nclass\nGraphExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n((\n-\n3\n,\n10\n),\n(\n-\n1\n,\n8\n))\naxes\n.\nadd_coordinate_labels\n()\nself\n.\nplay\n(\nWrite\n(\naxes\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n1\n))\n# Axes.get_graph will return the graph of a function\nsin_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2\n*\nmath\n.\nsin\n(\nx\n),\ncolor\n=\nBLUE\n,\n)\n# By default, it draws it so as to somewhat smoothly interpolate\n# between sampled points (x, f(x)).  If the graph is meant to have\n# a corner, though, you can set use_smoothing to False\nrelu_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\nmax\n(\nx\n,\n0\n),\nuse_smoothing\n=\nFalse\n,\ncolor\n=\nYELLOW\n,\n)\n# For discontinuous functions, you can specify the point of\n# discontinuity so that it does not try to draw over the gap.\nstep_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2.0\nif\nx\n>\n3\nelse\n1.0\n,\ndiscontinuities\n=\n[\n3\n],\ncolor\n=\nGREEN\n,\n)\n# Axes.get_graph_label takes in either a string or a mobject.\n# If it's a string, it treats it as a LaTeX expression.  By default\n# it places the label next to the graph near the right side, and\n# has it match the color of the graph\nsin_label\n=\naxes\n.\nget_graph_label\n(\nsin_graph\n,\n\"\n\\\\\nsin(x)\"\n)\nrelu_label\n=\naxes\n.\nget_graph_label\n(\nrelu_graph\n,\nText\n(\n\"ReLU\"\n))\nstep_label\n=\naxes\n.\nget_graph_label\n(\nstep_graph\n,\nText\n(\n\"Step\"\n),\nx\n=\n4\n)\nself\n.\nplay\n(\nShowCreation\n(\nsin_graph\n),\nFadeIn\n(\nsin_label\n,\nRIGHT\n),\n)\nself\n.\nwait\n(\n2\n)\nself\n.\nplay\n(\nReplacementTransform\n(\nsin_graph\n,\nrelu_graph\n),\nFadeTransform\n(\nsin_label\n,\nrelu_label\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nReplacementTransform\n(\nrelu_graph\n,\nstep_graph\n),\nFadeTransform\n(\nrelu_label\n,\nstep_label\n),\n)\nself\n.\nwait\n()\nparabola\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n0.25\n*\nx\n**\n2\n)\nparabola\n.\nset_stroke\n(\nBLUE\n)\nself\n.\nplay\n(\nFadeOut\n(\nstep_graph\n),\nFadeOut\n(\nstep_label\n),\nShowCreation\n(\nparabola\n)\n)\nself\n.\nwait\n()\n# You can use axes.input_to_graph_point, abbreviated\n# to axes.i2gp, to find a particular point on a graph\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\ni2gp\n(\n2\n,\nparabola\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\n# A value tracker lets us animate a parameter, usually\n# with the intent of having other mobjects update based\n# on the parameter\nx_tracker\n=\nValueTracker\n(\n2\n)\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\ni2gp\n(\nx_tracker\n.\nget_value\n(),\nparabola\n)\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n4\n),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n-\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\nSurfaceExample\n¶\nSurfaceExample\n¶\nclass\nSurfaceExample\n(\nScene\n):\nCONFIG\n=\n{\n\"camera_class\"\n:\nThreeDCamera\n,\n}\ndef\nconstruct\n(\nself\n):\nsurface_text\n=\nText\n(\n\"For 3d scenes, try using surfaces\"\n)\nsurface_text\n.\nfix_in_frame\n()\nsurface_text\n.\nto_edge\n(\nUP\n)\nself\n.\nadd\n(\nsurface_text\n)\nself\n.\nwait\n(\n0.1\n)\ntorus1\n=\nTorus\n(\nr1\n=\n1\n,\nr2\n=\n1\n)\ntorus2\n=\nTorus\n(\nr1\n=\n3\n,\nr2\n=\n1\n)\nsphere\n=\nSphere\n(\nradius\n=\n3\n,\nresolution\n=\ntorus1\n.\nresolution\n)\n# You can texture a surface with up to two images, which will\n# be interpreted as the side towards the light, and away from\n# the light.  These can be either urls, or paths to a local file\n# in whatever you've set as the image directory in\n# the custom_config.yml file\n# day_texture = \"EarthTextureMap\"\n# night_texture = \"NightEarthTextureMap\"\nday_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\nnight_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\nsurfaces\n=\n[\nTexturedSurface\n(\nsurface\n,\nday_texture\n,\nnight_texture\n)\nfor\nsurface\nin\n[\nsphere\n,\ntorus1\n,\ntorus2\n]\n]\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nshift\n(\nIN\n)\nmob\n.\nmesh\n=\nSurfaceMesh\n(\nmob\n)\nmob\n.\nmesh\n.\nset_stroke\n(\nBLUE\n,\n1\n,\nopacity\n=\n0.5\n)\n# Set perspective\nframe\n=\nself\n.\ncamera\n.\nframe\nframe\n.\nset_euler_angles\n(\ntheta\n=-\n30\n*\nDEGREES\n,\nphi\n=\n70\n*\nDEGREES\n,\n)\nsurface\n=\nsurfaces\n[\n0\n]\nself\n.\nplay\n(\nFadeIn\n(\nsurface\n),\nShowCreation\n(\nsurface\n.\nmesh\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n3\n),\n)\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nadd\n(\nmob\n.\nmesh\n)\nsurface\n.\nsave_state\n()\nself\n.\nplay\n(\nRotate\n(\nsurface\n,\nPI\n/\n2\n),\nrun_time\n=\n2\n)\nfor\nmob\nin\nsurfaces\n[\n1\n:]:\nmob\n.\nrotate\n(\nPI\n/\n2\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n1\n]),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n2\n]),\n# Move camera frame during the transition\nframe\n.\nanimate\n.\nincrement_phi\n(\n-\n10\n*\nDEGREES\n),\nframe\n.\nanimate\n.\nincrement_theta\n(\n-\n20\n*\nDEGREES\n),\nrun_time\n=\n3\n)\n# Add ambient rotation\nframe\n.\nadd_updater\n(\nlambda\nm\n,\ndt\n:\nm\n.\nincrement_theta\n(\n-\n0.1\n*\ndt\n))\n# Play around with where the light is\nlight_text\n=\nText\n(\n\"You can move around the light source\"\n)\nlight_text\n.\nmove_to\n(\nsurface_text\n)\nlight_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nsurface_text\n,\nlight_text\n))\nlight\n=\nself\n.\ncamera\n.\nlight_source\nself\n.\nadd\n(\nlight\n)\nlight\n.\nsave_state\n()\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nmove_to\n(\n3\n*\nIN\n),\nrun_time\n=\n5\n)\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nshift\n(\n10\n*\nOUT\n),\nrun_time\n=\n5\n)\ndrag_text\n=\nText\n(\n\"Try moving the mouse while pressing d or s\"\n)\ndrag_text\n.\nmove_to\n(\nlight_text\n)\ndrag_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nlight_text\n,\ndrag_text\n))\nself\n.\nwait\n()\nThis scene shows an example of using a three-dimensional surface, and\nthe related usage has been briefly described in the notes.\n.fix_in_frame()\nmakes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.\nOpeningManimExample\n¶\nOpeningManimExample\n¶\nclass\nOpeningManimExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nintro_words\n=\nText\n(\n\"\"\"\nThe original motivation for manim was to\nbetter illustrate mathematical functions\nas transformations.\n\"\"\"\n)\nintro_words\n.\nto_edge\n(\nUP\n)\nself\n.\nplay\n(\nWrite\n(\nintro_words\n))\nself\n.\nwait\n(\n2\n)\n# Linear transform\ngrid\n=\nNumberPlane\n((\n-\n10\n,\n10\n),\n(\n-\n5\n,\n5\n))\nmatrix\n=\n[[\n1\n,\n1\n],\n[\n0\n,\n1\n]]\nlinear_transform_words\n=\nVGroup\n(\nText\n(\n\"This is what the matrix\"\n),\nIntegerMatrix\n(\nmatrix\n,\ninclude_background_rectangle\n=\nTrue\n),\nText\n(\n\"looks like\"\n)\n)\nlinear_transform_words\n.\narrange\n(\nRIGHT\n)\nlinear_transform_words\n.\nto_edge\n(\nUP\n)\nlinear_transform_words\n.\nset_stroke\n(\nBLACK\n,\n10\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nShowCreation\n(\ngrid\n),\nFadeTransform\n(\nintro_words\n,\nlinear_transform_words\n)\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_matrix\n(\nmatrix\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# Complex map\nc_grid\n=\nComplexPlane\n()\nmoving_c_grid\n=\nc_grid\n.\ncopy\n()\nmoving_c_grid\n.\nprepare_for_nonlinear_transform\n()\nc_grid\n.\nset_stroke\n(\nBLUE_E\n,\n1\n)\nc_grid\n.\nadd_coordinate_labels\n(\nfont_size\n=\n24\n)\ncomplex_map_words\n=\nTexText\n(\n\"\"\"\nOr thinking of the plane as $\n\\\\\nmathds\n{C}\n$,\n\\\\\\\\\nthis is the map $z\n\\\\\nrightarrow z^2$\n\"\"\"\n)\ncomplex_map_words\n.\nto_corner\n(\nUR\n)\ncomplex_map_words\n.\nset_stroke\n(\nBLACK\n,\n5\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nFadeOut\n(\ngrid\n),\nWrite\n(\nc_grid\n,\nrun_time\n=\n3\n),\nFadeIn\n(\nmoving_c_grid\n),\nFadeTransform\n(\nlinear_transform_words\n,\ncomplex_map_words\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nmoving_c_grid\n.\nanimate\n.\napply_complex_function\n(\nlambda\nz\n:\nz\n**\n2\n),\nrun_time\n=\n6\n,\n)\nself\n.\nwait\n(\n2\n)\nThis scene is a comprehensive application of a two-dimensional scene.\nAfter seeing these scenes, you have already understood part of the\nusage of manim. For more examples, see\nthe video code of 3b1b\n.\nContents\nExample Scenes\nInteractiveDevlopment\nAnimatingMethods\nTextExample\nTexTransformExample\nUpdatersExample\nCoordinateSystemExample\nGraphExample\nSurfaceExample\nOpeningManimExample",
    "code_examples": [
      "example_scenes.py",
      "from manimlib import *\n\nclass InteractiveDevelopment(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n\n        # This opens an iPython terminal where you can keep writing\n        # lines as if they were part of this construct method.\n        # In particular, 'square', 'circle' and 'self' will all be\n        # part of the local namespace in that terminal.\n        self.embed()\n\n        # Try copying and pasting some of the lines below into\n        # the interactive shell\n        self.play(ReplacementTransform(square, circle))\n        self.wait()\n        self.play(circle.animate.stretch(4, 0))\n        self.play(Rotate(circle, 90 * DEGREES))\n        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))\n\n        text = Text(\"\"\"\n            In general, using the interactive shell\n            is very helpful when developing new scenes\n        \"\"\")\n        self.play(Write(text))\n\n        # In the interactive shell, you can just type\n        # play, add, remove, clear, wait, save_state and restore,\n        # instead of self.play, self.add, self.remove, etc.\n\n        # To interact with the window, type touch().  You can then\n        # scroll in the window, or zoom by holding down 'z' while scrolling,\n        # and change camera perspective by holding down 'd' while moving\n        # the mouse.  Press 'r' to reset to the standard camera position.\n        # Press 'q' to stop interacting with the window and go back to\n        # typing new commands into the shell.\n\n        # In principle you can customize a scene to be responsive to\n        # mouse and keyboard interactions\n        always(circle.move_to, self.mouse_point)",
      "class AnimatingMethods(Scene):\n    def construct(self):\n        grid = OldTex(r\"\\pi\").get_grid(10, 10, height=4)\n        self.add(grid)\n\n        # You can animate the application of mobject methods with the\n        # \".animate\" syntax:\n        self.play(grid.animate.shift(LEFT))\n\n        # Alternatively, you can use the older syntax by passing the\n        # method and then the arguments to the scene's \"play\" function:\n        self.play(grid.shift, LEFT)\n\n        # Both of those will interpolate between the mobject's initial\n        # state and whatever happens when you apply that method.\n        # For this example, calling grid.shift(LEFT) would shift the\n        # grid one unit to the left, but both of the previous calls to\n        # \"self.play\" animate that motion.\n\n        # The same applies for any method, including those setting colors.\n        self.play(grid.animate.set_color(YELLOW))\n        self.wait()\n        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))\n        self.wait()\n        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))\n        self.wait()\n\n        # The method Mobject.apply_complex_function lets you apply arbitrary\n        # complex functions, treating the points defining the mobject as\n        # complex numbers.\n        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)\n        self.wait()\n\n        # Even more generally, you could apply Mobject.apply_function,\n        # which takes in functions form R^3 to R^3\n        self.play(\n            grid.animate.apply_function(\n                lambda p: [\n                    p[0] + 0.5 * math.sin(p[1]),\n                    p[1] + 0.5 * math.sin(p[0]),\n                    p[2]\n                ]\n            ),\n            run_time=5,\n        )\n        self.wait()",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      "class TextExample(Scene):\n    def construct(self):\n        # To run this scene properly, you should have \"Consolas\" font in your computer\n        # for full usage, you can see https://github.com/3b1b/manim/pull/680\n        text = Text(\"Here is a text\", font=\"Consolas\", font_size=90)\n        difference = Text(\n            \"\"\"\n            The most important difference between Text and TexText is that\\n\n            you can change the font more easily, but can't use the LaTeX grammar\n            \"\"\",\n            font=\"Arial\", font_size=24,\n            # t2c is a dict that you can choose color for different text\n            t2c={\"Text\": BLUE, \"TexText\": BLUE, \"LaTeX\": ORANGE}\n        )\n        VGroup(text, difference).arrange(DOWN, buff=1)\n        self.play(Write(text))\n        self.play(FadeIn(difference, UP))\n        self.wait(3)\n\n        fonts = Text(\n            \"And you can also set the font according to different words\",\n            font=\"Arial\",\n            t2f={\"font\": \"Consolas\", \"words\": \"Consolas\"},\n            t2c={\"font\": BLUE, \"words\": GREEN}\n        )\n        fonts.set_width(FRAME_WIDTH - 1)\n        slant = Text(\n            \"And the same as slant and weight\",\n            font=\"Consolas\",\n            t2s={\"slant\": ITALIC},\n            t2w={\"weight\": BOLD},\n            t2c={\"slant\": ORANGE, \"weight\": RED}\n        )\n        VGroup(fonts, slant).arrange(DOWN, buff=0.8)\n        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))\n        self.play(Write(fonts))\n        self.wait()\n        self.play(Write(slant))\n        self.wait()",
      "class TexTransformExample(Scene):\n    def construct(self):\n        to_isolate = [\"B\", \"C\", \"=\", \"(\", \")\"]\n        lines = VGroup(\n            # Passing in muliple arguments to Tex will result\n            # in the same expression as if those arguments had\n            # been joined together, except that the submobject\n            # hierarchy of the resulting mobject ensure that the\n            # Tex mobject has a subject corresponding to\n            # each of these strings.  For example, the Tex mobject\n            # below will have 5 subjects, corresponding to the\n            # expressions [A^2, +, B^2, =, C^2]\n            OldTex(\"A^2\", \"+\", \"B^2\", \"=\", \"C^2\"),\n            # Likewise here\n            OldTex(\"A^2\", \"=\", \"C^2\", \"-\", \"B^2\"),\n            # Alternatively, you can pass in the keyword argument\n            # \"isolate\" with a list of strings that should be out as\n            # their own submobject.  So the line below is equivalent\n            # to the commented out line below it.\n            OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A^2\", *to_isolate]),\n            # OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\n            OldTex(\"A = \\\\sqrt{(C + B)(C - B)}\", isolate=[\"A\", *to_isolate])\n        )\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        for line in lines:\n            line.set_color_by_tex_to_color_map({\n                \"A\": BLUE,\n                \"B\": TEAL,\n                \"C\": GREEN,\n            })\n\n        play_kw = {\"run_time\": 2}\n        self.add(lines[0])\n        # The animation TransformMatchingTex will line up parts\n        # of the source and target which have matching tex strings.\n        # Here, giving it a little path_arc makes each part sort of\n        # rotate into their final positions, which feels appropriate\n        # for the idea of rearranging an equation\n        self.play(\n            TransformMatchingTex(\n                lines[0].copy(), lines[1],\n                path_arc=90 * DEGREES,\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # Now, we could try this again on the next line...\n        self.play(\n            TransformMatchingTex(lines[1].copy(), lines[2]),\n            **play_kw\n        )\n        self.wait()\n        # ...and this looks nice enough, but since there's no tex\n        # in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n        # out to nothing while the C and B terms fade in from nothing.\n        # If, however, we want the C^2 to go to C, and B^2 to go to B,\n        # we can specify that with a key map.\n        self.play(FadeOut(lines[2]))\n        self.play(\n            TransformMatchingTex(\n                lines[1].copy(), lines[2],\n                key_map={\n                    \"C^2\": \"C\",\n                    \"B^2\": \"B\",\n                }\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # And to finish off, a simple TransformMatchingShapes would work\n        # just fine.  But perhaps we want that exponent on A^2 to transform into\n        # the square root symbol.  At the moment, lines[2] treats the expression\n        # A^2 as a unit, so we might create a new version of the same line which\n        # separates out just the A.  This way, when TransformMatchingTex lines up\n        # all matching parts, the only mismatch will be between the \"^2\" from\n        # new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n        # transform_mismatches=True, it will transform this \"^2\" part into\n        # the \"\\sqrt\" part.\n        new_line2 = OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A\", *to_isolate])\n        new_line2.replace(lines[2])\n        new_line2.match_style(lines[2])\n\n        self.play(\n            TransformMatchingTex(\n                new_line2, lines[3],\n                transform_mismatches=True,\n            ),\n            **play_kw\n        )\n        self.wait(3)\n        self.play(FadeOut(lines, RIGHT))\n\n        # Alternatively, if you don't want to think about breaking up\n        # the tex strings deliberately, you can TransformMatchingShapes,\n        # which will try to line up all pieces of a source mobject with\n        # those of a target, regardless of the submobject hierarchy in\n        # each one, according to whether those pieces have the same\n        # shape (as best it can).\n        source = Text(\"the morse code\", height=1)\n        target = Text(\"here come dots\", height=1)\n\n        self.play(Write(source))\n        self.wait()\n        kw = {\"run_time\": 3, \"path_arc\": PI / 2}\n        self.play(TransformMatchingShapes(source, target, **kw))\n        self.wait()\n        self.play(TransformMatchingShapes(target, source, **kw))\n        self.wait()",
      "TransformMatchingTex",
      "TransformMatchingShapes",
      "TransformMatchingTeX",
      "TransformMatchingShapes",
      "class UpdatersExample(Scene):\n    def construct(self):\n        square = Square()\n        square.set_fill(BLUE_E, 1)\n\n        # On all all frames, the constructor Brace(square, UP) will\n        # be called, and the mobject brace will set its data to match\n        # that of the newly constructed object\n        brace = always_redraw(Brace, square, UP)\n\n        text, number = label = VGroup(\n            Text(\"Width = \"),\n            DecimalNumber(\n                0,\n                show_ellipsis=True,\n                num_decimal_places=2,\n                include_sign=True,\n            )\n        )\n        label.arrange(RIGHT)\n\n        # This ensures that the method deicmal.next_to(square)\n        # is called on every frame\n        always(label.next_to, brace, UP)\n        # You could also write the following equivalent line\n        # label.add_updater(lambda m: m.next_to(brace, UP))\n\n        # If the argument itself might change, you can use f_always,\n        # for which the arguments following the initial Mobject method\n        # should be functions returning arguments to that method.\n        # The following line ensures that decimal.set_value(square.get_y())\n        # is called every frame\n        f_always(number.set_value, square.get_width)\n        # You could also write the following equivalent line\n        # number.add_updater(lambda m: m.set_value(square.get_width()))\n\n        self.add(square, brace, label)\n\n        # Notice that the brace and label track with the square\n        self.play(\n            square.animate.scale(2),\n            rate_func=there_and_back,\n            run_time=2,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(5, stretch=True),\n            run_time=3,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(2),\n            run_time=3\n        )\n        self.wait()\n\n        # In general, you can alway call Mobject.add_updater, and pass in\n        # a function that you want to be called on every frame.  The function\n        # should take in either one argument, the mobject, or two arguments,\n        # the mobject and the amount of time since the last frame.\n        now = self.time\n        w0 = square.get_width()\n        square.add_updater(\n            lambda m: m.set_width(w0 * math.cos(self.time - now))\n        )\n        self.wait(4 * PI)",
      "always_redraw()",
      "DecimalNumber",
      ".add_updater()",
      "always_redraw()",
      "DecimalNumber",
      "always(f, x)",
      "f_always(f, g)",
      ".add_updater()",
      "mob1.add_updater(lambda mob: mob.next_to(mob2))",
      "mob1.next_to(mob2)",
      "class CoordinateSystemExample(Scene):\n    def construct(self):\n        axes = Axes(\n            # x-axis ranges from -1 to 10, with a default step size of 1\n            x_range=(-1, 10),\n            # y-axis ranges from -2 to 2 with a step size of 0.5\n            y_range=(-2, 2, 0.5),\n            # The axes will be stretched so as to match the specified\n            # height and width\n            height=6,\n            width=10,\n            # Axes is made of two NumberLine mobjects.  You can specify\n            # their configuration with axis_config\n            axis_config={\n                \"stroke_color\": GREY_A,\n                \"stroke_width\": 2,\n            },\n            # Alternatively, you can specify configuration for just one\n            # of them, like this.\n            y_axis_config={\n                \"include_tip\": False,\n            }\n        )\n        # Keyword arguments of add_coordinate_labels can be used to\n        # configure the DecimalNumber mobjects which it creates and\n        # adds to the axes\n        axes.add_coordinate_labels(\n            font_size=20,\n            num_decimal_places=1,\n        )\n        self.add(axes)\n\n        # Axes descends from the CoordinateSystem class, meaning\n        # you can call call axes.coords_to_point, abbreviated to\n        # axes.c2p, to associate a set of coordinates with a point,\n        # like so:\n        dot = Dot(color=RED)\n        dot.move_to(axes.c2p(0, 0))\n        self.play(FadeIn(dot, scale=0.5))\n        self.play(dot.animate.move_to(axes.c2p(3, 2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))\n        self.wait()\n\n        # Similarly, you can call axes.point_to_coords, or axes.p2c\n        # print(axes.p2c(dot.get_center()))\n\n        # We can draw lines from the axes to better mark the coordinates\n        # of a given point.\n        # Here, the always_redraw command means that on each new frame\n        # the lines will be redrawn\n        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))\n        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))\n\n        self.play(\n            ShowCreation(h_line),\n            ShowCreation(v_line),\n        )\n        self.play(dot.animate.move_to(axes.c2p(3, -2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(1, 1)))\n        self.wait()\n\n        # If we tie the dot to a particular set of coordinates, notice\n        # that as we move the axes around it respects the coordinate\n        # system defined by them.\n        f_always(dot.move_to, lambda: axes.c2p(1, 1))\n        self.play(\n            axes.animate.scale(0.75).to_corner(UL),\n            run_time=2,\n        )\n        self.wait()\n        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))\n\n        # Other coordinate systems you can play around with include\n        # ThreeDAxes, NumberPlane, and ComplexPlane.",
      "class GraphExample(Scene):\n    def construct(self):\n        axes = Axes((-3, 10), (-1, 8))\n        axes.add_coordinate_labels()\n\n        self.play(Write(axes, lag_ratio=0.01, run_time=1))\n\n        # Axes.get_graph will return the graph of a function\n        sin_graph = axes.get_graph(\n            lambda x: 2 * math.sin(x),\n            color=BLUE,\n        )\n        # By default, it draws it so as to somewhat smoothly interpolate\n        # between sampled points (x, f(x)).  If the graph is meant to have\n        # a corner, though, you can set use_smoothing to False\n        relu_graph = axes.get_graph(\n            lambda x: max(x, 0),\n            use_smoothing=False,\n            color=YELLOW,\n        )\n        # For discontinuous functions, you can specify the point of\n        # discontinuity so that it does not try to draw over the gap.\n        step_graph = axes.get_graph(\n            lambda x: 2.0 if x > 3 else 1.0,\n            discontinuities=[3],\n            color=GREEN,\n        )\n\n        # Axes.get_graph_label takes in either a string or a mobject.\n        # If it's a string, it treats it as a LaTeX expression.  By default\n        # it places the label next to the graph near the right side, and\n        # has it match the color of the graph\n        sin_label = axes.get_graph_label(sin_graph, \"\\\\sin(x)\")\n        relu_label = axes.get_graph_label(relu_graph, Text(\"ReLU\"))\n        step_label = axes.get_graph_label(step_graph, Text(\"Step\"), x=4)\n\n        self.play(\n            ShowCreation(sin_graph),\n            FadeIn(sin_label, RIGHT),\n        )\n        self.wait(2)\n        self.play(\n            ReplacementTransform(sin_graph, relu_graph),\n            FadeTransform(sin_label, relu_label),\n        )\n        self.wait()\n        self.play(\n            ReplacementTransform(relu_graph, step_graph),\n            FadeTransform(relu_label, step_label),\n        )\n        self.wait()\n\n        parabola = axes.get_graph(lambda x: 0.25 * x**2)\n        parabola.set_stroke(BLUE)\n        self.play(\n            FadeOut(step_graph),\n            FadeOut(step_label),\n            ShowCreation(parabola)\n        )\n        self.wait()\n\n        # You can use axes.input_to_graph_point, abbreviated\n        # to axes.i2gp, to find a particular point on a graph\n        dot = Dot(color=RED)\n        dot.move_to(axes.i2gp(2, parabola))\n        self.play(FadeIn(dot, scale=0.5))\n\n        # A value tracker lets us animate a parameter, usually\n        # with the intent of having other mobjects update based\n        # on the parameter\n        x_tracker = ValueTracker(2)\n        f_always(\n            dot.move_to,\n            lambda: axes.i2gp(x_tracker.get_value(), parabola)\n        )\n\n        self.play(x_tracker.animate.set_value(4), run_time=3)\n        self.play(x_tracker.animate.set_value(-2), run_time=3)\n        self.wait()",
      "class SurfaceExample(Scene):\n    CONFIG = {\n        \"camera_class\": ThreeDCamera,\n    }\n\n    def construct(self):\n        surface_text = Text(\"For 3d scenes, try using surfaces\")\n        surface_text.fix_in_frame()\n        surface_text.to_edge(UP)\n        self.add(surface_text)\n        self.wait(0.1)\n\n        torus1 = Torus(r1=1, r2=1)\n        torus2 = Torus(r1=3, r2=1)\n        sphere = Sphere(radius=3, resolution=torus1.resolution)\n        # You can texture a surface with up to two images, which will\n        # be interpreted as the side towards the light, and away from\n        # the light.  These can be either urls, or paths to a local file\n        # in whatever you've set as the image directory in\n        # the custom_config.yml file\n\n        # day_texture = \"EarthTextureMap\"\n        # night_texture = \"NightEarthTextureMap\"\n        day_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\n        night_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\n\n        surfaces = [\n            TexturedSurface(surface, day_texture, night_texture)\n            for surface in [sphere, torus1, torus2]\n        ]\n\n        for mob in surfaces:\n            mob.shift(IN)\n            mob.mesh = SurfaceMesh(mob)\n            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)\n\n        # Set perspective\n        frame = self.camera.frame\n        frame.set_euler_angles(\n            theta=-30 * DEGREES,\n            phi=70 * DEGREES,\n        )\n\n        surface = surfaces[0]\n\n        self.play(\n            FadeIn(surface),\n            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),\n        )\n        for mob in surfaces:\n            mob.add(mob.mesh)\n        surface.save_state()\n        self.play(Rotate(surface, PI / 2), run_time=2)\n        for mob in surfaces[1:]:\n            mob.rotate(PI / 2)\n\n        self.play(\n            Transform(surface, surfaces[1]),\n            run_time=3\n        )\n\n        self.play(\n            Transform(surface, surfaces[2]),\n            # Move camera frame during the transition\n            frame.animate.increment_phi(-10 * DEGREES),\n            frame.animate.increment_theta(-20 * DEGREES),\n            run_time=3\n        )\n        # Add ambient rotation\n        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))\n\n        # Play around with where the light is\n        light_text = Text(\"You can move around the light source\")\n        light_text.move_to(surface_text)\n        light_text.fix_in_frame()\n\n        self.play(FadeTransform(surface_text, light_text))\n        light = self.camera.light_source\n        self.add(light)\n        light.save_state()\n        self.play(light.animate.move_to(3 * IN), run_time=5)\n        self.play(light.animate.shift(10 * OUT), run_time=5)\n\n        drag_text = Text(\"Try moving the mouse while pressing d or s\")\n        drag_text.move_to(light_text)\n        drag_text.fix_in_frame()\n\n        self.play(FadeTransform(light_text, drag_text))\n        self.wait()",
      ".fix_in_frame()",
      "class OpeningManimExample(Scene):\n    def construct(self):\n        intro_words = Text(\"\"\"\n            The original motivation for manim was to\n            better illustrate mathematical functions\n            as transformations.\n        \"\"\")\n        intro_words.to_edge(UP)\n\n        self.play(Write(intro_words))\n        self.wait(2)\n\n        # Linear transform\n        grid = NumberPlane((-10, 10), (-5, 5))\n        matrix = [[1, 1], [0, 1]]\n        linear_transform_words = VGroup(\n            Text(\"This is what the matrix\"),\n            IntegerMatrix(matrix, include_background_rectangle=True),\n            Text(\"looks like\")\n        )\n        linear_transform_words.arrange(RIGHT)\n        linear_transform_words.to_edge(UP)\n        linear_transform_words.set_stroke(BLACK, 10, background=True)\n\n        self.play(\n            ShowCreation(grid),\n            FadeTransform(intro_words, linear_transform_words)\n        )\n        self.wait()\n        self.play(grid.animate.apply_matrix(matrix), run_time=3)\n        self.wait()\n\n        # Complex map\n        c_grid = ComplexPlane()\n        moving_c_grid = c_grid.copy()\n        moving_c_grid.prepare_for_nonlinear_transform()\n        c_grid.set_stroke(BLUE_E, 1)\n        c_grid.add_coordinate_labels(font_size=24)\n        complex_map_words = TexText(\"\"\"\n            Or thinking of the plane as $\\\\mathds{C}$,\\\\\\\\\n            this is the map $z \\\\rightarrow z^2$\n        \"\"\")\n        complex_map_words.to_corner(UR)\n        complex_map_words.set_stroke(BLACK, 5, background=True)\n\n        self.play(\n            FadeOut(grid),\n            Write(c_grid, run_time=3),\n            FadeIn(moving_c_grid),\n            FadeTransform(linear_transform_words, complex_map_words),\n        )\n        self.wait()\n        self.play(\n            moving_c_grid.animate.apply_complex_function(lambda z: z**2),\n            run_time=6,\n        )\n        self.wait(2)"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#example-scenes",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevelopment",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample"
    ],
    "scraped_at": 1752428846.476583
  },
  "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample": {
    "url": "https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample",
    "title": "Example Scenes - manim  documentation",
    "content": "Example Scenes\n¶\nAfter understanding the previous knowledge, we can understand more scenes.\nMany example scenes are given in\nexample_scenes.py\n, let’s start with\nthe simplest and one by one.\nInteractiveDevlopment\n¶\nInteractiveDevelopment\n¶\nfrom\nmanimlib\nimport\n*\nclass\nInteractiveDevelopment\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nsquare\n=\nSquare\n()\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nself\n.\nwait\n()\n# This opens an iPython terminal where you can keep writing\n# lines as if they were part of this construct method.\n# In particular, 'square', 'circle' and 'self' will all be\n# part of the local namespace in that terminal.\nself\n.\nembed\n()\n# Try copying and pasting some of the lines below into\n# the interactive shell\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nstretch\n(\n4\n,\n0\n))\nself\n.\nplay\n(\nRotate\n(\ncircle\n,\n90\n*\nDEGREES\n))\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nshift\n(\n2\n*\nRIGHT\n)\n.\nscale\n(\n0.25\n))\ntext\n=\nText\n(\n\"\"\"\nIn general, using the interactive shell\nis very helpful when developing new scenes\n\"\"\"\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\n# In the interactive shell, you can just type\n# play, add, remove, clear, wait, save_state and restore,\n# instead of self.play, self.add, self.remove, etc.\n# To interact with the window, type touch().  You can then\n# scroll in the window, or zoom by holding down 'z' while scrolling,\n# and change camera perspective by holding down 'd' while moving\n# the mouse.  Press 'r' to reset to the standard camera position.\n# Press 'q' to stop interacting with the window and go back to\n# typing new commands into the shell.\n# In principle you can customize a scene to be responsive to\n# mouse and keyboard interactions\nalways\n(\ncircle\n.\nmove_to\n,\nself\n.\nmouse_point\n)\nThis scene is similar to what we wrote in\nQuick Start\n.\nAnd how to interact has been written in the comments.\nNo more explanation here.\nAnimatingMethods\n¶\nAnimatingMethods\n¶\nclass\nAnimatingMethods\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ngrid\n=\nOldTex\n(\nr\n\"\\pi\"\n)\n.\nget_grid\n(\n10\n,\n10\n,\nheight\n=\n4\n)\nself\n.\nadd\n(\ngrid\n)\n# You can animate the application of mobject methods with the\n# \".animate\" syntax:\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nshift\n(\nLEFT\n))\n# Alternatively, you can use the older syntax by passing the\n# method and then the arguments to the scene's \"play\" function:\nself\n.\nplay\n(\ngrid\n.\nshift\n,\nLEFT\n)\n# Both of those will interpolate between the mobject's initial\n# state and whatever happens when you apply that method.\n# For this example, calling grid.shift(LEFT) would shift the\n# grid one unit to the left, but both of the previous calls to\n# \"self.play\" animate that motion.\n# The same applies for any method, including those setting colors.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_color\n(\nYELLOW\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_submobject_colors_by_gradient\n(\nBLUE\n,\nGREEN\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_height\n(\nTAU\n-\nMED_SMALL_BUFF\n))\nself\n.\nwait\n()\n# The method Mobject.apply_complex_function lets you apply arbitrary\n# complex functions, treating the points defining the mobject as\n# complex numbers.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_complex_function\n(\nnp\n.\nexp\n),\nrun_time\n=\n5\n)\nself\n.\nwait\n()\n# Even more generally, you could apply Mobject.apply_function,\n# which takes in functions form R^3 to R^3\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_function\n(\nlambda\np\n:\n[\np\n[\n0\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n1\n]),\np\n[\n1\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n0\n]),\np\n[\n2\n]\n]\n),\nrun_time\n=\n5\n,\n)\nself\n.\nwait\n()\nThe new usage in this scene is\n.get_grid()\nand\nself.play(mob.animate.method(args))\n.\n.get_grid()\nmethod will return a new mobject containing multiple copies of this one arranged in a grid.\nself.play(mob.animate.method(args))\nanimates the method, and the details are in the comments above.\nTextExample\n¶\nTextExample\n¶\nclass\nTextExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\n# To run this scene properly, you should have \"Consolas\" font in your computer\n# for full usage, you can see https://github.com/3b1b/manim/pull/680\ntext\n=\nText\n(\n\"Here is a text\"\n,\nfont\n=\n\"Consolas\"\n,\nfont_size\n=\n90\n)\ndifference\n=\nText\n(\n\"\"\"\nThe most important difference between Text and TexText is that\\n\nyou can change the font more easily, but can't use the LaTeX grammar\n\"\"\"\n,\nfont\n=\n\"Arial\"\n,\nfont_size\n=\n24\n,\n# t2c is a dict that you can choose color for different text\nt2c\n=\n{\n\"Text\"\n:\nBLUE\n,\n\"TexText\"\n:\nBLUE\n,\n\"LaTeX\"\n:\nORANGE\n}\n)\nVGroup\n(\ntext\n,\ndifference\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\nself\n.\nplay\n(\nFadeIn\n(\ndifference\n,\nUP\n))\nself\n.\nwait\n(\n3\n)\nfonts\n=\nText\n(\n\"And you can also set the font according to different words\"\n,\nfont\n=\n\"Arial\"\n,\nt2f\n=\n{\n\"font\"\n:\n\"Consolas\"\n,\n\"words\"\n:\n\"Consolas\"\n},\nt2c\n=\n{\n\"font\"\n:\nBLUE\n,\n\"words\"\n:\nGREEN\n}\n)\nfonts\n.\nset_width\n(\nFRAME_WIDTH\n-\n1\n)\nslant\n=\nText\n(\n\"And the same as slant and weight\"\n,\nfont\n=\n\"Consolas\"\n,\nt2s\n=\n{\n\"slant\"\n:\nITALIC\n},\nt2w\n=\n{\n\"weight\"\n:\nBOLD\n},\nt2c\n=\n{\n\"slant\"\n:\nORANGE\n,\n\"weight\"\n:\nRED\n}\n)\nVGroup\n(\nfonts\n,\nslant\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n0.8\n)\nself\n.\nplay\n(\nFadeOut\n(\ntext\n),\nFadeOut\n(\ndifference\n,\nshift\n=\nDOWN\n))\nself\n.\nplay\n(\nWrite\n(\nfonts\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nWrite\n(\nslant\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nText\n,\nVGroup\n,\nWrite\n,\nFadeIn\nand\nFadeOut\n.\nText\ncan create text, define fonts, etc. The usage ais clearly reflected in the above examples.\nVGroup\ncan put multiple\nVMobject\ntogether as a whole. In the example, the\n.arrange()\nmethod is called to arrange the sub-mobjects in sequence downward (\nDOWN\n), and the spacing is\nbuff\n.\nWrite\nis an animation that shows similar writing effects.\nFadeIn\nfades the object in, the second parameter indicates the direction of the fade in.\nFadeOut\nfades out the object, the second parameter indicates the direction of the fade out.\nTexTransformExample\n¶\nTexTransformExample\n¶\nclass\nTexTransformExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nto_isolate\n=\n[\n\"B\"\n,\n\"C\"\n,\n\"=\"\n,\n\"(\"\n,\n\")\"\n]\nlines\n=\nVGroup\n(\n# Passing in muliple arguments to Tex will result\n# in the same expression as if those arguments had\n# been joined together, except that the submobject\n# hierarchy of the resulting mobject ensure that the\n# Tex mobject has a subject corresponding to\n# each of these strings.  For example, the Tex mobject\n# below will have 5 subjects, corresponding to the\n# expressions [A^2, +, B^2, =, C^2]\nOldTex\n(\n\"A^2\"\n,\n\"+\"\n,\n\"B^2\"\n,\n\"=\"\n,\n\"C^2\"\n),\n# Likewise here\nOldTex\n(\n\"A^2\"\n,\n\"=\"\n,\n\"C^2\"\n,\n\"-\"\n,\n\"B^2\"\n),\n# Alternatively, you can pass in the keyword argument\n# \"isolate\" with a list of strings that should be out as\n# their own submobject.  So the line below is equivalent\n# to the commented out line below it.\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A^2\"\n,\n*\nto_isolate\n]),\n# OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\nOldTex\n(\n\"A =\n\\\\\nsqrt{(C + B)(C - B)}\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\n)\nlines\n.\narrange\n(\nDOWN\n,\nbuff\n=\nLARGE_BUFF\n)\nfor\nline\nin\nlines\n:\nline\n.\nset_color_by_tex_to_color_map\n({\n\"A\"\n:\nBLUE\n,\n\"B\"\n:\nTEAL\n,\n\"C\"\n:\nGREEN\n,\n})\nplay_kw\n=\n{\n\"run_time\"\n:\n2\n}\nself\n.\nadd\n(\nlines\n[\n0\n])\n# The animation TransformMatchingTex will line up parts\n# of the source and target which have matching tex strings.\n# Here, giving it a little path_arc makes each part sort of\n# rotate into their final positions, which feels appropriate\n# for the idea of rearranging an equation\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n0\n]\n.\ncopy\n(),\nlines\n[\n1\n],\npath_arc\n=\n90\n*\nDEGREES\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# Now, we could try this again on the next line...\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n]),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# ...and this looks nice enough, but since there's no tex\n# in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n# out to nothing while the C and B terms fade in from nothing.\n# If, however, we want the C^2 to go to C, and B^2 to go to B,\n# we can specify that with a key map.\nself\n.\nplay\n(\nFadeOut\n(\nlines\n[\n2\n]))\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n],\nkey_map\n=\n{\n\"C^2\"\n:\n\"C\"\n,\n\"B^2\"\n:\n\"B\"\n,\n}\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# And to finish off, a simple TransformMatchingShapes would work\n# just fine.  But perhaps we want that exponent on A^2 to transform into\n# the square root symbol.  At the moment, lines[2] treats the expression\n# A^2 as a unit, so we might create a new version of the same line which\n# separates out just the A.  This way, when TransformMatchingTex lines up\n# all matching parts, the only mismatch will be between the \"^2\" from\n# new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n# transform_mismatches=True, it will transform this \"^2\" part into\n# the \"\\sqrt\" part.\nnew_line2\n=\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\nnew_line2\n.\nreplace\n(\nlines\n[\n2\n])\nnew_line2\n.\nmatch_style\n(\nlines\n[\n2\n])\nself\n.\nplay\n(\nTransformMatchingTex\n(\nnew_line2\n,\nlines\n[\n3\n],\ntransform_mismatches\n=\nTrue\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n(\n3\n)\nself\n.\nplay\n(\nFadeOut\n(\nlines\n,\nRIGHT\n))\n# Alternatively, if you don't want to think about breaking up\n# the tex strings deliberately, you can TransformMatchingShapes,\n# which will try to line up all pieces of a source mobject with\n# those of a target, regardless of the submobject hierarchy in\n# each one, according to whether those pieces have the same\n# shape (as best it can).\nsource\n=\nText\n(\n\"the morse code\"\n,\nheight\n=\n1\n)\ntarget\n=\nText\n(\n\"here come dots\"\n,\nheight\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\nsource\n))\nself\n.\nwait\n()\nkw\n=\n{\n\"run_time\"\n:\n3\n,\n\"path_arc\"\n:\nPI\n/\n2\n}\nself\n.\nplay\n(\nTransformMatchingShapes\n(\nsource\n,\ntarget\n,\n**\nkw\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nTransformMatchingShapes\n(\ntarget\n,\nsource\n,\n**\nkw\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nTex\n,\nTexText\n,\nTransformMatchingTex\nand\nTransformMatchingShapes\n.\nTex\nuses LaTeX to create mathematical formulas.\nTexText\nuses LaTeX to create text.\nTransformMatchingTeX\nautomatically transforms sub-objects according to the similarities and differences of tex in\nTex\n.\nTransformMatchingShapes\nautomatically transform sub-objects directly based on the similarities and differences of the object point sets.\nUpdatersExample\n¶\nUpdatersExample\n¶\nclass\nUpdatersExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nsquare\n=\nSquare\n()\nsquare\n.\nset_fill\n(\nBLUE_E\n,\n1\n)\n# On all all frames, the constructor Brace(square, UP) will\n# be called, and the mobject brace will set its data to match\n# that of the newly constructed object\nbrace\n=\nalways_redraw\n(\nBrace\n,\nsquare\n,\nUP\n)\ntext\n,\nnumber\n=\nlabel\n=\nVGroup\n(\nText\n(\n\"Width = \"\n),\nDecimalNumber\n(\n0\n,\nshow_ellipsis\n=\nTrue\n,\nnum_decimal_places\n=\n2\n,\ninclude_sign\n=\nTrue\n,\n)\n)\nlabel\n.\narrange\n(\nRIGHT\n)\n# This ensures that the method deicmal.next_to(square)\n# is called on every frame\nalways\n(\nlabel\n.\nnext_to\n,\nbrace\n,\nUP\n)\n# You could also write the following equivalent line\n# label.add_updater(lambda m: m.next_to(brace, UP))\n# If the argument itself might change, you can use f_always,\n# for which the arguments following the initial Mobject method\n# should be functions returning arguments to that method.\n# The following line ensures that decimal.set_value(square.get_y())\n# is called every frame\nf_always\n(\nnumber\n.\nset_value\n,\nsquare\n.\nget_width\n)\n# You could also write the following equivalent line\n# number.add_updater(lambda m: m.set_value(square.get_width()))\nself\n.\nadd\n(\nsquare\n,\nbrace\n,\nlabel\n)\n# Notice that the brace and label track with the square\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nscale\n(\n2\n),\nrate_func\n=\nthere_and_back\n,\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n5\n,\nstretch\n=\nTrue\n),\nrun_time\n=\n3\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# In general, you can alway call Mobject.add_updater, and pass in\n# a function that you want to be called on every frame.  The function\n# should take in either one argument, the mobject, or two arguments,\n# the mobject and the amount of time since the last frame.\nnow\n=\nself\n.\ntime\nw0\n=\nsquare\n.\nget_width\n()\nsquare\n.\nadd_updater\n(\nlambda\nm\n:\nm\n.\nset_width\n(\nw0\n*\nmath\n.\ncos\n(\nself\n.\ntime\n-\nnow\n))\n)\nself\n.\nwait\n(\n4\n*\nPI\n)\nThe new classes and usage in this scene are\nalways_redraw()\n,\nDecimalNumber\n,\n.to_edge()\n,\n.center()\n,\nalways()\n,\nf_always()\n,\n.set_y()\nand\n.add_updater()\n.\nalways_redraw()\nfunction create a new mobject every frame.\nDecimalNumber\nis a variable number, speed it up by breaking it into\nText\ncharacters.\n.to_edge()\nmeans to place the object on the edge of the screen.\n.center()\nmeans to place the object in the center of the screen.\nalways(f,\nx)\nmeans that a certain function (\nf(x)\n) is executed every frame.\nf_always(f,\ng)\nis similar to\nalways\n, executed\nf(g())\nevery frame.\n.set_y()\nmeans to set the ordinate of the object on the screen.\n.add_updater()\nsets an update function for the object. For example:\nmob1.add_updater(lambda\nmob:\nmob.next_to(mob2))\nmeans\nmob1.next_to(mob2)\nis executed every frame.\nCoordinateSystemExample\n¶\nCoordinateSystemExample\n¶\nclass\nCoordinateSystemExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n(\n# x-axis ranges from -1 to 10, with a default step size of 1\nx_range\n=\n(\n-\n1\n,\n10\n),\n# y-axis ranges from -2 to 2 with a step size of 0.5\ny_range\n=\n(\n-\n2\n,\n2\n,\n0.5\n),\n# The axes will be stretched so as to match the specified\n# height and width\nheight\n=\n6\n,\nwidth\n=\n10\n,\n# Axes is made of two NumberLine mobjects.  You can specify\n# their configuration with axis_config\naxis_config\n=\n{\n\"stroke_color\"\n:\nGREY_A\n,\n\"stroke_width\"\n:\n2\n,\n},\n# Alternatively, you can specify configuration for just one\n# of them, like this.\ny_axis_config\n=\n{\n\"include_tip\"\n:\nFalse\n,\n}\n)\n# Keyword arguments of add_coordinate_labels can be used to\n# configure the DecimalNumber mobjects which it creates and\n# adds to the axes\naxes\n.\nadd_coordinate_labels\n(\nfont_size\n=\n20\n,\nnum_decimal_places\n=\n1\n,\n)\nself\n.\nadd\n(\naxes\n)\n# Axes descends from the CoordinateSystem class, meaning\n# you can call call axes.coords_to_point, abbreviated to\n# axes.c2p, to associate a set of coordinates with a point,\n# like so:\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\nc2p\n(\n0\n,\n0\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n5\n,\n0.5\n)))\nself\n.\nwait\n()\n# Similarly, you can call axes.point_to_coords, or axes.p2c\n# print(axes.p2c(dot.get_center()))\n# We can draw lines from the axes to better mark the coordinates\n# of a given point.\n# Here, the always_redraw command means that on each new frame\n# the lines will be redrawn\nh_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_h_line\n(\ndot\n.\nget_left\n()))\nv_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_v_line\n(\ndot\n.\nget_bottom\n()))\nself\n.\nplay\n(\nShowCreation\n(\nh_line\n),\nShowCreation\n(\nv_line\n),\n)\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n-\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n1\n,\n1\n)))\nself\n.\nwait\n()\n# If we tie the dot to a particular set of coordinates, notice\n# that as we move the axes around it respects the coordinate\n# system defined by them.\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\nc2p\n(\n1\n,\n1\n))\nself\n.\nplay\n(\naxes\n.\nanimate\n.\nscale\n(\n0.75\n)\n.\nto_corner\n(\nUL\n),\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nFadeOut\n(\nVGroup\n(\naxes\n,\ndot\n,\nh_line\n,\nv_line\n)))\n# Other coordinate systems you can play around with include\n# ThreeDAxes, NumberPlane, and ComplexPlane.\nGraphExample\n¶\nGraphExample\n¶\nclass\nGraphExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n((\n-\n3\n,\n10\n),\n(\n-\n1\n,\n8\n))\naxes\n.\nadd_coordinate_labels\n()\nself\n.\nplay\n(\nWrite\n(\naxes\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n1\n))\n# Axes.get_graph will return the graph of a function\nsin_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2\n*\nmath\n.\nsin\n(\nx\n),\ncolor\n=\nBLUE\n,\n)\n# By default, it draws it so as to somewhat smoothly interpolate\n# between sampled points (x, f(x)).  If the graph is meant to have\n# a corner, though, you can set use_smoothing to False\nrelu_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\nmax\n(\nx\n,\n0\n),\nuse_smoothing\n=\nFalse\n,\ncolor\n=\nYELLOW\n,\n)\n# For discontinuous functions, you can specify the point of\n# discontinuity so that it does not try to draw over the gap.\nstep_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2.0\nif\nx\n>\n3\nelse\n1.0\n,\ndiscontinuities\n=\n[\n3\n],\ncolor\n=\nGREEN\n,\n)\n# Axes.get_graph_label takes in either a string or a mobject.\n# If it's a string, it treats it as a LaTeX expression.  By default\n# it places the label next to the graph near the right side, and\n# has it match the color of the graph\nsin_label\n=\naxes\n.\nget_graph_label\n(\nsin_graph\n,\n\"\n\\\\\nsin(x)\"\n)\nrelu_label\n=\naxes\n.\nget_graph_label\n(\nrelu_graph\n,\nText\n(\n\"ReLU\"\n))\nstep_label\n=\naxes\n.\nget_graph_label\n(\nstep_graph\n,\nText\n(\n\"Step\"\n),\nx\n=\n4\n)\nself\n.\nplay\n(\nShowCreation\n(\nsin_graph\n),\nFadeIn\n(\nsin_label\n,\nRIGHT\n),\n)\nself\n.\nwait\n(\n2\n)\nself\n.\nplay\n(\nReplacementTransform\n(\nsin_graph\n,\nrelu_graph\n),\nFadeTransform\n(\nsin_label\n,\nrelu_label\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nReplacementTransform\n(\nrelu_graph\n,\nstep_graph\n),\nFadeTransform\n(\nrelu_label\n,\nstep_label\n),\n)\nself\n.\nwait\n()\nparabola\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n0.25\n*\nx\n**\n2\n)\nparabola\n.\nset_stroke\n(\nBLUE\n)\nself\n.\nplay\n(\nFadeOut\n(\nstep_graph\n),\nFadeOut\n(\nstep_label\n),\nShowCreation\n(\nparabola\n)\n)\nself\n.\nwait\n()\n# You can use axes.input_to_graph_point, abbreviated\n# to axes.i2gp, to find a particular point on a graph\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\ni2gp\n(\n2\n,\nparabola\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\n# A value tracker lets us animate a parameter, usually\n# with the intent of having other mobjects update based\n# on the parameter\nx_tracker\n=\nValueTracker\n(\n2\n)\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\ni2gp\n(\nx_tracker\n.\nget_value\n(),\nparabola\n)\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n4\n),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n-\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\nSurfaceExample\n¶\nSurfaceExample\n¶\nclass\nSurfaceExample\n(\nScene\n):\nCONFIG\n=\n{\n\"camera_class\"\n:\nThreeDCamera\n,\n}\ndef\nconstruct\n(\nself\n):\nsurface_text\n=\nText\n(\n\"For 3d scenes, try using surfaces\"\n)\nsurface_text\n.\nfix_in_frame\n()\nsurface_text\n.\nto_edge\n(\nUP\n)\nself\n.\nadd\n(\nsurface_text\n)\nself\n.\nwait\n(\n0.1\n)\ntorus1\n=\nTorus\n(\nr1\n=\n1\n,\nr2\n=\n1\n)\ntorus2\n=\nTorus\n(\nr1\n=\n3\n,\nr2\n=\n1\n)\nsphere\n=\nSphere\n(\nradius\n=\n3\n,\nresolution\n=\ntorus1\n.\nresolution\n)\n# You can texture a surface with up to two images, which will\n# be interpreted as the side towards the light, and away from\n# the light.  These can be either urls, or paths to a local file\n# in whatever you've set as the image directory in\n# the custom_config.yml file\n# day_texture = \"EarthTextureMap\"\n# night_texture = \"NightEarthTextureMap\"\nday_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\nnight_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\nsurfaces\n=\n[\nTexturedSurface\n(\nsurface\n,\nday_texture\n,\nnight_texture\n)\nfor\nsurface\nin\n[\nsphere\n,\ntorus1\n,\ntorus2\n]\n]\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nshift\n(\nIN\n)\nmob\n.\nmesh\n=\nSurfaceMesh\n(\nmob\n)\nmob\n.\nmesh\n.\nset_stroke\n(\nBLUE\n,\n1\n,\nopacity\n=\n0.5\n)\n# Set perspective\nframe\n=\nself\n.\ncamera\n.\nframe\nframe\n.\nset_euler_angles\n(\ntheta\n=-\n30\n*\nDEGREES\n,\nphi\n=\n70\n*\nDEGREES\n,\n)\nsurface\n=\nsurfaces\n[\n0\n]\nself\n.\nplay\n(\nFadeIn\n(\nsurface\n),\nShowCreation\n(\nsurface\n.\nmesh\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n3\n),\n)\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nadd\n(\nmob\n.\nmesh\n)\nsurface\n.\nsave_state\n()\nself\n.\nplay\n(\nRotate\n(\nsurface\n,\nPI\n/\n2\n),\nrun_time\n=\n2\n)\nfor\nmob\nin\nsurfaces\n[\n1\n:]:\nmob\n.\nrotate\n(\nPI\n/\n2\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n1\n]),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n2\n]),\n# Move camera frame during the transition\nframe\n.\nanimate\n.\nincrement_phi\n(\n-\n10\n*\nDEGREES\n),\nframe\n.\nanimate\n.\nincrement_theta\n(\n-\n20\n*\nDEGREES\n),\nrun_time\n=\n3\n)\n# Add ambient rotation\nframe\n.\nadd_updater\n(\nlambda\nm\n,\ndt\n:\nm\n.\nincrement_theta\n(\n-\n0.1\n*\ndt\n))\n# Play around with where the light is\nlight_text\n=\nText\n(\n\"You can move around the light source\"\n)\nlight_text\n.\nmove_to\n(\nsurface_text\n)\nlight_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nsurface_text\n,\nlight_text\n))\nlight\n=\nself\n.\ncamera\n.\nlight_source\nself\n.\nadd\n(\nlight\n)\nlight\n.\nsave_state\n()\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nmove_to\n(\n3\n*\nIN\n),\nrun_time\n=\n5\n)\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nshift\n(\n10\n*\nOUT\n),\nrun_time\n=\n5\n)\ndrag_text\n=\nText\n(\n\"Try moving the mouse while pressing d or s\"\n)\ndrag_text\n.\nmove_to\n(\nlight_text\n)\ndrag_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nlight_text\n,\ndrag_text\n))\nself\n.\nwait\n()\nThis scene shows an example of using a three-dimensional surface, and\nthe related usage has been briefly described in the notes.\n.fix_in_frame()\nmakes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.\nOpeningManimExample\n¶\nOpeningManimExample\n¶\nclass\nOpeningManimExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nintro_words\n=\nText\n(\n\"\"\"\nThe original motivation for manim was to\nbetter illustrate mathematical functions\nas transformations.\n\"\"\"\n)\nintro_words\n.\nto_edge\n(\nUP\n)\nself\n.\nplay\n(\nWrite\n(\nintro_words\n))\nself\n.\nwait\n(\n2\n)\n# Linear transform\ngrid\n=\nNumberPlane\n((\n-\n10\n,\n10\n),\n(\n-\n5\n,\n5\n))\nmatrix\n=\n[[\n1\n,\n1\n],\n[\n0\n,\n1\n]]\nlinear_transform_words\n=\nVGroup\n(\nText\n(\n\"This is what the matrix\"\n),\nIntegerMatrix\n(\nmatrix\n,\ninclude_background_rectangle\n=\nTrue\n),\nText\n(\n\"looks like\"\n)\n)\nlinear_transform_words\n.\narrange\n(\nRIGHT\n)\nlinear_transform_words\n.\nto_edge\n(\nUP\n)\nlinear_transform_words\n.\nset_stroke\n(\nBLACK\n,\n10\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nShowCreation\n(\ngrid\n),\nFadeTransform\n(\nintro_words\n,\nlinear_transform_words\n)\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_matrix\n(\nmatrix\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# Complex map\nc_grid\n=\nComplexPlane\n()\nmoving_c_grid\n=\nc_grid\n.\ncopy\n()\nmoving_c_grid\n.\nprepare_for_nonlinear_transform\n()\nc_grid\n.\nset_stroke\n(\nBLUE_E\n,\n1\n)\nc_grid\n.\nadd_coordinate_labels\n(\nfont_size\n=\n24\n)\ncomplex_map_words\n=\nTexText\n(\n\"\"\"\nOr thinking of the plane as $\n\\\\\nmathds\n{C}\n$,\n\\\\\\\\\nthis is the map $z\n\\\\\nrightarrow z^2$\n\"\"\"\n)\ncomplex_map_words\n.\nto_corner\n(\nUR\n)\ncomplex_map_words\n.\nset_stroke\n(\nBLACK\n,\n5\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nFadeOut\n(\ngrid\n),\nWrite\n(\nc_grid\n,\nrun_time\n=\n3\n),\nFadeIn\n(\nmoving_c_grid\n),\nFadeTransform\n(\nlinear_transform_words\n,\ncomplex_map_words\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nmoving_c_grid\n.\nanimate\n.\napply_complex_function\n(\nlambda\nz\n:\nz\n**\n2\n),\nrun_time\n=\n6\n,\n)\nself\n.\nwait\n(\n2\n)\nThis scene is a comprehensive application of a two-dimensional scene.\nAfter seeing these scenes, you have already understood part of the\nusage of manim. For more examples, see\nthe video code of 3b1b\n.\nContents\nExample Scenes\nInteractiveDevlopment\nAnimatingMethods\nTextExample\nTexTransformExample\nUpdatersExample\nCoordinateSystemExample\nGraphExample\nSurfaceExample\nOpeningManimExample",
    "code_examples": [
      "example_scenes.py",
      "from manimlib import *\n\nclass InteractiveDevelopment(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n\n        # This opens an iPython terminal where you can keep writing\n        # lines as if they were part of this construct method.\n        # In particular, 'square', 'circle' and 'self' will all be\n        # part of the local namespace in that terminal.\n        self.embed()\n\n        # Try copying and pasting some of the lines below into\n        # the interactive shell\n        self.play(ReplacementTransform(square, circle))\n        self.wait()\n        self.play(circle.animate.stretch(4, 0))\n        self.play(Rotate(circle, 90 * DEGREES))\n        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))\n\n        text = Text(\"\"\"\n            In general, using the interactive shell\n            is very helpful when developing new scenes\n        \"\"\")\n        self.play(Write(text))\n\n        # In the interactive shell, you can just type\n        # play, add, remove, clear, wait, save_state and restore,\n        # instead of self.play, self.add, self.remove, etc.\n\n        # To interact with the window, type touch().  You can then\n        # scroll in the window, or zoom by holding down 'z' while scrolling,\n        # and change camera perspective by holding down 'd' while moving\n        # the mouse.  Press 'r' to reset to the standard camera position.\n        # Press 'q' to stop interacting with the window and go back to\n        # typing new commands into the shell.\n\n        # In principle you can customize a scene to be responsive to\n        # mouse and keyboard interactions\n        always(circle.move_to, self.mouse_point)",
      "class AnimatingMethods(Scene):\n    def construct(self):\n        grid = OldTex(r\"\\pi\").get_grid(10, 10, height=4)\n        self.add(grid)\n\n        # You can animate the application of mobject methods with the\n        # \".animate\" syntax:\n        self.play(grid.animate.shift(LEFT))\n\n        # Alternatively, you can use the older syntax by passing the\n        # method and then the arguments to the scene's \"play\" function:\n        self.play(grid.shift, LEFT)\n\n        # Both of those will interpolate between the mobject's initial\n        # state and whatever happens when you apply that method.\n        # For this example, calling grid.shift(LEFT) would shift the\n        # grid one unit to the left, but both of the previous calls to\n        # \"self.play\" animate that motion.\n\n        # The same applies for any method, including those setting colors.\n        self.play(grid.animate.set_color(YELLOW))\n        self.wait()\n        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))\n        self.wait()\n        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))\n        self.wait()\n\n        # The method Mobject.apply_complex_function lets you apply arbitrary\n        # complex functions, treating the points defining the mobject as\n        # complex numbers.\n        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)\n        self.wait()\n\n        # Even more generally, you could apply Mobject.apply_function,\n        # which takes in functions form R^3 to R^3\n        self.play(\n            grid.animate.apply_function(\n                lambda p: [\n                    p[0] + 0.5 * math.sin(p[1]),\n                    p[1] + 0.5 * math.sin(p[0]),\n                    p[2]\n                ]\n            ),\n            run_time=5,\n        )\n        self.wait()",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      "class TextExample(Scene):\n    def construct(self):\n        # To run this scene properly, you should have \"Consolas\" font in your computer\n        # for full usage, you can see https://github.com/3b1b/manim/pull/680\n        text = Text(\"Here is a text\", font=\"Consolas\", font_size=90)\n        difference = Text(\n            \"\"\"\n            The most important difference between Text and TexText is that\\n\n            you can change the font more easily, but can't use the LaTeX grammar\n            \"\"\",\n            font=\"Arial\", font_size=24,\n            # t2c is a dict that you can choose color for different text\n            t2c={\"Text\": BLUE, \"TexText\": BLUE, \"LaTeX\": ORANGE}\n        )\n        VGroup(text, difference).arrange(DOWN, buff=1)\n        self.play(Write(text))\n        self.play(FadeIn(difference, UP))\n        self.wait(3)\n\n        fonts = Text(\n            \"And you can also set the font according to different words\",\n            font=\"Arial\",\n            t2f={\"font\": \"Consolas\", \"words\": \"Consolas\"},\n            t2c={\"font\": BLUE, \"words\": GREEN}\n        )\n        fonts.set_width(FRAME_WIDTH - 1)\n        slant = Text(\n            \"And the same as slant and weight\",\n            font=\"Consolas\",\n            t2s={\"slant\": ITALIC},\n            t2w={\"weight\": BOLD},\n            t2c={\"slant\": ORANGE, \"weight\": RED}\n        )\n        VGroup(fonts, slant).arrange(DOWN, buff=0.8)\n        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))\n        self.play(Write(fonts))\n        self.wait()\n        self.play(Write(slant))\n        self.wait()",
      "class TexTransformExample(Scene):\n    def construct(self):\n        to_isolate = [\"B\", \"C\", \"=\", \"(\", \")\"]\n        lines = VGroup(\n            # Passing in muliple arguments to Tex will result\n            # in the same expression as if those arguments had\n            # been joined together, except that the submobject\n            # hierarchy of the resulting mobject ensure that the\n            # Tex mobject has a subject corresponding to\n            # each of these strings.  For example, the Tex mobject\n            # below will have 5 subjects, corresponding to the\n            # expressions [A^2, +, B^2, =, C^2]\n            OldTex(\"A^2\", \"+\", \"B^2\", \"=\", \"C^2\"),\n            # Likewise here\n            OldTex(\"A^2\", \"=\", \"C^2\", \"-\", \"B^2\"),\n            # Alternatively, you can pass in the keyword argument\n            # \"isolate\" with a list of strings that should be out as\n            # their own submobject.  So the line below is equivalent\n            # to the commented out line below it.\n            OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A^2\", *to_isolate]),\n            # OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\n            OldTex(\"A = \\\\sqrt{(C + B)(C - B)}\", isolate=[\"A\", *to_isolate])\n        )\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        for line in lines:\n            line.set_color_by_tex_to_color_map({\n                \"A\": BLUE,\n                \"B\": TEAL,\n                \"C\": GREEN,\n            })\n\n        play_kw = {\"run_time\": 2}\n        self.add(lines[0])\n        # The animation TransformMatchingTex will line up parts\n        # of the source and target which have matching tex strings.\n        # Here, giving it a little path_arc makes each part sort of\n        # rotate into their final positions, which feels appropriate\n        # for the idea of rearranging an equation\n        self.play(\n            TransformMatchingTex(\n                lines[0].copy(), lines[1],\n                path_arc=90 * DEGREES,\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # Now, we could try this again on the next line...\n        self.play(\n            TransformMatchingTex(lines[1].copy(), lines[2]),\n            **play_kw\n        )\n        self.wait()\n        # ...and this looks nice enough, but since there's no tex\n        # in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n        # out to nothing while the C and B terms fade in from nothing.\n        # If, however, we want the C^2 to go to C, and B^2 to go to B,\n        # we can specify that with a key map.\n        self.play(FadeOut(lines[2]))\n        self.play(\n            TransformMatchingTex(\n                lines[1].copy(), lines[2],\n                key_map={\n                    \"C^2\": \"C\",\n                    \"B^2\": \"B\",\n                }\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # And to finish off, a simple TransformMatchingShapes would work\n        # just fine.  But perhaps we want that exponent on A^2 to transform into\n        # the square root symbol.  At the moment, lines[2] treats the expression\n        # A^2 as a unit, so we might create a new version of the same line which\n        # separates out just the A.  This way, when TransformMatchingTex lines up\n        # all matching parts, the only mismatch will be between the \"^2\" from\n        # new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n        # transform_mismatches=True, it will transform this \"^2\" part into\n        # the \"\\sqrt\" part.\n        new_line2 = OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A\", *to_isolate])\n        new_line2.replace(lines[2])\n        new_line2.match_style(lines[2])\n\n        self.play(\n            TransformMatchingTex(\n                new_line2, lines[3],\n                transform_mismatches=True,\n            ),\n            **play_kw\n        )\n        self.wait(3)\n        self.play(FadeOut(lines, RIGHT))\n\n        # Alternatively, if you don't want to think about breaking up\n        # the tex strings deliberately, you can TransformMatchingShapes,\n        # which will try to line up all pieces of a source mobject with\n        # those of a target, regardless of the submobject hierarchy in\n        # each one, according to whether those pieces have the same\n        # shape (as best it can).\n        source = Text(\"the morse code\", height=1)\n        target = Text(\"here come dots\", height=1)\n\n        self.play(Write(source))\n        self.wait()\n        kw = {\"run_time\": 3, \"path_arc\": PI / 2}\n        self.play(TransformMatchingShapes(source, target, **kw))\n        self.wait()\n        self.play(TransformMatchingShapes(target, source, **kw))\n        self.wait()",
      "TransformMatchingTex",
      "TransformMatchingShapes",
      "TransformMatchingTeX",
      "TransformMatchingShapes",
      "class UpdatersExample(Scene):\n    def construct(self):\n        square = Square()\n        square.set_fill(BLUE_E, 1)\n\n        # On all all frames, the constructor Brace(square, UP) will\n        # be called, and the mobject brace will set its data to match\n        # that of the newly constructed object\n        brace = always_redraw(Brace, square, UP)\n\n        text, number = label = VGroup(\n            Text(\"Width = \"),\n            DecimalNumber(\n                0,\n                show_ellipsis=True,\n                num_decimal_places=2,\n                include_sign=True,\n            )\n        )\n        label.arrange(RIGHT)\n\n        # This ensures that the method deicmal.next_to(square)\n        # is called on every frame\n        always(label.next_to, brace, UP)\n        # You could also write the following equivalent line\n        # label.add_updater(lambda m: m.next_to(brace, UP))\n\n        # If the argument itself might change, you can use f_always,\n        # for which the arguments following the initial Mobject method\n        # should be functions returning arguments to that method.\n        # The following line ensures that decimal.set_value(square.get_y())\n        # is called every frame\n        f_always(number.set_value, square.get_width)\n        # You could also write the following equivalent line\n        # number.add_updater(lambda m: m.set_value(square.get_width()))\n\n        self.add(square, brace, label)\n\n        # Notice that the brace and label track with the square\n        self.play(\n            square.animate.scale(2),\n            rate_func=there_and_back,\n            run_time=2,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(5, stretch=True),\n            run_time=3,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(2),\n            run_time=3\n        )\n        self.wait()\n\n        # In general, you can alway call Mobject.add_updater, and pass in\n        # a function that you want to be called on every frame.  The function\n        # should take in either one argument, the mobject, or two arguments,\n        # the mobject and the amount of time since the last frame.\n        now = self.time\n        w0 = square.get_width()\n        square.add_updater(\n            lambda m: m.set_width(w0 * math.cos(self.time - now))\n        )\n        self.wait(4 * PI)",
      "always_redraw()",
      "DecimalNumber",
      ".add_updater()",
      "always_redraw()",
      "DecimalNumber",
      "always(f, x)",
      "f_always(f, g)",
      ".add_updater()",
      "mob1.add_updater(lambda mob: mob.next_to(mob2))",
      "mob1.next_to(mob2)",
      "class CoordinateSystemExample(Scene):\n    def construct(self):\n        axes = Axes(\n            # x-axis ranges from -1 to 10, with a default step size of 1\n            x_range=(-1, 10),\n            # y-axis ranges from -2 to 2 with a step size of 0.5\n            y_range=(-2, 2, 0.5),\n            # The axes will be stretched so as to match the specified\n            # height and width\n            height=6,\n            width=10,\n            # Axes is made of two NumberLine mobjects.  You can specify\n            # their configuration with axis_config\n            axis_config={\n                \"stroke_color\": GREY_A,\n                \"stroke_width\": 2,\n            },\n            # Alternatively, you can specify configuration for just one\n            # of them, like this.\n            y_axis_config={\n                \"include_tip\": False,\n            }\n        )\n        # Keyword arguments of add_coordinate_labels can be used to\n        # configure the DecimalNumber mobjects which it creates and\n        # adds to the axes\n        axes.add_coordinate_labels(\n            font_size=20,\n            num_decimal_places=1,\n        )\n        self.add(axes)\n\n        # Axes descends from the CoordinateSystem class, meaning\n        # you can call call axes.coords_to_point, abbreviated to\n        # axes.c2p, to associate a set of coordinates with a point,\n        # like so:\n        dot = Dot(color=RED)\n        dot.move_to(axes.c2p(0, 0))\n        self.play(FadeIn(dot, scale=0.5))\n        self.play(dot.animate.move_to(axes.c2p(3, 2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))\n        self.wait()\n\n        # Similarly, you can call axes.point_to_coords, or axes.p2c\n        # print(axes.p2c(dot.get_center()))\n\n        # We can draw lines from the axes to better mark the coordinates\n        # of a given point.\n        # Here, the always_redraw command means that on each new frame\n        # the lines will be redrawn\n        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))\n        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))\n\n        self.play(\n            ShowCreation(h_line),\n            ShowCreation(v_line),\n        )\n        self.play(dot.animate.move_to(axes.c2p(3, -2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(1, 1)))\n        self.wait()\n\n        # If we tie the dot to a particular set of coordinates, notice\n        # that as we move the axes around it respects the coordinate\n        # system defined by them.\n        f_always(dot.move_to, lambda: axes.c2p(1, 1))\n        self.play(\n            axes.animate.scale(0.75).to_corner(UL),\n            run_time=2,\n        )\n        self.wait()\n        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))\n\n        # Other coordinate systems you can play around with include\n        # ThreeDAxes, NumberPlane, and ComplexPlane.",
      "class GraphExample(Scene):\n    def construct(self):\n        axes = Axes((-3, 10), (-1, 8))\n        axes.add_coordinate_labels()\n\n        self.play(Write(axes, lag_ratio=0.01, run_time=1))\n\n        # Axes.get_graph will return the graph of a function\n        sin_graph = axes.get_graph(\n            lambda x: 2 * math.sin(x),\n            color=BLUE,\n        )\n        # By default, it draws it so as to somewhat smoothly interpolate\n        # between sampled points (x, f(x)).  If the graph is meant to have\n        # a corner, though, you can set use_smoothing to False\n        relu_graph = axes.get_graph(\n            lambda x: max(x, 0),\n            use_smoothing=False,\n            color=YELLOW,\n        )\n        # For discontinuous functions, you can specify the point of\n        # discontinuity so that it does not try to draw over the gap.\n        step_graph = axes.get_graph(\n            lambda x: 2.0 if x > 3 else 1.0,\n            discontinuities=[3],\n            color=GREEN,\n        )\n\n        # Axes.get_graph_label takes in either a string or a mobject.\n        # If it's a string, it treats it as a LaTeX expression.  By default\n        # it places the label next to the graph near the right side, and\n        # has it match the color of the graph\n        sin_label = axes.get_graph_label(sin_graph, \"\\\\sin(x)\")\n        relu_label = axes.get_graph_label(relu_graph, Text(\"ReLU\"))\n        step_label = axes.get_graph_label(step_graph, Text(\"Step\"), x=4)\n\n        self.play(\n            ShowCreation(sin_graph),\n            FadeIn(sin_label, RIGHT),\n        )\n        self.wait(2)\n        self.play(\n            ReplacementTransform(sin_graph, relu_graph),\n            FadeTransform(sin_label, relu_label),\n        )\n        self.wait()\n        self.play(\n            ReplacementTransform(relu_graph, step_graph),\n            FadeTransform(relu_label, step_label),\n        )\n        self.wait()\n\n        parabola = axes.get_graph(lambda x: 0.25 * x**2)\n        parabola.set_stroke(BLUE)\n        self.play(\n            FadeOut(step_graph),\n            FadeOut(step_label),\n            ShowCreation(parabola)\n        )\n        self.wait()\n\n        # You can use axes.input_to_graph_point, abbreviated\n        # to axes.i2gp, to find a particular point on a graph\n        dot = Dot(color=RED)\n        dot.move_to(axes.i2gp(2, parabola))\n        self.play(FadeIn(dot, scale=0.5))\n\n        # A value tracker lets us animate a parameter, usually\n        # with the intent of having other mobjects update based\n        # on the parameter\n        x_tracker = ValueTracker(2)\n        f_always(\n            dot.move_to,\n            lambda: axes.i2gp(x_tracker.get_value(), parabola)\n        )\n\n        self.play(x_tracker.animate.set_value(4), run_time=3)\n        self.play(x_tracker.animate.set_value(-2), run_time=3)\n        self.wait()",
      "class SurfaceExample(Scene):\n    CONFIG = {\n        \"camera_class\": ThreeDCamera,\n    }\n\n    def construct(self):\n        surface_text = Text(\"For 3d scenes, try using surfaces\")\n        surface_text.fix_in_frame()\n        surface_text.to_edge(UP)\n        self.add(surface_text)\n        self.wait(0.1)\n\n        torus1 = Torus(r1=1, r2=1)\n        torus2 = Torus(r1=3, r2=1)\n        sphere = Sphere(radius=3, resolution=torus1.resolution)\n        # You can texture a surface with up to two images, which will\n        # be interpreted as the side towards the light, and away from\n        # the light.  These can be either urls, or paths to a local file\n        # in whatever you've set as the image directory in\n        # the custom_config.yml file\n\n        # day_texture = \"EarthTextureMap\"\n        # night_texture = \"NightEarthTextureMap\"\n        day_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\n        night_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\n\n        surfaces = [\n            TexturedSurface(surface, day_texture, night_texture)\n            for surface in [sphere, torus1, torus2]\n        ]\n\n        for mob in surfaces:\n            mob.shift(IN)\n            mob.mesh = SurfaceMesh(mob)\n            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)\n\n        # Set perspective\n        frame = self.camera.frame\n        frame.set_euler_angles(\n            theta=-30 * DEGREES,\n            phi=70 * DEGREES,\n        )\n\n        surface = surfaces[0]\n\n        self.play(\n            FadeIn(surface),\n            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),\n        )\n        for mob in surfaces:\n            mob.add(mob.mesh)\n        surface.save_state()\n        self.play(Rotate(surface, PI / 2), run_time=2)\n        for mob in surfaces[1:]:\n            mob.rotate(PI / 2)\n\n        self.play(\n            Transform(surface, surfaces[1]),\n            run_time=3\n        )\n\n        self.play(\n            Transform(surface, surfaces[2]),\n            # Move camera frame during the transition\n            frame.animate.increment_phi(-10 * DEGREES),\n            frame.animate.increment_theta(-20 * DEGREES),\n            run_time=3\n        )\n        # Add ambient rotation\n        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))\n\n        # Play around with where the light is\n        light_text = Text(\"You can move around the light source\")\n        light_text.move_to(surface_text)\n        light_text.fix_in_frame()\n\n        self.play(FadeTransform(surface_text, light_text))\n        light = self.camera.light_source\n        self.add(light)\n        light.save_state()\n        self.play(light.animate.move_to(3 * IN), run_time=5)\n        self.play(light.animate.shift(10 * OUT), run_time=5)\n\n        drag_text = Text(\"Try moving the mouse while pressing d or s\")\n        drag_text.move_to(light_text)\n        drag_text.fix_in_frame()\n\n        self.play(FadeTransform(light_text, drag_text))\n        self.wait()",
      ".fix_in_frame()",
      "class OpeningManimExample(Scene):\n    def construct(self):\n        intro_words = Text(\"\"\"\n            The original motivation for manim was to\n            better illustrate mathematical functions\n            as transformations.\n        \"\"\")\n        intro_words.to_edge(UP)\n\n        self.play(Write(intro_words))\n        self.wait(2)\n\n        # Linear transform\n        grid = NumberPlane((-10, 10), (-5, 5))\n        matrix = [[1, 1], [0, 1]]\n        linear_transform_words = VGroup(\n            Text(\"This is what the matrix\"),\n            IntegerMatrix(matrix, include_background_rectangle=True),\n            Text(\"looks like\")\n        )\n        linear_transform_words.arrange(RIGHT)\n        linear_transform_words.to_edge(UP)\n        linear_transform_words.set_stroke(BLACK, 10, background=True)\n\n        self.play(\n            ShowCreation(grid),\n            FadeTransform(intro_words, linear_transform_words)\n        )\n        self.wait()\n        self.play(grid.animate.apply_matrix(matrix), run_time=3)\n        self.wait()\n\n        # Complex map\n        c_grid = ComplexPlane()\n        moving_c_grid = c_grid.copy()\n        moving_c_grid.prepare_for_nonlinear_transform()\n        c_grid.set_stroke(BLUE_E, 1)\n        c_grid.add_coordinate_labels(font_size=24)\n        complex_map_words = TexText(\"\"\"\n            Or thinking of the plane as $\\\\mathds{C}$,\\\\\\\\\n            this is the map $z \\\\rightarrow z^2$\n        \"\"\")\n        complex_map_words.to_corner(UR)\n        complex_map_words.set_stroke(BLACK, 5, background=True)\n\n        self.play(\n            FadeOut(grid),\n            Write(c_grid, run_time=3),\n            FadeIn(moving_c_grid),\n            FadeTransform(linear_transform_words, complex_map_words),\n        )\n        self.wait()\n        self.play(\n            moving_c_grid.animate.apply_complex_function(lambda z: z**2),\n            run_time=6,\n        )\n        self.wait(2)"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#example-scenes",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevelopment",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample"
    ],
    "scraped_at": 1752428847.5882182
  },
  "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample": {
    "url": "https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample",
    "title": "Example Scenes - manim  documentation",
    "content": "Example Scenes\n¶\nAfter understanding the previous knowledge, we can understand more scenes.\nMany example scenes are given in\nexample_scenes.py\n, let’s start with\nthe simplest and one by one.\nInteractiveDevlopment\n¶\nInteractiveDevelopment\n¶\nfrom\nmanimlib\nimport\n*\nclass\nInteractiveDevelopment\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nsquare\n=\nSquare\n()\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nself\n.\nwait\n()\n# This opens an iPython terminal where you can keep writing\n# lines as if they were part of this construct method.\n# In particular, 'square', 'circle' and 'self' will all be\n# part of the local namespace in that terminal.\nself\n.\nembed\n()\n# Try copying and pasting some of the lines below into\n# the interactive shell\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nstretch\n(\n4\n,\n0\n))\nself\n.\nplay\n(\nRotate\n(\ncircle\n,\n90\n*\nDEGREES\n))\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nshift\n(\n2\n*\nRIGHT\n)\n.\nscale\n(\n0.25\n))\ntext\n=\nText\n(\n\"\"\"\nIn general, using the interactive shell\nis very helpful when developing new scenes\n\"\"\"\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\n# In the interactive shell, you can just type\n# play, add, remove, clear, wait, save_state and restore,\n# instead of self.play, self.add, self.remove, etc.\n# To interact with the window, type touch().  You can then\n# scroll in the window, or zoom by holding down 'z' while scrolling,\n# and change camera perspective by holding down 'd' while moving\n# the mouse.  Press 'r' to reset to the standard camera position.\n# Press 'q' to stop interacting with the window and go back to\n# typing new commands into the shell.\n# In principle you can customize a scene to be responsive to\n# mouse and keyboard interactions\nalways\n(\ncircle\n.\nmove_to\n,\nself\n.\nmouse_point\n)\nThis scene is similar to what we wrote in\nQuick Start\n.\nAnd how to interact has been written in the comments.\nNo more explanation here.\nAnimatingMethods\n¶\nAnimatingMethods\n¶\nclass\nAnimatingMethods\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ngrid\n=\nOldTex\n(\nr\n\"\\pi\"\n)\n.\nget_grid\n(\n10\n,\n10\n,\nheight\n=\n4\n)\nself\n.\nadd\n(\ngrid\n)\n# You can animate the application of mobject methods with the\n# \".animate\" syntax:\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nshift\n(\nLEFT\n))\n# Alternatively, you can use the older syntax by passing the\n# method and then the arguments to the scene's \"play\" function:\nself\n.\nplay\n(\ngrid\n.\nshift\n,\nLEFT\n)\n# Both of those will interpolate between the mobject's initial\n# state and whatever happens when you apply that method.\n# For this example, calling grid.shift(LEFT) would shift the\n# grid one unit to the left, but both of the previous calls to\n# \"self.play\" animate that motion.\n# The same applies for any method, including those setting colors.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_color\n(\nYELLOW\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_submobject_colors_by_gradient\n(\nBLUE\n,\nGREEN\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_height\n(\nTAU\n-\nMED_SMALL_BUFF\n))\nself\n.\nwait\n()\n# The method Mobject.apply_complex_function lets you apply arbitrary\n# complex functions, treating the points defining the mobject as\n# complex numbers.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_complex_function\n(\nnp\n.\nexp\n),\nrun_time\n=\n5\n)\nself\n.\nwait\n()\n# Even more generally, you could apply Mobject.apply_function,\n# which takes in functions form R^3 to R^3\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_function\n(\nlambda\np\n:\n[\np\n[\n0\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n1\n]),\np\n[\n1\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n0\n]),\np\n[\n2\n]\n]\n),\nrun_time\n=\n5\n,\n)\nself\n.\nwait\n()\nThe new usage in this scene is\n.get_grid()\nand\nself.play(mob.animate.method(args))\n.\n.get_grid()\nmethod will return a new mobject containing multiple copies of this one arranged in a grid.\nself.play(mob.animate.method(args))\nanimates the method, and the details are in the comments above.\nTextExample\n¶\nTextExample\n¶\nclass\nTextExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\n# To run this scene properly, you should have \"Consolas\" font in your computer\n# for full usage, you can see https://github.com/3b1b/manim/pull/680\ntext\n=\nText\n(\n\"Here is a text\"\n,\nfont\n=\n\"Consolas\"\n,\nfont_size\n=\n90\n)\ndifference\n=\nText\n(\n\"\"\"\nThe most important difference between Text and TexText is that\\n\nyou can change the font more easily, but can't use the LaTeX grammar\n\"\"\"\n,\nfont\n=\n\"Arial\"\n,\nfont_size\n=\n24\n,\n# t2c is a dict that you can choose color for different text\nt2c\n=\n{\n\"Text\"\n:\nBLUE\n,\n\"TexText\"\n:\nBLUE\n,\n\"LaTeX\"\n:\nORANGE\n}\n)\nVGroup\n(\ntext\n,\ndifference\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\nself\n.\nplay\n(\nFadeIn\n(\ndifference\n,\nUP\n))\nself\n.\nwait\n(\n3\n)\nfonts\n=\nText\n(\n\"And you can also set the font according to different words\"\n,\nfont\n=\n\"Arial\"\n,\nt2f\n=\n{\n\"font\"\n:\n\"Consolas\"\n,\n\"words\"\n:\n\"Consolas\"\n},\nt2c\n=\n{\n\"font\"\n:\nBLUE\n,\n\"words\"\n:\nGREEN\n}\n)\nfonts\n.\nset_width\n(\nFRAME_WIDTH\n-\n1\n)\nslant\n=\nText\n(\n\"And the same as slant and weight\"\n,\nfont\n=\n\"Consolas\"\n,\nt2s\n=\n{\n\"slant\"\n:\nITALIC\n},\nt2w\n=\n{\n\"weight\"\n:\nBOLD\n},\nt2c\n=\n{\n\"slant\"\n:\nORANGE\n,\n\"weight\"\n:\nRED\n}\n)\nVGroup\n(\nfonts\n,\nslant\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n0.8\n)\nself\n.\nplay\n(\nFadeOut\n(\ntext\n),\nFadeOut\n(\ndifference\n,\nshift\n=\nDOWN\n))\nself\n.\nplay\n(\nWrite\n(\nfonts\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nWrite\n(\nslant\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nText\n,\nVGroup\n,\nWrite\n,\nFadeIn\nand\nFadeOut\n.\nText\ncan create text, define fonts, etc. The usage ais clearly reflected in the above examples.\nVGroup\ncan put multiple\nVMobject\ntogether as a whole. In the example, the\n.arrange()\nmethod is called to arrange the sub-mobjects in sequence downward (\nDOWN\n), and the spacing is\nbuff\n.\nWrite\nis an animation that shows similar writing effects.\nFadeIn\nfades the object in, the second parameter indicates the direction of the fade in.\nFadeOut\nfades out the object, the second parameter indicates the direction of the fade out.\nTexTransformExample\n¶\nTexTransformExample\n¶\nclass\nTexTransformExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nto_isolate\n=\n[\n\"B\"\n,\n\"C\"\n,\n\"=\"\n,\n\"(\"\n,\n\")\"\n]\nlines\n=\nVGroup\n(\n# Passing in muliple arguments to Tex will result\n# in the same expression as if those arguments had\n# been joined together, except that the submobject\n# hierarchy of the resulting mobject ensure that the\n# Tex mobject has a subject corresponding to\n# each of these strings.  For example, the Tex mobject\n# below will have 5 subjects, corresponding to the\n# expressions [A^2, +, B^2, =, C^2]\nOldTex\n(\n\"A^2\"\n,\n\"+\"\n,\n\"B^2\"\n,\n\"=\"\n,\n\"C^2\"\n),\n# Likewise here\nOldTex\n(\n\"A^2\"\n,\n\"=\"\n,\n\"C^2\"\n,\n\"-\"\n,\n\"B^2\"\n),\n# Alternatively, you can pass in the keyword argument\n# \"isolate\" with a list of strings that should be out as\n# their own submobject.  So the line below is equivalent\n# to the commented out line below it.\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A^2\"\n,\n*\nto_isolate\n]),\n# OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\nOldTex\n(\n\"A =\n\\\\\nsqrt{(C + B)(C - B)}\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\n)\nlines\n.\narrange\n(\nDOWN\n,\nbuff\n=\nLARGE_BUFF\n)\nfor\nline\nin\nlines\n:\nline\n.\nset_color_by_tex_to_color_map\n({\n\"A\"\n:\nBLUE\n,\n\"B\"\n:\nTEAL\n,\n\"C\"\n:\nGREEN\n,\n})\nplay_kw\n=\n{\n\"run_time\"\n:\n2\n}\nself\n.\nadd\n(\nlines\n[\n0\n])\n# The animation TransformMatchingTex will line up parts\n# of the source and target which have matching tex strings.\n# Here, giving it a little path_arc makes each part sort of\n# rotate into their final positions, which feels appropriate\n# for the idea of rearranging an equation\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n0\n]\n.\ncopy\n(),\nlines\n[\n1\n],\npath_arc\n=\n90\n*\nDEGREES\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# Now, we could try this again on the next line...\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n]),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# ...and this looks nice enough, but since there's no tex\n# in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n# out to nothing while the C and B terms fade in from nothing.\n# If, however, we want the C^2 to go to C, and B^2 to go to B,\n# we can specify that with a key map.\nself\n.\nplay\n(\nFadeOut\n(\nlines\n[\n2\n]))\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n],\nkey_map\n=\n{\n\"C^2\"\n:\n\"C\"\n,\n\"B^2\"\n:\n\"B\"\n,\n}\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# And to finish off, a simple TransformMatchingShapes would work\n# just fine.  But perhaps we want that exponent on A^2 to transform into\n# the square root symbol.  At the moment, lines[2] treats the expression\n# A^2 as a unit, so we might create a new version of the same line which\n# separates out just the A.  This way, when TransformMatchingTex lines up\n# all matching parts, the only mismatch will be between the \"^2\" from\n# new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n# transform_mismatches=True, it will transform this \"^2\" part into\n# the \"\\sqrt\" part.\nnew_line2\n=\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\nnew_line2\n.\nreplace\n(\nlines\n[\n2\n])\nnew_line2\n.\nmatch_style\n(\nlines\n[\n2\n])\nself\n.\nplay\n(\nTransformMatchingTex\n(\nnew_line2\n,\nlines\n[\n3\n],\ntransform_mismatches\n=\nTrue\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n(\n3\n)\nself\n.\nplay\n(\nFadeOut\n(\nlines\n,\nRIGHT\n))\n# Alternatively, if you don't want to think about breaking up\n# the tex strings deliberately, you can TransformMatchingShapes,\n# which will try to line up all pieces of a source mobject with\n# those of a target, regardless of the submobject hierarchy in\n# each one, according to whether those pieces have the same\n# shape (as best it can).\nsource\n=\nText\n(\n\"the morse code\"\n,\nheight\n=\n1\n)\ntarget\n=\nText\n(\n\"here come dots\"\n,\nheight\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\nsource\n))\nself\n.\nwait\n()\nkw\n=\n{\n\"run_time\"\n:\n3\n,\n\"path_arc\"\n:\nPI\n/\n2\n}\nself\n.\nplay\n(\nTransformMatchingShapes\n(\nsource\n,\ntarget\n,\n**\nkw\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nTransformMatchingShapes\n(\ntarget\n,\nsource\n,\n**\nkw\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nTex\n,\nTexText\n,\nTransformMatchingTex\nand\nTransformMatchingShapes\n.\nTex\nuses LaTeX to create mathematical formulas.\nTexText\nuses LaTeX to create text.\nTransformMatchingTeX\nautomatically transforms sub-objects according to the similarities and differences of tex in\nTex\n.\nTransformMatchingShapes\nautomatically transform sub-objects directly based on the similarities and differences of the object point sets.\nUpdatersExample\n¶\nUpdatersExample\n¶\nclass\nUpdatersExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nsquare\n=\nSquare\n()\nsquare\n.\nset_fill\n(\nBLUE_E\n,\n1\n)\n# On all all frames, the constructor Brace(square, UP) will\n# be called, and the mobject brace will set its data to match\n# that of the newly constructed object\nbrace\n=\nalways_redraw\n(\nBrace\n,\nsquare\n,\nUP\n)\ntext\n,\nnumber\n=\nlabel\n=\nVGroup\n(\nText\n(\n\"Width = \"\n),\nDecimalNumber\n(\n0\n,\nshow_ellipsis\n=\nTrue\n,\nnum_decimal_places\n=\n2\n,\ninclude_sign\n=\nTrue\n,\n)\n)\nlabel\n.\narrange\n(\nRIGHT\n)\n# This ensures that the method deicmal.next_to(square)\n# is called on every frame\nalways\n(\nlabel\n.\nnext_to\n,\nbrace\n,\nUP\n)\n# You could also write the following equivalent line\n# label.add_updater(lambda m: m.next_to(brace, UP))\n# If the argument itself might change, you can use f_always,\n# for which the arguments following the initial Mobject method\n# should be functions returning arguments to that method.\n# The following line ensures that decimal.set_value(square.get_y())\n# is called every frame\nf_always\n(\nnumber\n.\nset_value\n,\nsquare\n.\nget_width\n)\n# You could also write the following equivalent line\n# number.add_updater(lambda m: m.set_value(square.get_width()))\nself\n.\nadd\n(\nsquare\n,\nbrace\n,\nlabel\n)\n# Notice that the brace and label track with the square\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nscale\n(\n2\n),\nrate_func\n=\nthere_and_back\n,\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n5\n,\nstretch\n=\nTrue\n),\nrun_time\n=\n3\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# In general, you can alway call Mobject.add_updater, and pass in\n# a function that you want to be called on every frame.  The function\n# should take in either one argument, the mobject, or two arguments,\n# the mobject and the amount of time since the last frame.\nnow\n=\nself\n.\ntime\nw0\n=\nsquare\n.\nget_width\n()\nsquare\n.\nadd_updater\n(\nlambda\nm\n:\nm\n.\nset_width\n(\nw0\n*\nmath\n.\ncos\n(\nself\n.\ntime\n-\nnow\n))\n)\nself\n.\nwait\n(\n4\n*\nPI\n)\nThe new classes and usage in this scene are\nalways_redraw()\n,\nDecimalNumber\n,\n.to_edge()\n,\n.center()\n,\nalways()\n,\nf_always()\n,\n.set_y()\nand\n.add_updater()\n.\nalways_redraw()\nfunction create a new mobject every frame.\nDecimalNumber\nis a variable number, speed it up by breaking it into\nText\ncharacters.\n.to_edge()\nmeans to place the object on the edge of the screen.\n.center()\nmeans to place the object in the center of the screen.\nalways(f,\nx)\nmeans that a certain function (\nf(x)\n) is executed every frame.\nf_always(f,\ng)\nis similar to\nalways\n, executed\nf(g())\nevery frame.\n.set_y()\nmeans to set the ordinate of the object on the screen.\n.add_updater()\nsets an update function for the object. For example:\nmob1.add_updater(lambda\nmob:\nmob.next_to(mob2))\nmeans\nmob1.next_to(mob2)\nis executed every frame.\nCoordinateSystemExample\n¶\nCoordinateSystemExample\n¶\nclass\nCoordinateSystemExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n(\n# x-axis ranges from -1 to 10, with a default step size of 1\nx_range\n=\n(\n-\n1\n,\n10\n),\n# y-axis ranges from -2 to 2 with a step size of 0.5\ny_range\n=\n(\n-\n2\n,\n2\n,\n0.5\n),\n# The axes will be stretched so as to match the specified\n# height and width\nheight\n=\n6\n,\nwidth\n=\n10\n,\n# Axes is made of two NumberLine mobjects.  You can specify\n# their configuration with axis_config\naxis_config\n=\n{\n\"stroke_color\"\n:\nGREY_A\n,\n\"stroke_width\"\n:\n2\n,\n},\n# Alternatively, you can specify configuration for just one\n# of them, like this.\ny_axis_config\n=\n{\n\"include_tip\"\n:\nFalse\n,\n}\n)\n# Keyword arguments of add_coordinate_labels can be used to\n# configure the DecimalNumber mobjects which it creates and\n# adds to the axes\naxes\n.\nadd_coordinate_labels\n(\nfont_size\n=\n20\n,\nnum_decimal_places\n=\n1\n,\n)\nself\n.\nadd\n(\naxes\n)\n# Axes descends from the CoordinateSystem class, meaning\n# you can call call axes.coords_to_point, abbreviated to\n# axes.c2p, to associate a set of coordinates with a point,\n# like so:\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\nc2p\n(\n0\n,\n0\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n5\n,\n0.5\n)))\nself\n.\nwait\n()\n# Similarly, you can call axes.point_to_coords, or axes.p2c\n# print(axes.p2c(dot.get_center()))\n# We can draw lines from the axes to better mark the coordinates\n# of a given point.\n# Here, the always_redraw command means that on each new frame\n# the lines will be redrawn\nh_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_h_line\n(\ndot\n.\nget_left\n()))\nv_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_v_line\n(\ndot\n.\nget_bottom\n()))\nself\n.\nplay\n(\nShowCreation\n(\nh_line\n),\nShowCreation\n(\nv_line\n),\n)\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n-\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n1\n,\n1\n)))\nself\n.\nwait\n()\n# If we tie the dot to a particular set of coordinates, notice\n# that as we move the axes around it respects the coordinate\n# system defined by them.\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\nc2p\n(\n1\n,\n1\n))\nself\n.\nplay\n(\naxes\n.\nanimate\n.\nscale\n(\n0.75\n)\n.\nto_corner\n(\nUL\n),\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nFadeOut\n(\nVGroup\n(\naxes\n,\ndot\n,\nh_line\n,\nv_line\n)))\n# Other coordinate systems you can play around with include\n# ThreeDAxes, NumberPlane, and ComplexPlane.\nGraphExample\n¶\nGraphExample\n¶\nclass\nGraphExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n((\n-\n3\n,\n10\n),\n(\n-\n1\n,\n8\n))\naxes\n.\nadd_coordinate_labels\n()\nself\n.\nplay\n(\nWrite\n(\naxes\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n1\n))\n# Axes.get_graph will return the graph of a function\nsin_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2\n*\nmath\n.\nsin\n(\nx\n),\ncolor\n=\nBLUE\n,\n)\n# By default, it draws it so as to somewhat smoothly interpolate\n# between sampled points (x, f(x)).  If the graph is meant to have\n# a corner, though, you can set use_smoothing to False\nrelu_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\nmax\n(\nx\n,\n0\n),\nuse_smoothing\n=\nFalse\n,\ncolor\n=\nYELLOW\n,\n)\n# For discontinuous functions, you can specify the point of\n# discontinuity so that it does not try to draw over the gap.\nstep_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2.0\nif\nx\n>\n3\nelse\n1.0\n,\ndiscontinuities\n=\n[\n3\n],\ncolor\n=\nGREEN\n,\n)\n# Axes.get_graph_label takes in either a string or a mobject.\n# If it's a string, it treats it as a LaTeX expression.  By default\n# it places the label next to the graph near the right side, and\n# has it match the color of the graph\nsin_label\n=\naxes\n.\nget_graph_label\n(\nsin_graph\n,\n\"\n\\\\\nsin(x)\"\n)\nrelu_label\n=\naxes\n.\nget_graph_label\n(\nrelu_graph\n,\nText\n(\n\"ReLU\"\n))\nstep_label\n=\naxes\n.\nget_graph_label\n(\nstep_graph\n,\nText\n(\n\"Step\"\n),\nx\n=\n4\n)\nself\n.\nplay\n(\nShowCreation\n(\nsin_graph\n),\nFadeIn\n(\nsin_label\n,\nRIGHT\n),\n)\nself\n.\nwait\n(\n2\n)\nself\n.\nplay\n(\nReplacementTransform\n(\nsin_graph\n,\nrelu_graph\n),\nFadeTransform\n(\nsin_label\n,\nrelu_label\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nReplacementTransform\n(\nrelu_graph\n,\nstep_graph\n),\nFadeTransform\n(\nrelu_label\n,\nstep_label\n),\n)\nself\n.\nwait\n()\nparabola\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n0.25\n*\nx\n**\n2\n)\nparabola\n.\nset_stroke\n(\nBLUE\n)\nself\n.\nplay\n(\nFadeOut\n(\nstep_graph\n),\nFadeOut\n(\nstep_label\n),\nShowCreation\n(\nparabola\n)\n)\nself\n.\nwait\n()\n# You can use axes.input_to_graph_point, abbreviated\n# to axes.i2gp, to find a particular point on a graph\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\ni2gp\n(\n2\n,\nparabola\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\n# A value tracker lets us animate a parameter, usually\n# with the intent of having other mobjects update based\n# on the parameter\nx_tracker\n=\nValueTracker\n(\n2\n)\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\ni2gp\n(\nx_tracker\n.\nget_value\n(),\nparabola\n)\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n4\n),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n-\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\nSurfaceExample\n¶\nSurfaceExample\n¶\nclass\nSurfaceExample\n(\nScene\n):\nCONFIG\n=\n{\n\"camera_class\"\n:\nThreeDCamera\n,\n}\ndef\nconstruct\n(\nself\n):\nsurface_text\n=\nText\n(\n\"For 3d scenes, try using surfaces\"\n)\nsurface_text\n.\nfix_in_frame\n()\nsurface_text\n.\nto_edge\n(\nUP\n)\nself\n.\nadd\n(\nsurface_text\n)\nself\n.\nwait\n(\n0.1\n)\ntorus1\n=\nTorus\n(\nr1\n=\n1\n,\nr2\n=\n1\n)\ntorus2\n=\nTorus\n(\nr1\n=\n3\n,\nr2\n=\n1\n)\nsphere\n=\nSphere\n(\nradius\n=\n3\n,\nresolution\n=\ntorus1\n.\nresolution\n)\n# You can texture a surface with up to two images, which will\n# be interpreted as the side towards the light, and away from\n# the light.  These can be either urls, or paths to a local file\n# in whatever you've set as the image directory in\n# the custom_config.yml file\n# day_texture = \"EarthTextureMap\"\n# night_texture = \"NightEarthTextureMap\"\nday_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\nnight_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\nsurfaces\n=\n[\nTexturedSurface\n(\nsurface\n,\nday_texture\n,\nnight_texture\n)\nfor\nsurface\nin\n[\nsphere\n,\ntorus1\n,\ntorus2\n]\n]\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nshift\n(\nIN\n)\nmob\n.\nmesh\n=\nSurfaceMesh\n(\nmob\n)\nmob\n.\nmesh\n.\nset_stroke\n(\nBLUE\n,\n1\n,\nopacity\n=\n0.5\n)\n# Set perspective\nframe\n=\nself\n.\ncamera\n.\nframe\nframe\n.\nset_euler_angles\n(\ntheta\n=-\n30\n*\nDEGREES\n,\nphi\n=\n70\n*\nDEGREES\n,\n)\nsurface\n=\nsurfaces\n[\n0\n]\nself\n.\nplay\n(\nFadeIn\n(\nsurface\n),\nShowCreation\n(\nsurface\n.\nmesh\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n3\n),\n)\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nadd\n(\nmob\n.\nmesh\n)\nsurface\n.\nsave_state\n()\nself\n.\nplay\n(\nRotate\n(\nsurface\n,\nPI\n/\n2\n),\nrun_time\n=\n2\n)\nfor\nmob\nin\nsurfaces\n[\n1\n:]:\nmob\n.\nrotate\n(\nPI\n/\n2\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n1\n]),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n2\n]),\n# Move camera frame during the transition\nframe\n.\nanimate\n.\nincrement_phi\n(\n-\n10\n*\nDEGREES\n),\nframe\n.\nanimate\n.\nincrement_theta\n(\n-\n20\n*\nDEGREES\n),\nrun_time\n=\n3\n)\n# Add ambient rotation\nframe\n.\nadd_updater\n(\nlambda\nm\n,\ndt\n:\nm\n.\nincrement_theta\n(\n-\n0.1\n*\ndt\n))\n# Play around with where the light is\nlight_text\n=\nText\n(\n\"You can move around the light source\"\n)\nlight_text\n.\nmove_to\n(\nsurface_text\n)\nlight_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nsurface_text\n,\nlight_text\n))\nlight\n=\nself\n.\ncamera\n.\nlight_source\nself\n.\nadd\n(\nlight\n)\nlight\n.\nsave_state\n()\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nmove_to\n(\n3\n*\nIN\n),\nrun_time\n=\n5\n)\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nshift\n(\n10\n*\nOUT\n),\nrun_time\n=\n5\n)\ndrag_text\n=\nText\n(\n\"Try moving the mouse while pressing d or s\"\n)\ndrag_text\n.\nmove_to\n(\nlight_text\n)\ndrag_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nlight_text\n,\ndrag_text\n))\nself\n.\nwait\n()\nThis scene shows an example of using a three-dimensional surface, and\nthe related usage has been briefly described in the notes.\n.fix_in_frame()\nmakes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.\nOpeningManimExample\n¶\nOpeningManimExample\n¶\nclass\nOpeningManimExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nintro_words\n=\nText\n(\n\"\"\"\nThe original motivation for manim was to\nbetter illustrate mathematical functions\nas transformations.\n\"\"\"\n)\nintro_words\n.\nto_edge\n(\nUP\n)\nself\n.\nplay\n(\nWrite\n(\nintro_words\n))\nself\n.\nwait\n(\n2\n)\n# Linear transform\ngrid\n=\nNumberPlane\n((\n-\n10\n,\n10\n),\n(\n-\n5\n,\n5\n))\nmatrix\n=\n[[\n1\n,\n1\n],\n[\n0\n,\n1\n]]\nlinear_transform_words\n=\nVGroup\n(\nText\n(\n\"This is what the matrix\"\n),\nIntegerMatrix\n(\nmatrix\n,\ninclude_background_rectangle\n=\nTrue\n),\nText\n(\n\"looks like\"\n)\n)\nlinear_transform_words\n.\narrange\n(\nRIGHT\n)\nlinear_transform_words\n.\nto_edge\n(\nUP\n)\nlinear_transform_words\n.\nset_stroke\n(\nBLACK\n,\n10\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nShowCreation\n(\ngrid\n),\nFadeTransform\n(\nintro_words\n,\nlinear_transform_words\n)\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_matrix\n(\nmatrix\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# Complex map\nc_grid\n=\nComplexPlane\n()\nmoving_c_grid\n=\nc_grid\n.\ncopy\n()\nmoving_c_grid\n.\nprepare_for_nonlinear_transform\n()\nc_grid\n.\nset_stroke\n(\nBLUE_E\n,\n1\n)\nc_grid\n.\nadd_coordinate_labels\n(\nfont_size\n=\n24\n)\ncomplex_map_words\n=\nTexText\n(\n\"\"\"\nOr thinking of the plane as $\n\\\\\nmathds\n{C}\n$,\n\\\\\\\\\nthis is the map $z\n\\\\\nrightarrow z^2$\n\"\"\"\n)\ncomplex_map_words\n.\nto_corner\n(\nUR\n)\ncomplex_map_words\n.\nset_stroke\n(\nBLACK\n,\n5\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nFadeOut\n(\ngrid\n),\nWrite\n(\nc_grid\n,\nrun_time\n=\n3\n),\nFadeIn\n(\nmoving_c_grid\n),\nFadeTransform\n(\nlinear_transform_words\n,\ncomplex_map_words\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nmoving_c_grid\n.\nanimate\n.\napply_complex_function\n(\nlambda\nz\n:\nz\n**\n2\n),\nrun_time\n=\n6\n,\n)\nself\n.\nwait\n(\n2\n)\nThis scene is a comprehensive application of a two-dimensional scene.\nAfter seeing these scenes, you have already understood part of the\nusage of manim. For more examples, see\nthe video code of 3b1b\n.\nContents\nExample Scenes\nInteractiveDevlopment\nAnimatingMethods\nTextExample\nTexTransformExample\nUpdatersExample\nCoordinateSystemExample\nGraphExample\nSurfaceExample\nOpeningManimExample",
    "code_examples": [
      "example_scenes.py",
      "from manimlib import *\n\nclass InteractiveDevelopment(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n\n        # This opens an iPython terminal where you can keep writing\n        # lines as if they were part of this construct method.\n        # In particular, 'square', 'circle' and 'self' will all be\n        # part of the local namespace in that terminal.\n        self.embed()\n\n        # Try copying and pasting some of the lines below into\n        # the interactive shell\n        self.play(ReplacementTransform(square, circle))\n        self.wait()\n        self.play(circle.animate.stretch(4, 0))\n        self.play(Rotate(circle, 90 * DEGREES))\n        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))\n\n        text = Text(\"\"\"\n            In general, using the interactive shell\n            is very helpful when developing new scenes\n        \"\"\")\n        self.play(Write(text))\n\n        # In the interactive shell, you can just type\n        # play, add, remove, clear, wait, save_state and restore,\n        # instead of self.play, self.add, self.remove, etc.\n\n        # To interact with the window, type touch().  You can then\n        # scroll in the window, or zoom by holding down 'z' while scrolling,\n        # and change camera perspective by holding down 'd' while moving\n        # the mouse.  Press 'r' to reset to the standard camera position.\n        # Press 'q' to stop interacting with the window and go back to\n        # typing new commands into the shell.\n\n        # In principle you can customize a scene to be responsive to\n        # mouse and keyboard interactions\n        always(circle.move_to, self.mouse_point)",
      "class AnimatingMethods(Scene):\n    def construct(self):\n        grid = OldTex(r\"\\pi\").get_grid(10, 10, height=4)\n        self.add(grid)\n\n        # You can animate the application of mobject methods with the\n        # \".animate\" syntax:\n        self.play(grid.animate.shift(LEFT))\n\n        # Alternatively, you can use the older syntax by passing the\n        # method and then the arguments to the scene's \"play\" function:\n        self.play(grid.shift, LEFT)\n\n        # Both of those will interpolate between the mobject's initial\n        # state and whatever happens when you apply that method.\n        # For this example, calling grid.shift(LEFT) would shift the\n        # grid one unit to the left, but both of the previous calls to\n        # \"self.play\" animate that motion.\n\n        # The same applies for any method, including those setting colors.\n        self.play(grid.animate.set_color(YELLOW))\n        self.wait()\n        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))\n        self.wait()\n        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))\n        self.wait()\n\n        # The method Mobject.apply_complex_function lets you apply arbitrary\n        # complex functions, treating the points defining the mobject as\n        # complex numbers.\n        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)\n        self.wait()\n\n        # Even more generally, you could apply Mobject.apply_function,\n        # which takes in functions form R^3 to R^3\n        self.play(\n            grid.animate.apply_function(\n                lambda p: [\n                    p[0] + 0.5 * math.sin(p[1]),\n                    p[1] + 0.5 * math.sin(p[0]),\n                    p[2]\n                ]\n            ),\n            run_time=5,\n        )\n        self.wait()",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      "class TextExample(Scene):\n    def construct(self):\n        # To run this scene properly, you should have \"Consolas\" font in your computer\n        # for full usage, you can see https://github.com/3b1b/manim/pull/680\n        text = Text(\"Here is a text\", font=\"Consolas\", font_size=90)\n        difference = Text(\n            \"\"\"\n            The most important difference between Text and TexText is that\\n\n            you can change the font more easily, but can't use the LaTeX grammar\n            \"\"\",\n            font=\"Arial\", font_size=24,\n            # t2c is a dict that you can choose color for different text\n            t2c={\"Text\": BLUE, \"TexText\": BLUE, \"LaTeX\": ORANGE}\n        )\n        VGroup(text, difference).arrange(DOWN, buff=1)\n        self.play(Write(text))\n        self.play(FadeIn(difference, UP))\n        self.wait(3)\n\n        fonts = Text(\n            \"And you can also set the font according to different words\",\n            font=\"Arial\",\n            t2f={\"font\": \"Consolas\", \"words\": \"Consolas\"},\n            t2c={\"font\": BLUE, \"words\": GREEN}\n        )\n        fonts.set_width(FRAME_WIDTH - 1)\n        slant = Text(\n            \"And the same as slant and weight\",\n            font=\"Consolas\",\n            t2s={\"slant\": ITALIC},\n            t2w={\"weight\": BOLD},\n            t2c={\"slant\": ORANGE, \"weight\": RED}\n        )\n        VGroup(fonts, slant).arrange(DOWN, buff=0.8)\n        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))\n        self.play(Write(fonts))\n        self.wait()\n        self.play(Write(slant))\n        self.wait()",
      "class TexTransformExample(Scene):\n    def construct(self):\n        to_isolate = [\"B\", \"C\", \"=\", \"(\", \")\"]\n        lines = VGroup(\n            # Passing in muliple arguments to Tex will result\n            # in the same expression as if those arguments had\n            # been joined together, except that the submobject\n            # hierarchy of the resulting mobject ensure that the\n            # Tex mobject has a subject corresponding to\n            # each of these strings.  For example, the Tex mobject\n            # below will have 5 subjects, corresponding to the\n            # expressions [A^2, +, B^2, =, C^2]\n            OldTex(\"A^2\", \"+\", \"B^2\", \"=\", \"C^2\"),\n            # Likewise here\n            OldTex(\"A^2\", \"=\", \"C^2\", \"-\", \"B^2\"),\n            # Alternatively, you can pass in the keyword argument\n            # \"isolate\" with a list of strings that should be out as\n            # their own submobject.  So the line below is equivalent\n            # to the commented out line below it.\n            OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A^2\", *to_isolate]),\n            # OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\n            OldTex(\"A = \\\\sqrt{(C + B)(C - B)}\", isolate=[\"A\", *to_isolate])\n        )\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        for line in lines:\n            line.set_color_by_tex_to_color_map({\n                \"A\": BLUE,\n                \"B\": TEAL,\n                \"C\": GREEN,\n            })\n\n        play_kw = {\"run_time\": 2}\n        self.add(lines[0])\n        # The animation TransformMatchingTex will line up parts\n        # of the source and target which have matching tex strings.\n        # Here, giving it a little path_arc makes each part sort of\n        # rotate into their final positions, which feels appropriate\n        # for the idea of rearranging an equation\n        self.play(\n            TransformMatchingTex(\n                lines[0].copy(), lines[1],\n                path_arc=90 * DEGREES,\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # Now, we could try this again on the next line...\n        self.play(\n            TransformMatchingTex(lines[1].copy(), lines[2]),\n            **play_kw\n        )\n        self.wait()\n        # ...and this looks nice enough, but since there's no tex\n        # in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n        # out to nothing while the C and B terms fade in from nothing.\n        # If, however, we want the C^2 to go to C, and B^2 to go to B,\n        # we can specify that with a key map.\n        self.play(FadeOut(lines[2]))\n        self.play(\n            TransformMatchingTex(\n                lines[1].copy(), lines[2],\n                key_map={\n                    \"C^2\": \"C\",\n                    \"B^2\": \"B\",\n                }\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # And to finish off, a simple TransformMatchingShapes would work\n        # just fine.  But perhaps we want that exponent on A^2 to transform into\n        # the square root symbol.  At the moment, lines[2] treats the expression\n        # A^2 as a unit, so we might create a new version of the same line which\n        # separates out just the A.  This way, when TransformMatchingTex lines up\n        # all matching parts, the only mismatch will be between the \"^2\" from\n        # new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n        # transform_mismatches=True, it will transform this \"^2\" part into\n        # the \"\\sqrt\" part.\n        new_line2 = OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A\", *to_isolate])\n        new_line2.replace(lines[2])\n        new_line2.match_style(lines[2])\n\n        self.play(\n            TransformMatchingTex(\n                new_line2, lines[3],\n                transform_mismatches=True,\n            ),\n            **play_kw\n        )\n        self.wait(3)\n        self.play(FadeOut(lines, RIGHT))\n\n        # Alternatively, if you don't want to think about breaking up\n        # the tex strings deliberately, you can TransformMatchingShapes,\n        # which will try to line up all pieces of a source mobject with\n        # those of a target, regardless of the submobject hierarchy in\n        # each one, according to whether those pieces have the same\n        # shape (as best it can).\n        source = Text(\"the morse code\", height=1)\n        target = Text(\"here come dots\", height=1)\n\n        self.play(Write(source))\n        self.wait()\n        kw = {\"run_time\": 3, \"path_arc\": PI / 2}\n        self.play(TransformMatchingShapes(source, target, **kw))\n        self.wait()\n        self.play(TransformMatchingShapes(target, source, **kw))\n        self.wait()",
      "TransformMatchingTex",
      "TransformMatchingShapes",
      "TransformMatchingTeX",
      "TransformMatchingShapes",
      "class UpdatersExample(Scene):\n    def construct(self):\n        square = Square()\n        square.set_fill(BLUE_E, 1)\n\n        # On all all frames, the constructor Brace(square, UP) will\n        # be called, and the mobject brace will set its data to match\n        # that of the newly constructed object\n        brace = always_redraw(Brace, square, UP)\n\n        text, number = label = VGroup(\n            Text(\"Width = \"),\n            DecimalNumber(\n                0,\n                show_ellipsis=True,\n                num_decimal_places=2,\n                include_sign=True,\n            )\n        )\n        label.arrange(RIGHT)\n\n        # This ensures that the method deicmal.next_to(square)\n        # is called on every frame\n        always(label.next_to, brace, UP)\n        # You could also write the following equivalent line\n        # label.add_updater(lambda m: m.next_to(brace, UP))\n\n        # If the argument itself might change, you can use f_always,\n        # for which the arguments following the initial Mobject method\n        # should be functions returning arguments to that method.\n        # The following line ensures that decimal.set_value(square.get_y())\n        # is called every frame\n        f_always(number.set_value, square.get_width)\n        # You could also write the following equivalent line\n        # number.add_updater(lambda m: m.set_value(square.get_width()))\n\n        self.add(square, brace, label)\n\n        # Notice that the brace and label track with the square\n        self.play(\n            square.animate.scale(2),\n            rate_func=there_and_back,\n            run_time=2,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(5, stretch=True),\n            run_time=3,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(2),\n            run_time=3\n        )\n        self.wait()\n\n        # In general, you can alway call Mobject.add_updater, and pass in\n        # a function that you want to be called on every frame.  The function\n        # should take in either one argument, the mobject, or two arguments,\n        # the mobject and the amount of time since the last frame.\n        now = self.time\n        w0 = square.get_width()\n        square.add_updater(\n            lambda m: m.set_width(w0 * math.cos(self.time - now))\n        )\n        self.wait(4 * PI)",
      "always_redraw()",
      "DecimalNumber",
      ".add_updater()",
      "always_redraw()",
      "DecimalNumber",
      "always(f, x)",
      "f_always(f, g)",
      ".add_updater()",
      "mob1.add_updater(lambda mob: mob.next_to(mob2))",
      "mob1.next_to(mob2)",
      "class CoordinateSystemExample(Scene):\n    def construct(self):\n        axes = Axes(\n            # x-axis ranges from -1 to 10, with a default step size of 1\n            x_range=(-1, 10),\n            # y-axis ranges from -2 to 2 with a step size of 0.5\n            y_range=(-2, 2, 0.5),\n            # The axes will be stretched so as to match the specified\n            # height and width\n            height=6,\n            width=10,\n            # Axes is made of two NumberLine mobjects.  You can specify\n            # their configuration with axis_config\n            axis_config={\n                \"stroke_color\": GREY_A,\n                \"stroke_width\": 2,\n            },\n            # Alternatively, you can specify configuration for just one\n            # of them, like this.\n            y_axis_config={\n                \"include_tip\": False,\n            }\n        )\n        # Keyword arguments of add_coordinate_labels can be used to\n        # configure the DecimalNumber mobjects which it creates and\n        # adds to the axes\n        axes.add_coordinate_labels(\n            font_size=20,\n            num_decimal_places=1,\n        )\n        self.add(axes)\n\n        # Axes descends from the CoordinateSystem class, meaning\n        # you can call call axes.coords_to_point, abbreviated to\n        # axes.c2p, to associate a set of coordinates with a point,\n        # like so:\n        dot = Dot(color=RED)\n        dot.move_to(axes.c2p(0, 0))\n        self.play(FadeIn(dot, scale=0.5))\n        self.play(dot.animate.move_to(axes.c2p(3, 2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))\n        self.wait()\n\n        # Similarly, you can call axes.point_to_coords, or axes.p2c\n        # print(axes.p2c(dot.get_center()))\n\n        # We can draw lines from the axes to better mark the coordinates\n        # of a given point.\n        # Here, the always_redraw command means that on each new frame\n        # the lines will be redrawn\n        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))\n        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))\n\n        self.play(\n            ShowCreation(h_line),\n            ShowCreation(v_line),\n        )\n        self.play(dot.animate.move_to(axes.c2p(3, -2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(1, 1)))\n        self.wait()\n\n        # If we tie the dot to a particular set of coordinates, notice\n        # that as we move the axes around it respects the coordinate\n        # system defined by them.\n        f_always(dot.move_to, lambda: axes.c2p(1, 1))\n        self.play(\n            axes.animate.scale(0.75).to_corner(UL),\n            run_time=2,\n        )\n        self.wait()\n        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))\n\n        # Other coordinate systems you can play around with include\n        # ThreeDAxes, NumberPlane, and ComplexPlane.",
      "class GraphExample(Scene):\n    def construct(self):\n        axes = Axes((-3, 10), (-1, 8))\n        axes.add_coordinate_labels()\n\n        self.play(Write(axes, lag_ratio=0.01, run_time=1))\n\n        # Axes.get_graph will return the graph of a function\n        sin_graph = axes.get_graph(\n            lambda x: 2 * math.sin(x),\n            color=BLUE,\n        )\n        # By default, it draws it so as to somewhat smoothly interpolate\n        # between sampled points (x, f(x)).  If the graph is meant to have\n        # a corner, though, you can set use_smoothing to False\n        relu_graph = axes.get_graph(\n            lambda x: max(x, 0),\n            use_smoothing=False,\n            color=YELLOW,\n        )\n        # For discontinuous functions, you can specify the point of\n        # discontinuity so that it does not try to draw over the gap.\n        step_graph = axes.get_graph(\n            lambda x: 2.0 if x > 3 else 1.0,\n            discontinuities=[3],\n            color=GREEN,\n        )\n\n        # Axes.get_graph_label takes in either a string or a mobject.\n        # If it's a string, it treats it as a LaTeX expression.  By default\n        # it places the label next to the graph near the right side, and\n        # has it match the color of the graph\n        sin_label = axes.get_graph_label(sin_graph, \"\\\\sin(x)\")\n        relu_label = axes.get_graph_label(relu_graph, Text(\"ReLU\"))\n        step_label = axes.get_graph_label(step_graph, Text(\"Step\"), x=4)\n\n        self.play(\n            ShowCreation(sin_graph),\n            FadeIn(sin_label, RIGHT),\n        )\n        self.wait(2)\n        self.play(\n            ReplacementTransform(sin_graph, relu_graph),\n            FadeTransform(sin_label, relu_label),\n        )\n        self.wait()\n        self.play(\n            ReplacementTransform(relu_graph, step_graph),\n            FadeTransform(relu_label, step_label),\n        )\n        self.wait()\n\n        parabola = axes.get_graph(lambda x: 0.25 * x**2)\n        parabola.set_stroke(BLUE)\n        self.play(\n            FadeOut(step_graph),\n            FadeOut(step_label),\n            ShowCreation(parabola)\n        )\n        self.wait()\n\n        # You can use axes.input_to_graph_point, abbreviated\n        # to axes.i2gp, to find a particular point on a graph\n        dot = Dot(color=RED)\n        dot.move_to(axes.i2gp(2, parabola))\n        self.play(FadeIn(dot, scale=0.5))\n\n        # A value tracker lets us animate a parameter, usually\n        # with the intent of having other mobjects update based\n        # on the parameter\n        x_tracker = ValueTracker(2)\n        f_always(\n            dot.move_to,\n            lambda: axes.i2gp(x_tracker.get_value(), parabola)\n        )\n\n        self.play(x_tracker.animate.set_value(4), run_time=3)\n        self.play(x_tracker.animate.set_value(-2), run_time=3)\n        self.wait()",
      "class SurfaceExample(Scene):\n    CONFIG = {\n        \"camera_class\": ThreeDCamera,\n    }\n\n    def construct(self):\n        surface_text = Text(\"For 3d scenes, try using surfaces\")\n        surface_text.fix_in_frame()\n        surface_text.to_edge(UP)\n        self.add(surface_text)\n        self.wait(0.1)\n\n        torus1 = Torus(r1=1, r2=1)\n        torus2 = Torus(r1=3, r2=1)\n        sphere = Sphere(radius=3, resolution=torus1.resolution)\n        # You can texture a surface with up to two images, which will\n        # be interpreted as the side towards the light, and away from\n        # the light.  These can be either urls, or paths to a local file\n        # in whatever you've set as the image directory in\n        # the custom_config.yml file\n\n        # day_texture = \"EarthTextureMap\"\n        # night_texture = \"NightEarthTextureMap\"\n        day_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\n        night_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\n\n        surfaces = [\n            TexturedSurface(surface, day_texture, night_texture)\n            for surface in [sphere, torus1, torus2]\n        ]\n\n        for mob in surfaces:\n            mob.shift(IN)\n            mob.mesh = SurfaceMesh(mob)\n            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)\n\n        # Set perspective\n        frame = self.camera.frame\n        frame.set_euler_angles(\n            theta=-30 * DEGREES,\n            phi=70 * DEGREES,\n        )\n\n        surface = surfaces[0]\n\n        self.play(\n            FadeIn(surface),\n            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),\n        )\n        for mob in surfaces:\n            mob.add(mob.mesh)\n        surface.save_state()\n        self.play(Rotate(surface, PI / 2), run_time=2)\n        for mob in surfaces[1:]:\n            mob.rotate(PI / 2)\n\n        self.play(\n            Transform(surface, surfaces[1]),\n            run_time=3\n        )\n\n        self.play(\n            Transform(surface, surfaces[2]),\n            # Move camera frame during the transition\n            frame.animate.increment_phi(-10 * DEGREES),\n            frame.animate.increment_theta(-20 * DEGREES),\n            run_time=3\n        )\n        # Add ambient rotation\n        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))\n\n        # Play around with where the light is\n        light_text = Text(\"You can move around the light source\")\n        light_text.move_to(surface_text)\n        light_text.fix_in_frame()\n\n        self.play(FadeTransform(surface_text, light_text))\n        light = self.camera.light_source\n        self.add(light)\n        light.save_state()\n        self.play(light.animate.move_to(3 * IN), run_time=5)\n        self.play(light.animate.shift(10 * OUT), run_time=5)\n\n        drag_text = Text(\"Try moving the mouse while pressing d or s\")\n        drag_text.move_to(light_text)\n        drag_text.fix_in_frame()\n\n        self.play(FadeTransform(light_text, drag_text))\n        self.wait()",
      ".fix_in_frame()",
      "class OpeningManimExample(Scene):\n    def construct(self):\n        intro_words = Text(\"\"\"\n            The original motivation for manim was to\n            better illustrate mathematical functions\n            as transformations.\n        \"\"\")\n        intro_words.to_edge(UP)\n\n        self.play(Write(intro_words))\n        self.wait(2)\n\n        # Linear transform\n        grid = NumberPlane((-10, 10), (-5, 5))\n        matrix = [[1, 1], [0, 1]]\n        linear_transform_words = VGroup(\n            Text(\"This is what the matrix\"),\n            IntegerMatrix(matrix, include_background_rectangle=True),\n            Text(\"looks like\")\n        )\n        linear_transform_words.arrange(RIGHT)\n        linear_transform_words.to_edge(UP)\n        linear_transform_words.set_stroke(BLACK, 10, background=True)\n\n        self.play(\n            ShowCreation(grid),\n            FadeTransform(intro_words, linear_transform_words)\n        )\n        self.wait()\n        self.play(grid.animate.apply_matrix(matrix), run_time=3)\n        self.wait()\n\n        # Complex map\n        c_grid = ComplexPlane()\n        moving_c_grid = c_grid.copy()\n        moving_c_grid.prepare_for_nonlinear_transform()\n        c_grid.set_stroke(BLUE_E, 1)\n        c_grid.add_coordinate_labels(font_size=24)\n        complex_map_words = TexText(\"\"\"\n            Or thinking of the plane as $\\\\mathds{C}$,\\\\\\\\\n            this is the map $z \\\\rightarrow z^2$\n        \"\"\")\n        complex_map_words.to_corner(UR)\n        complex_map_words.set_stroke(BLACK, 5, background=True)\n\n        self.play(\n            FadeOut(grid),\n            Write(c_grid, run_time=3),\n            FadeIn(moving_c_grid),\n            FadeTransform(linear_transform_words, complex_map_words),\n        )\n        self.wait()\n        self.play(\n            moving_c_grid.animate.apply_complex_function(lambda z: z**2),\n            run_time=6,\n        )\n        self.wait(2)"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#example-scenes",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevelopment",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample"
    ],
    "scraped_at": 1752428848.657334
  },
  "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample": {
    "url": "https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample",
    "title": "Example Scenes - manim  documentation",
    "content": "Example Scenes\n¶\nAfter understanding the previous knowledge, we can understand more scenes.\nMany example scenes are given in\nexample_scenes.py\n, let’s start with\nthe simplest and one by one.\nInteractiveDevlopment\n¶\nInteractiveDevelopment\n¶\nfrom\nmanimlib\nimport\n*\nclass\nInteractiveDevelopment\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nsquare\n=\nSquare\n()\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nself\n.\nwait\n()\n# This opens an iPython terminal where you can keep writing\n# lines as if they were part of this construct method.\n# In particular, 'square', 'circle' and 'self' will all be\n# part of the local namespace in that terminal.\nself\n.\nembed\n()\n# Try copying and pasting some of the lines below into\n# the interactive shell\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nstretch\n(\n4\n,\n0\n))\nself\n.\nplay\n(\nRotate\n(\ncircle\n,\n90\n*\nDEGREES\n))\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nshift\n(\n2\n*\nRIGHT\n)\n.\nscale\n(\n0.25\n))\ntext\n=\nText\n(\n\"\"\"\nIn general, using the interactive shell\nis very helpful when developing new scenes\n\"\"\"\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\n# In the interactive shell, you can just type\n# play, add, remove, clear, wait, save_state and restore,\n# instead of self.play, self.add, self.remove, etc.\n# To interact with the window, type touch().  You can then\n# scroll in the window, or zoom by holding down 'z' while scrolling,\n# and change camera perspective by holding down 'd' while moving\n# the mouse.  Press 'r' to reset to the standard camera position.\n# Press 'q' to stop interacting with the window and go back to\n# typing new commands into the shell.\n# In principle you can customize a scene to be responsive to\n# mouse and keyboard interactions\nalways\n(\ncircle\n.\nmove_to\n,\nself\n.\nmouse_point\n)\nThis scene is similar to what we wrote in\nQuick Start\n.\nAnd how to interact has been written in the comments.\nNo more explanation here.\nAnimatingMethods\n¶\nAnimatingMethods\n¶\nclass\nAnimatingMethods\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ngrid\n=\nOldTex\n(\nr\n\"\\pi\"\n)\n.\nget_grid\n(\n10\n,\n10\n,\nheight\n=\n4\n)\nself\n.\nadd\n(\ngrid\n)\n# You can animate the application of mobject methods with the\n# \".animate\" syntax:\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nshift\n(\nLEFT\n))\n# Alternatively, you can use the older syntax by passing the\n# method and then the arguments to the scene's \"play\" function:\nself\n.\nplay\n(\ngrid\n.\nshift\n,\nLEFT\n)\n# Both of those will interpolate between the mobject's initial\n# state and whatever happens when you apply that method.\n# For this example, calling grid.shift(LEFT) would shift the\n# grid one unit to the left, but both of the previous calls to\n# \"self.play\" animate that motion.\n# The same applies for any method, including those setting colors.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_color\n(\nYELLOW\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_submobject_colors_by_gradient\n(\nBLUE\n,\nGREEN\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_height\n(\nTAU\n-\nMED_SMALL_BUFF\n))\nself\n.\nwait\n()\n# The method Mobject.apply_complex_function lets you apply arbitrary\n# complex functions, treating the points defining the mobject as\n# complex numbers.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_complex_function\n(\nnp\n.\nexp\n),\nrun_time\n=\n5\n)\nself\n.\nwait\n()\n# Even more generally, you could apply Mobject.apply_function,\n# which takes in functions form R^3 to R^3\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_function\n(\nlambda\np\n:\n[\np\n[\n0\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n1\n]),\np\n[\n1\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n0\n]),\np\n[\n2\n]\n]\n),\nrun_time\n=\n5\n,\n)\nself\n.\nwait\n()\nThe new usage in this scene is\n.get_grid()\nand\nself.play(mob.animate.method(args))\n.\n.get_grid()\nmethod will return a new mobject containing multiple copies of this one arranged in a grid.\nself.play(mob.animate.method(args))\nanimates the method, and the details are in the comments above.\nTextExample\n¶\nTextExample\n¶\nclass\nTextExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\n# To run this scene properly, you should have \"Consolas\" font in your computer\n# for full usage, you can see https://github.com/3b1b/manim/pull/680\ntext\n=\nText\n(\n\"Here is a text\"\n,\nfont\n=\n\"Consolas\"\n,\nfont_size\n=\n90\n)\ndifference\n=\nText\n(\n\"\"\"\nThe most important difference between Text and TexText is that\\n\nyou can change the font more easily, but can't use the LaTeX grammar\n\"\"\"\n,\nfont\n=\n\"Arial\"\n,\nfont_size\n=\n24\n,\n# t2c is a dict that you can choose color for different text\nt2c\n=\n{\n\"Text\"\n:\nBLUE\n,\n\"TexText\"\n:\nBLUE\n,\n\"LaTeX\"\n:\nORANGE\n}\n)\nVGroup\n(\ntext\n,\ndifference\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\nself\n.\nplay\n(\nFadeIn\n(\ndifference\n,\nUP\n))\nself\n.\nwait\n(\n3\n)\nfonts\n=\nText\n(\n\"And you can also set the font according to different words\"\n,\nfont\n=\n\"Arial\"\n,\nt2f\n=\n{\n\"font\"\n:\n\"Consolas\"\n,\n\"words\"\n:\n\"Consolas\"\n},\nt2c\n=\n{\n\"font\"\n:\nBLUE\n,\n\"words\"\n:\nGREEN\n}\n)\nfonts\n.\nset_width\n(\nFRAME_WIDTH\n-\n1\n)\nslant\n=\nText\n(\n\"And the same as slant and weight\"\n,\nfont\n=\n\"Consolas\"\n,\nt2s\n=\n{\n\"slant\"\n:\nITALIC\n},\nt2w\n=\n{\n\"weight\"\n:\nBOLD\n},\nt2c\n=\n{\n\"slant\"\n:\nORANGE\n,\n\"weight\"\n:\nRED\n}\n)\nVGroup\n(\nfonts\n,\nslant\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n0.8\n)\nself\n.\nplay\n(\nFadeOut\n(\ntext\n),\nFadeOut\n(\ndifference\n,\nshift\n=\nDOWN\n))\nself\n.\nplay\n(\nWrite\n(\nfonts\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nWrite\n(\nslant\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nText\n,\nVGroup\n,\nWrite\n,\nFadeIn\nand\nFadeOut\n.\nText\ncan create text, define fonts, etc. The usage ais clearly reflected in the above examples.\nVGroup\ncan put multiple\nVMobject\ntogether as a whole. In the example, the\n.arrange()\nmethod is called to arrange the sub-mobjects in sequence downward (\nDOWN\n), and the spacing is\nbuff\n.\nWrite\nis an animation that shows similar writing effects.\nFadeIn\nfades the object in, the second parameter indicates the direction of the fade in.\nFadeOut\nfades out the object, the second parameter indicates the direction of the fade out.\nTexTransformExample\n¶\nTexTransformExample\n¶\nclass\nTexTransformExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nto_isolate\n=\n[\n\"B\"\n,\n\"C\"\n,\n\"=\"\n,\n\"(\"\n,\n\")\"\n]\nlines\n=\nVGroup\n(\n# Passing in muliple arguments to Tex will result\n# in the same expression as if those arguments had\n# been joined together, except that the submobject\n# hierarchy of the resulting mobject ensure that the\n# Tex mobject has a subject corresponding to\n# each of these strings.  For example, the Tex mobject\n# below will have 5 subjects, corresponding to the\n# expressions [A^2, +, B^2, =, C^2]\nOldTex\n(\n\"A^2\"\n,\n\"+\"\n,\n\"B^2\"\n,\n\"=\"\n,\n\"C^2\"\n),\n# Likewise here\nOldTex\n(\n\"A^2\"\n,\n\"=\"\n,\n\"C^2\"\n,\n\"-\"\n,\n\"B^2\"\n),\n# Alternatively, you can pass in the keyword argument\n# \"isolate\" with a list of strings that should be out as\n# their own submobject.  So the line below is equivalent\n# to the commented out line below it.\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A^2\"\n,\n*\nto_isolate\n]),\n# OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\nOldTex\n(\n\"A =\n\\\\\nsqrt{(C + B)(C - B)}\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\n)\nlines\n.\narrange\n(\nDOWN\n,\nbuff\n=\nLARGE_BUFF\n)\nfor\nline\nin\nlines\n:\nline\n.\nset_color_by_tex_to_color_map\n({\n\"A\"\n:\nBLUE\n,\n\"B\"\n:\nTEAL\n,\n\"C\"\n:\nGREEN\n,\n})\nplay_kw\n=\n{\n\"run_time\"\n:\n2\n}\nself\n.\nadd\n(\nlines\n[\n0\n])\n# The animation TransformMatchingTex will line up parts\n# of the source and target which have matching tex strings.\n# Here, giving it a little path_arc makes each part sort of\n# rotate into their final positions, which feels appropriate\n# for the idea of rearranging an equation\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n0\n]\n.\ncopy\n(),\nlines\n[\n1\n],\npath_arc\n=\n90\n*\nDEGREES\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# Now, we could try this again on the next line...\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n]),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# ...and this looks nice enough, but since there's no tex\n# in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n# out to nothing while the C and B terms fade in from nothing.\n# If, however, we want the C^2 to go to C, and B^2 to go to B,\n# we can specify that with a key map.\nself\n.\nplay\n(\nFadeOut\n(\nlines\n[\n2\n]))\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n],\nkey_map\n=\n{\n\"C^2\"\n:\n\"C\"\n,\n\"B^2\"\n:\n\"B\"\n,\n}\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# And to finish off, a simple TransformMatchingShapes would work\n# just fine.  But perhaps we want that exponent on A^2 to transform into\n# the square root symbol.  At the moment, lines[2] treats the expression\n# A^2 as a unit, so we might create a new version of the same line which\n# separates out just the A.  This way, when TransformMatchingTex lines up\n# all matching parts, the only mismatch will be between the \"^2\" from\n# new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n# transform_mismatches=True, it will transform this \"^2\" part into\n# the \"\\sqrt\" part.\nnew_line2\n=\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\nnew_line2\n.\nreplace\n(\nlines\n[\n2\n])\nnew_line2\n.\nmatch_style\n(\nlines\n[\n2\n])\nself\n.\nplay\n(\nTransformMatchingTex\n(\nnew_line2\n,\nlines\n[\n3\n],\ntransform_mismatches\n=\nTrue\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n(\n3\n)\nself\n.\nplay\n(\nFadeOut\n(\nlines\n,\nRIGHT\n))\n# Alternatively, if you don't want to think about breaking up\n# the tex strings deliberately, you can TransformMatchingShapes,\n# which will try to line up all pieces of a source mobject with\n# those of a target, regardless of the submobject hierarchy in\n# each one, according to whether those pieces have the same\n# shape (as best it can).\nsource\n=\nText\n(\n\"the morse code\"\n,\nheight\n=\n1\n)\ntarget\n=\nText\n(\n\"here come dots\"\n,\nheight\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\nsource\n))\nself\n.\nwait\n()\nkw\n=\n{\n\"run_time\"\n:\n3\n,\n\"path_arc\"\n:\nPI\n/\n2\n}\nself\n.\nplay\n(\nTransformMatchingShapes\n(\nsource\n,\ntarget\n,\n**\nkw\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nTransformMatchingShapes\n(\ntarget\n,\nsource\n,\n**\nkw\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nTex\n,\nTexText\n,\nTransformMatchingTex\nand\nTransformMatchingShapes\n.\nTex\nuses LaTeX to create mathematical formulas.\nTexText\nuses LaTeX to create text.\nTransformMatchingTeX\nautomatically transforms sub-objects according to the similarities and differences of tex in\nTex\n.\nTransformMatchingShapes\nautomatically transform sub-objects directly based on the similarities and differences of the object point sets.\nUpdatersExample\n¶\nUpdatersExample\n¶\nclass\nUpdatersExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nsquare\n=\nSquare\n()\nsquare\n.\nset_fill\n(\nBLUE_E\n,\n1\n)\n# On all all frames, the constructor Brace(square, UP) will\n# be called, and the mobject brace will set its data to match\n# that of the newly constructed object\nbrace\n=\nalways_redraw\n(\nBrace\n,\nsquare\n,\nUP\n)\ntext\n,\nnumber\n=\nlabel\n=\nVGroup\n(\nText\n(\n\"Width = \"\n),\nDecimalNumber\n(\n0\n,\nshow_ellipsis\n=\nTrue\n,\nnum_decimal_places\n=\n2\n,\ninclude_sign\n=\nTrue\n,\n)\n)\nlabel\n.\narrange\n(\nRIGHT\n)\n# This ensures that the method deicmal.next_to(square)\n# is called on every frame\nalways\n(\nlabel\n.\nnext_to\n,\nbrace\n,\nUP\n)\n# You could also write the following equivalent line\n# label.add_updater(lambda m: m.next_to(brace, UP))\n# If the argument itself might change, you can use f_always,\n# for which the arguments following the initial Mobject method\n# should be functions returning arguments to that method.\n# The following line ensures that decimal.set_value(square.get_y())\n# is called every frame\nf_always\n(\nnumber\n.\nset_value\n,\nsquare\n.\nget_width\n)\n# You could also write the following equivalent line\n# number.add_updater(lambda m: m.set_value(square.get_width()))\nself\n.\nadd\n(\nsquare\n,\nbrace\n,\nlabel\n)\n# Notice that the brace and label track with the square\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nscale\n(\n2\n),\nrate_func\n=\nthere_and_back\n,\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n5\n,\nstretch\n=\nTrue\n),\nrun_time\n=\n3\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# In general, you can alway call Mobject.add_updater, and pass in\n# a function that you want to be called on every frame.  The function\n# should take in either one argument, the mobject, or two arguments,\n# the mobject and the amount of time since the last frame.\nnow\n=\nself\n.\ntime\nw0\n=\nsquare\n.\nget_width\n()\nsquare\n.\nadd_updater\n(\nlambda\nm\n:\nm\n.\nset_width\n(\nw0\n*\nmath\n.\ncos\n(\nself\n.\ntime\n-\nnow\n))\n)\nself\n.\nwait\n(\n4\n*\nPI\n)\nThe new classes and usage in this scene are\nalways_redraw()\n,\nDecimalNumber\n,\n.to_edge()\n,\n.center()\n,\nalways()\n,\nf_always()\n,\n.set_y()\nand\n.add_updater()\n.\nalways_redraw()\nfunction create a new mobject every frame.\nDecimalNumber\nis a variable number, speed it up by breaking it into\nText\ncharacters.\n.to_edge()\nmeans to place the object on the edge of the screen.\n.center()\nmeans to place the object in the center of the screen.\nalways(f,\nx)\nmeans that a certain function (\nf(x)\n) is executed every frame.\nf_always(f,\ng)\nis similar to\nalways\n, executed\nf(g())\nevery frame.\n.set_y()\nmeans to set the ordinate of the object on the screen.\n.add_updater()\nsets an update function for the object. For example:\nmob1.add_updater(lambda\nmob:\nmob.next_to(mob2))\nmeans\nmob1.next_to(mob2)\nis executed every frame.\nCoordinateSystemExample\n¶\nCoordinateSystemExample\n¶\nclass\nCoordinateSystemExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n(\n# x-axis ranges from -1 to 10, with a default step size of 1\nx_range\n=\n(\n-\n1\n,\n10\n),\n# y-axis ranges from -2 to 2 with a step size of 0.5\ny_range\n=\n(\n-\n2\n,\n2\n,\n0.5\n),\n# The axes will be stretched so as to match the specified\n# height and width\nheight\n=\n6\n,\nwidth\n=\n10\n,\n# Axes is made of two NumberLine mobjects.  You can specify\n# their configuration with axis_config\naxis_config\n=\n{\n\"stroke_color\"\n:\nGREY_A\n,\n\"stroke_width\"\n:\n2\n,\n},\n# Alternatively, you can specify configuration for just one\n# of them, like this.\ny_axis_config\n=\n{\n\"include_tip\"\n:\nFalse\n,\n}\n)\n# Keyword arguments of add_coordinate_labels can be used to\n# configure the DecimalNumber mobjects which it creates and\n# adds to the axes\naxes\n.\nadd_coordinate_labels\n(\nfont_size\n=\n20\n,\nnum_decimal_places\n=\n1\n,\n)\nself\n.\nadd\n(\naxes\n)\n# Axes descends from the CoordinateSystem class, meaning\n# you can call call axes.coords_to_point, abbreviated to\n# axes.c2p, to associate a set of coordinates with a point,\n# like so:\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\nc2p\n(\n0\n,\n0\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n5\n,\n0.5\n)))\nself\n.\nwait\n()\n# Similarly, you can call axes.point_to_coords, or axes.p2c\n# print(axes.p2c(dot.get_center()))\n# We can draw lines from the axes to better mark the coordinates\n# of a given point.\n# Here, the always_redraw command means that on each new frame\n# the lines will be redrawn\nh_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_h_line\n(\ndot\n.\nget_left\n()))\nv_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_v_line\n(\ndot\n.\nget_bottom\n()))\nself\n.\nplay\n(\nShowCreation\n(\nh_line\n),\nShowCreation\n(\nv_line\n),\n)\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n-\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n1\n,\n1\n)))\nself\n.\nwait\n()\n# If we tie the dot to a particular set of coordinates, notice\n# that as we move the axes around it respects the coordinate\n# system defined by them.\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\nc2p\n(\n1\n,\n1\n))\nself\n.\nplay\n(\naxes\n.\nanimate\n.\nscale\n(\n0.75\n)\n.\nto_corner\n(\nUL\n),\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nFadeOut\n(\nVGroup\n(\naxes\n,\ndot\n,\nh_line\n,\nv_line\n)))\n# Other coordinate systems you can play around with include\n# ThreeDAxes, NumberPlane, and ComplexPlane.\nGraphExample\n¶\nGraphExample\n¶\nclass\nGraphExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n((\n-\n3\n,\n10\n),\n(\n-\n1\n,\n8\n))\naxes\n.\nadd_coordinate_labels\n()\nself\n.\nplay\n(\nWrite\n(\naxes\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n1\n))\n# Axes.get_graph will return the graph of a function\nsin_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2\n*\nmath\n.\nsin\n(\nx\n),\ncolor\n=\nBLUE\n,\n)\n# By default, it draws it so as to somewhat smoothly interpolate\n# between sampled points (x, f(x)).  If the graph is meant to have\n# a corner, though, you can set use_smoothing to False\nrelu_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\nmax\n(\nx\n,\n0\n),\nuse_smoothing\n=\nFalse\n,\ncolor\n=\nYELLOW\n,\n)\n# For discontinuous functions, you can specify the point of\n# discontinuity so that it does not try to draw over the gap.\nstep_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2.0\nif\nx\n>\n3\nelse\n1.0\n,\ndiscontinuities\n=\n[\n3\n],\ncolor\n=\nGREEN\n,\n)\n# Axes.get_graph_label takes in either a string or a mobject.\n# If it's a string, it treats it as a LaTeX expression.  By default\n# it places the label next to the graph near the right side, and\n# has it match the color of the graph\nsin_label\n=\naxes\n.\nget_graph_label\n(\nsin_graph\n,\n\"\n\\\\\nsin(x)\"\n)\nrelu_label\n=\naxes\n.\nget_graph_label\n(\nrelu_graph\n,\nText\n(\n\"ReLU\"\n))\nstep_label\n=\naxes\n.\nget_graph_label\n(\nstep_graph\n,\nText\n(\n\"Step\"\n),\nx\n=\n4\n)\nself\n.\nplay\n(\nShowCreation\n(\nsin_graph\n),\nFadeIn\n(\nsin_label\n,\nRIGHT\n),\n)\nself\n.\nwait\n(\n2\n)\nself\n.\nplay\n(\nReplacementTransform\n(\nsin_graph\n,\nrelu_graph\n),\nFadeTransform\n(\nsin_label\n,\nrelu_label\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nReplacementTransform\n(\nrelu_graph\n,\nstep_graph\n),\nFadeTransform\n(\nrelu_label\n,\nstep_label\n),\n)\nself\n.\nwait\n()\nparabola\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n0.25\n*\nx\n**\n2\n)\nparabola\n.\nset_stroke\n(\nBLUE\n)\nself\n.\nplay\n(\nFadeOut\n(\nstep_graph\n),\nFadeOut\n(\nstep_label\n),\nShowCreation\n(\nparabola\n)\n)\nself\n.\nwait\n()\n# You can use axes.input_to_graph_point, abbreviated\n# to axes.i2gp, to find a particular point on a graph\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\ni2gp\n(\n2\n,\nparabola\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\n# A value tracker lets us animate a parameter, usually\n# with the intent of having other mobjects update based\n# on the parameter\nx_tracker\n=\nValueTracker\n(\n2\n)\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\ni2gp\n(\nx_tracker\n.\nget_value\n(),\nparabola\n)\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n4\n),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n-\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\nSurfaceExample\n¶\nSurfaceExample\n¶\nclass\nSurfaceExample\n(\nScene\n):\nCONFIG\n=\n{\n\"camera_class\"\n:\nThreeDCamera\n,\n}\ndef\nconstruct\n(\nself\n):\nsurface_text\n=\nText\n(\n\"For 3d scenes, try using surfaces\"\n)\nsurface_text\n.\nfix_in_frame\n()\nsurface_text\n.\nto_edge\n(\nUP\n)\nself\n.\nadd\n(\nsurface_text\n)\nself\n.\nwait\n(\n0.1\n)\ntorus1\n=\nTorus\n(\nr1\n=\n1\n,\nr2\n=\n1\n)\ntorus2\n=\nTorus\n(\nr1\n=\n3\n,\nr2\n=\n1\n)\nsphere\n=\nSphere\n(\nradius\n=\n3\n,\nresolution\n=\ntorus1\n.\nresolution\n)\n# You can texture a surface with up to two images, which will\n# be interpreted as the side towards the light, and away from\n# the light.  These can be either urls, or paths to a local file\n# in whatever you've set as the image directory in\n# the custom_config.yml file\n# day_texture = \"EarthTextureMap\"\n# night_texture = \"NightEarthTextureMap\"\nday_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\nnight_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\nsurfaces\n=\n[\nTexturedSurface\n(\nsurface\n,\nday_texture\n,\nnight_texture\n)\nfor\nsurface\nin\n[\nsphere\n,\ntorus1\n,\ntorus2\n]\n]\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nshift\n(\nIN\n)\nmob\n.\nmesh\n=\nSurfaceMesh\n(\nmob\n)\nmob\n.\nmesh\n.\nset_stroke\n(\nBLUE\n,\n1\n,\nopacity\n=\n0.5\n)\n# Set perspective\nframe\n=\nself\n.\ncamera\n.\nframe\nframe\n.\nset_euler_angles\n(\ntheta\n=-\n30\n*\nDEGREES\n,\nphi\n=\n70\n*\nDEGREES\n,\n)\nsurface\n=\nsurfaces\n[\n0\n]\nself\n.\nplay\n(\nFadeIn\n(\nsurface\n),\nShowCreation\n(\nsurface\n.\nmesh\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n3\n),\n)\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nadd\n(\nmob\n.\nmesh\n)\nsurface\n.\nsave_state\n()\nself\n.\nplay\n(\nRotate\n(\nsurface\n,\nPI\n/\n2\n),\nrun_time\n=\n2\n)\nfor\nmob\nin\nsurfaces\n[\n1\n:]:\nmob\n.\nrotate\n(\nPI\n/\n2\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n1\n]),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n2\n]),\n# Move camera frame during the transition\nframe\n.\nanimate\n.\nincrement_phi\n(\n-\n10\n*\nDEGREES\n),\nframe\n.\nanimate\n.\nincrement_theta\n(\n-\n20\n*\nDEGREES\n),\nrun_time\n=\n3\n)\n# Add ambient rotation\nframe\n.\nadd_updater\n(\nlambda\nm\n,\ndt\n:\nm\n.\nincrement_theta\n(\n-\n0.1\n*\ndt\n))\n# Play around with where the light is\nlight_text\n=\nText\n(\n\"You can move around the light source\"\n)\nlight_text\n.\nmove_to\n(\nsurface_text\n)\nlight_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nsurface_text\n,\nlight_text\n))\nlight\n=\nself\n.\ncamera\n.\nlight_source\nself\n.\nadd\n(\nlight\n)\nlight\n.\nsave_state\n()\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nmove_to\n(\n3\n*\nIN\n),\nrun_time\n=\n5\n)\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nshift\n(\n10\n*\nOUT\n),\nrun_time\n=\n5\n)\ndrag_text\n=\nText\n(\n\"Try moving the mouse while pressing d or s\"\n)\ndrag_text\n.\nmove_to\n(\nlight_text\n)\ndrag_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nlight_text\n,\ndrag_text\n))\nself\n.\nwait\n()\nThis scene shows an example of using a three-dimensional surface, and\nthe related usage has been briefly described in the notes.\n.fix_in_frame()\nmakes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.\nOpeningManimExample\n¶\nOpeningManimExample\n¶\nclass\nOpeningManimExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nintro_words\n=\nText\n(\n\"\"\"\nThe original motivation for manim was to\nbetter illustrate mathematical functions\nas transformations.\n\"\"\"\n)\nintro_words\n.\nto_edge\n(\nUP\n)\nself\n.\nplay\n(\nWrite\n(\nintro_words\n))\nself\n.\nwait\n(\n2\n)\n# Linear transform\ngrid\n=\nNumberPlane\n((\n-\n10\n,\n10\n),\n(\n-\n5\n,\n5\n))\nmatrix\n=\n[[\n1\n,\n1\n],\n[\n0\n,\n1\n]]\nlinear_transform_words\n=\nVGroup\n(\nText\n(\n\"This is what the matrix\"\n),\nIntegerMatrix\n(\nmatrix\n,\ninclude_background_rectangle\n=\nTrue\n),\nText\n(\n\"looks like\"\n)\n)\nlinear_transform_words\n.\narrange\n(\nRIGHT\n)\nlinear_transform_words\n.\nto_edge\n(\nUP\n)\nlinear_transform_words\n.\nset_stroke\n(\nBLACK\n,\n10\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nShowCreation\n(\ngrid\n),\nFadeTransform\n(\nintro_words\n,\nlinear_transform_words\n)\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_matrix\n(\nmatrix\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# Complex map\nc_grid\n=\nComplexPlane\n()\nmoving_c_grid\n=\nc_grid\n.\ncopy\n()\nmoving_c_grid\n.\nprepare_for_nonlinear_transform\n()\nc_grid\n.\nset_stroke\n(\nBLUE_E\n,\n1\n)\nc_grid\n.\nadd_coordinate_labels\n(\nfont_size\n=\n24\n)\ncomplex_map_words\n=\nTexText\n(\n\"\"\"\nOr thinking of the plane as $\n\\\\\nmathds\n{C}\n$,\n\\\\\\\\\nthis is the map $z\n\\\\\nrightarrow z^2$\n\"\"\"\n)\ncomplex_map_words\n.\nto_corner\n(\nUR\n)\ncomplex_map_words\n.\nset_stroke\n(\nBLACK\n,\n5\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nFadeOut\n(\ngrid\n),\nWrite\n(\nc_grid\n,\nrun_time\n=\n3\n),\nFadeIn\n(\nmoving_c_grid\n),\nFadeTransform\n(\nlinear_transform_words\n,\ncomplex_map_words\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nmoving_c_grid\n.\nanimate\n.\napply_complex_function\n(\nlambda\nz\n:\nz\n**\n2\n),\nrun_time\n=\n6\n,\n)\nself\n.\nwait\n(\n2\n)\nThis scene is a comprehensive application of a two-dimensional scene.\nAfter seeing these scenes, you have already understood part of the\nusage of manim. For more examples, see\nthe video code of 3b1b\n.\nContents\nExample Scenes\nInteractiveDevlopment\nAnimatingMethods\nTextExample\nTexTransformExample\nUpdatersExample\nCoordinateSystemExample\nGraphExample\nSurfaceExample\nOpeningManimExample",
    "code_examples": [
      "example_scenes.py",
      "from manimlib import *\n\nclass InteractiveDevelopment(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n\n        # This opens an iPython terminal where you can keep writing\n        # lines as if they were part of this construct method.\n        # In particular, 'square', 'circle' and 'self' will all be\n        # part of the local namespace in that terminal.\n        self.embed()\n\n        # Try copying and pasting some of the lines below into\n        # the interactive shell\n        self.play(ReplacementTransform(square, circle))\n        self.wait()\n        self.play(circle.animate.stretch(4, 0))\n        self.play(Rotate(circle, 90 * DEGREES))\n        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))\n\n        text = Text(\"\"\"\n            In general, using the interactive shell\n            is very helpful when developing new scenes\n        \"\"\")\n        self.play(Write(text))\n\n        # In the interactive shell, you can just type\n        # play, add, remove, clear, wait, save_state and restore,\n        # instead of self.play, self.add, self.remove, etc.\n\n        # To interact with the window, type touch().  You can then\n        # scroll in the window, or zoom by holding down 'z' while scrolling,\n        # and change camera perspective by holding down 'd' while moving\n        # the mouse.  Press 'r' to reset to the standard camera position.\n        # Press 'q' to stop interacting with the window and go back to\n        # typing new commands into the shell.\n\n        # In principle you can customize a scene to be responsive to\n        # mouse and keyboard interactions\n        always(circle.move_to, self.mouse_point)",
      "class AnimatingMethods(Scene):\n    def construct(self):\n        grid = OldTex(r\"\\pi\").get_grid(10, 10, height=4)\n        self.add(grid)\n\n        # You can animate the application of mobject methods with the\n        # \".animate\" syntax:\n        self.play(grid.animate.shift(LEFT))\n\n        # Alternatively, you can use the older syntax by passing the\n        # method and then the arguments to the scene's \"play\" function:\n        self.play(grid.shift, LEFT)\n\n        # Both of those will interpolate between the mobject's initial\n        # state and whatever happens when you apply that method.\n        # For this example, calling grid.shift(LEFT) would shift the\n        # grid one unit to the left, but both of the previous calls to\n        # \"self.play\" animate that motion.\n\n        # The same applies for any method, including those setting colors.\n        self.play(grid.animate.set_color(YELLOW))\n        self.wait()\n        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))\n        self.wait()\n        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))\n        self.wait()\n\n        # The method Mobject.apply_complex_function lets you apply arbitrary\n        # complex functions, treating the points defining the mobject as\n        # complex numbers.\n        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)\n        self.wait()\n\n        # Even more generally, you could apply Mobject.apply_function,\n        # which takes in functions form R^3 to R^3\n        self.play(\n            grid.animate.apply_function(\n                lambda p: [\n                    p[0] + 0.5 * math.sin(p[1]),\n                    p[1] + 0.5 * math.sin(p[0]),\n                    p[2]\n                ]\n            ),\n            run_time=5,\n        )\n        self.wait()",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      "class TextExample(Scene):\n    def construct(self):\n        # To run this scene properly, you should have \"Consolas\" font in your computer\n        # for full usage, you can see https://github.com/3b1b/manim/pull/680\n        text = Text(\"Here is a text\", font=\"Consolas\", font_size=90)\n        difference = Text(\n            \"\"\"\n            The most important difference between Text and TexText is that\\n\n            you can change the font more easily, but can't use the LaTeX grammar\n            \"\"\",\n            font=\"Arial\", font_size=24,\n            # t2c is a dict that you can choose color for different text\n            t2c={\"Text\": BLUE, \"TexText\": BLUE, \"LaTeX\": ORANGE}\n        )\n        VGroup(text, difference).arrange(DOWN, buff=1)\n        self.play(Write(text))\n        self.play(FadeIn(difference, UP))\n        self.wait(3)\n\n        fonts = Text(\n            \"And you can also set the font according to different words\",\n            font=\"Arial\",\n            t2f={\"font\": \"Consolas\", \"words\": \"Consolas\"},\n            t2c={\"font\": BLUE, \"words\": GREEN}\n        )\n        fonts.set_width(FRAME_WIDTH - 1)\n        slant = Text(\n            \"And the same as slant and weight\",\n            font=\"Consolas\",\n            t2s={\"slant\": ITALIC},\n            t2w={\"weight\": BOLD},\n            t2c={\"slant\": ORANGE, \"weight\": RED}\n        )\n        VGroup(fonts, slant).arrange(DOWN, buff=0.8)\n        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))\n        self.play(Write(fonts))\n        self.wait()\n        self.play(Write(slant))\n        self.wait()",
      "class TexTransformExample(Scene):\n    def construct(self):\n        to_isolate = [\"B\", \"C\", \"=\", \"(\", \")\"]\n        lines = VGroup(\n            # Passing in muliple arguments to Tex will result\n            # in the same expression as if those arguments had\n            # been joined together, except that the submobject\n            # hierarchy of the resulting mobject ensure that the\n            # Tex mobject has a subject corresponding to\n            # each of these strings.  For example, the Tex mobject\n            # below will have 5 subjects, corresponding to the\n            # expressions [A^2, +, B^2, =, C^2]\n            OldTex(\"A^2\", \"+\", \"B^2\", \"=\", \"C^2\"),\n            # Likewise here\n            OldTex(\"A^2\", \"=\", \"C^2\", \"-\", \"B^2\"),\n            # Alternatively, you can pass in the keyword argument\n            # \"isolate\" with a list of strings that should be out as\n            # their own submobject.  So the line below is equivalent\n            # to the commented out line below it.\n            OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A^2\", *to_isolate]),\n            # OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\n            OldTex(\"A = \\\\sqrt{(C + B)(C - B)}\", isolate=[\"A\", *to_isolate])\n        )\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        for line in lines:\n            line.set_color_by_tex_to_color_map({\n                \"A\": BLUE,\n                \"B\": TEAL,\n                \"C\": GREEN,\n            })\n\n        play_kw = {\"run_time\": 2}\n        self.add(lines[0])\n        # The animation TransformMatchingTex will line up parts\n        # of the source and target which have matching tex strings.\n        # Here, giving it a little path_arc makes each part sort of\n        # rotate into their final positions, which feels appropriate\n        # for the idea of rearranging an equation\n        self.play(\n            TransformMatchingTex(\n                lines[0].copy(), lines[1],\n                path_arc=90 * DEGREES,\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # Now, we could try this again on the next line...\n        self.play(\n            TransformMatchingTex(lines[1].copy(), lines[2]),\n            **play_kw\n        )\n        self.wait()\n        # ...and this looks nice enough, but since there's no tex\n        # in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n        # out to nothing while the C and B terms fade in from nothing.\n        # If, however, we want the C^2 to go to C, and B^2 to go to B,\n        # we can specify that with a key map.\n        self.play(FadeOut(lines[2]))\n        self.play(\n            TransformMatchingTex(\n                lines[1].copy(), lines[2],\n                key_map={\n                    \"C^2\": \"C\",\n                    \"B^2\": \"B\",\n                }\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # And to finish off, a simple TransformMatchingShapes would work\n        # just fine.  But perhaps we want that exponent on A^2 to transform into\n        # the square root symbol.  At the moment, lines[2] treats the expression\n        # A^2 as a unit, so we might create a new version of the same line which\n        # separates out just the A.  This way, when TransformMatchingTex lines up\n        # all matching parts, the only mismatch will be between the \"^2\" from\n        # new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n        # transform_mismatches=True, it will transform this \"^2\" part into\n        # the \"\\sqrt\" part.\n        new_line2 = OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A\", *to_isolate])\n        new_line2.replace(lines[2])\n        new_line2.match_style(lines[2])\n\n        self.play(\n            TransformMatchingTex(\n                new_line2, lines[3],\n                transform_mismatches=True,\n            ),\n            **play_kw\n        )\n        self.wait(3)\n        self.play(FadeOut(lines, RIGHT))\n\n        # Alternatively, if you don't want to think about breaking up\n        # the tex strings deliberately, you can TransformMatchingShapes,\n        # which will try to line up all pieces of a source mobject with\n        # those of a target, regardless of the submobject hierarchy in\n        # each one, according to whether those pieces have the same\n        # shape (as best it can).\n        source = Text(\"the morse code\", height=1)\n        target = Text(\"here come dots\", height=1)\n\n        self.play(Write(source))\n        self.wait()\n        kw = {\"run_time\": 3, \"path_arc\": PI / 2}\n        self.play(TransformMatchingShapes(source, target, **kw))\n        self.wait()\n        self.play(TransformMatchingShapes(target, source, **kw))\n        self.wait()",
      "TransformMatchingTex",
      "TransformMatchingShapes",
      "TransformMatchingTeX",
      "TransformMatchingShapes",
      "class UpdatersExample(Scene):\n    def construct(self):\n        square = Square()\n        square.set_fill(BLUE_E, 1)\n\n        # On all all frames, the constructor Brace(square, UP) will\n        # be called, and the mobject brace will set its data to match\n        # that of the newly constructed object\n        brace = always_redraw(Brace, square, UP)\n\n        text, number = label = VGroup(\n            Text(\"Width = \"),\n            DecimalNumber(\n                0,\n                show_ellipsis=True,\n                num_decimal_places=2,\n                include_sign=True,\n            )\n        )\n        label.arrange(RIGHT)\n\n        # This ensures that the method deicmal.next_to(square)\n        # is called on every frame\n        always(label.next_to, brace, UP)\n        # You could also write the following equivalent line\n        # label.add_updater(lambda m: m.next_to(brace, UP))\n\n        # If the argument itself might change, you can use f_always,\n        # for which the arguments following the initial Mobject method\n        # should be functions returning arguments to that method.\n        # The following line ensures that decimal.set_value(square.get_y())\n        # is called every frame\n        f_always(number.set_value, square.get_width)\n        # You could also write the following equivalent line\n        # number.add_updater(lambda m: m.set_value(square.get_width()))\n\n        self.add(square, brace, label)\n\n        # Notice that the brace and label track with the square\n        self.play(\n            square.animate.scale(2),\n            rate_func=there_and_back,\n            run_time=2,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(5, stretch=True),\n            run_time=3,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(2),\n            run_time=3\n        )\n        self.wait()\n\n        # In general, you can alway call Mobject.add_updater, and pass in\n        # a function that you want to be called on every frame.  The function\n        # should take in either one argument, the mobject, or two arguments,\n        # the mobject and the amount of time since the last frame.\n        now = self.time\n        w0 = square.get_width()\n        square.add_updater(\n            lambda m: m.set_width(w0 * math.cos(self.time - now))\n        )\n        self.wait(4 * PI)",
      "always_redraw()",
      "DecimalNumber",
      ".add_updater()",
      "always_redraw()",
      "DecimalNumber",
      "always(f, x)",
      "f_always(f, g)",
      ".add_updater()",
      "mob1.add_updater(lambda mob: mob.next_to(mob2))",
      "mob1.next_to(mob2)",
      "class CoordinateSystemExample(Scene):\n    def construct(self):\n        axes = Axes(\n            # x-axis ranges from -1 to 10, with a default step size of 1\n            x_range=(-1, 10),\n            # y-axis ranges from -2 to 2 with a step size of 0.5\n            y_range=(-2, 2, 0.5),\n            # The axes will be stretched so as to match the specified\n            # height and width\n            height=6,\n            width=10,\n            # Axes is made of two NumberLine mobjects.  You can specify\n            # their configuration with axis_config\n            axis_config={\n                \"stroke_color\": GREY_A,\n                \"stroke_width\": 2,\n            },\n            # Alternatively, you can specify configuration for just one\n            # of them, like this.\n            y_axis_config={\n                \"include_tip\": False,\n            }\n        )\n        # Keyword arguments of add_coordinate_labels can be used to\n        # configure the DecimalNumber mobjects which it creates and\n        # adds to the axes\n        axes.add_coordinate_labels(\n            font_size=20,\n            num_decimal_places=1,\n        )\n        self.add(axes)\n\n        # Axes descends from the CoordinateSystem class, meaning\n        # you can call call axes.coords_to_point, abbreviated to\n        # axes.c2p, to associate a set of coordinates with a point,\n        # like so:\n        dot = Dot(color=RED)\n        dot.move_to(axes.c2p(0, 0))\n        self.play(FadeIn(dot, scale=0.5))\n        self.play(dot.animate.move_to(axes.c2p(3, 2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))\n        self.wait()\n\n        # Similarly, you can call axes.point_to_coords, or axes.p2c\n        # print(axes.p2c(dot.get_center()))\n\n        # We can draw lines from the axes to better mark the coordinates\n        # of a given point.\n        # Here, the always_redraw command means that on each new frame\n        # the lines will be redrawn\n        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))\n        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))\n\n        self.play(\n            ShowCreation(h_line),\n            ShowCreation(v_line),\n        )\n        self.play(dot.animate.move_to(axes.c2p(3, -2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(1, 1)))\n        self.wait()\n\n        # If we tie the dot to a particular set of coordinates, notice\n        # that as we move the axes around it respects the coordinate\n        # system defined by them.\n        f_always(dot.move_to, lambda: axes.c2p(1, 1))\n        self.play(\n            axes.animate.scale(0.75).to_corner(UL),\n            run_time=2,\n        )\n        self.wait()\n        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))\n\n        # Other coordinate systems you can play around with include\n        # ThreeDAxes, NumberPlane, and ComplexPlane.",
      "class GraphExample(Scene):\n    def construct(self):\n        axes = Axes((-3, 10), (-1, 8))\n        axes.add_coordinate_labels()\n\n        self.play(Write(axes, lag_ratio=0.01, run_time=1))\n\n        # Axes.get_graph will return the graph of a function\n        sin_graph = axes.get_graph(\n            lambda x: 2 * math.sin(x),\n            color=BLUE,\n        )\n        # By default, it draws it so as to somewhat smoothly interpolate\n        # between sampled points (x, f(x)).  If the graph is meant to have\n        # a corner, though, you can set use_smoothing to False\n        relu_graph = axes.get_graph(\n            lambda x: max(x, 0),\n            use_smoothing=False,\n            color=YELLOW,\n        )\n        # For discontinuous functions, you can specify the point of\n        # discontinuity so that it does not try to draw over the gap.\n        step_graph = axes.get_graph(\n            lambda x: 2.0 if x > 3 else 1.0,\n            discontinuities=[3],\n            color=GREEN,\n        )\n\n        # Axes.get_graph_label takes in either a string or a mobject.\n        # If it's a string, it treats it as a LaTeX expression.  By default\n        # it places the label next to the graph near the right side, and\n        # has it match the color of the graph\n        sin_label = axes.get_graph_label(sin_graph, \"\\\\sin(x)\")\n        relu_label = axes.get_graph_label(relu_graph, Text(\"ReLU\"))\n        step_label = axes.get_graph_label(step_graph, Text(\"Step\"), x=4)\n\n        self.play(\n            ShowCreation(sin_graph),\n            FadeIn(sin_label, RIGHT),\n        )\n        self.wait(2)\n        self.play(\n            ReplacementTransform(sin_graph, relu_graph),\n            FadeTransform(sin_label, relu_label),\n        )\n        self.wait()\n        self.play(\n            ReplacementTransform(relu_graph, step_graph),\n            FadeTransform(relu_label, step_label),\n        )\n        self.wait()\n\n        parabola = axes.get_graph(lambda x: 0.25 * x**2)\n        parabola.set_stroke(BLUE)\n        self.play(\n            FadeOut(step_graph),\n            FadeOut(step_label),\n            ShowCreation(parabola)\n        )\n        self.wait()\n\n        # You can use axes.input_to_graph_point, abbreviated\n        # to axes.i2gp, to find a particular point on a graph\n        dot = Dot(color=RED)\n        dot.move_to(axes.i2gp(2, parabola))\n        self.play(FadeIn(dot, scale=0.5))\n\n        # A value tracker lets us animate a parameter, usually\n        # with the intent of having other mobjects update based\n        # on the parameter\n        x_tracker = ValueTracker(2)\n        f_always(\n            dot.move_to,\n            lambda: axes.i2gp(x_tracker.get_value(), parabola)\n        )\n\n        self.play(x_tracker.animate.set_value(4), run_time=3)\n        self.play(x_tracker.animate.set_value(-2), run_time=3)\n        self.wait()",
      "class SurfaceExample(Scene):\n    CONFIG = {\n        \"camera_class\": ThreeDCamera,\n    }\n\n    def construct(self):\n        surface_text = Text(\"For 3d scenes, try using surfaces\")\n        surface_text.fix_in_frame()\n        surface_text.to_edge(UP)\n        self.add(surface_text)\n        self.wait(0.1)\n\n        torus1 = Torus(r1=1, r2=1)\n        torus2 = Torus(r1=3, r2=1)\n        sphere = Sphere(radius=3, resolution=torus1.resolution)\n        # You can texture a surface with up to two images, which will\n        # be interpreted as the side towards the light, and away from\n        # the light.  These can be either urls, or paths to a local file\n        # in whatever you've set as the image directory in\n        # the custom_config.yml file\n\n        # day_texture = \"EarthTextureMap\"\n        # night_texture = \"NightEarthTextureMap\"\n        day_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\n        night_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\n\n        surfaces = [\n            TexturedSurface(surface, day_texture, night_texture)\n            for surface in [sphere, torus1, torus2]\n        ]\n\n        for mob in surfaces:\n            mob.shift(IN)\n            mob.mesh = SurfaceMesh(mob)\n            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)\n\n        # Set perspective\n        frame = self.camera.frame\n        frame.set_euler_angles(\n            theta=-30 * DEGREES,\n            phi=70 * DEGREES,\n        )\n\n        surface = surfaces[0]\n\n        self.play(\n            FadeIn(surface),\n            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),\n        )\n        for mob in surfaces:\n            mob.add(mob.mesh)\n        surface.save_state()\n        self.play(Rotate(surface, PI / 2), run_time=2)\n        for mob in surfaces[1:]:\n            mob.rotate(PI / 2)\n\n        self.play(\n            Transform(surface, surfaces[1]),\n            run_time=3\n        )\n\n        self.play(\n            Transform(surface, surfaces[2]),\n            # Move camera frame during the transition\n            frame.animate.increment_phi(-10 * DEGREES),\n            frame.animate.increment_theta(-20 * DEGREES),\n            run_time=3\n        )\n        # Add ambient rotation\n        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))\n\n        # Play around with where the light is\n        light_text = Text(\"You can move around the light source\")\n        light_text.move_to(surface_text)\n        light_text.fix_in_frame()\n\n        self.play(FadeTransform(surface_text, light_text))\n        light = self.camera.light_source\n        self.add(light)\n        light.save_state()\n        self.play(light.animate.move_to(3 * IN), run_time=5)\n        self.play(light.animate.shift(10 * OUT), run_time=5)\n\n        drag_text = Text(\"Try moving the mouse while pressing d or s\")\n        drag_text.move_to(light_text)\n        drag_text.fix_in_frame()\n\n        self.play(FadeTransform(light_text, drag_text))\n        self.wait()",
      ".fix_in_frame()",
      "class OpeningManimExample(Scene):\n    def construct(self):\n        intro_words = Text(\"\"\"\n            The original motivation for manim was to\n            better illustrate mathematical functions\n            as transformations.\n        \"\"\")\n        intro_words.to_edge(UP)\n\n        self.play(Write(intro_words))\n        self.wait(2)\n\n        # Linear transform\n        grid = NumberPlane((-10, 10), (-5, 5))\n        matrix = [[1, 1], [0, 1]]\n        linear_transform_words = VGroup(\n            Text(\"This is what the matrix\"),\n            IntegerMatrix(matrix, include_background_rectangle=True),\n            Text(\"looks like\")\n        )\n        linear_transform_words.arrange(RIGHT)\n        linear_transform_words.to_edge(UP)\n        linear_transform_words.set_stroke(BLACK, 10, background=True)\n\n        self.play(\n            ShowCreation(grid),\n            FadeTransform(intro_words, linear_transform_words)\n        )\n        self.wait()\n        self.play(grid.animate.apply_matrix(matrix), run_time=3)\n        self.wait()\n\n        # Complex map\n        c_grid = ComplexPlane()\n        moving_c_grid = c_grid.copy()\n        moving_c_grid.prepare_for_nonlinear_transform()\n        c_grid.set_stroke(BLUE_E, 1)\n        c_grid.add_coordinate_labels(font_size=24)\n        complex_map_words = TexText(\"\"\"\n            Or thinking of the plane as $\\\\mathds{C}$,\\\\\\\\\n            this is the map $z \\\\rightarrow z^2$\n        \"\"\")\n        complex_map_words.to_corner(UR)\n        complex_map_words.set_stroke(BLACK, 5, background=True)\n\n        self.play(\n            FadeOut(grid),\n            Write(c_grid, run_time=3),\n            FadeIn(moving_c_grid),\n            FadeTransform(linear_transform_words, complex_map_words),\n        )\n        self.wait()\n        self.play(\n            moving_c_grid.animate.apply_complex_function(lambda z: z**2),\n            run_time=6,\n        )\n        self.wait(2)"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#example-scenes",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevelopment",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample"
    ],
    "scraped_at": 1752428849.8169222
  },
  "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample": {
    "url": "https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample",
    "title": "Example Scenes - manim  documentation",
    "content": "Example Scenes\n¶\nAfter understanding the previous knowledge, we can understand more scenes.\nMany example scenes are given in\nexample_scenes.py\n, let’s start with\nthe simplest and one by one.\nInteractiveDevlopment\n¶\nInteractiveDevelopment\n¶\nfrom\nmanimlib\nimport\n*\nclass\nInteractiveDevelopment\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nsquare\n=\nSquare\n()\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nself\n.\nwait\n()\n# This opens an iPython terminal where you can keep writing\n# lines as if they were part of this construct method.\n# In particular, 'square', 'circle' and 'self' will all be\n# part of the local namespace in that terminal.\nself\n.\nembed\n()\n# Try copying and pasting some of the lines below into\n# the interactive shell\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nstretch\n(\n4\n,\n0\n))\nself\n.\nplay\n(\nRotate\n(\ncircle\n,\n90\n*\nDEGREES\n))\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nshift\n(\n2\n*\nRIGHT\n)\n.\nscale\n(\n0.25\n))\ntext\n=\nText\n(\n\"\"\"\nIn general, using the interactive shell\nis very helpful when developing new scenes\n\"\"\"\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\n# In the interactive shell, you can just type\n# play, add, remove, clear, wait, save_state and restore,\n# instead of self.play, self.add, self.remove, etc.\n# To interact with the window, type touch().  You can then\n# scroll in the window, or zoom by holding down 'z' while scrolling,\n# and change camera perspective by holding down 'd' while moving\n# the mouse.  Press 'r' to reset to the standard camera position.\n# Press 'q' to stop interacting with the window and go back to\n# typing new commands into the shell.\n# In principle you can customize a scene to be responsive to\n# mouse and keyboard interactions\nalways\n(\ncircle\n.\nmove_to\n,\nself\n.\nmouse_point\n)\nThis scene is similar to what we wrote in\nQuick Start\n.\nAnd how to interact has been written in the comments.\nNo more explanation here.\nAnimatingMethods\n¶\nAnimatingMethods\n¶\nclass\nAnimatingMethods\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ngrid\n=\nOldTex\n(\nr\n\"\\pi\"\n)\n.\nget_grid\n(\n10\n,\n10\n,\nheight\n=\n4\n)\nself\n.\nadd\n(\ngrid\n)\n# You can animate the application of mobject methods with the\n# \".animate\" syntax:\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nshift\n(\nLEFT\n))\n# Alternatively, you can use the older syntax by passing the\n# method and then the arguments to the scene's \"play\" function:\nself\n.\nplay\n(\ngrid\n.\nshift\n,\nLEFT\n)\n# Both of those will interpolate between the mobject's initial\n# state and whatever happens when you apply that method.\n# For this example, calling grid.shift(LEFT) would shift the\n# grid one unit to the left, but both of the previous calls to\n# \"self.play\" animate that motion.\n# The same applies for any method, including those setting colors.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_color\n(\nYELLOW\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_submobject_colors_by_gradient\n(\nBLUE\n,\nGREEN\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_height\n(\nTAU\n-\nMED_SMALL_BUFF\n))\nself\n.\nwait\n()\n# The method Mobject.apply_complex_function lets you apply arbitrary\n# complex functions, treating the points defining the mobject as\n# complex numbers.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_complex_function\n(\nnp\n.\nexp\n),\nrun_time\n=\n5\n)\nself\n.\nwait\n()\n# Even more generally, you could apply Mobject.apply_function,\n# which takes in functions form R^3 to R^3\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_function\n(\nlambda\np\n:\n[\np\n[\n0\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n1\n]),\np\n[\n1\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n0\n]),\np\n[\n2\n]\n]\n),\nrun_time\n=\n5\n,\n)\nself\n.\nwait\n()\nThe new usage in this scene is\n.get_grid()\nand\nself.play(mob.animate.method(args))\n.\n.get_grid()\nmethod will return a new mobject containing multiple copies of this one arranged in a grid.\nself.play(mob.animate.method(args))\nanimates the method, and the details are in the comments above.\nTextExample\n¶\nTextExample\n¶\nclass\nTextExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\n# To run this scene properly, you should have \"Consolas\" font in your computer\n# for full usage, you can see https://github.com/3b1b/manim/pull/680\ntext\n=\nText\n(\n\"Here is a text\"\n,\nfont\n=\n\"Consolas\"\n,\nfont_size\n=\n90\n)\ndifference\n=\nText\n(\n\"\"\"\nThe most important difference between Text and TexText is that\\n\nyou can change the font more easily, but can't use the LaTeX grammar\n\"\"\"\n,\nfont\n=\n\"Arial\"\n,\nfont_size\n=\n24\n,\n# t2c is a dict that you can choose color for different text\nt2c\n=\n{\n\"Text\"\n:\nBLUE\n,\n\"TexText\"\n:\nBLUE\n,\n\"LaTeX\"\n:\nORANGE\n}\n)\nVGroup\n(\ntext\n,\ndifference\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\nself\n.\nplay\n(\nFadeIn\n(\ndifference\n,\nUP\n))\nself\n.\nwait\n(\n3\n)\nfonts\n=\nText\n(\n\"And you can also set the font according to different words\"\n,\nfont\n=\n\"Arial\"\n,\nt2f\n=\n{\n\"font\"\n:\n\"Consolas\"\n,\n\"words\"\n:\n\"Consolas\"\n},\nt2c\n=\n{\n\"font\"\n:\nBLUE\n,\n\"words\"\n:\nGREEN\n}\n)\nfonts\n.\nset_width\n(\nFRAME_WIDTH\n-\n1\n)\nslant\n=\nText\n(\n\"And the same as slant and weight\"\n,\nfont\n=\n\"Consolas\"\n,\nt2s\n=\n{\n\"slant\"\n:\nITALIC\n},\nt2w\n=\n{\n\"weight\"\n:\nBOLD\n},\nt2c\n=\n{\n\"slant\"\n:\nORANGE\n,\n\"weight\"\n:\nRED\n}\n)\nVGroup\n(\nfonts\n,\nslant\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n0.8\n)\nself\n.\nplay\n(\nFadeOut\n(\ntext\n),\nFadeOut\n(\ndifference\n,\nshift\n=\nDOWN\n))\nself\n.\nplay\n(\nWrite\n(\nfonts\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nWrite\n(\nslant\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nText\n,\nVGroup\n,\nWrite\n,\nFadeIn\nand\nFadeOut\n.\nText\ncan create text, define fonts, etc. The usage ais clearly reflected in the above examples.\nVGroup\ncan put multiple\nVMobject\ntogether as a whole. In the example, the\n.arrange()\nmethod is called to arrange the sub-mobjects in sequence downward (\nDOWN\n), and the spacing is\nbuff\n.\nWrite\nis an animation that shows similar writing effects.\nFadeIn\nfades the object in, the second parameter indicates the direction of the fade in.\nFadeOut\nfades out the object, the second parameter indicates the direction of the fade out.\nTexTransformExample\n¶\nTexTransformExample\n¶\nclass\nTexTransformExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nto_isolate\n=\n[\n\"B\"\n,\n\"C\"\n,\n\"=\"\n,\n\"(\"\n,\n\")\"\n]\nlines\n=\nVGroup\n(\n# Passing in muliple arguments to Tex will result\n# in the same expression as if those arguments had\n# been joined together, except that the submobject\n# hierarchy of the resulting mobject ensure that the\n# Tex mobject has a subject corresponding to\n# each of these strings.  For example, the Tex mobject\n# below will have 5 subjects, corresponding to the\n# expressions [A^2, +, B^2, =, C^2]\nOldTex\n(\n\"A^2\"\n,\n\"+\"\n,\n\"B^2\"\n,\n\"=\"\n,\n\"C^2\"\n),\n# Likewise here\nOldTex\n(\n\"A^2\"\n,\n\"=\"\n,\n\"C^2\"\n,\n\"-\"\n,\n\"B^2\"\n),\n# Alternatively, you can pass in the keyword argument\n# \"isolate\" with a list of strings that should be out as\n# their own submobject.  So the line below is equivalent\n# to the commented out line below it.\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A^2\"\n,\n*\nto_isolate\n]),\n# OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\nOldTex\n(\n\"A =\n\\\\\nsqrt{(C + B)(C - B)}\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\n)\nlines\n.\narrange\n(\nDOWN\n,\nbuff\n=\nLARGE_BUFF\n)\nfor\nline\nin\nlines\n:\nline\n.\nset_color_by_tex_to_color_map\n({\n\"A\"\n:\nBLUE\n,\n\"B\"\n:\nTEAL\n,\n\"C\"\n:\nGREEN\n,\n})\nplay_kw\n=\n{\n\"run_time\"\n:\n2\n}\nself\n.\nadd\n(\nlines\n[\n0\n])\n# The animation TransformMatchingTex will line up parts\n# of the source and target which have matching tex strings.\n# Here, giving it a little path_arc makes each part sort of\n# rotate into their final positions, which feels appropriate\n# for the idea of rearranging an equation\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n0\n]\n.\ncopy\n(),\nlines\n[\n1\n],\npath_arc\n=\n90\n*\nDEGREES\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# Now, we could try this again on the next line...\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n]),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# ...and this looks nice enough, but since there's no tex\n# in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n# out to nothing while the C and B terms fade in from nothing.\n# If, however, we want the C^2 to go to C, and B^2 to go to B,\n# we can specify that with a key map.\nself\n.\nplay\n(\nFadeOut\n(\nlines\n[\n2\n]))\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n],\nkey_map\n=\n{\n\"C^2\"\n:\n\"C\"\n,\n\"B^2\"\n:\n\"B\"\n,\n}\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# And to finish off, a simple TransformMatchingShapes would work\n# just fine.  But perhaps we want that exponent on A^2 to transform into\n# the square root symbol.  At the moment, lines[2] treats the expression\n# A^2 as a unit, so we might create a new version of the same line which\n# separates out just the A.  This way, when TransformMatchingTex lines up\n# all matching parts, the only mismatch will be between the \"^2\" from\n# new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n# transform_mismatches=True, it will transform this \"^2\" part into\n# the \"\\sqrt\" part.\nnew_line2\n=\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\nnew_line2\n.\nreplace\n(\nlines\n[\n2\n])\nnew_line2\n.\nmatch_style\n(\nlines\n[\n2\n])\nself\n.\nplay\n(\nTransformMatchingTex\n(\nnew_line2\n,\nlines\n[\n3\n],\ntransform_mismatches\n=\nTrue\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n(\n3\n)\nself\n.\nplay\n(\nFadeOut\n(\nlines\n,\nRIGHT\n))\n# Alternatively, if you don't want to think about breaking up\n# the tex strings deliberately, you can TransformMatchingShapes,\n# which will try to line up all pieces of a source mobject with\n# those of a target, regardless of the submobject hierarchy in\n# each one, according to whether those pieces have the same\n# shape (as best it can).\nsource\n=\nText\n(\n\"the morse code\"\n,\nheight\n=\n1\n)\ntarget\n=\nText\n(\n\"here come dots\"\n,\nheight\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\nsource\n))\nself\n.\nwait\n()\nkw\n=\n{\n\"run_time\"\n:\n3\n,\n\"path_arc\"\n:\nPI\n/\n2\n}\nself\n.\nplay\n(\nTransformMatchingShapes\n(\nsource\n,\ntarget\n,\n**\nkw\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nTransformMatchingShapes\n(\ntarget\n,\nsource\n,\n**\nkw\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nTex\n,\nTexText\n,\nTransformMatchingTex\nand\nTransformMatchingShapes\n.\nTex\nuses LaTeX to create mathematical formulas.\nTexText\nuses LaTeX to create text.\nTransformMatchingTeX\nautomatically transforms sub-objects according to the similarities and differences of tex in\nTex\n.\nTransformMatchingShapes\nautomatically transform sub-objects directly based on the similarities and differences of the object point sets.\nUpdatersExample\n¶\nUpdatersExample\n¶\nclass\nUpdatersExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nsquare\n=\nSquare\n()\nsquare\n.\nset_fill\n(\nBLUE_E\n,\n1\n)\n# On all all frames, the constructor Brace(square, UP) will\n# be called, and the mobject brace will set its data to match\n# that of the newly constructed object\nbrace\n=\nalways_redraw\n(\nBrace\n,\nsquare\n,\nUP\n)\ntext\n,\nnumber\n=\nlabel\n=\nVGroup\n(\nText\n(\n\"Width = \"\n),\nDecimalNumber\n(\n0\n,\nshow_ellipsis\n=\nTrue\n,\nnum_decimal_places\n=\n2\n,\ninclude_sign\n=\nTrue\n,\n)\n)\nlabel\n.\narrange\n(\nRIGHT\n)\n# This ensures that the method deicmal.next_to(square)\n# is called on every frame\nalways\n(\nlabel\n.\nnext_to\n,\nbrace\n,\nUP\n)\n# You could also write the following equivalent line\n# label.add_updater(lambda m: m.next_to(brace, UP))\n# If the argument itself might change, you can use f_always,\n# for which the arguments following the initial Mobject method\n# should be functions returning arguments to that method.\n# The following line ensures that decimal.set_value(square.get_y())\n# is called every frame\nf_always\n(\nnumber\n.\nset_value\n,\nsquare\n.\nget_width\n)\n# You could also write the following equivalent line\n# number.add_updater(lambda m: m.set_value(square.get_width()))\nself\n.\nadd\n(\nsquare\n,\nbrace\n,\nlabel\n)\n# Notice that the brace and label track with the square\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nscale\n(\n2\n),\nrate_func\n=\nthere_and_back\n,\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n5\n,\nstretch\n=\nTrue\n),\nrun_time\n=\n3\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# In general, you can alway call Mobject.add_updater, and pass in\n# a function that you want to be called on every frame.  The function\n# should take in either one argument, the mobject, or two arguments,\n# the mobject and the amount of time since the last frame.\nnow\n=\nself\n.\ntime\nw0\n=\nsquare\n.\nget_width\n()\nsquare\n.\nadd_updater\n(\nlambda\nm\n:\nm\n.\nset_width\n(\nw0\n*\nmath\n.\ncos\n(\nself\n.\ntime\n-\nnow\n))\n)\nself\n.\nwait\n(\n4\n*\nPI\n)\nThe new classes and usage in this scene are\nalways_redraw()\n,\nDecimalNumber\n,\n.to_edge()\n,\n.center()\n,\nalways()\n,\nf_always()\n,\n.set_y()\nand\n.add_updater()\n.\nalways_redraw()\nfunction create a new mobject every frame.\nDecimalNumber\nis a variable number, speed it up by breaking it into\nText\ncharacters.\n.to_edge()\nmeans to place the object on the edge of the screen.\n.center()\nmeans to place the object in the center of the screen.\nalways(f,\nx)\nmeans that a certain function (\nf(x)\n) is executed every frame.\nf_always(f,\ng)\nis similar to\nalways\n, executed\nf(g())\nevery frame.\n.set_y()\nmeans to set the ordinate of the object on the screen.\n.add_updater()\nsets an update function for the object. For example:\nmob1.add_updater(lambda\nmob:\nmob.next_to(mob2))\nmeans\nmob1.next_to(mob2)\nis executed every frame.\nCoordinateSystemExample\n¶\nCoordinateSystemExample\n¶\nclass\nCoordinateSystemExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n(\n# x-axis ranges from -1 to 10, with a default step size of 1\nx_range\n=\n(\n-\n1\n,\n10\n),\n# y-axis ranges from -2 to 2 with a step size of 0.5\ny_range\n=\n(\n-\n2\n,\n2\n,\n0.5\n),\n# The axes will be stretched so as to match the specified\n# height and width\nheight\n=\n6\n,\nwidth\n=\n10\n,\n# Axes is made of two NumberLine mobjects.  You can specify\n# their configuration with axis_config\naxis_config\n=\n{\n\"stroke_color\"\n:\nGREY_A\n,\n\"stroke_width\"\n:\n2\n,\n},\n# Alternatively, you can specify configuration for just one\n# of them, like this.\ny_axis_config\n=\n{\n\"include_tip\"\n:\nFalse\n,\n}\n)\n# Keyword arguments of add_coordinate_labels can be used to\n# configure the DecimalNumber mobjects which it creates and\n# adds to the axes\naxes\n.\nadd_coordinate_labels\n(\nfont_size\n=\n20\n,\nnum_decimal_places\n=\n1\n,\n)\nself\n.\nadd\n(\naxes\n)\n# Axes descends from the CoordinateSystem class, meaning\n# you can call call axes.coords_to_point, abbreviated to\n# axes.c2p, to associate a set of coordinates with a point,\n# like so:\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\nc2p\n(\n0\n,\n0\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n5\n,\n0.5\n)))\nself\n.\nwait\n()\n# Similarly, you can call axes.point_to_coords, or axes.p2c\n# print(axes.p2c(dot.get_center()))\n# We can draw lines from the axes to better mark the coordinates\n# of a given point.\n# Here, the always_redraw command means that on each new frame\n# the lines will be redrawn\nh_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_h_line\n(\ndot\n.\nget_left\n()))\nv_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_v_line\n(\ndot\n.\nget_bottom\n()))\nself\n.\nplay\n(\nShowCreation\n(\nh_line\n),\nShowCreation\n(\nv_line\n),\n)\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n-\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n1\n,\n1\n)))\nself\n.\nwait\n()\n# If we tie the dot to a particular set of coordinates, notice\n# that as we move the axes around it respects the coordinate\n# system defined by them.\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\nc2p\n(\n1\n,\n1\n))\nself\n.\nplay\n(\naxes\n.\nanimate\n.\nscale\n(\n0.75\n)\n.\nto_corner\n(\nUL\n),\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nFadeOut\n(\nVGroup\n(\naxes\n,\ndot\n,\nh_line\n,\nv_line\n)))\n# Other coordinate systems you can play around with include\n# ThreeDAxes, NumberPlane, and ComplexPlane.\nGraphExample\n¶\nGraphExample\n¶\nclass\nGraphExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n((\n-\n3\n,\n10\n),\n(\n-\n1\n,\n8\n))\naxes\n.\nadd_coordinate_labels\n()\nself\n.\nplay\n(\nWrite\n(\naxes\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n1\n))\n# Axes.get_graph will return the graph of a function\nsin_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2\n*\nmath\n.\nsin\n(\nx\n),\ncolor\n=\nBLUE\n,\n)\n# By default, it draws it so as to somewhat smoothly interpolate\n# between sampled points (x, f(x)).  If the graph is meant to have\n# a corner, though, you can set use_smoothing to False\nrelu_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\nmax\n(\nx\n,\n0\n),\nuse_smoothing\n=\nFalse\n,\ncolor\n=\nYELLOW\n,\n)\n# For discontinuous functions, you can specify the point of\n# discontinuity so that it does not try to draw over the gap.\nstep_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2.0\nif\nx\n>\n3\nelse\n1.0\n,\ndiscontinuities\n=\n[\n3\n],\ncolor\n=\nGREEN\n,\n)\n# Axes.get_graph_label takes in either a string or a mobject.\n# If it's a string, it treats it as a LaTeX expression.  By default\n# it places the label next to the graph near the right side, and\n# has it match the color of the graph\nsin_label\n=\naxes\n.\nget_graph_label\n(\nsin_graph\n,\n\"\n\\\\\nsin(x)\"\n)\nrelu_label\n=\naxes\n.\nget_graph_label\n(\nrelu_graph\n,\nText\n(\n\"ReLU\"\n))\nstep_label\n=\naxes\n.\nget_graph_label\n(\nstep_graph\n,\nText\n(\n\"Step\"\n),\nx\n=\n4\n)\nself\n.\nplay\n(\nShowCreation\n(\nsin_graph\n),\nFadeIn\n(\nsin_label\n,\nRIGHT\n),\n)\nself\n.\nwait\n(\n2\n)\nself\n.\nplay\n(\nReplacementTransform\n(\nsin_graph\n,\nrelu_graph\n),\nFadeTransform\n(\nsin_label\n,\nrelu_label\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nReplacementTransform\n(\nrelu_graph\n,\nstep_graph\n),\nFadeTransform\n(\nrelu_label\n,\nstep_label\n),\n)\nself\n.\nwait\n()\nparabola\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n0.25\n*\nx\n**\n2\n)\nparabola\n.\nset_stroke\n(\nBLUE\n)\nself\n.\nplay\n(\nFadeOut\n(\nstep_graph\n),\nFadeOut\n(\nstep_label\n),\nShowCreation\n(\nparabola\n)\n)\nself\n.\nwait\n()\n# You can use axes.input_to_graph_point, abbreviated\n# to axes.i2gp, to find a particular point on a graph\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\ni2gp\n(\n2\n,\nparabola\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\n# A value tracker lets us animate a parameter, usually\n# with the intent of having other mobjects update based\n# on the parameter\nx_tracker\n=\nValueTracker\n(\n2\n)\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\ni2gp\n(\nx_tracker\n.\nget_value\n(),\nparabola\n)\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n4\n),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n-\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\nSurfaceExample\n¶\nSurfaceExample\n¶\nclass\nSurfaceExample\n(\nScene\n):\nCONFIG\n=\n{\n\"camera_class\"\n:\nThreeDCamera\n,\n}\ndef\nconstruct\n(\nself\n):\nsurface_text\n=\nText\n(\n\"For 3d scenes, try using surfaces\"\n)\nsurface_text\n.\nfix_in_frame\n()\nsurface_text\n.\nto_edge\n(\nUP\n)\nself\n.\nadd\n(\nsurface_text\n)\nself\n.\nwait\n(\n0.1\n)\ntorus1\n=\nTorus\n(\nr1\n=\n1\n,\nr2\n=\n1\n)\ntorus2\n=\nTorus\n(\nr1\n=\n3\n,\nr2\n=\n1\n)\nsphere\n=\nSphere\n(\nradius\n=\n3\n,\nresolution\n=\ntorus1\n.\nresolution\n)\n# You can texture a surface with up to two images, which will\n# be interpreted as the side towards the light, and away from\n# the light.  These can be either urls, or paths to a local file\n# in whatever you've set as the image directory in\n# the custom_config.yml file\n# day_texture = \"EarthTextureMap\"\n# night_texture = \"NightEarthTextureMap\"\nday_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\nnight_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\nsurfaces\n=\n[\nTexturedSurface\n(\nsurface\n,\nday_texture\n,\nnight_texture\n)\nfor\nsurface\nin\n[\nsphere\n,\ntorus1\n,\ntorus2\n]\n]\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nshift\n(\nIN\n)\nmob\n.\nmesh\n=\nSurfaceMesh\n(\nmob\n)\nmob\n.\nmesh\n.\nset_stroke\n(\nBLUE\n,\n1\n,\nopacity\n=\n0.5\n)\n# Set perspective\nframe\n=\nself\n.\ncamera\n.\nframe\nframe\n.\nset_euler_angles\n(\ntheta\n=-\n30\n*\nDEGREES\n,\nphi\n=\n70\n*\nDEGREES\n,\n)\nsurface\n=\nsurfaces\n[\n0\n]\nself\n.\nplay\n(\nFadeIn\n(\nsurface\n),\nShowCreation\n(\nsurface\n.\nmesh\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n3\n),\n)\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nadd\n(\nmob\n.\nmesh\n)\nsurface\n.\nsave_state\n()\nself\n.\nplay\n(\nRotate\n(\nsurface\n,\nPI\n/\n2\n),\nrun_time\n=\n2\n)\nfor\nmob\nin\nsurfaces\n[\n1\n:]:\nmob\n.\nrotate\n(\nPI\n/\n2\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n1\n]),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n2\n]),\n# Move camera frame during the transition\nframe\n.\nanimate\n.\nincrement_phi\n(\n-\n10\n*\nDEGREES\n),\nframe\n.\nanimate\n.\nincrement_theta\n(\n-\n20\n*\nDEGREES\n),\nrun_time\n=\n3\n)\n# Add ambient rotation\nframe\n.\nadd_updater\n(\nlambda\nm\n,\ndt\n:\nm\n.\nincrement_theta\n(\n-\n0.1\n*\ndt\n))\n# Play around with where the light is\nlight_text\n=\nText\n(\n\"You can move around the light source\"\n)\nlight_text\n.\nmove_to\n(\nsurface_text\n)\nlight_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nsurface_text\n,\nlight_text\n))\nlight\n=\nself\n.\ncamera\n.\nlight_source\nself\n.\nadd\n(\nlight\n)\nlight\n.\nsave_state\n()\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nmove_to\n(\n3\n*\nIN\n),\nrun_time\n=\n5\n)\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nshift\n(\n10\n*\nOUT\n),\nrun_time\n=\n5\n)\ndrag_text\n=\nText\n(\n\"Try moving the mouse while pressing d or s\"\n)\ndrag_text\n.\nmove_to\n(\nlight_text\n)\ndrag_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nlight_text\n,\ndrag_text\n))\nself\n.\nwait\n()\nThis scene shows an example of using a three-dimensional surface, and\nthe related usage has been briefly described in the notes.\n.fix_in_frame()\nmakes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.\nOpeningManimExample\n¶\nOpeningManimExample\n¶\nclass\nOpeningManimExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nintro_words\n=\nText\n(\n\"\"\"\nThe original motivation for manim was to\nbetter illustrate mathematical functions\nas transformations.\n\"\"\"\n)\nintro_words\n.\nto_edge\n(\nUP\n)\nself\n.\nplay\n(\nWrite\n(\nintro_words\n))\nself\n.\nwait\n(\n2\n)\n# Linear transform\ngrid\n=\nNumberPlane\n((\n-\n10\n,\n10\n),\n(\n-\n5\n,\n5\n))\nmatrix\n=\n[[\n1\n,\n1\n],\n[\n0\n,\n1\n]]\nlinear_transform_words\n=\nVGroup\n(\nText\n(\n\"This is what the matrix\"\n),\nIntegerMatrix\n(\nmatrix\n,\ninclude_background_rectangle\n=\nTrue\n),\nText\n(\n\"looks like\"\n)\n)\nlinear_transform_words\n.\narrange\n(\nRIGHT\n)\nlinear_transform_words\n.\nto_edge\n(\nUP\n)\nlinear_transform_words\n.\nset_stroke\n(\nBLACK\n,\n10\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nShowCreation\n(\ngrid\n),\nFadeTransform\n(\nintro_words\n,\nlinear_transform_words\n)\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_matrix\n(\nmatrix\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# Complex map\nc_grid\n=\nComplexPlane\n()\nmoving_c_grid\n=\nc_grid\n.\ncopy\n()\nmoving_c_grid\n.\nprepare_for_nonlinear_transform\n()\nc_grid\n.\nset_stroke\n(\nBLUE_E\n,\n1\n)\nc_grid\n.\nadd_coordinate_labels\n(\nfont_size\n=\n24\n)\ncomplex_map_words\n=\nTexText\n(\n\"\"\"\nOr thinking of the plane as $\n\\\\\nmathds\n{C}\n$,\n\\\\\\\\\nthis is the map $z\n\\\\\nrightarrow z^2$\n\"\"\"\n)\ncomplex_map_words\n.\nto_corner\n(\nUR\n)\ncomplex_map_words\n.\nset_stroke\n(\nBLACK\n,\n5\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nFadeOut\n(\ngrid\n),\nWrite\n(\nc_grid\n,\nrun_time\n=\n3\n),\nFadeIn\n(\nmoving_c_grid\n),\nFadeTransform\n(\nlinear_transform_words\n,\ncomplex_map_words\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nmoving_c_grid\n.\nanimate\n.\napply_complex_function\n(\nlambda\nz\n:\nz\n**\n2\n),\nrun_time\n=\n6\n,\n)\nself\n.\nwait\n(\n2\n)\nThis scene is a comprehensive application of a two-dimensional scene.\nAfter seeing these scenes, you have already understood part of the\nusage of manim. For more examples, see\nthe video code of 3b1b\n.\nContents\nExample Scenes\nInteractiveDevlopment\nAnimatingMethods\nTextExample\nTexTransformExample\nUpdatersExample\nCoordinateSystemExample\nGraphExample\nSurfaceExample\nOpeningManimExample",
    "code_examples": [
      "example_scenes.py",
      "from manimlib import *\n\nclass InteractiveDevelopment(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n\n        # This opens an iPython terminal where you can keep writing\n        # lines as if they were part of this construct method.\n        # In particular, 'square', 'circle' and 'self' will all be\n        # part of the local namespace in that terminal.\n        self.embed()\n\n        # Try copying and pasting some of the lines below into\n        # the interactive shell\n        self.play(ReplacementTransform(square, circle))\n        self.wait()\n        self.play(circle.animate.stretch(4, 0))\n        self.play(Rotate(circle, 90 * DEGREES))\n        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))\n\n        text = Text(\"\"\"\n            In general, using the interactive shell\n            is very helpful when developing new scenes\n        \"\"\")\n        self.play(Write(text))\n\n        # In the interactive shell, you can just type\n        # play, add, remove, clear, wait, save_state and restore,\n        # instead of self.play, self.add, self.remove, etc.\n\n        # To interact with the window, type touch().  You can then\n        # scroll in the window, or zoom by holding down 'z' while scrolling,\n        # and change camera perspective by holding down 'd' while moving\n        # the mouse.  Press 'r' to reset to the standard camera position.\n        # Press 'q' to stop interacting with the window and go back to\n        # typing new commands into the shell.\n\n        # In principle you can customize a scene to be responsive to\n        # mouse and keyboard interactions\n        always(circle.move_to, self.mouse_point)",
      "class AnimatingMethods(Scene):\n    def construct(self):\n        grid = OldTex(r\"\\pi\").get_grid(10, 10, height=4)\n        self.add(grid)\n\n        # You can animate the application of mobject methods with the\n        # \".animate\" syntax:\n        self.play(grid.animate.shift(LEFT))\n\n        # Alternatively, you can use the older syntax by passing the\n        # method and then the arguments to the scene's \"play\" function:\n        self.play(grid.shift, LEFT)\n\n        # Both of those will interpolate between the mobject's initial\n        # state and whatever happens when you apply that method.\n        # For this example, calling grid.shift(LEFT) would shift the\n        # grid one unit to the left, but both of the previous calls to\n        # \"self.play\" animate that motion.\n\n        # The same applies for any method, including those setting colors.\n        self.play(grid.animate.set_color(YELLOW))\n        self.wait()\n        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))\n        self.wait()\n        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))\n        self.wait()\n\n        # The method Mobject.apply_complex_function lets you apply arbitrary\n        # complex functions, treating the points defining the mobject as\n        # complex numbers.\n        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)\n        self.wait()\n\n        # Even more generally, you could apply Mobject.apply_function,\n        # which takes in functions form R^3 to R^3\n        self.play(\n            grid.animate.apply_function(\n                lambda p: [\n                    p[0] + 0.5 * math.sin(p[1]),\n                    p[1] + 0.5 * math.sin(p[0]),\n                    p[2]\n                ]\n            ),\n            run_time=5,\n        )\n        self.wait()",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      "class TextExample(Scene):\n    def construct(self):\n        # To run this scene properly, you should have \"Consolas\" font in your computer\n        # for full usage, you can see https://github.com/3b1b/manim/pull/680\n        text = Text(\"Here is a text\", font=\"Consolas\", font_size=90)\n        difference = Text(\n            \"\"\"\n            The most important difference between Text and TexText is that\\n\n            you can change the font more easily, but can't use the LaTeX grammar\n            \"\"\",\n            font=\"Arial\", font_size=24,\n            # t2c is a dict that you can choose color for different text\n            t2c={\"Text\": BLUE, \"TexText\": BLUE, \"LaTeX\": ORANGE}\n        )\n        VGroup(text, difference).arrange(DOWN, buff=1)\n        self.play(Write(text))\n        self.play(FadeIn(difference, UP))\n        self.wait(3)\n\n        fonts = Text(\n            \"And you can also set the font according to different words\",\n            font=\"Arial\",\n            t2f={\"font\": \"Consolas\", \"words\": \"Consolas\"},\n            t2c={\"font\": BLUE, \"words\": GREEN}\n        )\n        fonts.set_width(FRAME_WIDTH - 1)\n        slant = Text(\n            \"And the same as slant and weight\",\n            font=\"Consolas\",\n            t2s={\"slant\": ITALIC},\n            t2w={\"weight\": BOLD},\n            t2c={\"slant\": ORANGE, \"weight\": RED}\n        )\n        VGroup(fonts, slant).arrange(DOWN, buff=0.8)\n        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))\n        self.play(Write(fonts))\n        self.wait()\n        self.play(Write(slant))\n        self.wait()",
      "class TexTransformExample(Scene):\n    def construct(self):\n        to_isolate = [\"B\", \"C\", \"=\", \"(\", \")\"]\n        lines = VGroup(\n            # Passing in muliple arguments to Tex will result\n            # in the same expression as if those arguments had\n            # been joined together, except that the submobject\n            # hierarchy of the resulting mobject ensure that the\n            # Tex mobject has a subject corresponding to\n            # each of these strings.  For example, the Tex mobject\n            # below will have 5 subjects, corresponding to the\n            # expressions [A^2, +, B^2, =, C^2]\n            OldTex(\"A^2\", \"+\", \"B^2\", \"=\", \"C^2\"),\n            # Likewise here\n            OldTex(\"A^2\", \"=\", \"C^2\", \"-\", \"B^2\"),\n            # Alternatively, you can pass in the keyword argument\n            # \"isolate\" with a list of strings that should be out as\n            # their own submobject.  So the line below is equivalent\n            # to the commented out line below it.\n            OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A^2\", *to_isolate]),\n            # OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\n            OldTex(\"A = \\\\sqrt{(C + B)(C - B)}\", isolate=[\"A\", *to_isolate])\n        )\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        for line in lines:\n            line.set_color_by_tex_to_color_map({\n                \"A\": BLUE,\n                \"B\": TEAL,\n                \"C\": GREEN,\n            })\n\n        play_kw = {\"run_time\": 2}\n        self.add(lines[0])\n        # The animation TransformMatchingTex will line up parts\n        # of the source and target which have matching tex strings.\n        # Here, giving it a little path_arc makes each part sort of\n        # rotate into their final positions, which feels appropriate\n        # for the idea of rearranging an equation\n        self.play(\n            TransformMatchingTex(\n                lines[0].copy(), lines[1],\n                path_arc=90 * DEGREES,\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # Now, we could try this again on the next line...\n        self.play(\n            TransformMatchingTex(lines[1].copy(), lines[2]),\n            **play_kw\n        )\n        self.wait()\n        # ...and this looks nice enough, but since there's no tex\n        # in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n        # out to nothing while the C and B terms fade in from nothing.\n        # If, however, we want the C^2 to go to C, and B^2 to go to B,\n        # we can specify that with a key map.\n        self.play(FadeOut(lines[2]))\n        self.play(\n            TransformMatchingTex(\n                lines[1].copy(), lines[2],\n                key_map={\n                    \"C^2\": \"C\",\n                    \"B^2\": \"B\",\n                }\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # And to finish off, a simple TransformMatchingShapes would work\n        # just fine.  But perhaps we want that exponent on A^2 to transform into\n        # the square root symbol.  At the moment, lines[2] treats the expression\n        # A^2 as a unit, so we might create a new version of the same line which\n        # separates out just the A.  This way, when TransformMatchingTex lines up\n        # all matching parts, the only mismatch will be between the \"^2\" from\n        # new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n        # transform_mismatches=True, it will transform this \"^2\" part into\n        # the \"\\sqrt\" part.\n        new_line2 = OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A\", *to_isolate])\n        new_line2.replace(lines[2])\n        new_line2.match_style(lines[2])\n\n        self.play(\n            TransformMatchingTex(\n                new_line2, lines[3],\n                transform_mismatches=True,\n            ),\n            **play_kw\n        )\n        self.wait(3)\n        self.play(FadeOut(lines, RIGHT))\n\n        # Alternatively, if you don't want to think about breaking up\n        # the tex strings deliberately, you can TransformMatchingShapes,\n        # which will try to line up all pieces of a source mobject with\n        # those of a target, regardless of the submobject hierarchy in\n        # each one, according to whether those pieces have the same\n        # shape (as best it can).\n        source = Text(\"the morse code\", height=1)\n        target = Text(\"here come dots\", height=1)\n\n        self.play(Write(source))\n        self.wait()\n        kw = {\"run_time\": 3, \"path_arc\": PI / 2}\n        self.play(TransformMatchingShapes(source, target, **kw))\n        self.wait()\n        self.play(TransformMatchingShapes(target, source, **kw))\n        self.wait()",
      "TransformMatchingTex",
      "TransformMatchingShapes",
      "TransformMatchingTeX",
      "TransformMatchingShapes",
      "class UpdatersExample(Scene):\n    def construct(self):\n        square = Square()\n        square.set_fill(BLUE_E, 1)\n\n        # On all all frames, the constructor Brace(square, UP) will\n        # be called, and the mobject brace will set its data to match\n        # that of the newly constructed object\n        brace = always_redraw(Brace, square, UP)\n\n        text, number = label = VGroup(\n            Text(\"Width = \"),\n            DecimalNumber(\n                0,\n                show_ellipsis=True,\n                num_decimal_places=2,\n                include_sign=True,\n            )\n        )\n        label.arrange(RIGHT)\n\n        # This ensures that the method deicmal.next_to(square)\n        # is called on every frame\n        always(label.next_to, brace, UP)\n        # You could also write the following equivalent line\n        # label.add_updater(lambda m: m.next_to(brace, UP))\n\n        # If the argument itself might change, you can use f_always,\n        # for which the arguments following the initial Mobject method\n        # should be functions returning arguments to that method.\n        # The following line ensures that decimal.set_value(square.get_y())\n        # is called every frame\n        f_always(number.set_value, square.get_width)\n        # You could also write the following equivalent line\n        # number.add_updater(lambda m: m.set_value(square.get_width()))\n\n        self.add(square, brace, label)\n\n        # Notice that the brace and label track with the square\n        self.play(\n            square.animate.scale(2),\n            rate_func=there_and_back,\n            run_time=2,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(5, stretch=True),\n            run_time=3,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(2),\n            run_time=3\n        )\n        self.wait()\n\n        # In general, you can alway call Mobject.add_updater, and pass in\n        # a function that you want to be called on every frame.  The function\n        # should take in either one argument, the mobject, or two arguments,\n        # the mobject and the amount of time since the last frame.\n        now = self.time\n        w0 = square.get_width()\n        square.add_updater(\n            lambda m: m.set_width(w0 * math.cos(self.time - now))\n        )\n        self.wait(4 * PI)",
      "always_redraw()",
      "DecimalNumber",
      ".add_updater()",
      "always_redraw()",
      "DecimalNumber",
      "always(f, x)",
      "f_always(f, g)",
      ".add_updater()",
      "mob1.add_updater(lambda mob: mob.next_to(mob2))",
      "mob1.next_to(mob2)",
      "class CoordinateSystemExample(Scene):\n    def construct(self):\n        axes = Axes(\n            # x-axis ranges from -1 to 10, with a default step size of 1\n            x_range=(-1, 10),\n            # y-axis ranges from -2 to 2 with a step size of 0.5\n            y_range=(-2, 2, 0.5),\n            # The axes will be stretched so as to match the specified\n            # height and width\n            height=6,\n            width=10,\n            # Axes is made of two NumberLine mobjects.  You can specify\n            # their configuration with axis_config\n            axis_config={\n                \"stroke_color\": GREY_A,\n                \"stroke_width\": 2,\n            },\n            # Alternatively, you can specify configuration for just one\n            # of them, like this.\n            y_axis_config={\n                \"include_tip\": False,\n            }\n        )\n        # Keyword arguments of add_coordinate_labels can be used to\n        # configure the DecimalNumber mobjects which it creates and\n        # adds to the axes\n        axes.add_coordinate_labels(\n            font_size=20,\n            num_decimal_places=1,\n        )\n        self.add(axes)\n\n        # Axes descends from the CoordinateSystem class, meaning\n        # you can call call axes.coords_to_point, abbreviated to\n        # axes.c2p, to associate a set of coordinates with a point,\n        # like so:\n        dot = Dot(color=RED)\n        dot.move_to(axes.c2p(0, 0))\n        self.play(FadeIn(dot, scale=0.5))\n        self.play(dot.animate.move_to(axes.c2p(3, 2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))\n        self.wait()\n\n        # Similarly, you can call axes.point_to_coords, or axes.p2c\n        # print(axes.p2c(dot.get_center()))\n\n        # We can draw lines from the axes to better mark the coordinates\n        # of a given point.\n        # Here, the always_redraw command means that on each new frame\n        # the lines will be redrawn\n        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))\n        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))\n\n        self.play(\n            ShowCreation(h_line),\n            ShowCreation(v_line),\n        )\n        self.play(dot.animate.move_to(axes.c2p(3, -2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(1, 1)))\n        self.wait()\n\n        # If we tie the dot to a particular set of coordinates, notice\n        # that as we move the axes around it respects the coordinate\n        # system defined by them.\n        f_always(dot.move_to, lambda: axes.c2p(1, 1))\n        self.play(\n            axes.animate.scale(0.75).to_corner(UL),\n            run_time=2,\n        )\n        self.wait()\n        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))\n\n        # Other coordinate systems you can play around with include\n        # ThreeDAxes, NumberPlane, and ComplexPlane.",
      "class GraphExample(Scene):\n    def construct(self):\n        axes = Axes((-3, 10), (-1, 8))\n        axes.add_coordinate_labels()\n\n        self.play(Write(axes, lag_ratio=0.01, run_time=1))\n\n        # Axes.get_graph will return the graph of a function\n        sin_graph = axes.get_graph(\n            lambda x: 2 * math.sin(x),\n            color=BLUE,\n        )\n        # By default, it draws it so as to somewhat smoothly interpolate\n        # between sampled points (x, f(x)).  If the graph is meant to have\n        # a corner, though, you can set use_smoothing to False\n        relu_graph = axes.get_graph(\n            lambda x: max(x, 0),\n            use_smoothing=False,\n            color=YELLOW,\n        )\n        # For discontinuous functions, you can specify the point of\n        # discontinuity so that it does not try to draw over the gap.\n        step_graph = axes.get_graph(\n            lambda x: 2.0 if x > 3 else 1.0,\n            discontinuities=[3],\n            color=GREEN,\n        )\n\n        # Axes.get_graph_label takes in either a string or a mobject.\n        # If it's a string, it treats it as a LaTeX expression.  By default\n        # it places the label next to the graph near the right side, and\n        # has it match the color of the graph\n        sin_label = axes.get_graph_label(sin_graph, \"\\\\sin(x)\")\n        relu_label = axes.get_graph_label(relu_graph, Text(\"ReLU\"))\n        step_label = axes.get_graph_label(step_graph, Text(\"Step\"), x=4)\n\n        self.play(\n            ShowCreation(sin_graph),\n            FadeIn(sin_label, RIGHT),\n        )\n        self.wait(2)\n        self.play(\n            ReplacementTransform(sin_graph, relu_graph),\n            FadeTransform(sin_label, relu_label),\n        )\n        self.wait()\n        self.play(\n            ReplacementTransform(relu_graph, step_graph),\n            FadeTransform(relu_label, step_label),\n        )\n        self.wait()\n\n        parabola = axes.get_graph(lambda x: 0.25 * x**2)\n        parabola.set_stroke(BLUE)\n        self.play(\n            FadeOut(step_graph),\n            FadeOut(step_label),\n            ShowCreation(parabola)\n        )\n        self.wait()\n\n        # You can use axes.input_to_graph_point, abbreviated\n        # to axes.i2gp, to find a particular point on a graph\n        dot = Dot(color=RED)\n        dot.move_to(axes.i2gp(2, parabola))\n        self.play(FadeIn(dot, scale=0.5))\n\n        # A value tracker lets us animate a parameter, usually\n        # with the intent of having other mobjects update based\n        # on the parameter\n        x_tracker = ValueTracker(2)\n        f_always(\n            dot.move_to,\n            lambda: axes.i2gp(x_tracker.get_value(), parabola)\n        )\n\n        self.play(x_tracker.animate.set_value(4), run_time=3)\n        self.play(x_tracker.animate.set_value(-2), run_time=3)\n        self.wait()",
      "class SurfaceExample(Scene):\n    CONFIG = {\n        \"camera_class\": ThreeDCamera,\n    }\n\n    def construct(self):\n        surface_text = Text(\"For 3d scenes, try using surfaces\")\n        surface_text.fix_in_frame()\n        surface_text.to_edge(UP)\n        self.add(surface_text)\n        self.wait(0.1)\n\n        torus1 = Torus(r1=1, r2=1)\n        torus2 = Torus(r1=3, r2=1)\n        sphere = Sphere(radius=3, resolution=torus1.resolution)\n        # You can texture a surface with up to two images, which will\n        # be interpreted as the side towards the light, and away from\n        # the light.  These can be either urls, or paths to a local file\n        # in whatever you've set as the image directory in\n        # the custom_config.yml file\n\n        # day_texture = \"EarthTextureMap\"\n        # night_texture = \"NightEarthTextureMap\"\n        day_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\n        night_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\n\n        surfaces = [\n            TexturedSurface(surface, day_texture, night_texture)\n            for surface in [sphere, torus1, torus2]\n        ]\n\n        for mob in surfaces:\n            mob.shift(IN)\n            mob.mesh = SurfaceMesh(mob)\n            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)\n\n        # Set perspective\n        frame = self.camera.frame\n        frame.set_euler_angles(\n            theta=-30 * DEGREES,\n            phi=70 * DEGREES,\n        )\n\n        surface = surfaces[0]\n\n        self.play(\n            FadeIn(surface),\n            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),\n        )\n        for mob in surfaces:\n            mob.add(mob.mesh)\n        surface.save_state()\n        self.play(Rotate(surface, PI / 2), run_time=2)\n        for mob in surfaces[1:]:\n            mob.rotate(PI / 2)\n\n        self.play(\n            Transform(surface, surfaces[1]),\n            run_time=3\n        )\n\n        self.play(\n            Transform(surface, surfaces[2]),\n            # Move camera frame during the transition\n            frame.animate.increment_phi(-10 * DEGREES),\n            frame.animate.increment_theta(-20 * DEGREES),\n            run_time=3\n        )\n        # Add ambient rotation\n        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))\n\n        # Play around with where the light is\n        light_text = Text(\"You can move around the light source\")\n        light_text.move_to(surface_text)\n        light_text.fix_in_frame()\n\n        self.play(FadeTransform(surface_text, light_text))\n        light = self.camera.light_source\n        self.add(light)\n        light.save_state()\n        self.play(light.animate.move_to(3 * IN), run_time=5)\n        self.play(light.animate.shift(10 * OUT), run_time=5)\n\n        drag_text = Text(\"Try moving the mouse while pressing d or s\")\n        drag_text.move_to(light_text)\n        drag_text.fix_in_frame()\n\n        self.play(FadeTransform(light_text, drag_text))\n        self.wait()",
      ".fix_in_frame()",
      "class OpeningManimExample(Scene):\n    def construct(self):\n        intro_words = Text(\"\"\"\n            The original motivation for manim was to\n            better illustrate mathematical functions\n            as transformations.\n        \"\"\")\n        intro_words.to_edge(UP)\n\n        self.play(Write(intro_words))\n        self.wait(2)\n\n        # Linear transform\n        grid = NumberPlane((-10, 10), (-5, 5))\n        matrix = [[1, 1], [0, 1]]\n        linear_transform_words = VGroup(\n            Text(\"This is what the matrix\"),\n            IntegerMatrix(matrix, include_background_rectangle=True),\n            Text(\"looks like\")\n        )\n        linear_transform_words.arrange(RIGHT)\n        linear_transform_words.to_edge(UP)\n        linear_transform_words.set_stroke(BLACK, 10, background=True)\n\n        self.play(\n            ShowCreation(grid),\n            FadeTransform(intro_words, linear_transform_words)\n        )\n        self.wait()\n        self.play(grid.animate.apply_matrix(matrix), run_time=3)\n        self.wait()\n\n        # Complex map\n        c_grid = ComplexPlane()\n        moving_c_grid = c_grid.copy()\n        moving_c_grid.prepare_for_nonlinear_transform()\n        c_grid.set_stroke(BLUE_E, 1)\n        c_grid.add_coordinate_labels(font_size=24)\n        complex_map_words = TexText(\"\"\"\n            Or thinking of the plane as $\\\\mathds{C}$,\\\\\\\\\n            this is the map $z \\\\rightarrow z^2$\n        \"\"\")\n        complex_map_words.to_corner(UR)\n        complex_map_words.set_stroke(BLACK, 5, background=True)\n\n        self.play(\n            FadeOut(grid),\n            Write(c_grid, run_time=3),\n            FadeIn(moving_c_grid),\n            FadeTransform(linear_transform_words, complex_map_words),\n        )\n        self.wait()\n        self.play(\n            moving_c_grid.animate.apply_complex_function(lambda z: z**2),\n            run_time=6,\n        )\n        self.wait(2)"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#example-scenes",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevelopment",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample"
    ],
    "scraped_at": 1752428850.8866591
  },
  "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample": {
    "url": "https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample",
    "title": "Example Scenes - manim  documentation",
    "content": "Example Scenes\n¶\nAfter understanding the previous knowledge, we can understand more scenes.\nMany example scenes are given in\nexample_scenes.py\n, let’s start with\nthe simplest and one by one.\nInteractiveDevlopment\n¶\nInteractiveDevelopment\n¶\nfrom\nmanimlib\nimport\n*\nclass\nInteractiveDevelopment\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ncircle\n=\nCircle\n()\ncircle\n.\nset_fill\n(\nBLUE\n,\nopacity\n=\n0.5\n)\ncircle\n.\nset_stroke\n(\nBLUE_E\n,\nwidth\n=\n4\n)\nsquare\n=\nSquare\n()\nself\n.\nplay\n(\nShowCreation\n(\nsquare\n))\nself\n.\nwait\n()\n# This opens an iPython terminal where you can keep writing\n# lines as if they were part of this construct method.\n# In particular, 'square', 'circle' and 'self' will all be\n# part of the local namespace in that terminal.\nself\n.\nembed\n()\n# Try copying and pasting some of the lines below into\n# the interactive shell\nself\n.\nplay\n(\nReplacementTransform\n(\nsquare\n,\ncircle\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nstretch\n(\n4\n,\n0\n))\nself\n.\nplay\n(\nRotate\n(\ncircle\n,\n90\n*\nDEGREES\n))\nself\n.\nplay\n(\ncircle\n.\nanimate\n.\nshift\n(\n2\n*\nRIGHT\n)\n.\nscale\n(\n0.25\n))\ntext\n=\nText\n(\n\"\"\"\nIn general, using the interactive shell\nis very helpful when developing new scenes\n\"\"\"\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\n# In the interactive shell, you can just type\n# play, add, remove, clear, wait, save_state and restore,\n# instead of self.play, self.add, self.remove, etc.\n# To interact with the window, type touch().  You can then\n# scroll in the window, or zoom by holding down 'z' while scrolling,\n# and change camera perspective by holding down 'd' while moving\n# the mouse.  Press 'r' to reset to the standard camera position.\n# Press 'q' to stop interacting with the window and go back to\n# typing new commands into the shell.\n# In principle you can customize a scene to be responsive to\n# mouse and keyboard interactions\nalways\n(\ncircle\n.\nmove_to\n,\nself\n.\nmouse_point\n)\nThis scene is similar to what we wrote in\nQuick Start\n.\nAnd how to interact has been written in the comments.\nNo more explanation here.\nAnimatingMethods\n¶\nAnimatingMethods\n¶\nclass\nAnimatingMethods\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\ngrid\n=\nOldTex\n(\nr\n\"\\pi\"\n)\n.\nget_grid\n(\n10\n,\n10\n,\nheight\n=\n4\n)\nself\n.\nadd\n(\ngrid\n)\n# You can animate the application of mobject methods with the\n# \".animate\" syntax:\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nshift\n(\nLEFT\n))\n# Alternatively, you can use the older syntax by passing the\n# method and then the arguments to the scene's \"play\" function:\nself\n.\nplay\n(\ngrid\n.\nshift\n,\nLEFT\n)\n# Both of those will interpolate between the mobject's initial\n# state and whatever happens when you apply that method.\n# For this example, calling grid.shift(LEFT) would shift the\n# grid one unit to the left, but both of the previous calls to\n# \"self.play\" animate that motion.\n# The same applies for any method, including those setting colors.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_color\n(\nYELLOW\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_submobject_colors_by_gradient\n(\nBLUE\n,\nGREEN\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\nset_height\n(\nTAU\n-\nMED_SMALL_BUFF\n))\nself\n.\nwait\n()\n# The method Mobject.apply_complex_function lets you apply arbitrary\n# complex functions, treating the points defining the mobject as\n# complex numbers.\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_complex_function\n(\nnp\n.\nexp\n),\nrun_time\n=\n5\n)\nself\n.\nwait\n()\n# Even more generally, you could apply Mobject.apply_function,\n# which takes in functions form R^3 to R^3\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_function\n(\nlambda\np\n:\n[\np\n[\n0\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n1\n]),\np\n[\n1\n]\n+\n0.5\n*\nmath\n.\nsin\n(\np\n[\n0\n]),\np\n[\n2\n]\n]\n),\nrun_time\n=\n5\n,\n)\nself\n.\nwait\n()\nThe new usage in this scene is\n.get_grid()\nand\nself.play(mob.animate.method(args))\n.\n.get_grid()\nmethod will return a new mobject containing multiple copies of this one arranged in a grid.\nself.play(mob.animate.method(args))\nanimates the method, and the details are in the comments above.\nTextExample\n¶\nTextExample\n¶\nclass\nTextExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\n# To run this scene properly, you should have \"Consolas\" font in your computer\n# for full usage, you can see https://github.com/3b1b/manim/pull/680\ntext\n=\nText\n(\n\"Here is a text\"\n,\nfont\n=\n\"Consolas\"\n,\nfont_size\n=\n90\n)\ndifference\n=\nText\n(\n\"\"\"\nThe most important difference between Text and TexText is that\\n\nyou can change the font more easily, but can't use the LaTeX grammar\n\"\"\"\n,\nfont\n=\n\"Arial\"\n,\nfont_size\n=\n24\n,\n# t2c is a dict that you can choose color for different text\nt2c\n=\n{\n\"Text\"\n:\nBLUE\n,\n\"TexText\"\n:\nBLUE\n,\n\"LaTeX\"\n:\nORANGE\n}\n)\nVGroup\n(\ntext\n,\ndifference\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\ntext\n))\nself\n.\nplay\n(\nFadeIn\n(\ndifference\n,\nUP\n))\nself\n.\nwait\n(\n3\n)\nfonts\n=\nText\n(\n\"And you can also set the font according to different words\"\n,\nfont\n=\n\"Arial\"\n,\nt2f\n=\n{\n\"font\"\n:\n\"Consolas\"\n,\n\"words\"\n:\n\"Consolas\"\n},\nt2c\n=\n{\n\"font\"\n:\nBLUE\n,\n\"words\"\n:\nGREEN\n}\n)\nfonts\n.\nset_width\n(\nFRAME_WIDTH\n-\n1\n)\nslant\n=\nText\n(\n\"And the same as slant and weight\"\n,\nfont\n=\n\"Consolas\"\n,\nt2s\n=\n{\n\"slant\"\n:\nITALIC\n},\nt2w\n=\n{\n\"weight\"\n:\nBOLD\n},\nt2c\n=\n{\n\"slant\"\n:\nORANGE\n,\n\"weight\"\n:\nRED\n}\n)\nVGroup\n(\nfonts\n,\nslant\n)\n.\narrange\n(\nDOWN\n,\nbuff\n=\n0.8\n)\nself\n.\nplay\n(\nFadeOut\n(\ntext\n),\nFadeOut\n(\ndifference\n,\nshift\n=\nDOWN\n))\nself\n.\nplay\n(\nWrite\n(\nfonts\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nWrite\n(\nslant\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nText\n,\nVGroup\n,\nWrite\n,\nFadeIn\nand\nFadeOut\n.\nText\ncan create text, define fonts, etc. The usage ais clearly reflected in the above examples.\nVGroup\ncan put multiple\nVMobject\ntogether as a whole. In the example, the\n.arrange()\nmethod is called to arrange the sub-mobjects in sequence downward (\nDOWN\n), and the spacing is\nbuff\n.\nWrite\nis an animation that shows similar writing effects.\nFadeIn\nfades the object in, the second parameter indicates the direction of the fade in.\nFadeOut\nfades out the object, the second parameter indicates the direction of the fade out.\nTexTransformExample\n¶\nTexTransformExample\n¶\nclass\nTexTransformExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nto_isolate\n=\n[\n\"B\"\n,\n\"C\"\n,\n\"=\"\n,\n\"(\"\n,\n\")\"\n]\nlines\n=\nVGroup\n(\n# Passing in muliple arguments to Tex will result\n# in the same expression as if those arguments had\n# been joined together, except that the submobject\n# hierarchy of the resulting mobject ensure that the\n# Tex mobject has a subject corresponding to\n# each of these strings.  For example, the Tex mobject\n# below will have 5 subjects, corresponding to the\n# expressions [A^2, +, B^2, =, C^2]\nOldTex\n(\n\"A^2\"\n,\n\"+\"\n,\n\"B^2\"\n,\n\"=\"\n,\n\"C^2\"\n),\n# Likewise here\nOldTex\n(\n\"A^2\"\n,\n\"=\"\n,\n\"C^2\"\n,\n\"-\"\n,\n\"B^2\"\n),\n# Alternatively, you can pass in the keyword argument\n# \"isolate\" with a list of strings that should be out as\n# their own submobject.  So the line below is equivalent\n# to the commented out line below it.\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A^2\"\n,\n*\nto_isolate\n]),\n# OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\nOldTex\n(\n\"A =\n\\\\\nsqrt{(C + B)(C - B)}\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\n)\nlines\n.\narrange\n(\nDOWN\n,\nbuff\n=\nLARGE_BUFF\n)\nfor\nline\nin\nlines\n:\nline\n.\nset_color_by_tex_to_color_map\n({\n\"A\"\n:\nBLUE\n,\n\"B\"\n:\nTEAL\n,\n\"C\"\n:\nGREEN\n,\n})\nplay_kw\n=\n{\n\"run_time\"\n:\n2\n}\nself\n.\nadd\n(\nlines\n[\n0\n])\n# The animation TransformMatchingTex will line up parts\n# of the source and target which have matching tex strings.\n# Here, giving it a little path_arc makes each part sort of\n# rotate into their final positions, which feels appropriate\n# for the idea of rearranging an equation\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n0\n]\n.\ncopy\n(),\nlines\n[\n1\n],\npath_arc\n=\n90\n*\nDEGREES\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# Now, we could try this again on the next line...\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n]),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# ...and this looks nice enough, but since there's no tex\n# in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n# out to nothing while the C and B terms fade in from nothing.\n# If, however, we want the C^2 to go to C, and B^2 to go to B,\n# we can specify that with a key map.\nself\n.\nplay\n(\nFadeOut\n(\nlines\n[\n2\n]))\nself\n.\nplay\n(\nTransformMatchingTex\n(\nlines\n[\n1\n]\n.\ncopy\n(),\nlines\n[\n2\n],\nkey_map\n=\n{\n\"C^2\"\n:\n\"C\"\n,\n\"B^2\"\n:\n\"B\"\n,\n}\n),\n**\nplay_kw\n)\nself\n.\nwait\n()\n# And to finish off, a simple TransformMatchingShapes would work\n# just fine.  But perhaps we want that exponent on A^2 to transform into\n# the square root symbol.  At the moment, lines[2] treats the expression\n# A^2 as a unit, so we might create a new version of the same line which\n# separates out just the A.  This way, when TransformMatchingTex lines up\n# all matching parts, the only mismatch will be between the \"^2\" from\n# new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n# transform_mismatches=True, it will transform this \"^2\" part into\n# the \"\\sqrt\" part.\nnew_line2\n=\nOldTex\n(\n\"A^2 = (C + B)(C - B)\"\n,\nisolate\n=\n[\n\"A\"\n,\n*\nto_isolate\n])\nnew_line2\n.\nreplace\n(\nlines\n[\n2\n])\nnew_line2\n.\nmatch_style\n(\nlines\n[\n2\n])\nself\n.\nplay\n(\nTransformMatchingTex\n(\nnew_line2\n,\nlines\n[\n3\n],\ntransform_mismatches\n=\nTrue\n,\n),\n**\nplay_kw\n)\nself\n.\nwait\n(\n3\n)\nself\n.\nplay\n(\nFadeOut\n(\nlines\n,\nRIGHT\n))\n# Alternatively, if you don't want to think about breaking up\n# the tex strings deliberately, you can TransformMatchingShapes,\n# which will try to line up all pieces of a source mobject with\n# those of a target, regardless of the submobject hierarchy in\n# each one, according to whether those pieces have the same\n# shape (as best it can).\nsource\n=\nText\n(\n\"the morse code\"\n,\nheight\n=\n1\n)\ntarget\n=\nText\n(\n\"here come dots\"\n,\nheight\n=\n1\n)\nself\n.\nplay\n(\nWrite\n(\nsource\n))\nself\n.\nwait\n()\nkw\n=\n{\n\"run_time\"\n:\n3\n,\n\"path_arc\"\n:\nPI\n/\n2\n}\nself\n.\nplay\n(\nTransformMatchingShapes\n(\nsource\n,\ntarget\n,\n**\nkw\n))\nself\n.\nwait\n()\nself\n.\nplay\n(\nTransformMatchingShapes\n(\ntarget\n,\nsource\n,\n**\nkw\n))\nself\n.\nwait\n()\nThe new classes in this scene are\nTex\n,\nTexText\n,\nTransformMatchingTex\nand\nTransformMatchingShapes\n.\nTex\nuses LaTeX to create mathematical formulas.\nTexText\nuses LaTeX to create text.\nTransformMatchingTeX\nautomatically transforms sub-objects according to the similarities and differences of tex in\nTex\n.\nTransformMatchingShapes\nautomatically transform sub-objects directly based on the similarities and differences of the object point sets.\nUpdatersExample\n¶\nUpdatersExample\n¶\nclass\nUpdatersExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nsquare\n=\nSquare\n()\nsquare\n.\nset_fill\n(\nBLUE_E\n,\n1\n)\n# On all all frames, the constructor Brace(square, UP) will\n# be called, and the mobject brace will set its data to match\n# that of the newly constructed object\nbrace\n=\nalways_redraw\n(\nBrace\n,\nsquare\n,\nUP\n)\ntext\n,\nnumber\n=\nlabel\n=\nVGroup\n(\nText\n(\n\"Width = \"\n),\nDecimalNumber\n(\n0\n,\nshow_ellipsis\n=\nTrue\n,\nnum_decimal_places\n=\n2\n,\ninclude_sign\n=\nTrue\n,\n)\n)\nlabel\n.\narrange\n(\nRIGHT\n)\n# This ensures that the method deicmal.next_to(square)\n# is called on every frame\nalways\n(\nlabel\n.\nnext_to\n,\nbrace\n,\nUP\n)\n# You could also write the following equivalent line\n# label.add_updater(lambda m: m.next_to(brace, UP))\n# If the argument itself might change, you can use f_always,\n# for which the arguments following the initial Mobject method\n# should be functions returning arguments to that method.\n# The following line ensures that decimal.set_value(square.get_y())\n# is called every frame\nf_always\n(\nnumber\n.\nset_value\n,\nsquare\n.\nget_width\n)\n# You could also write the following equivalent line\n# number.add_updater(lambda m: m.set_value(square.get_width()))\nself\n.\nadd\n(\nsquare\n,\nbrace\n,\nlabel\n)\n# Notice that the brace and label track with the square\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nscale\n(\n2\n),\nrate_func\n=\nthere_and_back\n,\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n5\n,\nstretch\n=\nTrue\n),\nrun_time\n=\n3\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nsquare\n.\nanimate\n.\nset_width\n(\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# In general, you can alway call Mobject.add_updater, and pass in\n# a function that you want to be called on every frame.  The function\n# should take in either one argument, the mobject, or two arguments,\n# the mobject and the amount of time since the last frame.\nnow\n=\nself\n.\ntime\nw0\n=\nsquare\n.\nget_width\n()\nsquare\n.\nadd_updater\n(\nlambda\nm\n:\nm\n.\nset_width\n(\nw0\n*\nmath\n.\ncos\n(\nself\n.\ntime\n-\nnow\n))\n)\nself\n.\nwait\n(\n4\n*\nPI\n)\nThe new classes and usage in this scene are\nalways_redraw()\n,\nDecimalNumber\n,\n.to_edge()\n,\n.center()\n,\nalways()\n,\nf_always()\n,\n.set_y()\nand\n.add_updater()\n.\nalways_redraw()\nfunction create a new mobject every frame.\nDecimalNumber\nis a variable number, speed it up by breaking it into\nText\ncharacters.\n.to_edge()\nmeans to place the object on the edge of the screen.\n.center()\nmeans to place the object in the center of the screen.\nalways(f,\nx)\nmeans that a certain function (\nf(x)\n) is executed every frame.\nf_always(f,\ng)\nis similar to\nalways\n, executed\nf(g())\nevery frame.\n.set_y()\nmeans to set the ordinate of the object on the screen.\n.add_updater()\nsets an update function for the object. For example:\nmob1.add_updater(lambda\nmob:\nmob.next_to(mob2))\nmeans\nmob1.next_to(mob2)\nis executed every frame.\nCoordinateSystemExample\n¶\nCoordinateSystemExample\n¶\nclass\nCoordinateSystemExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n(\n# x-axis ranges from -1 to 10, with a default step size of 1\nx_range\n=\n(\n-\n1\n,\n10\n),\n# y-axis ranges from -2 to 2 with a step size of 0.5\ny_range\n=\n(\n-\n2\n,\n2\n,\n0.5\n),\n# The axes will be stretched so as to match the specified\n# height and width\nheight\n=\n6\n,\nwidth\n=\n10\n,\n# Axes is made of two NumberLine mobjects.  You can specify\n# their configuration with axis_config\naxis_config\n=\n{\n\"stroke_color\"\n:\nGREY_A\n,\n\"stroke_width\"\n:\n2\n,\n},\n# Alternatively, you can specify configuration for just one\n# of them, like this.\ny_axis_config\n=\n{\n\"include_tip\"\n:\nFalse\n,\n}\n)\n# Keyword arguments of add_coordinate_labels can be used to\n# configure the DecimalNumber mobjects which it creates and\n# adds to the axes\naxes\n.\nadd_coordinate_labels\n(\nfont_size\n=\n20\n,\nnum_decimal_places\n=\n1\n,\n)\nself\n.\nadd\n(\naxes\n)\n# Axes descends from the CoordinateSystem class, meaning\n# you can call call axes.coords_to_point, abbreviated to\n# axes.c2p, to associate a set of coordinates with a point,\n# like so:\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\nc2p\n(\n0\n,\n0\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n5\n,\n0.5\n)))\nself\n.\nwait\n()\n# Similarly, you can call axes.point_to_coords, or axes.p2c\n# print(axes.p2c(dot.get_center()))\n# We can draw lines from the axes to better mark the coordinates\n# of a given point.\n# Here, the always_redraw command means that on each new frame\n# the lines will be redrawn\nh_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_h_line\n(\ndot\n.\nget_left\n()))\nv_line\n=\nalways_redraw\n(\nlambda\n:\naxes\n.\nget_v_line\n(\ndot\n.\nget_bottom\n()))\nself\n.\nplay\n(\nShowCreation\n(\nh_line\n),\nShowCreation\n(\nv_line\n),\n)\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n3\n,\n-\n2\n)))\nself\n.\nwait\n()\nself\n.\nplay\n(\ndot\n.\nanimate\n.\nmove_to\n(\naxes\n.\nc2p\n(\n1\n,\n1\n)))\nself\n.\nwait\n()\n# If we tie the dot to a particular set of coordinates, notice\n# that as we move the axes around it respects the coordinate\n# system defined by them.\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\nc2p\n(\n1\n,\n1\n))\nself\n.\nplay\n(\naxes\n.\nanimate\n.\nscale\n(\n0.75\n)\n.\nto_corner\n(\nUL\n),\nrun_time\n=\n2\n,\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nFadeOut\n(\nVGroup\n(\naxes\n,\ndot\n,\nh_line\n,\nv_line\n)))\n# Other coordinate systems you can play around with include\n# ThreeDAxes, NumberPlane, and ComplexPlane.\nGraphExample\n¶\nGraphExample\n¶\nclass\nGraphExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\naxes\n=\nAxes\n((\n-\n3\n,\n10\n),\n(\n-\n1\n,\n8\n))\naxes\n.\nadd_coordinate_labels\n()\nself\n.\nplay\n(\nWrite\n(\naxes\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n1\n))\n# Axes.get_graph will return the graph of a function\nsin_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2\n*\nmath\n.\nsin\n(\nx\n),\ncolor\n=\nBLUE\n,\n)\n# By default, it draws it so as to somewhat smoothly interpolate\n# between sampled points (x, f(x)).  If the graph is meant to have\n# a corner, though, you can set use_smoothing to False\nrelu_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\nmax\n(\nx\n,\n0\n),\nuse_smoothing\n=\nFalse\n,\ncolor\n=\nYELLOW\n,\n)\n# For discontinuous functions, you can specify the point of\n# discontinuity so that it does not try to draw over the gap.\nstep_graph\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n2.0\nif\nx\n>\n3\nelse\n1.0\n,\ndiscontinuities\n=\n[\n3\n],\ncolor\n=\nGREEN\n,\n)\n# Axes.get_graph_label takes in either a string or a mobject.\n# If it's a string, it treats it as a LaTeX expression.  By default\n# it places the label next to the graph near the right side, and\n# has it match the color of the graph\nsin_label\n=\naxes\n.\nget_graph_label\n(\nsin_graph\n,\n\"\n\\\\\nsin(x)\"\n)\nrelu_label\n=\naxes\n.\nget_graph_label\n(\nrelu_graph\n,\nText\n(\n\"ReLU\"\n))\nstep_label\n=\naxes\n.\nget_graph_label\n(\nstep_graph\n,\nText\n(\n\"Step\"\n),\nx\n=\n4\n)\nself\n.\nplay\n(\nShowCreation\n(\nsin_graph\n),\nFadeIn\n(\nsin_label\n,\nRIGHT\n),\n)\nself\n.\nwait\n(\n2\n)\nself\n.\nplay\n(\nReplacementTransform\n(\nsin_graph\n,\nrelu_graph\n),\nFadeTransform\n(\nsin_label\n,\nrelu_label\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nReplacementTransform\n(\nrelu_graph\n,\nstep_graph\n),\nFadeTransform\n(\nrelu_label\n,\nstep_label\n),\n)\nself\n.\nwait\n()\nparabola\n=\naxes\n.\nget_graph\n(\nlambda\nx\n:\n0.25\n*\nx\n**\n2\n)\nparabola\n.\nset_stroke\n(\nBLUE\n)\nself\n.\nplay\n(\nFadeOut\n(\nstep_graph\n),\nFadeOut\n(\nstep_label\n),\nShowCreation\n(\nparabola\n)\n)\nself\n.\nwait\n()\n# You can use axes.input_to_graph_point, abbreviated\n# to axes.i2gp, to find a particular point on a graph\ndot\n=\nDot\n(\ncolor\n=\nRED\n)\ndot\n.\nmove_to\n(\naxes\n.\ni2gp\n(\n2\n,\nparabola\n))\nself\n.\nplay\n(\nFadeIn\n(\ndot\n,\nscale\n=\n0.5\n))\n# A value tracker lets us animate a parameter, usually\n# with the intent of having other mobjects update based\n# on the parameter\nx_tracker\n=\nValueTracker\n(\n2\n)\nf_always\n(\ndot\n.\nmove_to\n,\nlambda\n:\naxes\n.\ni2gp\n(\nx_tracker\n.\nget_value\n(),\nparabola\n)\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n4\n),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nx_tracker\n.\nanimate\n.\nset_value\n(\n-\n2\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\nSurfaceExample\n¶\nSurfaceExample\n¶\nclass\nSurfaceExample\n(\nScene\n):\nCONFIG\n=\n{\n\"camera_class\"\n:\nThreeDCamera\n,\n}\ndef\nconstruct\n(\nself\n):\nsurface_text\n=\nText\n(\n\"For 3d scenes, try using surfaces\"\n)\nsurface_text\n.\nfix_in_frame\n()\nsurface_text\n.\nto_edge\n(\nUP\n)\nself\n.\nadd\n(\nsurface_text\n)\nself\n.\nwait\n(\n0.1\n)\ntorus1\n=\nTorus\n(\nr1\n=\n1\n,\nr2\n=\n1\n)\ntorus2\n=\nTorus\n(\nr1\n=\n3\n,\nr2\n=\n1\n)\nsphere\n=\nSphere\n(\nradius\n=\n3\n,\nresolution\n=\ntorus1\n.\nresolution\n)\n# You can texture a surface with up to two images, which will\n# be interpreted as the side towards the light, and away from\n# the light.  These can be either urls, or paths to a local file\n# in whatever you've set as the image directory in\n# the custom_config.yml file\n# day_texture = \"EarthTextureMap\"\n# night_texture = \"NightEarthTextureMap\"\nday_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\nnight_texture\n=\n\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\nsurfaces\n=\n[\nTexturedSurface\n(\nsurface\n,\nday_texture\n,\nnight_texture\n)\nfor\nsurface\nin\n[\nsphere\n,\ntorus1\n,\ntorus2\n]\n]\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nshift\n(\nIN\n)\nmob\n.\nmesh\n=\nSurfaceMesh\n(\nmob\n)\nmob\n.\nmesh\n.\nset_stroke\n(\nBLUE\n,\n1\n,\nopacity\n=\n0.5\n)\n# Set perspective\nframe\n=\nself\n.\ncamera\n.\nframe\nframe\n.\nset_euler_angles\n(\ntheta\n=-\n30\n*\nDEGREES\n,\nphi\n=\n70\n*\nDEGREES\n,\n)\nsurface\n=\nsurfaces\n[\n0\n]\nself\n.\nplay\n(\nFadeIn\n(\nsurface\n),\nShowCreation\n(\nsurface\n.\nmesh\n,\nlag_ratio\n=\n0.01\n,\nrun_time\n=\n3\n),\n)\nfor\nmob\nin\nsurfaces\n:\nmob\n.\nadd\n(\nmob\n.\nmesh\n)\nsurface\n.\nsave_state\n()\nself\n.\nplay\n(\nRotate\n(\nsurface\n,\nPI\n/\n2\n),\nrun_time\n=\n2\n)\nfor\nmob\nin\nsurfaces\n[\n1\n:]:\nmob\n.\nrotate\n(\nPI\n/\n2\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n1\n]),\nrun_time\n=\n3\n)\nself\n.\nplay\n(\nTransform\n(\nsurface\n,\nsurfaces\n[\n2\n]),\n# Move camera frame during the transition\nframe\n.\nanimate\n.\nincrement_phi\n(\n-\n10\n*\nDEGREES\n),\nframe\n.\nanimate\n.\nincrement_theta\n(\n-\n20\n*\nDEGREES\n),\nrun_time\n=\n3\n)\n# Add ambient rotation\nframe\n.\nadd_updater\n(\nlambda\nm\n,\ndt\n:\nm\n.\nincrement_theta\n(\n-\n0.1\n*\ndt\n))\n# Play around with where the light is\nlight_text\n=\nText\n(\n\"You can move around the light source\"\n)\nlight_text\n.\nmove_to\n(\nsurface_text\n)\nlight_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nsurface_text\n,\nlight_text\n))\nlight\n=\nself\n.\ncamera\n.\nlight_source\nself\n.\nadd\n(\nlight\n)\nlight\n.\nsave_state\n()\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nmove_to\n(\n3\n*\nIN\n),\nrun_time\n=\n5\n)\nself\n.\nplay\n(\nlight\n.\nanimate\n.\nshift\n(\n10\n*\nOUT\n),\nrun_time\n=\n5\n)\ndrag_text\n=\nText\n(\n\"Try moving the mouse while pressing d or s\"\n)\ndrag_text\n.\nmove_to\n(\nlight_text\n)\ndrag_text\n.\nfix_in_frame\n()\nself\n.\nplay\n(\nFadeTransform\n(\nlight_text\n,\ndrag_text\n))\nself\n.\nwait\n()\nThis scene shows an example of using a three-dimensional surface, and\nthe related usage has been briefly described in the notes.\n.fix_in_frame()\nmakes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.\nOpeningManimExample\n¶\nOpeningManimExample\n¶\nclass\nOpeningManimExample\n(\nScene\n):\ndef\nconstruct\n(\nself\n):\nintro_words\n=\nText\n(\n\"\"\"\nThe original motivation for manim was to\nbetter illustrate mathematical functions\nas transformations.\n\"\"\"\n)\nintro_words\n.\nto_edge\n(\nUP\n)\nself\n.\nplay\n(\nWrite\n(\nintro_words\n))\nself\n.\nwait\n(\n2\n)\n# Linear transform\ngrid\n=\nNumberPlane\n((\n-\n10\n,\n10\n),\n(\n-\n5\n,\n5\n))\nmatrix\n=\n[[\n1\n,\n1\n],\n[\n0\n,\n1\n]]\nlinear_transform_words\n=\nVGroup\n(\nText\n(\n\"This is what the matrix\"\n),\nIntegerMatrix\n(\nmatrix\n,\ninclude_background_rectangle\n=\nTrue\n),\nText\n(\n\"looks like\"\n)\n)\nlinear_transform_words\n.\narrange\n(\nRIGHT\n)\nlinear_transform_words\n.\nto_edge\n(\nUP\n)\nlinear_transform_words\n.\nset_stroke\n(\nBLACK\n,\n10\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nShowCreation\n(\ngrid\n),\nFadeTransform\n(\nintro_words\n,\nlinear_transform_words\n)\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\ngrid\n.\nanimate\n.\napply_matrix\n(\nmatrix\n),\nrun_time\n=\n3\n)\nself\n.\nwait\n()\n# Complex map\nc_grid\n=\nComplexPlane\n()\nmoving_c_grid\n=\nc_grid\n.\ncopy\n()\nmoving_c_grid\n.\nprepare_for_nonlinear_transform\n()\nc_grid\n.\nset_stroke\n(\nBLUE_E\n,\n1\n)\nc_grid\n.\nadd_coordinate_labels\n(\nfont_size\n=\n24\n)\ncomplex_map_words\n=\nTexText\n(\n\"\"\"\nOr thinking of the plane as $\n\\\\\nmathds\n{C}\n$,\n\\\\\\\\\nthis is the map $z\n\\\\\nrightarrow z^2$\n\"\"\"\n)\ncomplex_map_words\n.\nto_corner\n(\nUR\n)\ncomplex_map_words\n.\nset_stroke\n(\nBLACK\n,\n5\n,\nbackground\n=\nTrue\n)\nself\n.\nplay\n(\nFadeOut\n(\ngrid\n),\nWrite\n(\nc_grid\n,\nrun_time\n=\n3\n),\nFadeIn\n(\nmoving_c_grid\n),\nFadeTransform\n(\nlinear_transform_words\n,\ncomplex_map_words\n),\n)\nself\n.\nwait\n()\nself\n.\nplay\n(\nmoving_c_grid\n.\nanimate\n.\napply_complex_function\n(\nlambda\nz\n:\nz\n**\n2\n),\nrun_time\n=\n6\n,\n)\nself\n.\nwait\n(\n2\n)\nThis scene is a comprehensive application of a two-dimensional scene.\nAfter seeing these scenes, you have already understood part of the\nusage of manim. For more examples, see\nthe video code of 3b1b\n.\nContents\nExample Scenes\nInteractiveDevlopment\nAnimatingMethods\nTextExample\nTexTransformExample\nUpdatersExample\nCoordinateSystemExample\nGraphExample\nSurfaceExample\nOpeningManimExample",
    "code_examples": [
      "example_scenes.py",
      "from manimlib import *\n\nclass InteractiveDevelopment(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n\n        # This opens an iPython terminal where you can keep writing\n        # lines as if they were part of this construct method.\n        # In particular, 'square', 'circle' and 'self' will all be\n        # part of the local namespace in that terminal.\n        self.embed()\n\n        # Try copying and pasting some of the lines below into\n        # the interactive shell\n        self.play(ReplacementTransform(square, circle))\n        self.wait()\n        self.play(circle.animate.stretch(4, 0))\n        self.play(Rotate(circle, 90 * DEGREES))\n        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))\n\n        text = Text(\"\"\"\n            In general, using the interactive shell\n            is very helpful when developing new scenes\n        \"\"\")\n        self.play(Write(text))\n\n        # In the interactive shell, you can just type\n        # play, add, remove, clear, wait, save_state and restore,\n        # instead of self.play, self.add, self.remove, etc.\n\n        # To interact with the window, type touch().  You can then\n        # scroll in the window, or zoom by holding down 'z' while scrolling,\n        # and change camera perspective by holding down 'd' while moving\n        # the mouse.  Press 'r' to reset to the standard camera position.\n        # Press 'q' to stop interacting with the window and go back to\n        # typing new commands into the shell.\n\n        # In principle you can customize a scene to be responsive to\n        # mouse and keyboard interactions\n        always(circle.move_to, self.mouse_point)",
      "class AnimatingMethods(Scene):\n    def construct(self):\n        grid = OldTex(r\"\\pi\").get_grid(10, 10, height=4)\n        self.add(grid)\n\n        # You can animate the application of mobject methods with the\n        # \".animate\" syntax:\n        self.play(grid.animate.shift(LEFT))\n\n        # Alternatively, you can use the older syntax by passing the\n        # method and then the arguments to the scene's \"play\" function:\n        self.play(grid.shift, LEFT)\n\n        # Both of those will interpolate between the mobject's initial\n        # state and whatever happens when you apply that method.\n        # For this example, calling grid.shift(LEFT) would shift the\n        # grid one unit to the left, but both of the previous calls to\n        # \"self.play\" animate that motion.\n\n        # The same applies for any method, including those setting colors.\n        self.play(grid.animate.set_color(YELLOW))\n        self.wait()\n        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))\n        self.wait()\n        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))\n        self.wait()\n\n        # The method Mobject.apply_complex_function lets you apply arbitrary\n        # complex functions, treating the points defining the mobject as\n        # complex numbers.\n        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)\n        self.wait()\n\n        # Even more generally, you could apply Mobject.apply_function,\n        # which takes in functions form R^3 to R^3\n        self.play(\n            grid.animate.apply_function(\n                lambda p: [\n                    p[0] + 0.5 * math.sin(p[1]),\n                    p[1] + 0.5 * math.sin(p[0]),\n                    p[2]\n                ]\n            ),\n            run_time=5,\n        )\n        self.wait()",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      ".get_grid()",
      "self.play(mob.animate.method(args))",
      "class TextExample(Scene):\n    def construct(self):\n        # To run this scene properly, you should have \"Consolas\" font in your computer\n        # for full usage, you can see https://github.com/3b1b/manim/pull/680\n        text = Text(\"Here is a text\", font=\"Consolas\", font_size=90)\n        difference = Text(\n            \"\"\"\n            The most important difference between Text and TexText is that\\n\n            you can change the font more easily, but can't use the LaTeX grammar\n            \"\"\",\n            font=\"Arial\", font_size=24,\n            # t2c is a dict that you can choose color for different text\n            t2c={\"Text\": BLUE, \"TexText\": BLUE, \"LaTeX\": ORANGE}\n        )\n        VGroup(text, difference).arrange(DOWN, buff=1)\n        self.play(Write(text))\n        self.play(FadeIn(difference, UP))\n        self.wait(3)\n\n        fonts = Text(\n            \"And you can also set the font according to different words\",\n            font=\"Arial\",\n            t2f={\"font\": \"Consolas\", \"words\": \"Consolas\"},\n            t2c={\"font\": BLUE, \"words\": GREEN}\n        )\n        fonts.set_width(FRAME_WIDTH - 1)\n        slant = Text(\n            \"And the same as slant and weight\",\n            font=\"Consolas\",\n            t2s={\"slant\": ITALIC},\n            t2w={\"weight\": BOLD},\n            t2c={\"slant\": ORANGE, \"weight\": RED}\n        )\n        VGroup(fonts, slant).arrange(DOWN, buff=0.8)\n        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))\n        self.play(Write(fonts))\n        self.wait()\n        self.play(Write(slant))\n        self.wait()",
      "class TexTransformExample(Scene):\n    def construct(self):\n        to_isolate = [\"B\", \"C\", \"=\", \"(\", \")\"]\n        lines = VGroup(\n            # Passing in muliple arguments to Tex will result\n            # in the same expression as if those arguments had\n            # been joined together, except that the submobject\n            # hierarchy of the resulting mobject ensure that the\n            # Tex mobject has a subject corresponding to\n            # each of these strings.  For example, the Tex mobject\n            # below will have 5 subjects, corresponding to the\n            # expressions [A^2, +, B^2, =, C^2]\n            OldTex(\"A^2\", \"+\", \"B^2\", \"=\", \"C^2\"),\n            # Likewise here\n            OldTex(\"A^2\", \"=\", \"C^2\", \"-\", \"B^2\"),\n            # Alternatively, you can pass in the keyword argument\n            # \"isolate\" with a list of strings that should be out as\n            # their own submobject.  So the line below is equivalent\n            # to the commented out line below it.\n            OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A^2\", *to_isolate]),\n            # OldTex(\"A^2\", \"=\", \"(\", \"C\", \"+\", \"B\", \")\", \"(\", \"C\", \"-\", \"B\", \")\"),\n            OldTex(\"A = \\\\sqrt{(C + B)(C - B)}\", isolate=[\"A\", *to_isolate])\n        )\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        for line in lines:\n            line.set_color_by_tex_to_color_map({\n                \"A\": BLUE,\n                \"B\": TEAL,\n                \"C\": GREEN,\n            })\n\n        play_kw = {\"run_time\": 2}\n        self.add(lines[0])\n        # The animation TransformMatchingTex will line up parts\n        # of the source and target which have matching tex strings.\n        # Here, giving it a little path_arc makes each part sort of\n        # rotate into their final positions, which feels appropriate\n        # for the idea of rearranging an equation\n        self.play(\n            TransformMatchingTex(\n                lines[0].copy(), lines[1],\n                path_arc=90 * DEGREES,\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # Now, we could try this again on the next line...\n        self.play(\n            TransformMatchingTex(lines[1].copy(), lines[2]),\n            **play_kw\n        )\n        self.wait()\n        # ...and this looks nice enough, but since there's no tex\n        # in lines[2] which matches \"C^2\" or \"B^2\", those terms fade\n        # out to nothing while the C and B terms fade in from nothing.\n        # If, however, we want the C^2 to go to C, and B^2 to go to B,\n        # we can specify that with a key map.\n        self.play(FadeOut(lines[2]))\n        self.play(\n            TransformMatchingTex(\n                lines[1].copy(), lines[2],\n                key_map={\n                    \"C^2\": \"C\",\n                    \"B^2\": \"B\",\n                }\n            ),\n            **play_kw\n        )\n        self.wait()\n\n        # And to finish off, a simple TransformMatchingShapes would work\n        # just fine.  But perhaps we want that exponent on A^2 to transform into\n        # the square root symbol.  At the moment, lines[2] treats the expression\n        # A^2 as a unit, so we might create a new version of the same line which\n        # separates out just the A.  This way, when TransformMatchingTex lines up\n        # all matching parts, the only mismatch will be between the \"^2\" from\n        # new_line2 and the \"\\sqrt\" from the final line.  By passing in,\n        # transform_mismatches=True, it will transform this \"^2\" part into\n        # the \"\\sqrt\" part.\n        new_line2 = OldTex(\"A^2 = (C + B)(C - B)\", isolate=[\"A\", *to_isolate])\n        new_line2.replace(lines[2])\n        new_line2.match_style(lines[2])\n\n        self.play(\n            TransformMatchingTex(\n                new_line2, lines[3],\n                transform_mismatches=True,\n            ),\n            **play_kw\n        )\n        self.wait(3)\n        self.play(FadeOut(lines, RIGHT))\n\n        # Alternatively, if you don't want to think about breaking up\n        # the tex strings deliberately, you can TransformMatchingShapes,\n        # which will try to line up all pieces of a source mobject with\n        # those of a target, regardless of the submobject hierarchy in\n        # each one, according to whether those pieces have the same\n        # shape (as best it can).\n        source = Text(\"the morse code\", height=1)\n        target = Text(\"here come dots\", height=1)\n\n        self.play(Write(source))\n        self.wait()\n        kw = {\"run_time\": 3, \"path_arc\": PI / 2}\n        self.play(TransformMatchingShapes(source, target, **kw))\n        self.wait()\n        self.play(TransformMatchingShapes(target, source, **kw))\n        self.wait()",
      "TransformMatchingTex",
      "TransformMatchingShapes",
      "TransformMatchingTeX",
      "TransformMatchingShapes",
      "class UpdatersExample(Scene):\n    def construct(self):\n        square = Square()\n        square.set_fill(BLUE_E, 1)\n\n        # On all all frames, the constructor Brace(square, UP) will\n        # be called, and the mobject brace will set its data to match\n        # that of the newly constructed object\n        brace = always_redraw(Brace, square, UP)\n\n        text, number = label = VGroup(\n            Text(\"Width = \"),\n            DecimalNumber(\n                0,\n                show_ellipsis=True,\n                num_decimal_places=2,\n                include_sign=True,\n            )\n        )\n        label.arrange(RIGHT)\n\n        # This ensures that the method deicmal.next_to(square)\n        # is called on every frame\n        always(label.next_to, brace, UP)\n        # You could also write the following equivalent line\n        # label.add_updater(lambda m: m.next_to(brace, UP))\n\n        # If the argument itself might change, you can use f_always,\n        # for which the arguments following the initial Mobject method\n        # should be functions returning arguments to that method.\n        # The following line ensures that decimal.set_value(square.get_y())\n        # is called every frame\n        f_always(number.set_value, square.get_width)\n        # You could also write the following equivalent line\n        # number.add_updater(lambda m: m.set_value(square.get_width()))\n\n        self.add(square, brace, label)\n\n        # Notice that the brace and label track with the square\n        self.play(\n            square.animate.scale(2),\n            rate_func=there_and_back,\n            run_time=2,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(5, stretch=True),\n            run_time=3,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(2),\n            run_time=3\n        )\n        self.wait()\n\n        # In general, you can alway call Mobject.add_updater, and pass in\n        # a function that you want to be called on every frame.  The function\n        # should take in either one argument, the mobject, or two arguments,\n        # the mobject and the amount of time since the last frame.\n        now = self.time\n        w0 = square.get_width()\n        square.add_updater(\n            lambda m: m.set_width(w0 * math.cos(self.time - now))\n        )\n        self.wait(4 * PI)",
      "always_redraw()",
      "DecimalNumber",
      ".add_updater()",
      "always_redraw()",
      "DecimalNumber",
      "always(f, x)",
      "f_always(f, g)",
      ".add_updater()",
      "mob1.add_updater(lambda mob: mob.next_to(mob2))",
      "mob1.next_to(mob2)",
      "class CoordinateSystemExample(Scene):\n    def construct(self):\n        axes = Axes(\n            # x-axis ranges from -1 to 10, with a default step size of 1\n            x_range=(-1, 10),\n            # y-axis ranges from -2 to 2 with a step size of 0.5\n            y_range=(-2, 2, 0.5),\n            # The axes will be stretched so as to match the specified\n            # height and width\n            height=6,\n            width=10,\n            # Axes is made of two NumberLine mobjects.  You can specify\n            # their configuration with axis_config\n            axis_config={\n                \"stroke_color\": GREY_A,\n                \"stroke_width\": 2,\n            },\n            # Alternatively, you can specify configuration for just one\n            # of them, like this.\n            y_axis_config={\n                \"include_tip\": False,\n            }\n        )\n        # Keyword arguments of add_coordinate_labels can be used to\n        # configure the DecimalNumber mobjects which it creates and\n        # adds to the axes\n        axes.add_coordinate_labels(\n            font_size=20,\n            num_decimal_places=1,\n        )\n        self.add(axes)\n\n        # Axes descends from the CoordinateSystem class, meaning\n        # you can call call axes.coords_to_point, abbreviated to\n        # axes.c2p, to associate a set of coordinates with a point,\n        # like so:\n        dot = Dot(color=RED)\n        dot.move_to(axes.c2p(0, 0))\n        self.play(FadeIn(dot, scale=0.5))\n        self.play(dot.animate.move_to(axes.c2p(3, 2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))\n        self.wait()\n\n        # Similarly, you can call axes.point_to_coords, or axes.p2c\n        # print(axes.p2c(dot.get_center()))\n\n        # We can draw lines from the axes to better mark the coordinates\n        # of a given point.\n        # Here, the always_redraw command means that on each new frame\n        # the lines will be redrawn\n        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))\n        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))\n\n        self.play(\n            ShowCreation(h_line),\n            ShowCreation(v_line),\n        )\n        self.play(dot.animate.move_to(axes.c2p(3, -2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(1, 1)))\n        self.wait()\n\n        # If we tie the dot to a particular set of coordinates, notice\n        # that as we move the axes around it respects the coordinate\n        # system defined by them.\n        f_always(dot.move_to, lambda: axes.c2p(1, 1))\n        self.play(\n            axes.animate.scale(0.75).to_corner(UL),\n            run_time=2,\n        )\n        self.wait()\n        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))\n\n        # Other coordinate systems you can play around with include\n        # ThreeDAxes, NumberPlane, and ComplexPlane.",
      "class GraphExample(Scene):\n    def construct(self):\n        axes = Axes((-3, 10), (-1, 8))\n        axes.add_coordinate_labels()\n\n        self.play(Write(axes, lag_ratio=0.01, run_time=1))\n\n        # Axes.get_graph will return the graph of a function\n        sin_graph = axes.get_graph(\n            lambda x: 2 * math.sin(x),\n            color=BLUE,\n        )\n        # By default, it draws it so as to somewhat smoothly interpolate\n        # between sampled points (x, f(x)).  If the graph is meant to have\n        # a corner, though, you can set use_smoothing to False\n        relu_graph = axes.get_graph(\n            lambda x: max(x, 0),\n            use_smoothing=False,\n            color=YELLOW,\n        )\n        # For discontinuous functions, you can specify the point of\n        # discontinuity so that it does not try to draw over the gap.\n        step_graph = axes.get_graph(\n            lambda x: 2.0 if x > 3 else 1.0,\n            discontinuities=[3],\n            color=GREEN,\n        )\n\n        # Axes.get_graph_label takes in either a string or a mobject.\n        # If it's a string, it treats it as a LaTeX expression.  By default\n        # it places the label next to the graph near the right side, and\n        # has it match the color of the graph\n        sin_label = axes.get_graph_label(sin_graph, \"\\\\sin(x)\")\n        relu_label = axes.get_graph_label(relu_graph, Text(\"ReLU\"))\n        step_label = axes.get_graph_label(step_graph, Text(\"Step\"), x=4)\n\n        self.play(\n            ShowCreation(sin_graph),\n            FadeIn(sin_label, RIGHT),\n        )\n        self.wait(2)\n        self.play(\n            ReplacementTransform(sin_graph, relu_graph),\n            FadeTransform(sin_label, relu_label),\n        )\n        self.wait()\n        self.play(\n            ReplacementTransform(relu_graph, step_graph),\n            FadeTransform(relu_label, step_label),\n        )\n        self.wait()\n\n        parabola = axes.get_graph(lambda x: 0.25 * x**2)\n        parabola.set_stroke(BLUE)\n        self.play(\n            FadeOut(step_graph),\n            FadeOut(step_label),\n            ShowCreation(parabola)\n        )\n        self.wait()\n\n        # You can use axes.input_to_graph_point, abbreviated\n        # to axes.i2gp, to find a particular point on a graph\n        dot = Dot(color=RED)\n        dot.move_to(axes.i2gp(2, parabola))\n        self.play(FadeIn(dot, scale=0.5))\n\n        # A value tracker lets us animate a parameter, usually\n        # with the intent of having other mobjects update based\n        # on the parameter\n        x_tracker = ValueTracker(2)\n        f_always(\n            dot.move_to,\n            lambda: axes.i2gp(x_tracker.get_value(), parabola)\n        )\n\n        self.play(x_tracker.animate.set_value(4), run_time=3)\n        self.play(x_tracker.animate.set_value(-2), run_time=3)\n        self.wait()",
      "class SurfaceExample(Scene):\n    CONFIG = {\n        \"camera_class\": ThreeDCamera,\n    }\n\n    def construct(self):\n        surface_text = Text(\"For 3d scenes, try using surfaces\")\n        surface_text.fix_in_frame()\n        surface_text.to_edge(UP)\n        self.add(surface_text)\n        self.wait(0.1)\n\n        torus1 = Torus(r1=1, r2=1)\n        torus2 = Torus(r1=3, r2=1)\n        sphere = Sphere(radius=3, resolution=torus1.resolution)\n        # You can texture a surface with up to two images, which will\n        # be interpreted as the side towards the light, and away from\n        # the light.  These can be either urls, or paths to a local file\n        # in whatever you've set as the image directory in\n        # the custom_config.yml file\n\n        # day_texture = \"EarthTextureMap\"\n        # night_texture = \"NightEarthTextureMap\"\n        day_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\n        night_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\n\n        surfaces = [\n            TexturedSurface(surface, day_texture, night_texture)\n            for surface in [sphere, torus1, torus2]\n        ]\n\n        for mob in surfaces:\n            mob.shift(IN)\n            mob.mesh = SurfaceMesh(mob)\n            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)\n\n        # Set perspective\n        frame = self.camera.frame\n        frame.set_euler_angles(\n            theta=-30 * DEGREES,\n            phi=70 * DEGREES,\n        )\n\n        surface = surfaces[0]\n\n        self.play(\n            FadeIn(surface),\n            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),\n        )\n        for mob in surfaces:\n            mob.add(mob.mesh)\n        surface.save_state()\n        self.play(Rotate(surface, PI / 2), run_time=2)\n        for mob in surfaces[1:]:\n            mob.rotate(PI / 2)\n\n        self.play(\n            Transform(surface, surfaces[1]),\n            run_time=3\n        )\n\n        self.play(\n            Transform(surface, surfaces[2]),\n            # Move camera frame during the transition\n            frame.animate.increment_phi(-10 * DEGREES),\n            frame.animate.increment_theta(-20 * DEGREES),\n            run_time=3\n        )\n        # Add ambient rotation\n        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))\n\n        # Play around with where the light is\n        light_text = Text(\"You can move around the light source\")\n        light_text.move_to(surface_text)\n        light_text.fix_in_frame()\n\n        self.play(FadeTransform(surface_text, light_text))\n        light = self.camera.light_source\n        self.add(light)\n        light.save_state()\n        self.play(light.animate.move_to(3 * IN), run_time=5)\n        self.play(light.animate.shift(10 * OUT), run_time=5)\n\n        drag_text = Text(\"Try moving the mouse while pressing d or s\")\n        drag_text.move_to(light_text)\n        drag_text.fix_in_frame()\n\n        self.play(FadeTransform(light_text, drag_text))\n        self.wait()",
      ".fix_in_frame()",
      "class OpeningManimExample(Scene):\n    def construct(self):\n        intro_words = Text(\"\"\"\n            The original motivation for manim was to\n            better illustrate mathematical functions\n            as transformations.\n        \"\"\")\n        intro_words.to_edge(UP)\n\n        self.play(Write(intro_words))\n        self.wait(2)\n\n        # Linear transform\n        grid = NumberPlane((-10, 10), (-5, 5))\n        matrix = [[1, 1], [0, 1]]\n        linear_transform_words = VGroup(\n            Text(\"This is what the matrix\"),\n            IntegerMatrix(matrix, include_background_rectangle=True),\n            Text(\"looks like\")\n        )\n        linear_transform_words.arrange(RIGHT)\n        linear_transform_words.to_edge(UP)\n        linear_transform_words.set_stroke(BLACK, 10, background=True)\n\n        self.play(\n            ShowCreation(grid),\n            FadeTransform(intro_words, linear_transform_words)\n        )\n        self.wait()\n        self.play(grid.animate.apply_matrix(matrix), run_time=3)\n        self.wait()\n\n        # Complex map\n        c_grid = ComplexPlane()\n        moving_c_grid = c_grid.copy()\n        moving_c_grid.prepare_for_nonlinear_transform()\n        c_grid.set_stroke(BLUE_E, 1)\n        c_grid.add_coordinate_labels(font_size=24)\n        complex_map_words = TexText(\"\"\"\n            Or thinking of the plane as $\\\\mathds{C}$,\\\\\\\\\n            this is the map $z \\\\rightarrow z^2$\n        \"\"\")\n        complex_map_words.to_corner(UR)\n        complex_map_words.set_stroke(BLACK, 5, background=True)\n\n        self.play(\n            FadeOut(grid),\n            Write(c_grid, run_time=3),\n            FadeIn(moving_c_grid),\n            FadeTransform(linear_transform_words, complex_map_words),\n        )\n        self.wait()\n        self.play(\n            moving_c_grid.animate.apply_complex_function(lambda z: z**2),\n            run_time=6,\n        )\n        self.wait(2)"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#example-scenes",
      "https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevelopment"
    ],
    "scraped_at": 1752428851.964491
  },
  "https://3b1b.github.io/manim/getting_started/structure.html#manim-s-directory-structure": {
    "url": "https://3b1b.github.io/manim/getting_started/structure.html#manim-s-directory-structure",
    "title": "Manim’s structure - manim  documentation",
    "content": "Manim’s structure\n¶\nManim’s directory structure\n¶\nThe manim directory looks very complicated, with a lot of files,\nbut the structure is clear.\nBelow is the directory structure of manim:\nmanimlib/ # manim library\n├── __init__.py\n├── __main__.py\n├── default_config.yml   # Default configuration file\n├── config.py            # Process CLI flags\n├── constants.py         # Defined some constants\n├── extract_scene.py     # Extract and run the scene\n├── shader_wrapper.py    # Shaders' Wrapper for convenient control\n├── window.py            # Playback window\n├── tex_templates/ # Templates preset for LaTeX\n│   ├── tex_templates.tex   # Tex template (will be compiled with latex, default)\n│   └── ctex_templates.tex  # Tex template that support Chinese (will be compiled with xelatex)\n├── camera/\n│   └── camera.py        # Including Camera and CameraFrame\n├── scene/\n│   ├── scene_file_writer.py     # Used to write scene to video file\n│   ├── scene.py                 # The basic Scene class\n│   ├── three_d_scene.py         # Three-dimensional scene\n│   ├── sample_space_scene.py    # Probability related sample space scene\n│   └── vector_space_scene.py    # Vector field scene\n├── animation/\n│   ├── animation.py     # The basic class of animation\n│   ├── composition.py   # Animation group\n│   ├── creation.py      # Animation related to Create\n│   ├── fading.py        # Fade related animation\n│   ├── growing.py       # Animation related to Grow\n│   ├── indication.py    # Some animations for emphasis\n│   ├── movement.py      # Animation related to movement\n│   ├── numbers.py       # Realize changes to DecimalNumber\n│   ├── rotation.py      # Animation related to rotation\n│   ├── specialized.py   # Some uncommon animations for special projects\n│   ├── transform_matching_parts.py # Transform which can automatically match parts\n│   ├── transform.py     # Some Transforms\n│   └── update.py        # Realize update from function\n├── mobject/\n│   ├── mobject.py       # The basic class of all math object\n│   ├── types/ # 4 types of mobject\n│   │   ├── dot_cloud.py            # Dot cloud (an subclass of PMobject)\n│   │   ├── image_mobject.py        # Insert pictures\n│   │   ├── point_cloud_mobject.py  # PMobject (mobject composed of points)\n│   │   ├── surface.py              # ParametricSurface\n│   │   └── vectorized_mobject.py   # VMobject (vectorized mobject)\n│   ├── svg/ # mobject related to svg\n│   │   ├── svg_mobject.py          # SVGMobject\n│   │   ├── brace.py                # Brace\n│   │   ├── drawings.py             # Some special mobject of svg image\n│   │   ├── tex_mobject.py          # Tex and TexText implemented by LaTeX\n│   │   └── text_mobject.py         # Text implemented by manimpango\n│   ├── changing.py             # Dynamically changing mobject\n│   ├── coordinate_systems.py   # coordinate system\n│   ├── frame.py                # mobject related to frame\n│   ├── functions.py            # ParametricFunction\n│   ├── geometry.py             # geometry mobjects\n│   ├── matrix.py               # matrix\n│   ├── mobject_update_utils.py # some defined updater\n│   ├── number_line.py          # Number line\n│   ├── numbers.py              # Numbers that can be changed\n│   ├── probability.py          # mobject related to probability\n│   ├── shape_matchers.py       # mobject adapted to the size of other objects\n│   ├── three_dimensions.py     # Three-dimensional objects\n│   ├── value_tracker.py        # ValueTracker which storage number\n│   └── vector_field.py         # VectorField\n├── once_useful_constructs/  # 3b1b's Common scenes written for some videos\n│   └── ...\n├── shaders/ # GLSL scripts for rendering\n│   ├── simple_vert.glsl    # a simple glsl script for position\n│   ├── insert/ # glsl scripts to be inserted in other glsl scripts\n│   │   ├── NOTE.md   # explain how to insert glsl scripts\n│   │   └── ...       # useful scripts\n│   ├── image/ # glsl for images\n│   │   └── ... # containing shaders for vertex and fragment\n│   ├── quadratic_bezier_fill/ # glsl for the fill of quadratic bezier curve\n│   │   └── ... # containing shaders for vertex, fragment and geometry\n│   ├── quadratic_bezier_stroke/ # glsl for the stroke of quadratic bezier curve\n│   │   └── ... # containing shaders for vertex, fragment and geometry\n│   ├── surface/ # glsl for surfaces\n│   │   └── ... # containing shaders for vertex and fragment\n│   ├── textured_surface/ # glsl for textured_surface\n│   │   └── ... # containing shaders for vertex and fragment\n│   └── true_dot/ # glsl for a dot\n│       └── ... # containing shaders for vertex, fragment and geometry\n└── utils/ # Some useful utility functions\n    ├── bezier.py             # For bezier curve\n    ├── color.py              # For color\n    ├── dict_ops.py           # Functions related to dictionary processing\n    ├── customization.py      # Read from custom_config.yml\n    ├── debug.py              # Utilities for debugging in program\n    ├── directories.py        # Read directories from config file\n    ├── family_ops.py         # Process family members\n    ├── file_ops.py           # Process files and directories\n    ├── images.py             # Read image\n    ├── init_config.py        # Configuration guide\n    ├── iterables.py          # Functions related to list/dictionary processing\n    ├── paths.py              # Curve path\n    ├── rate_functions.py     # Some defined rate_functions\n    ├── simple_functions.py   # Some commonly used functions\n    ├── sounds.py             # Process sounds\n    ├── space_ops.py          # Space coordinate calculation\n    ├── strings.py            # Process strings\n    └── tex_file_writing.py   # Use LaTeX to write strings as svg\nInheritance structure of manim’s classes\n¶\nHere\nis a pdf showed inheritance structure of manim’s classes, large,\nbut basically all classes have included:\nManim execution process\n¶\nContents\nManim’s structure\nManim’s directory structure\nInheritance structure of manim’s classes\nManim execution process",
    "code_examples": [
      "manimlib/ # manim library\n├── __init__.py\n├── __main__.py\n├── default_config.yml   # Default configuration file\n├── config.py            # Process CLI flags\n├── constants.py         # Defined some constants\n├── extract_scene.py     # Extract and run the scene\n├── shader_wrapper.py    # Shaders' Wrapper for convenient control\n├── window.py            # Playback window\n├── tex_templates/ # Templates preset for LaTeX\n│   ├── tex_templates.tex   # Tex template (will be compiled with latex, default)\n│   └── ctex_templates.tex  # Tex template that support Chinese (will be compiled with xelatex)\n├── camera/\n│   └── camera.py        # Including Camera and CameraFrame\n├── scene/\n│   ├── scene_file_writer.py     # Used to write scene to video file\n│   ├── scene.py                 # The basic Scene class\n│   ├── three_d_scene.py         # Three-dimensional scene\n│   ├── sample_space_scene.py    # Probability related sample space scene\n│   └── vector_space_scene.py    # Vector field scene\n├── animation/\n│   ├── animation.py     # The basic class of animation\n│   ├── composition.py   # Animation group\n│   ├── creation.py      # Animation related to Create\n│   ├── fading.py        # Fade related animation\n│   ├── growing.py       # Animation related to Grow\n│   ├── indication.py    # Some animations for emphasis\n│   ├── movement.py      # Animation related to movement\n│   ├── numbers.py       # Realize changes to DecimalNumber\n│   ├── rotation.py      # Animation related to rotation\n│   ├── specialized.py   # Some uncommon animations for special projects\n│   ├── transform_matching_parts.py # Transform which can automatically match parts\n│   ├── transform.py     # Some Transforms\n│   └── update.py        # Realize update from function\n├── mobject/\n│   ├── mobject.py       # The basic class of all math object\n│   ├── types/ # 4 types of mobject\n│   │   ├── dot_cloud.py            # Dot cloud (an subclass of PMobject)\n│   │   ├── image_mobject.py        # Insert pictures\n│   │   ├── point_cloud_mobject.py  # PMobject (mobject composed of points)\n│   │   ├── surface.py              # ParametricSurface\n│   │   └── vectorized_mobject.py   # VMobject (vectorized mobject)\n│   ├── svg/ # mobject related to svg\n│   │   ├── svg_mobject.py          # SVGMobject\n│   │   ├── brace.py                # Brace\n│   │   ├── drawings.py             # Some special mobject of svg image\n│   │   ├── tex_mobject.py          # Tex and TexText implemented by LaTeX\n│   │   └── text_mobject.py         # Text implemented by manimpango\n│   ├── changing.py             # Dynamically changing mobject\n│   ├── coordinate_systems.py   # coordinate system\n│   ├── frame.py                # mobject related to frame\n│   ├── functions.py            # ParametricFunction\n│   ├── geometry.py             # geometry mobjects\n│   ├── matrix.py               # matrix\n│   ├── mobject_update_utils.py # some defined updater\n│   ├── number_line.py          # Number line\n│   ├── numbers.py              # Numbers that can be changed\n│   ├── probability.py          # mobject related to probability\n│   ├── shape_matchers.py       # mobject adapted to the size of other objects\n│   ├── three_dimensions.py     # Three-dimensional objects\n│   ├── value_tracker.py        # ValueTracker which storage number\n│   └── vector_field.py         # VectorField\n├── once_useful_constructs/  # 3b1b's Common scenes written for some videos\n│   └── ...\n├── shaders/ # GLSL scripts for rendering\n│   ├── simple_vert.glsl    # a simple glsl script for position\n│   ├── insert/ # glsl scripts to be inserted in other glsl scripts\n│   │   ├── NOTE.md   # explain how to insert glsl scripts\n│   │   └── ...       # useful scripts\n│   ├── image/ # glsl for images\n│   │   └── ... # containing shaders for vertex and fragment\n│   ├── quadratic_bezier_fill/ # glsl for the fill of quadratic bezier curve\n│   │   └── ... # containing shaders for vertex, fragment and geometry\n│   ├── quadratic_bezier_stroke/ # glsl for the stroke of quadratic bezier curve\n│   │   └── ... # containing shaders for vertex, fragment and geometry\n│   ├── surface/ # glsl for surfaces\n│   │   └── ... # containing shaders for vertex and fragment\n│   ├── textured_surface/ # glsl for textured_surface\n│   │   └── ... # containing shaders for vertex and fragment\n│   └── true_dot/ # glsl for a dot\n│       └── ... # containing shaders for vertex, fragment and geometry\n└── utils/ # Some useful utility functions\n    ├── bezier.py             # For bezier curve\n    ├── color.py              # For color\n    ├── dict_ops.py           # Functions related to dictionary processing\n    ├── customization.py      # Read from custom_config.yml\n    ├── debug.py              # Utilities for debugging in program\n    ├── directories.py        # Read directories from config file\n    ├── family_ops.py         # Process family members\n    ├── file_ops.py           # Process files and directories\n    ├── images.py             # Read image\n    ├── init_config.py        # Configuration guide\n    ├── iterables.py          # Functions related to list/dictionary processing\n    ├── paths.py              # Curve path\n    ├── rate_functions.py     # Some defined rate_functions\n    ├── simple_functions.py   # Some commonly used functions\n    ├── sounds.py             # Process sounds\n    ├── space_ops.py          # Space coordinate calculation\n    ├── strings.py            # Process strings\n    └── tex_file_writing.py   # Use LaTeX to write strings as svg"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/structure.html#manim-s-structure",
      "https://3b1b.github.io/manim/getting_started/structure.html#inheritance-structure-of-manim-s-classes",
      "https://3b1b.github.io/manim/getting_started/structure.html#manim-execution-process",
      "https://3b1b.github.io/manim/getting_started/structure.html#inheritance-structure-of-manim-s-classes",
      "https://3b1b.github.io/manim/getting_started/structure.html#manim-execution-process"
    ],
    "scraped_at": 1752428853.091187
  },
  "https://3b1b.github.io/manim/getting_started/structure.html#inheritance-structure-of-manim-s-classes": {
    "url": "https://3b1b.github.io/manim/getting_started/structure.html#inheritance-structure-of-manim-s-classes",
    "title": "Manim’s structure - manim  documentation",
    "content": "Manim’s structure\n¶\nManim’s directory structure\n¶\nThe manim directory looks very complicated, with a lot of files,\nbut the structure is clear.\nBelow is the directory structure of manim:\nmanimlib/ # manim library\n├── __init__.py\n├── __main__.py\n├── default_config.yml   # Default configuration file\n├── config.py            # Process CLI flags\n├── constants.py         # Defined some constants\n├── extract_scene.py     # Extract and run the scene\n├── shader_wrapper.py    # Shaders' Wrapper for convenient control\n├── window.py            # Playback window\n├── tex_templates/ # Templates preset for LaTeX\n│   ├── tex_templates.tex   # Tex template (will be compiled with latex, default)\n│   └── ctex_templates.tex  # Tex template that support Chinese (will be compiled with xelatex)\n├── camera/\n│   └── camera.py        # Including Camera and CameraFrame\n├── scene/\n│   ├── scene_file_writer.py     # Used to write scene to video file\n│   ├── scene.py                 # The basic Scene class\n│   ├── three_d_scene.py         # Three-dimensional scene\n│   ├── sample_space_scene.py    # Probability related sample space scene\n│   └── vector_space_scene.py    # Vector field scene\n├── animation/\n│   ├── animation.py     # The basic class of animation\n│   ├── composition.py   # Animation group\n│   ├── creation.py      # Animation related to Create\n│   ├── fading.py        # Fade related animation\n│   ├── growing.py       # Animation related to Grow\n│   ├── indication.py    # Some animations for emphasis\n│   ├── movement.py      # Animation related to movement\n│   ├── numbers.py       # Realize changes to DecimalNumber\n│   ├── rotation.py      # Animation related to rotation\n│   ├── specialized.py   # Some uncommon animations for special projects\n│   ├── transform_matching_parts.py # Transform which can automatically match parts\n│   ├── transform.py     # Some Transforms\n│   └── update.py        # Realize update from function\n├── mobject/\n│   ├── mobject.py       # The basic class of all math object\n│   ├── types/ # 4 types of mobject\n│   │   ├── dot_cloud.py            # Dot cloud (an subclass of PMobject)\n│   │   ├── image_mobject.py        # Insert pictures\n│   │   ├── point_cloud_mobject.py  # PMobject (mobject composed of points)\n│   │   ├── surface.py              # ParametricSurface\n│   │   └── vectorized_mobject.py   # VMobject (vectorized mobject)\n│   ├── svg/ # mobject related to svg\n│   │   ├── svg_mobject.py          # SVGMobject\n│   │   ├── brace.py                # Brace\n│   │   ├── drawings.py             # Some special mobject of svg image\n│   │   ├── tex_mobject.py          # Tex and TexText implemented by LaTeX\n│   │   └── text_mobject.py         # Text implemented by manimpango\n│   ├── changing.py             # Dynamically changing mobject\n│   ├── coordinate_systems.py   # coordinate system\n│   ├── frame.py                # mobject related to frame\n│   ├── functions.py            # ParametricFunction\n│   ├── geometry.py             # geometry mobjects\n│   ├── matrix.py               # matrix\n│   ├── mobject_update_utils.py # some defined updater\n│   ├── number_line.py          # Number line\n│   ├── numbers.py              # Numbers that can be changed\n│   ├── probability.py          # mobject related to probability\n│   ├── shape_matchers.py       # mobject adapted to the size of other objects\n│   ├── three_dimensions.py     # Three-dimensional objects\n│   ├── value_tracker.py        # ValueTracker which storage number\n│   └── vector_field.py         # VectorField\n├── once_useful_constructs/  # 3b1b's Common scenes written for some videos\n│   └── ...\n├── shaders/ # GLSL scripts for rendering\n│   ├── simple_vert.glsl    # a simple glsl script for position\n│   ├── insert/ # glsl scripts to be inserted in other glsl scripts\n│   │   ├── NOTE.md   # explain how to insert glsl scripts\n│   │   └── ...       # useful scripts\n│   ├── image/ # glsl for images\n│   │   └── ... # containing shaders for vertex and fragment\n│   ├── quadratic_bezier_fill/ # glsl for the fill of quadratic bezier curve\n│   │   └── ... # containing shaders for vertex, fragment and geometry\n│   ├── quadratic_bezier_stroke/ # glsl for the stroke of quadratic bezier curve\n│   │   └── ... # containing shaders for vertex, fragment and geometry\n│   ├── surface/ # glsl for surfaces\n│   │   └── ... # containing shaders for vertex and fragment\n│   ├── textured_surface/ # glsl for textured_surface\n│   │   └── ... # containing shaders for vertex and fragment\n│   └── true_dot/ # glsl for a dot\n│       └── ... # containing shaders for vertex, fragment and geometry\n└── utils/ # Some useful utility functions\n    ├── bezier.py             # For bezier curve\n    ├── color.py              # For color\n    ├── dict_ops.py           # Functions related to dictionary processing\n    ├── customization.py      # Read from custom_config.yml\n    ├── debug.py              # Utilities for debugging in program\n    ├── directories.py        # Read directories from config file\n    ├── family_ops.py         # Process family members\n    ├── file_ops.py           # Process files and directories\n    ├── images.py             # Read image\n    ├── init_config.py        # Configuration guide\n    ├── iterables.py          # Functions related to list/dictionary processing\n    ├── paths.py              # Curve path\n    ├── rate_functions.py     # Some defined rate_functions\n    ├── simple_functions.py   # Some commonly used functions\n    ├── sounds.py             # Process sounds\n    ├── space_ops.py          # Space coordinate calculation\n    ├── strings.py            # Process strings\n    └── tex_file_writing.py   # Use LaTeX to write strings as svg\nInheritance structure of manim’s classes\n¶\nHere\nis a pdf showed inheritance structure of manim’s classes, large,\nbut basically all classes have included:\nManim execution process\n¶\nContents\nManim’s structure\nManim’s directory structure\nInheritance structure of manim’s classes\nManim execution process",
    "code_examples": [
      "manimlib/ # manim library\n├── __init__.py\n├── __main__.py\n├── default_config.yml   # Default configuration file\n├── config.py            # Process CLI flags\n├── constants.py         # Defined some constants\n├── extract_scene.py     # Extract and run the scene\n├── shader_wrapper.py    # Shaders' Wrapper for convenient control\n├── window.py            # Playback window\n├── tex_templates/ # Templates preset for LaTeX\n│   ├── tex_templates.tex   # Tex template (will be compiled with latex, default)\n│   └── ctex_templates.tex  # Tex template that support Chinese (will be compiled with xelatex)\n├── camera/\n│   └── camera.py        # Including Camera and CameraFrame\n├── scene/\n│   ├── scene_file_writer.py     # Used to write scene to video file\n│   ├── scene.py                 # The basic Scene class\n│   ├── three_d_scene.py         # Three-dimensional scene\n│   ├── sample_space_scene.py    # Probability related sample space scene\n│   └── vector_space_scene.py    # Vector field scene\n├── animation/\n│   ├── animation.py     # The basic class of animation\n│   ├── composition.py   # Animation group\n│   ├── creation.py      # Animation related to Create\n│   ├── fading.py        # Fade related animation\n│   ├── growing.py       # Animation related to Grow\n│   ├── indication.py    # Some animations for emphasis\n│   ├── movement.py      # Animation related to movement\n│   ├── numbers.py       # Realize changes to DecimalNumber\n│   ├── rotation.py      # Animation related to rotation\n│   ├── specialized.py   # Some uncommon animations for special projects\n│   ├── transform_matching_parts.py # Transform which can automatically match parts\n│   ├── transform.py     # Some Transforms\n│   └── update.py        # Realize update from function\n├── mobject/\n│   ├── mobject.py       # The basic class of all math object\n│   ├── types/ # 4 types of mobject\n│   │   ├── dot_cloud.py            # Dot cloud (an subclass of PMobject)\n│   │   ├── image_mobject.py        # Insert pictures\n│   │   ├── point_cloud_mobject.py  # PMobject (mobject composed of points)\n│   │   ├── surface.py              # ParametricSurface\n│   │   └── vectorized_mobject.py   # VMobject (vectorized mobject)\n│   ├── svg/ # mobject related to svg\n│   │   ├── svg_mobject.py          # SVGMobject\n│   │   ├── brace.py                # Brace\n│   │   ├── drawings.py             # Some special mobject of svg image\n│   │   ├── tex_mobject.py          # Tex and TexText implemented by LaTeX\n│   │   └── text_mobject.py         # Text implemented by manimpango\n│   ├── changing.py             # Dynamically changing mobject\n│   ├── coordinate_systems.py   # coordinate system\n│   ├── frame.py                # mobject related to frame\n│   ├── functions.py            # ParametricFunction\n│   ├── geometry.py             # geometry mobjects\n│   ├── matrix.py               # matrix\n│   ├── mobject_update_utils.py # some defined updater\n│   ├── number_line.py          # Number line\n│   ├── numbers.py              # Numbers that can be changed\n│   ├── probability.py          # mobject related to probability\n│   ├── shape_matchers.py       # mobject adapted to the size of other objects\n│   ├── three_dimensions.py     # Three-dimensional objects\n│   ├── value_tracker.py        # ValueTracker which storage number\n│   └── vector_field.py         # VectorField\n├── once_useful_constructs/  # 3b1b's Common scenes written for some videos\n│   └── ...\n├── shaders/ # GLSL scripts for rendering\n│   ├── simple_vert.glsl    # a simple glsl script for position\n│   ├── insert/ # glsl scripts to be inserted in other glsl scripts\n│   │   ├── NOTE.md   # explain how to insert glsl scripts\n│   │   └── ...       # useful scripts\n│   ├── image/ # glsl for images\n│   │   └── ... # containing shaders for vertex and fragment\n│   ├── quadratic_bezier_fill/ # glsl for the fill of quadratic bezier curve\n│   │   └── ... # containing shaders for vertex, fragment and geometry\n│   ├── quadratic_bezier_stroke/ # glsl for the stroke of quadratic bezier curve\n│   │   └── ... # containing shaders for vertex, fragment and geometry\n│   ├── surface/ # glsl for surfaces\n│   │   └── ... # containing shaders for vertex and fragment\n│   ├── textured_surface/ # glsl for textured_surface\n│   │   └── ... # containing shaders for vertex and fragment\n│   └── true_dot/ # glsl for a dot\n│       └── ... # containing shaders for vertex, fragment and geometry\n└── utils/ # Some useful utility functions\n    ├── bezier.py             # For bezier curve\n    ├── color.py              # For color\n    ├── dict_ops.py           # Functions related to dictionary processing\n    ├── customization.py      # Read from custom_config.yml\n    ├── debug.py              # Utilities for debugging in program\n    ├── directories.py        # Read directories from config file\n    ├── family_ops.py         # Process family members\n    ├── file_ops.py           # Process files and directories\n    ├── images.py             # Read image\n    ├── init_config.py        # Configuration guide\n    ├── iterables.py          # Functions related to list/dictionary processing\n    ├── paths.py              # Curve path\n    ├── rate_functions.py     # Some defined rate_functions\n    ├── simple_functions.py   # Some commonly used functions\n    ├── sounds.py             # Process sounds\n    ├── space_ops.py          # Space coordinate calculation\n    ├── strings.py            # Process strings\n    └── tex_file_writing.py   # Use LaTeX to write strings as svg"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/structure.html#manim-s-structure",
      "https://3b1b.github.io/manim/getting_started/structure.html#manim-execution-process",
      "https://3b1b.github.io/manim/getting_started/structure.html#manim-execution-process"
    ],
    "scraped_at": 1752428854.116361
  },
  "https://3b1b.github.io/manim/getting_started/structure.html#manim-execution-process": {
    "url": "https://3b1b.github.io/manim/getting_started/structure.html#manim-execution-process",
    "title": "Manim’s structure - manim  documentation",
    "content": "Manim’s structure\n¶\nManim’s directory structure\n¶\nThe manim directory looks very complicated, with a lot of files,\nbut the structure is clear.\nBelow is the directory structure of manim:\nmanimlib/ # manim library\n├── __init__.py\n├── __main__.py\n├── default_config.yml   # Default configuration file\n├── config.py            # Process CLI flags\n├── constants.py         # Defined some constants\n├── extract_scene.py     # Extract and run the scene\n├── shader_wrapper.py    # Shaders' Wrapper for convenient control\n├── window.py            # Playback window\n├── tex_templates/ # Templates preset for LaTeX\n│   ├── tex_templates.tex   # Tex template (will be compiled with latex, default)\n│   └── ctex_templates.tex  # Tex template that support Chinese (will be compiled with xelatex)\n├── camera/\n│   └── camera.py        # Including Camera and CameraFrame\n├── scene/\n│   ├── scene_file_writer.py     # Used to write scene to video file\n│   ├── scene.py                 # The basic Scene class\n│   ├── three_d_scene.py         # Three-dimensional scene\n│   ├── sample_space_scene.py    # Probability related sample space scene\n│   └── vector_space_scene.py    # Vector field scene\n├── animation/\n│   ├── animation.py     # The basic class of animation\n│   ├── composition.py   # Animation group\n│   ├── creation.py      # Animation related to Create\n│   ├── fading.py        # Fade related animation\n│   ├── growing.py       # Animation related to Grow\n│   ├── indication.py    # Some animations for emphasis\n│   ├── movement.py      # Animation related to movement\n│   ├── numbers.py       # Realize changes to DecimalNumber\n│   ├── rotation.py      # Animation related to rotation\n│   ├── specialized.py   # Some uncommon animations for special projects\n│   ├── transform_matching_parts.py # Transform which can automatically match parts\n│   ├── transform.py     # Some Transforms\n│   └── update.py        # Realize update from function\n├── mobject/\n│   ├── mobject.py       # The basic class of all math object\n│   ├── types/ # 4 types of mobject\n│   │   ├── dot_cloud.py            # Dot cloud (an subclass of PMobject)\n│   │   ├── image_mobject.py        # Insert pictures\n│   │   ├── point_cloud_mobject.py  # PMobject (mobject composed of points)\n│   │   ├── surface.py              # ParametricSurface\n│   │   └── vectorized_mobject.py   # VMobject (vectorized mobject)\n│   ├── svg/ # mobject related to svg\n│   │   ├── svg_mobject.py          # SVGMobject\n│   │   ├── brace.py                # Brace\n│   │   ├── drawings.py             # Some special mobject of svg image\n│   │   ├── tex_mobject.py          # Tex and TexText implemented by LaTeX\n│   │   └── text_mobject.py         # Text implemented by manimpango\n│   ├── changing.py             # Dynamically changing mobject\n│   ├── coordinate_systems.py   # coordinate system\n│   ├── frame.py                # mobject related to frame\n│   ├── functions.py            # ParametricFunction\n│   ├── geometry.py             # geometry mobjects\n│   ├── matrix.py               # matrix\n│   ├── mobject_update_utils.py # some defined updater\n│   ├── number_line.py          # Number line\n│   ├── numbers.py              # Numbers that can be changed\n│   ├── probability.py          # mobject related to probability\n│   ├── shape_matchers.py       # mobject adapted to the size of other objects\n│   ├── three_dimensions.py     # Three-dimensional objects\n│   ├── value_tracker.py        # ValueTracker which storage number\n│   └── vector_field.py         # VectorField\n├── once_useful_constructs/  # 3b1b's Common scenes written for some videos\n│   └── ...\n├── shaders/ # GLSL scripts for rendering\n│   ├── simple_vert.glsl    # a simple glsl script for position\n│   ├── insert/ # glsl scripts to be inserted in other glsl scripts\n│   │   ├── NOTE.md   # explain how to insert glsl scripts\n│   │   └── ...       # useful scripts\n│   ├── image/ # glsl for images\n│   │   └── ... # containing shaders for vertex and fragment\n│   ├── quadratic_bezier_fill/ # glsl for the fill of quadratic bezier curve\n│   │   └── ... # containing shaders for vertex, fragment and geometry\n│   ├── quadratic_bezier_stroke/ # glsl for the stroke of quadratic bezier curve\n│   │   └── ... # containing shaders for vertex, fragment and geometry\n│   ├── surface/ # glsl for surfaces\n│   │   └── ... # containing shaders for vertex and fragment\n│   ├── textured_surface/ # glsl for textured_surface\n│   │   └── ... # containing shaders for vertex and fragment\n│   └── true_dot/ # glsl for a dot\n│       └── ... # containing shaders for vertex, fragment and geometry\n└── utils/ # Some useful utility functions\n    ├── bezier.py             # For bezier curve\n    ├── color.py              # For color\n    ├── dict_ops.py           # Functions related to dictionary processing\n    ├── customization.py      # Read from custom_config.yml\n    ├── debug.py              # Utilities for debugging in program\n    ├── directories.py        # Read directories from config file\n    ├── family_ops.py         # Process family members\n    ├── file_ops.py           # Process files and directories\n    ├── images.py             # Read image\n    ├── init_config.py        # Configuration guide\n    ├── iterables.py          # Functions related to list/dictionary processing\n    ├── paths.py              # Curve path\n    ├── rate_functions.py     # Some defined rate_functions\n    ├── simple_functions.py   # Some commonly used functions\n    ├── sounds.py             # Process sounds\n    ├── space_ops.py          # Space coordinate calculation\n    ├── strings.py            # Process strings\n    └── tex_file_writing.py   # Use LaTeX to write strings as svg\nInheritance structure of manim’s classes\n¶\nHere\nis a pdf showed inheritance structure of manim’s classes, large,\nbut basically all classes have included:\nManim execution process\n¶\nContents\nManim’s structure\nManim’s directory structure\nInheritance structure of manim’s classes\nManim execution process",
    "code_examples": [
      "manimlib/ # manim library\n├── __init__.py\n├── __main__.py\n├── default_config.yml   # Default configuration file\n├── config.py            # Process CLI flags\n├── constants.py         # Defined some constants\n├── extract_scene.py     # Extract and run the scene\n├── shader_wrapper.py    # Shaders' Wrapper for convenient control\n├── window.py            # Playback window\n├── tex_templates/ # Templates preset for LaTeX\n│   ├── tex_templates.tex   # Tex template (will be compiled with latex, default)\n│   └── ctex_templates.tex  # Tex template that support Chinese (will be compiled with xelatex)\n├── camera/\n│   └── camera.py        # Including Camera and CameraFrame\n├── scene/\n│   ├── scene_file_writer.py     # Used to write scene to video file\n│   ├── scene.py                 # The basic Scene class\n│   ├── three_d_scene.py         # Three-dimensional scene\n│   ├── sample_space_scene.py    # Probability related sample space scene\n│   └── vector_space_scene.py    # Vector field scene\n├── animation/\n│   ├── animation.py     # The basic class of animation\n│   ├── composition.py   # Animation group\n│   ├── creation.py      # Animation related to Create\n│   ├── fading.py        # Fade related animation\n│   ├── growing.py       # Animation related to Grow\n│   ├── indication.py    # Some animations for emphasis\n│   ├── movement.py      # Animation related to movement\n│   ├── numbers.py       # Realize changes to DecimalNumber\n│   ├── rotation.py      # Animation related to rotation\n│   ├── specialized.py   # Some uncommon animations for special projects\n│   ├── transform_matching_parts.py # Transform which can automatically match parts\n│   ├── transform.py     # Some Transforms\n│   └── update.py        # Realize update from function\n├── mobject/\n│   ├── mobject.py       # The basic class of all math object\n│   ├── types/ # 4 types of mobject\n│   │   ├── dot_cloud.py            # Dot cloud (an subclass of PMobject)\n│   │   ├── image_mobject.py        # Insert pictures\n│   │   ├── point_cloud_mobject.py  # PMobject (mobject composed of points)\n│   │   ├── surface.py              # ParametricSurface\n│   │   └── vectorized_mobject.py   # VMobject (vectorized mobject)\n│   ├── svg/ # mobject related to svg\n│   │   ├── svg_mobject.py          # SVGMobject\n│   │   ├── brace.py                # Brace\n│   │   ├── drawings.py             # Some special mobject of svg image\n│   │   ├── tex_mobject.py          # Tex and TexText implemented by LaTeX\n│   │   └── text_mobject.py         # Text implemented by manimpango\n│   ├── changing.py             # Dynamically changing mobject\n│   ├── coordinate_systems.py   # coordinate system\n│   ├── frame.py                # mobject related to frame\n│   ├── functions.py            # ParametricFunction\n│   ├── geometry.py             # geometry mobjects\n│   ├── matrix.py               # matrix\n│   ├── mobject_update_utils.py # some defined updater\n│   ├── number_line.py          # Number line\n│   ├── numbers.py              # Numbers that can be changed\n│   ├── probability.py          # mobject related to probability\n│   ├── shape_matchers.py       # mobject adapted to the size of other objects\n│   ├── three_dimensions.py     # Three-dimensional objects\n│   ├── value_tracker.py        # ValueTracker which storage number\n│   └── vector_field.py         # VectorField\n├── once_useful_constructs/  # 3b1b's Common scenes written for some videos\n│   └── ...\n├── shaders/ # GLSL scripts for rendering\n│   ├── simple_vert.glsl    # a simple glsl script for position\n│   ├── insert/ # glsl scripts to be inserted in other glsl scripts\n│   │   ├── NOTE.md   # explain how to insert glsl scripts\n│   │   └── ...       # useful scripts\n│   ├── image/ # glsl for images\n│   │   └── ... # containing shaders for vertex and fragment\n│   ├── quadratic_bezier_fill/ # glsl for the fill of quadratic bezier curve\n│   │   └── ... # containing shaders for vertex, fragment and geometry\n│   ├── quadratic_bezier_stroke/ # glsl for the stroke of quadratic bezier curve\n│   │   └── ... # containing shaders for vertex, fragment and geometry\n│   ├── surface/ # glsl for surfaces\n│   │   └── ... # containing shaders for vertex and fragment\n│   ├── textured_surface/ # glsl for textured_surface\n│   │   └── ... # containing shaders for vertex and fragment\n│   └── true_dot/ # glsl for a dot\n│       └── ... # containing shaders for vertex, fragment and geometry\n└── utils/ # Some useful utility functions\n    ├── bezier.py             # For bezier curve\n    ├── color.py              # For color\n    ├── dict_ops.py           # Functions related to dictionary processing\n    ├── customization.py      # Read from custom_config.yml\n    ├── debug.py              # Utilities for debugging in program\n    ├── directories.py        # Read directories from config file\n    ├── family_ops.py         # Process family members\n    ├── file_ops.py           # Process files and directories\n    ├── images.py             # Read image\n    ├── init_config.py        # Configuration guide\n    ├── iterables.py          # Functions related to list/dictionary processing\n    ├── paths.py              # Curve path\n    ├── rate_functions.py     # Some defined rate_functions\n    ├── simple_functions.py   # Some commonly used functions\n    ├── sounds.py             # Process sounds\n    ├── space_ops.py          # Space coordinate calculation\n    ├── strings.py            # Process strings\n    └── tex_file_writing.py   # Use LaTeX to write strings as svg"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/structure.html#manim-s-structure"
    ],
    "scraped_at": 1752428855.140032
  },
  "https://3b1b.github.io/manim/getting_started/whatsnew.html#usage-changes-of-new-version-manim": {
    "url": "https://3b1b.github.io/manim/getting_started/whatsnew.html#usage-changes-of-new-version-manim",
    "title": "What’s new - manim  documentation",
    "content": "What’s new\n¶\nUsage changes of new version manim\n¶\nThere are many changes in the new version of manim, and here are only the changes that\nmay have an impact at the code writing level.\nSome of the changes here may not have any major impact on the use, and some changes\nthat affect the use are not mentioned below.\nThis document is for reference only, see the source code for details.\nAnimation\nAdded\nFade\nas the parent class of\nFadeIn\nand\nFadeOut\nFadeIn\nand\nFadeOut\ncan be passed in\nshift\nand\nscale\nparameters\nDeleted\nFadeInFrom,\nFadeInFromDown,\nFadeOutAndShift,\nFadeOutAndShiftDown,\nFadeInFromLarge\n, these can be used\nFadeIn,\nFadeOut\nto achieve the same effect more easily\nAdded\nFadeTransform\nto cross fade between two objects, and subclass\nFadeTransformPieces\nAdded\nCountInFrom(decimal_mob,\nsource_number=0)\nto count\ndecimal_mob\nfrom\nsource_number\nto the current value\nRotating\ncan directly pass in\nangle\nand\naxis\nwithout writing keywords\nangle=,\naxis=\nRotate\nhas become a subclass of\nRotating\n, and the distortion effect in\nTransform\nwill not appear\nRemoved\nMoveCar\nanimation\nAdded\nTransformMatchingShapes(mobject,\ntarget_mobject)\nand\nTransformMatchingTex(mobject,\ntarget_mobject)\nCamera\nRemoved all camera classes except\nCamera\n(\nMappingCamera\n,\nMovingCamera\n,\nMultiCamera\n) and all functions in\nThreeDCamera\nImplemented\nCameraFrame\n(as a\nMobject\n)\nCan be called by\nself.camera.frame\nin\nScene\nAll methods of\nMobject\ncan be used, such as\n.shift()\n,\n.scale()\n, etc.\nCall\n.to_default_state()\nto place in the default position\nSet the Euler angles of the camera by\n.set_euler_angles(theta,\nphi,\ngamma)\nSet three single Euler angles by\n.set_theta(theta)\n,\n.set_phi(phi)\n,\n.set_gamma(gamma)\nUse\n.increment_theta(dtheta)\n,\n.increment_phi(dphi)\n,\n.increment_gamma(gamma)\nto increase the three Euler angles by a certain value. Can be used to realize automatic rotation\nself.camera.frame.add_updater(lambda\nmob,\ndt:\nmob.increment_theta(0.1\n*\ndt))\nCamera\nadds a light source, which is a\nPoint\n, which can be called by\nself.camera.light_source\nin\nScene\nto move and so on. The default position is\n(-\n10,\n10,\n10)\nDelete\nContainer\nMobject\nsvg\nrelated\nAdded\nCheckmark\nand\nExmark\nSome unnecessary classes have been removed from\ndrawings.py\nRemoved\nCode\nand\nParagraph\n(by mistake)\nTexMobject\nis renamed to\nTex\n,\nTextMobject\nis renamed to\nTexText\nfont_size\nhas been added to\nTex\n,\nTexText\nand\nText\nTex\nand\nTexText\nadded\nisolate\n, which is a list, which will be automatically split\nMobject\ntypes\nAdded a new class\nSurface\n, which is the parent class of\nParametricSurface\nand\nTexturedSurface\n.\nAdded the group\nSGroup\nfor\nSurface\nAdded\nTexturedSurface(uv_surface,\nimage_file,\ndark_image_file=None)\n, where\nuv_surface\nis a\nSurface\n,\nimage_file\nis the image to be posted, and\ndark_image_file\nis the image to be posted in the dark (default and\nimage_file\nis the same)\nDeleted\nMobject1D\n,\nMobject2D\n,\nPointCloudDot\nAdded\nDotCloud\n(a\nPMobject\n), which has been greatly optimized\nRemoved\nAbstractImageMobject\n,\nImageMobjectFromCamera\nRemoved\nsheen\nfrom\nVMobject\nMobject\nAdded\ngloss\nand\nshadow\n, which are the numbers between\n[0,\n1]\nrespectively. There are four methods of\n.get_gloss()\n,\n.set_gloss(gloss)\n,\n.get_shadow()\n,\n.set_shadow(shadow)\nAdded\n.get_grid(n_rows,\nn_cols)\nto copy into grid\nAdded\n.set_color_by_code(glsl_code)\nto use GLSL code to change the color\nAdded\n.set_color_by_xyz_func(glsl_snippet,\nmin_value=-5.0,\nmax_value=5.0,\ncolormap=\"viridis\")\nto pass in GLSL expression in the form of\nx,y,z\n, the return value should be a floating point number\nCoordinate system (including\nAxes\n,\nThreeDAxes\n,\nNumberPlane\n,\nComplexPlane\n)\nNo longer use\nx_min\n,\nx_max\n,\ny_min\n,\ny_max\n, but use\nx_range\n,\ny_range\nas a\nnp.array()\n, containing three numbers\nnp.array([\nMinimum,\nmaximum,\nstep\nsize])\nAdded the abbreviation\n.i2gp(x,\ngraph)\nof\n.input_to_graph_point(x,\ngraph)\nAdded some functions of the original\nGraphScene\nAdded\n.get_v_line(point)\n,\n.get_h_line(point)\nto return the line from\npoint\nto the two coordinate axes, and specify the line type through the keyword argument of\nline_func\n(default\nDashedLine\n)\nAdded\n.get_graph_label(graph,\nlabel,\nx,\ndirection,\nbuff,\ncolor)\nto return the label added to the image\nAdded\n.get_v_line_to_graph(x,\ngraph)\n,\n.get_h_line_to_graph(x,\ngraph)\nto return the line from the point with the abscissa of\nx\non the\ngraph\nto the two- axis line\nAdded\n.angle_of_tangent(x,\ngraph,\ndx=EPSILON)\n, returns the inclination angle of\ngraph\nat\nx\nAdded\n.slope_of_tangent(x,\ngraph,\ndx=EPSILON)\n, returns the slope of tangent line of\ngraph\nat\nx\nAdded\n.get_tangent_line(x,\ngraph,\nlength=5)\nto return the tangent line of\ngraph\nat\nx\nAdded\n.get_riemann_rectangles(graph,\nx_range,\ndx,\ninput_sample_type,\n...)\nto return Riemann rectangles (a\nVGroup\n)\nThe attribute\nnumber_line_config\nof\nAxes\nis renamed to\naxis_config\nAxes\noriginal\n.get_coordinate_labels(x_values,\ny_values)\nmethod was renamed to\n.add_coordinate_labels(x_values,\ny_values)\n(but it is not added to the screen)\n.add_coordinate_labels(numbers)\nof\nComplexPlane\nwill directly add the coordinates to the screen\nNumberLine\nNo longer use\nx_min\n,\nx_max\n,\ntick_frequency\n, but use\nx_range\n, which is an array containing three numbers\n[min,\nmax,\nstep]\nThe original\nlabel_direction\nattribute changed to the\nline_to_number_direction\nattribute\nReplace\ntip_width\nand\ntip_height\nwith\ntip_config\n(dictionary) attributes\nThe original\nexclude_zero_from_default\nattribute is modified to the\nnumbers_to_exclude\nattribute (default is None)\nThe original\n.add_tick_marks()\nmethod was changed to the\n.add_ticks()\nmethod\nDelete the\n.get_number_mobjects(*numbers)\nmethod, only use the\n.add_numbers(x_values=None,\nexcluding=None)\nmethod\nThree-dimensional objects\nAdded\nSurfaceMesh(uv_surface)\n, pass in a\nSurface\nto generate its uv mesh\nParametricSurface\nno longer uses\nu_min,\nu_max,\nv_min,\nv_max\n, but instead uses\nu_range,\nv_range\n, which is a tuple (\n(min,\nmax)\n), and\nresolution\ncan be set larger, don’t worry Speed ​​issue\nAdded\nTorus\n, controlled by\nr1,\nr2\nkeyword parameters\nAdded\nCylinder\n, controlled by\nheight,\nradius\nkeyword parameters\nAdded\nLine3D\n(extremely thin cylinder), controlled by the\nwidth\nkeyword parameter\nAdded\nDisk3D\n, controlled by\nradius\nkeyword parameter\nAdd\nSquare3D\n, controlled by\nside_length\nkeyword parameter\nImproved\nCube\nand\nPrism\n, the usage remains unchanged\nOther objects\nParametricFunction\nis renamed to\nParametricCurve\n. Instead of using\nt_min,\nt_max,\nstep_size\n, use\nt_range\n, which is an array of three numbers (\n[t_min,\nt_max,\nstep_size]\n).\ndt\nwas renamed to\nepsilon\n. Other usage remains unchanged\nAll\nTipableVMobject\ncan pass in\ntip_length\nto control the style of\ntip\nLine\nadds\n.set_points_by_ends(start,\nend,\nbuff=0,\npath_arc=0)\nmethod\nLine\nadded\n.get_projection(point)\nto return the projection position of\npoint\non a straight line\nArrow\nadds three attributes of\nthickness,\ntip_width_ratio,\ntip_angle\nCubicBezier\nis changed to\na0,\nh0,\nh1,\na1\n, that is, only a third-order Bezier curve is supported\nSquare\ncan be initialized directly by passing in\nside_length\ninstead of using the keyword\nside_length=\nalways_redraw(func,\n*args,\n**kwargs)\nsupports incoming parameters\n*args,\n**kwargs\nThe\ndigit_to_digit_buff\nproperty of\nDecimalNumber\nhas been renamed to\ndigit_buff_per_font_unit\n, and the\n.scale()\nmethod has been improved\nValueTracker\nadds\nvalue_type\nattribute, the default is\nnp.float64\nScene\nRemoved all functions of\nGraphScene\n(moved to\nonce_useful_constructs\n),\nMovingCameraScene\n,\nReconfigurableScene\n,\nSceneFromVideo\n,\nZoomedScene\n, and\nThreeDScene\n. Because these can basically be achieved by adjusting\nCameraFrame\n(\nself.camera.frame\n)\nCurrently\nSampleSpaceScene\nand\nVectorScene\nhave not been changed for the new version, so it is not recommended to use (only\nScene\nis recommended)\nFix the export of gif, just use the\n-i\noption directly\nAdded the\n.interact()\nmethod, during which the mouse and keyboard can be used to continue the interaction, which will be executed by default after the scene ends\nAdded\n.embed()\nmethod, open iPython terminal to enter interactive mode\nAdded\n.save_state()\nmethod to save the current state of the scene\nAdded\n.restore()\nmethod to restore the entire scene to the saved state\nutils\nA series of functions related to second-order Bezier have been added to\nutils/bezier.py\nAdded a function to read color map from\nmatplotlib\nin\nutils/color.py\nAdded a series of related functions for processing folders/custom styles/object families\nresize_array\n,\nresize_preserving_order\n,\nresize_with_interpolation\nthree functions have been added to\nutils/iterables.py\nThe definition of\nsmooth\nis updated in\nutils/rate_functions.py\nclip(a,\nmin_a,\nmax_a)\nfunction has been added to\nutils/simple_functions.py\nSome functions have been improved in\nutils/space_ops.py\n, some functions for space calculation, and functions for processing triangulation have been added\nconstants\nFixed the aspect ratio of the screen to 16:9\nDeleted the old gray series (\nLIGHT_GREY\n,\nGREY\n,\nDARK_GREY\n,\nDARKER_GREY\n), added a new series of gray\nGREY_A\n~\nGREY_E\nContents\nWhat’s new\nUsage changes of new version manim",
    "code_examples": [
      "FadeInFrom, FadeInFromDown, FadeOutAndShift, FadeOutAndShiftDown, FadeInFromLarge",
      "FadeIn, FadeOut",
      "FadeTransform",
      "FadeTransformPieces",
      "CountInFrom(decimal_mob, source_number=0)",
      "decimal_mob",
      "source_number",
      "angle=, axis=",
      "TransformMatchingShapes(mobject, target_mobject)",
      "TransformMatchingTex(mobject, target_mobject)",
      "MappingCamera",
      "MovingCamera",
      "MultiCamera",
      "ThreeDCamera",
      "CameraFrame",
      "self.camera.frame",
      ".to_default_state()",
      ".set_euler_angles(theta, phi, gamma)",
      ".set_theta(theta)",
      ".set_phi(phi)",
      ".set_gamma(gamma)",
      ".increment_theta(dtheta)",
      ".increment_phi(dphi)",
      ".increment_gamma(gamma)",
      "self.camera.frame.add_updater(lambda mob, dt: mob.increment_theta(0.1 * dt))",
      "self.camera.light_source",
      "(- 10, 10, 10)",
      "drawings.py",
      "TextMobject",
      "ParametricSurface",
      "TexturedSurface",
      "TexturedSurface(uv_surface, image_file, dark_image_file=None)",
      "dark_image_file",
      "PointCloudDot",
      "AbstractImageMobject",
      "ImageMobjectFromCamera",
      ".get_gloss()",
      ".set_gloss(gloss)",
      ".get_shadow()",
      ".set_shadow(shadow)",
      ".get_grid(n_rows, n_cols)",
      ".set_color_by_code(glsl_code)",
      ".set_color_by_xyz_func(glsl_snippet, min_value=-5.0, max_value=5.0, colormap=\"viridis\")",
      "NumberPlane",
      "ComplexPlane",
      "np.array([ Minimum, maximum, step size])",
      ".i2gp(x, graph)",
      ".input_to_graph_point(x, graph)",
      ".get_v_line(point)",
      ".get_h_line(point)",
      ".get_graph_label(graph, label, x, direction, buff, color)",
      ".get_v_line_to_graph(x, graph)",
      ".get_h_line_to_graph(x, graph)",
      ".angle_of_tangent(x, graph, dx=EPSILON)",
      ".slope_of_tangent(x, graph, dx=EPSILON)",
      ".get_tangent_line(x, graph, length=5)",
      ".get_riemann_rectangles(graph, x_range, dx, input_sample_type, ...)",
      "number_line_config",
      "axis_config",
      ".get_coordinate_labels(x_values, y_values)",
      ".add_coordinate_labels(x_values, y_values)",
      ".add_coordinate_labels(numbers)",
      "ComplexPlane",
      "tick_frequency",
      "[min, max, step]",
      "label_direction",
      "line_to_number_direction",
      "exclude_zero_from_default",
      "numbers_to_exclude",
      ".add_tick_marks()",
      ".add_ticks()",
      ".get_number_mobjects(*numbers)",
      ".add_numbers(x_values=None, excluding=None)",
      "SurfaceMesh(uv_surface)",
      "ParametricSurface",
      "u_min, u_max, v_min, v_max",
      "u_range, v_range",
      "height, radius",
      "side_length",
      "ParametricFunction",
      "ParametricCurve",
      "t_min, t_max, step_size",
      "[t_min, t_max, step_size]",
      "TipableVMobject",
      ".set_points_by_ends(start, end, buff=0, path_arc=0)",
      ".get_projection(point)",
      "thickness, tip_width_ratio, tip_angle",
      "CubicBezier",
      "a0, h0, h1, a1",
      "side_length",
      "side_length=",
      "always_redraw(func, *args, **kwargs)",
      "*args, **kwargs",
      "digit_to_digit_buff",
      "DecimalNumber",
      "digit_buff_per_font_unit",
      "ValueTracker",
      "once_useful_constructs",
      "MovingCameraScene",
      "ReconfigurableScene",
      "SceneFromVideo",
      "ZoomedScene",
      "ThreeDScene",
      "CameraFrame",
      "self.camera.frame",
      "SampleSpaceScene",
      "VectorScene",
      ".interact()",
      ".save_state()",
      "utils/bezier.py",
      "utils/color.py",
      "resize_array",
      "resize_preserving_order",
      "resize_with_interpolation",
      "utils/iterables.py",
      "utils/rate_functions.py",
      "clip(a, min_a, max_a)",
      "utils/simple_functions.py",
      "utils/space_ops.py",
      "DARKER_GREY"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/getting_started/whatsnew.html#what-s-new"
    ],
    "scraped_at": 1752428856.3112278
  },
  "https://3b1b.github.io/manim/documentation/constants.html#frame-and-pixel-shape": {
    "url": "https://3b1b.github.io/manim/documentation/constants.html#frame-and-pixel-shape",
    "title": "constants - manim  documentation",
    "content": "constants\n¶\nThe\nconstants.py\nin the\nmanimlib\nfolder defines the constants\nneeded when running manim. Some constants are not explained here because\nthey are only used inside manim.\nFrame and pixel shape\n¶\nASPECT_RATIO\n=\n16.0\n/\n9.0\nFRAME_HEIGHT\n=\n8.0\nFRAME_WIDTH\n=\nFRAME_HEIGHT\n*\nASPECT_RATIO\nFRAME_Y_RADIUS\n=\nFRAME_HEIGHT\n/\n2\nFRAME_X_RADIUS\n=\nFRAME_WIDTH\n/\n2\nDEFAULT_PIXEL_HEIGHT\n=\n1080\nDEFAULT_PIXEL_WIDTH\n=\n1920\nDEFAULT_FPS\n=\n30\nBuffs\n¶\nSMALL_BUFF\n=\n0.1\nMED_SMALL_BUFF\n=\n0.25\nMED_LARGE_BUFF\n=\n0.5\nLARGE_BUFF\n=\n1\nDEFAULT_MOBJECT_TO_EDGE_BUFFER\n=\nMED_LARGE_BUFF\n# Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER\n=\nMED_SMALL_BUFF\n# Distance between objects\nRun times\n¶\nDEFAULT_POINTWISE_FUNCTION_RUN_TIME\n=\n3.0\nDEFAULT_WAIT_TIME\n=\n1.0\nCoordinates\n¶\nmanim uses three-dimensional coordinates and uses the type of\nndarray\nORIGIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n0.\n))\nUP\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nDOWN\n=\nnp\n.\narray\n((\n0.\n,\n-\n1.\n,\n0.\n))\nRIGHT\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nLEFT\n=\nnp\n.\narray\n((\n-\n1.\n,\n0.\n,\n0.\n))\nIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n-\n1.\n))\nOUT\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\nX_AXIS\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nY_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nZ_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\n# Useful abbreviations for diagonals\nUL\n=\nUP\n+\nLEFT\nUR\n=\nUP\n+\nRIGHT\nDL\n=\nDOWN\n+\nLEFT\nDR\n=\nDOWN\n+\nRIGHT\nTOP\n=\nFRAME_Y_RADIUS\n*\nUP\nBOTTOM\n=\nFRAME_Y_RADIUS\n*\nDOWN\nLEFT_SIDE\n=\nFRAME_X_RADIUS\n*\nLEFT\nRIGHT_SIDE\n=\nFRAME_X_RADIUS\n*\nRIGHT\nMathematical constant\n¶\nPI\n=\nnp\n.\npi\nTAU\n=\n2\n*\nPI\nDEGREES\n=\nTAU\n/\n360\nText\n¶\nNORMAL\n=\n\"NORMAL\"\nITALIC\n=\n\"ITALIC\"\nOBLIQUE\n=\n\"OBLIQUE\"\nBOLD\n=\n\"BOLD\"\nStroke width\n¶\nDEFAULT_STROKE_WIDTH\n=\n4\nColours\n¶\nHere are the preview of default colours. (Modified from\nelteoremadebeethoven\n)\nBLUE\nBLUE_E\nBLUE_D\nBLUE_C\nBLUE_B\nBLUE_A\nTEAL\nTEAL_E\nTEAL_D\nTEAL_C\nTEAL_B\nTEAL_A\nGREEN\nGREEN_E\nGREEN_D\nGREEN_C\nGREEN_B\nGREEN_A\nYELLOW\nYELLOW_E\nYELLOW_D\nYELLOW_C\nYELLOW_B\nYELLOW_A\nGOLD\nGOLD_E\nGOLD_D\nGOLD_C\nGOLD_B\nGOLD_A\nRED\nRED_E\nRED_D\nRED_C\nRED_B\nRED_A\nMAROON\nMAROON_E\nMAROON_D\nMAROON_C\nMAROON_B\nMAROON_A\nPURPLE\nPURPLE_E\nPURPLE_D\nPURPLE_C\nPURPLE_B\nPURPLE_A\nGREY\nGREY_E\nGREY_D\nGREY_C\nGREY_B\nGREY_A\nOthers\nWHITE\nBLACK\nGREY_BROWN\nDARK_BROWN\nLIGHT_BROWN\nPINK\nLIGHT_PINK\nGREEN_SCREEN\nORANGE\nContents\nconstants\nFrame and pixel shape\nBuffs\nRun times\nCoordinates\nMathematical constant\nText\nStroke width\nColours",
    "code_examples": [
      "constants.py",
      "ASPECT_RATIO = 16.0 / 9.0\nFRAME_HEIGHT = 8.0\nFRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO\nFRAME_Y_RADIUS = FRAME_HEIGHT / 2\nFRAME_X_RADIUS = FRAME_WIDTH / 2\n\nDEFAULT_PIXEL_HEIGHT = 1080\nDEFAULT_PIXEL_WIDTH = 1920\nDEFAULT_FPS = 30",
      "SMALL_BUFF = 0.1\nMED_SMALL_BUFF = 0.25\nMED_LARGE_BUFF = 0.5\nLARGE_BUFF = 1\n\nDEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects",
      "DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0\nDEFAULT_WAIT_TIME = 1.0",
      "ORIGIN = np.array((0., 0., 0.))\nUP = np.array((0., 1., 0.))\nDOWN = np.array((0., -1., 0.))\nRIGHT = np.array((1., 0., 0.))\nLEFT = np.array((-1., 0., 0.))\nIN = np.array((0., 0., -1.))\nOUT = np.array((0., 0., 1.))\nX_AXIS = np.array((1., 0., 0.))\nY_AXIS = np.array((0., 1., 0.))\nZ_AXIS = np.array((0., 0., 1.))\n\n# Useful abbreviations for diagonals\nUL = UP + LEFT\nUR = UP + RIGHT\nDL = DOWN + LEFT\nDR = DOWN + RIGHT\n\nTOP = FRAME_Y_RADIUS * UP\nBOTTOM = FRAME_Y_RADIUS * DOWN\nLEFT_SIDE = FRAME_X_RADIUS * LEFT\nRIGHT_SIDE = FRAME_X_RADIUS * RIGHT",
      "PI = np.pi\nTAU = 2 * PI\nDEGREES = TAU / 360",
      "NORMAL = \"NORMAL\"\nITALIC = \"ITALIC\"\nOBLIQUE = \"OBLIQUE\"\nBOLD = \"BOLD\"",
      "DEFAULT_STROKE_WIDTH = 4"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/documentation/constants.html#constants",
      "https://3b1b.github.io/manim/documentation/constants.html#buffs",
      "https://3b1b.github.io/manim/documentation/constants.html#run-times",
      "https://3b1b.github.io/manim/documentation/constants.html#coordinates",
      "https://3b1b.github.io/manim/documentation/constants.html#mathematical-constant",
      "https://3b1b.github.io/manim/documentation/constants.html#text",
      "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
      "https://3b1b.github.io/manim/documentation/constants.html#colours",
      "https://3b1b.github.io/manim/documentation/constants.html#buffs",
      "https://3b1b.github.io/manim/documentation/constants.html#run-times",
      "https://3b1b.github.io/manim/documentation/constants.html#coordinates",
      "https://3b1b.github.io/manim/documentation/constants.html#mathematical-constant",
      "https://3b1b.github.io/manim/documentation/constants.html#text",
      "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
      "https://3b1b.github.io/manim/documentation/constants.html#colours"
    ],
    "scraped_at": 1752428857.432398
  },
  "https://3b1b.github.io/manim/documentation/constants.html#buffs": {
    "url": "https://3b1b.github.io/manim/documentation/constants.html#buffs",
    "title": "constants - manim  documentation",
    "content": "constants\n¶\nThe\nconstants.py\nin the\nmanimlib\nfolder defines the constants\nneeded when running manim. Some constants are not explained here because\nthey are only used inside manim.\nFrame and pixel shape\n¶\nASPECT_RATIO\n=\n16.0\n/\n9.0\nFRAME_HEIGHT\n=\n8.0\nFRAME_WIDTH\n=\nFRAME_HEIGHT\n*\nASPECT_RATIO\nFRAME_Y_RADIUS\n=\nFRAME_HEIGHT\n/\n2\nFRAME_X_RADIUS\n=\nFRAME_WIDTH\n/\n2\nDEFAULT_PIXEL_HEIGHT\n=\n1080\nDEFAULT_PIXEL_WIDTH\n=\n1920\nDEFAULT_FPS\n=\n30\nBuffs\n¶\nSMALL_BUFF\n=\n0.1\nMED_SMALL_BUFF\n=\n0.25\nMED_LARGE_BUFF\n=\n0.5\nLARGE_BUFF\n=\n1\nDEFAULT_MOBJECT_TO_EDGE_BUFFER\n=\nMED_LARGE_BUFF\n# Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER\n=\nMED_SMALL_BUFF\n# Distance between objects\nRun times\n¶\nDEFAULT_POINTWISE_FUNCTION_RUN_TIME\n=\n3.0\nDEFAULT_WAIT_TIME\n=\n1.0\nCoordinates\n¶\nmanim uses three-dimensional coordinates and uses the type of\nndarray\nORIGIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n0.\n))\nUP\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nDOWN\n=\nnp\n.\narray\n((\n0.\n,\n-\n1.\n,\n0.\n))\nRIGHT\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nLEFT\n=\nnp\n.\narray\n((\n-\n1.\n,\n0.\n,\n0.\n))\nIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n-\n1.\n))\nOUT\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\nX_AXIS\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nY_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nZ_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\n# Useful abbreviations for diagonals\nUL\n=\nUP\n+\nLEFT\nUR\n=\nUP\n+\nRIGHT\nDL\n=\nDOWN\n+\nLEFT\nDR\n=\nDOWN\n+\nRIGHT\nTOP\n=\nFRAME_Y_RADIUS\n*\nUP\nBOTTOM\n=\nFRAME_Y_RADIUS\n*\nDOWN\nLEFT_SIDE\n=\nFRAME_X_RADIUS\n*\nLEFT\nRIGHT_SIDE\n=\nFRAME_X_RADIUS\n*\nRIGHT\nMathematical constant\n¶\nPI\n=\nnp\n.\npi\nTAU\n=\n2\n*\nPI\nDEGREES\n=\nTAU\n/\n360\nText\n¶\nNORMAL\n=\n\"NORMAL\"\nITALIC\n=\n\"ITALIC\"\nOBLIQUE\n=\n\"OBLIQUE\"\nBOLD\n=\n\"BOLD\"\nStroke width\n¶\nDEFAULT_STROKE_WIDTH\n=\n4\nColours\n¶\nHere are the preview of default colours. (Modified from\nelteoremadebeethoven\n)\nBLUE\nBLUE_E\nBLUE_D\nBLUE_C\nBLUE_B\nBLUE_A\nTEAL\nTEAL_E\nTEAL_D\nTEAL_C\nTEAL_B\nTEAL_A\nGREEN\nGREEN_E\nGREEN_D\nGREEN_C\nGREEN_B\nGREEN_A\nYELLOW\nYELLOW_E\nYELLOW_D\nYELLOW_C\nYELLOW_B\nYELLOW_A\nGOLD\nGOLD_E\nGOLD_D\nGOLD_C\nGOLD_B\nGOLD_A\nRED\nRED_E\nRED_D\nRED_C\nRED_B\nRED_A\nMAROON\nMAROON_E\nMAROON_D\nMAROON_C\nMAROON_B\nMAROON_A\nPURPLE\nPURPLE_E\nPURPLE_D\nPURPLE_C\nPURPLE_B\nPURPLE_A\nGREY\nGREY_E\nGREY_D\nGREY_C\nGREY_B\nGREY_A\nOthers\nWHITE\nBLACK\nGREY_BROWN\nDARK_BROWN\nLIGHT_BROWN\nPINK\nLIGHT_PINK\nGREEN_SCREEN\nORANGE\nContents\nconstants\nFrame and pixel shape\nBuffs\nRun times\nCoordinates\nMathematical constant\nText\nStroke width\nColours",
    "code_examples": [
      "constants.py",
      "ASPECT_RATIO = 16.0 / 9.0\nFRAME_HEIGHT = 8.0\nFRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO\nFRAME_Y_RADIUS = FRAME_HEIGHT / 2\nFRAME_X_RADIUS = FRAME_WIDTH / 2\n\nDEFAULT_PIXEL_HEIGHT = 1080\nDEFAULT_PIXEL_WIDTH = 1920\nDEFAULT_FPS = 30",
      "SMALL_BUFF = 0.1\nMED_SMALL_BUFF = 0.25\nMED_LARGE_BUFF = 0.5\nLARGE_BUFF = 1\n\nDEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects",
      "DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0\nDEFAULT_WAIT_TIME = 1.0",
      "ORIGIN = np.array((0., 0., 0.))\nUP = np.array((0., 1., 0.))\nDOWN = np.array((0., -1., 0.))\nRIGHT = np.array((1., 0., 0.))\nLEFT = np.array((-1., 0., 0.))\nIN = np.array((0., 0., -1.))\nOUT = np.array((0., 0., 1.))\nX_AXIS = np.array((1., 0., 0.))\nY_AXIS = np.array((0., 1., 0.))\nZ_AXIS = np.array((0., 0., 1.))\n\n# Useful abbreviations for diagonals\nUL = UP + LEFT\nUR = UP + RIGHT\nDL = DOWN + LEFT\nDR = DOWN + RIGHT\n\nTOP = FRAME_Y_RADIUS * UP\nBOTTOM = FRAME_Y_RADIUS * DOWN\nLEFT_SIDE = FRAME_X_RADIUS * LEFT\nRIGHT_SIDE = FRAME_X_RADIUS * RIGHT",
      "PI = np.pi\nTAU = 2 * PI\nDEGREES = TAU / 360",
      "NORMAL = \"NORMAL\"\nITALIC = \"ITALIC\"\nOBLIQUE = \"OBLIQUE\"\nBOLD = \"BOLD\"",
      "DEFAULT_STROKE_WIDTH = 4"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/documentation/constants.html#constants",
      "https://3b1b.github.io/manim/documentation/constants.html#run-times",
      "https://3b1b.github.io/manim/documentation/constants.html#coordinates",
      "https://3b1b.github.io/manim/documentation/constants.html#mathematical-constant",
      "https://3b1b.github.io/manim/documentation/constants.html#text",
      "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
      "https://3b1b.github.io/manim/documentation/constants.html#colours",
      "https://3b1b.github.io/manim/documentation/constants.html#run-times",
      "https://3b1b.github.io/manim/documentation/constants.html#coordinates",
      "https://3b1b.github.io/manim/documentation/constants.html#mathematical-constant",
      "https://3b1b.github.io/manim/documentation/constants.html#text",
      "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
      "https://3b1b.github.io/manim/documentation/constants.html#colours"
    ],
    "scraped_at": 1752428858.461313
  },
  "https://3b1b.github.io/manim/documentation/constants.html#run-times": {
    "url": "https://3b1b.github.io/manim/documentation/constants.html#run-times",
    "title": "constants - manim  documentation",
    "content": "constants\n¶\nThe\nconstants.py\nin the\nmanimlib\nfolder defines the constants\nneeded when running manim. Some constants are not explained here because\nthey are only used inside manim.\nFrame and pixel shape\n¶\nASPECT_RATIO\n=\n16.0\n/\n9.0\nFRAME_HEIGHT\n=\n8.0\nFRAME_WIDTH\n=\nFRAME_HEIGHT\n*\nASPECT_RATIO\nFRAME_Y_RADIUS\n=\nFRAME_HEIGHT\n/\n2\nFRAME_X_RADIUS\n=\nFRAME_WIDTH\n/\n2\nDEFAULT_PIXEL_HEIGHT\n=\n1080\nDEFAULT_PIXEL_WIDTH\n=\n1920\nDEFAULT_FPS\n=\n30\nBuffs\n¶\nSMALL_BUFF\n=\n0.1\nMED_SMALL_BUFF\n=\n0.25\nMED_LARGE_BUFF\n=\n0.5\nLARGE_BUFF\n=\n1\nDEFAULT_MOBJECT_TO_EDGE_BUFFER\n=\nMED_LARGE_BUFF\n# Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER\n=\nMED_SMALL_BUFF\n# Distance between objects\nRun times\n¶\nDEFAULT_POINTWISE_FUNCTION_RUN_TIME\n=\n3.0\nDEFAULT_WAIT_TIME\n=\n1.0\nCoordinates\n¶\nmanim uses three-dimensional coordinates and uses the type of\nndarray\nORIGIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n0.\n))\nUP\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nDOWN\n=\nnp\n.\narray\n((\n0.\n,\n-\n1.\n,\n0.\n))\nRIGHT\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nLEFT\n=\nnp\n.\narray\n((\n-\n1.\n,\n0.\n,\n0.\n))\nIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n-\n1.\n))\nOUT\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\nX_AXIS\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nY_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nZ_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\n# Useful abbreviations for diagonals\nUL\n=\nUP\n+\nLEFT\nUR\n=\nUP\n+\nRIGHT\nDL\n=\nDOWN\n+\nLEFT\nDR\n=\nDOWN\n+\nRIGHT\nTOP\n=\nFRAME_Y_RADIUS\n*\nUP\nBOTTOM\n=\nFRAME_Y_RADIUS\n*\nDOWN\nLEFT_SIDE\n=\nFRAME_X_RADIUS\n*\nLEFT\nRIGHT_SIDE\n=\nFRAME_X_RADIUS\n*\nRIGHT\nMathematical constant\n¶\nPI\n=\nnp\n.\npi\nTAU\n=\n2\n*\nPI\nDEGREES\n=\nTAU\n/\n360\nText\n¶\nNORMAL\n=\n\"NORMAL\"\nITALIC\n=\n\"ITALIC\"\nOBLIQUE\n=\n\"OBLIQUE\"\nBOLD\n=\n\"BOLD\"\nStroke width\n¶\nDEFAULT_STROKE_WIDTH\n=\n4\nColours\n¶\nHere are the preview of default colours. (Modified from\nelteoremadebeethoven\n)\nBLUE\nBLUE_E\nBLUE_D\nBLUE_C\nBLUE_B\nBLUE_A\nTEAL\nTEAL_E\nTEAL_D\nTEAL_C\nTEAL_B\nTEAL_A\nGREEN\nGREEN_E\nGREEN_D\nGREEN_C\nGREEN_B\nGREEN_A\nYELLOW\nYELLOW_E\nYELLOW_D\nYELLOW_C\nYELLOW_B\nYELLOW_A\nGOLD\nGOLD_E\nGOLD_D\nGOLD_C\nGOLD_B\nGOLD_A\nRED\nRED_E\nRED_D\nRED_C\nRED_B\nRED_A\nMAROON\nMAROON_E\nMAROON_D\nMAROON_C\nMAROON_B\nMAROON_A\nPURPLE\nPURPLE_E\nPURPLE_D\nPURPLE_C\nPURPLE_B\nPURPLE_A\nGREY\nGREY_E\nGREY_D\nGREY_C\nGREY_B\nGREY_A\nOthers\nWHITE\nBLACK\nGREY_BROWN\nDARK_BROWN\nLIGHT_BROWN\nPINK\nLIGHT_PINK\nGREEN_SCREEN\nORANGE\nContents\nconstants\nFrame and pixel shape\nBuffs\nRun times\nCoordinates\nMathematical constant\nText\nStroke width\nColours",
    "code_examples": [
      "constants.py",
      "ASPECT_RATIO = 16.0 / 9.0\nFRAME_HEIGHT = 8.0\nFRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO\nFRAME_Y_RADIUS = FRAME_HEIGHT / 2\nFRAME_X_RADIUS = FRAME_WIDTH / 2\n\nDEFAULT_PIXEL_HEIGHT = 1080\nDEFAULT_PIXEL_WIDTH = 1920\nDEFAULT_FPS = 30",
      "SMALL_BUFF = 0.1\nMED_SMALL_BUFF = 0.25\nMED_LARGE_BUFF = 0.5\nLARGE_BUFF = 1\n\nDEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects",
      "DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0\nDEFAULT_WAIT_TIME = 1.0",
      "ORIGIN = np.array((0., 0., 0.))\nUP = np.array((0., 1., 0.))\nDOWN = np.array((0., -1., 0.))\nRIGHT = np.array((1., 0., 0.))\nLEFT = np.array((-1., 0., 0.))\nIN = np.array((0., 0., -1.))\nOUT = np.array((0., 0., 1.))\nX_AXIS = np.array((1., 0., 0.))\nY_AXIS = np.array((0., 1., 0.))\nZ_AXIS = np.array((0., 0., 1.))\n\n# Useful abbreviations for diagonals\nUL = UP + LEFT\nUR = UP + RIGHT\nDL = DOWN + LEFT\nDR = DOWN + RIGHT\n\nTOP = FRAME_Y_RADIUS * UP\nBOTTOM = FRAME_Y_RADIUS * DOWN\nLEFT_SIDE = FRAME_X_RADIUS * LEFT\nRIGHT_SIDE = FRAME_X_RADIUS * RIGHT",
      "PI = np.pi\nTAU = 2 * PI\nDEGREES = TAU / 360",
      "NORMAL = \"NORMAL\"\nITALIC = \"ITALIC\"\nOBLIQUE = \"OBLIQUE\"\nBOLD = \"BOLD\"",
      "DEFAULT_STROKE_WIDTH = 4"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/documentation/constants.html#constants",
      "https://3b1b.github.io/manim/documentation/constants.html#coordinates",
      "https://3b1b.github.io/manim/documentation/constants.html#mathematical-constant",
      "https://3b1b.github.io/manim/documentation/constants.html#text",
      "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
      "https://3b1b.github.io/manim/documentation/constants.html#colours",
      "https://3b1b.github.io/manim/documentation/constants.html#coordinates",
      "https://3b1b.github.io/manim/documentation/constants.html#mathematical-constant",
      "https://3b1b.github.io/manim/documentation/constants.html#text",
      "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
      "https://3b1b.github.io/manim/documentation/constants.html#colours"
    ],
    "scraped_at": 1752428859.4991622
  },
  "https://3b1b.github.io/manim/documentation/constants.html#coordinates": {
    "url": "https://3b1b.github.io/manim/documentation/constants.html#coordinates",
    "title": "constants - manim  documentation",
    "content": "constants\n¶\nThe\nconstants.py\nin the\nmanimlib\nfolder defines the constants\nneeded when running manim. Some constants are not explained here because\nthey are only used inside manim.\nFrame and pixel shape\n¶\nASPECT_RATIO\n=\n16.0\n/\n9.0\nFRAME_HEIGHT\n=\n8.0\nFRAME_WIDTH\n=\nFRAME_HEIGHT\n*\nASPECT_RATIO\nFRAME_Y_RADIUS\n=\nFRAME_HEIGHT\n/\n2\nFRAME_X_RADIUS\n=\nFRAME_WIDTH\n/\n2\nDEFAULT_PIXEL_HEIGHT\n=\n1080\nDEFAULT_PIXEL_WIDTH\n=\n1920\nDEFAULT_FPS\n=\n30\nBuffs\n¶\nSMALL_BUFF\n=\n0.1\nMED_SMALL_BUFF\n=\n0.25\nMED_LARGE_BUFF\n=\n0.5\nLARGE_BUFF\n=\n1\nDEFAULT_MOBJECT_TO_EDGE_BUFFER\n=\nMED_LARGE_BUFF\n# Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER\n=\nMED_SMALL_BUFF\n# Distance between objects\nRun times\n¶\nDEFAULT_POINTWISE_FUNCTION_RUN_TIME\n=\n3.0\nDEFAULT_WAIT_TIME\n=\n1.0\nCoordinates\n¶\nmanim uses three-dimensional coordinates and uses the type of\nndarray\nORIGIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n0.\n))\nUP\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nDOWN\n=\nnp\n.\narray\n((\n0.\n,\n-\n1.\n,\n0.\n))\nRIGHT\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nLEFT\n=\nnp\n.\narray\n((\n-\n1.\n,\n0.\n,\n0.\n))\nIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n-\n1.\n))\nOUT\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\nX_AXIS\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nY_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nZ_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\n# Useful abbreviations for diagonals\nUL\n=\nUP\n+\nLEFT\nUR\n=\nUP\n+\nRIGHT\nDL\n=\nDOWN\n+\nLEFT\nDR\n=\nDOWN\n+\nRIGHT\nTOP\n=\nFRAME_Y_RADIUS\n*\nUP\nBOTTOM\n=\nFRAME_Y_RADIUS\n*\nDOWN\nLEFT_SIDE\n=\nFRAME_X_RADIUS\n*\nLEFT\nRIGHT_SIDE\n=\nFRAME_X_RADIUS\n*\nRIGHT\nMathematical constant\n¶\nPI\n=\nnp\n.\npi\nTAU\n=\n2\n*\nPI\nDEGREES\n=\nTAU\n/\n360\nText\n¶\nNORMAL\n=\n\"NORMAL\"\nITALIC\n=\n\"ITALIC\"\nOBLIQUE\n=\n\"OBLIQUE\"\nBOLD\n=\n\"BOLD\"\nStroke width\n¶\nDEFAULT_STROKE_WIDTH\n=\n4\nColours\n¶\nHere are the preview of default colours. (Modified from\nelteoremadebeethoven\n)\nBLUE\nBLUE_E\nBLUE_D\nBLUE_C\nBLUE_B\nBLUE_A\nTEAL\nTEAL_E\nTEAL_D\nTEAL_C\nTEAL_B\nTEAL_A\nGREEN\nGREEN_E\nGREEN_D\nGREEN_C\nGREEN_B\nGREEN_A\nYELLOW\nYELLOW_E\nYELLOW_D\nYELLOW_C\nYELLOW_B\nYELLOW_A\nGOLD\nGOLD_E\nGOLD_D\nGOLD_C\nGOLD_B\nGOLD_A\nRED\nRED_E\nRED_D\nRED_C\nRED_B\nRED_A\nMAROON\nMAROON_E\nMAROON_D\nMAROON_C\nMAROON_B\nMAROON_A\nPURPLE\nPURPLE_E\nPURPLE_D\nPURPLE_C\nPURPLE_B\nPURPLE_A\nGREY\nGREY_E\nGREY_D\nGREY_C\nGREY_B\nGREY_A\nOthers\nWHITE\nBLACK\nGREY_BROWN\nDARK_BROWN\nLIGHT_BROWN\nPINK\nLIGHT_PINK\nGREEN_SCREEN\nORANGE\nContents\nconstants\nFrame and pixel shape\nBuffs\nRun times\nCoordinates\nMathematical constant\nText\nStroke width\nColours",
    "code_examples": [
      "constants.py",
      "ASPECT_RATIO = 16.0 / 9.0\nFRAME_HEIGHT = 8.0\nFRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO\nFRAME_Y_RADIUS = FRAME_HEIGHT / 2\nFRAME_X_RADIUS = FRAME_WIDTH / 2\n\nDEFAULT_PIXEL_HEIGHT = 1080\nDEFAULT_PIXEL_WIDTH = 1920\nDEFAULT_FPS = 30",
      "SMALL_BUFF = 0.1\nMED_SMALL_BUFF = 0.25\nMED_LARGE_BUFF = 0.5\nLARGE_BUFF = 1\n\nDEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects",
      "DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0\nDEFAULT_WAIT_TIME = 1.0",
      "ORIGIN = np.array((0., 0., 0.))\nUP = np.array((0., 1., 0.))\nDOWN = np.array((0., -1., 0.))\nRIGHT = np.array((1., 0., 0.))\nLEFT = np.array((-1., 0., 0.))\nIN = np.array((0., 0., -1.))\nOUT = np.array((0., 0., 1.))\nX_AXIS = np.array((1., 0., 0.))\nY_AXIS = np.array((0., 1., 0.))\nZ_AXIS = np.array((0., 0., 1.))\n\n# Useful abbreviations for diagonals\nUL = UP + LEFT\nUR = UP + RIGHT\nDL = DOWN + LEFT\nDR = DOWN + RIGHT\n\nTOP = FRAME_Y_RADIUS * UP\nBOTTOM = FRAME_Y_RADIUS * DOWN\nLEFT_SIDE = FRAME_X_RADIUS * LEFT\nRIGHT_SIDE = FRAME_X_RADIUS * RIGHT",
      "PI = np.pi\nTAU = 2 * PI\nDEGREES = TAU / 360",
      "NORMAL = \"NORMAL\"\nITALIC = \"ITALIC\"\nOBLIQUE = \"OBLIQUE\"\nBOLD = \"BOLD\"",
      "DEFAULT_STROKE_WIDTH = 4"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/documentation/constants.html#constants",
      "https://3b1b.github.io/manim/documentation/constants.html#mathematical-constant",
      "https://3b1b.github.io/manim/documentation/constants.html#text",
      "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
      "https://3b1b.github.io/manim/documentation/constants.html#colours",
      "https://3b1b.github.io/manim/documentation/constants.html#mathematical-constant",
      "https://3b1b.github.io/manim/documentation/constants.html#text",
      "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
      "https://3b1b.github.io/manim/documentation/constants.html#colours"
    ],
    "scraped_at": 1752428860.527186
  },
  "https://3b1b.github.io/manim/documentation/constants.html#mathematical-constant": {
    "url": "https://3b1b.github.io/manim/documentation/constants.html#mathematical-constant",
    "title": "constants - manim  documentation",
    "content": "constants\n¶\nThe\nconstants.py\nin the\nmanimlib\nfolder defines the constants\nneeded when running manim. Some constants are not explained here because\nthey are only used inside manim.\nFrame and pixel shape\n¶\nASPECT_RATIO\n=\n16.0\n/\n9.0\nFRAME_HEIGHT\n=\n8.0\nFRAME_WIDTH\n=\nFRAME_HEIGHT\n*\nASPECT_RATIO\nFRAME_Y_RADIUS\n=\nFRAME_HEIGHT\n/\n2\nFRAME_X_RADIUS\n=\nFRAME_WIDTH\n/\n2\nDEFAULT_PIXEL_HEIGHT\n=\n1080\nDEFAULT_PIXEL_WIDTH\n=\n1920\nDEFAULT_FPS\n=\n30\nBuffs\n¶\nSMALL_BUFF\n=\n0.1\nMED_SMALL_BUFF\n=\n0.25\nMED_LARGE_BUFF\n=\n0.5\nLARGE_BUFF\n=\n1\nDEFAULT_MOBJECT_TO_EDGE_BUFFER\n=\nMED_LARGE_BUFF\n# Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER\n=\nMED_SMALL_BUFF\n# Distance between objects\nRun times\n¶\nDEFAULT_POINTWISE_FUNCTION_RUN_TIME\n=\n3.0\nDEFAULT_WAIT_TIME\n=\n1.0\nCoordinates\n¶\nmanim uses three-dimensional coordinates and uses the type of\nndarray\nORIGIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n0.\n))\nUP\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nDOWN\n=\nnp\n.\narray\n((\n0.\n,\n-\n1.\n,\n0.\n))\nRIGHT\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nLEFT\n=\nnp\n.\narray\n((\n-\n1.\n,\n0.\n,\n0.\n))\nIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n-\n1.\n))\nOUT\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\nX_AXIS\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nY_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nZ_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\n# Useful abbreviations for diagonals\nUL\n=\nUP\n+\nLEFT\nUR\n=\nUP\n+\nRIGHT\nDL\n=\nDOWN\n+\nLEFT\nDR\n=\nDOWN\n+\nRIGHT\nTOP\n=\nFRAME_Y_RADIUS\n*\nUP\nBOTTOM\n=\nFRAME_Y_RADIUS\n*\nDOWN\nLEFT_SIDE\n=\nFRAME_X_RADIUS\n*\nLEFT\nRIGHT_SIDE\n=\nFRAME_X_RADIUS\n*\nRIGHT\nMathematical constant\n¶\nPI\n=\nnp\n.\npi\nTAU\n=\n2\n*\nPI\nDEGREES\n=\nTAU\n/\n360\nText\n¶\nNORMAL\n=\n\"NORMAL\"\nITALIC\n=\n\"ITALIC\"\nOBLIQUE\n=\n\"OBLIQUE\"\nBOLD\n=\n\"BOLD\"\nStroke width\n¶\nDEFAULT_STROKE_WIDTH\n=\n4\nColours\n¶\nHere are the preview of default colours. (Modified from\nelteoremadebeethoven\n)\nBLUE\nBLUE_E\nBLUE_D\nBLUE_C\nBLUE_B\nBLUE_A\nTEAL\nTEAL_E\nTEAL_D\nTEAL_C\nTEAL_B\nTEAL_A\nGREEN\nGREEN_E\nGREEN_D\nGREEN_C\nGREEN_B\nGREEN_A\nYELLOW\nYELLOW_E\nYELLOW_D\nYELLOW_C\nYELLOW_B\nYELLOW_A\nGOLD\nGOLD_E\nGOLD_D\nGOLD_C\nGOLD_B\nGOLD_A\nRED\nRED_E\nRED_D\nRED_C\nRED_B\nRED_A\nMAROON\nMAROON_E\nMAROON_D\nMAROON_C\nMAROON_B\nMAROON_A\nPURPLE\nPURPLE_E\nPURPLE_D\nPURPLE_C\nPURPLE_B\nPURPLE_A\nGREY\nGREY_E\nGREY_D\nGREY_C\nGREY_B\nGREY_A\nOthers\nWHITE\nBLACK\nGREY_BROWN\nDARK_BROWN\nLIGHT_BROWN\nPINK\nLIGHT_PINK\nGREEN_SCREEN\nORANGE\nContents\nconstants\nFrame and pixel shape\nBuffs\nRun times\nCoordinates\nMathematical constant\nText\nStroke width\nColours",
    "code_examples": [
      "constants.py",
      "ASPECT_RATIO = 16.0 / 9.0\nFRAME_HEIGHT = 8.0\nFRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO\nFRAME_Y_RADIUS = FRAME_HEIGHT / 2\nFRAME_X_RADIUS = FRAME_WIDTH / 2\n\nDEFAULT_PIXEL_HEIGHT = 1080\nDEFAULT_PIXEL_WIDTH = 1920\nDEFAULT_FPS = 30",
      "SMALL_BUFF = 0.1\nMED_SMALL_BUFF = 0.25\nMED_LARGE_BUFF = 0.5\nLARGE_BUFF = 1\n\nDEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects",
      "DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0\nDEFAULT_WAIT_TIME = 1.0",
      "ORIGIN = np.array((0., 0., 0.))\nUP = np.array((0., 1., 0.))\nDOWN = np.array((0., -1., 0.))\nRIGHT = np.array((1., 0., 0.))\nLEFT = np.array((-1., 0., 0.))\nIN = np.array((0., 0., -1.))\nOUT = np.array((0., 0., 1.))\nX_AXIS = np.array((1., 0., 0.))\nY_AXIS = np.array((0., 1., 0.))\nZ_AXIS = np.array((0., 0., 1.))\n\n# Useful abbreviations for diagonals\nUL = UP + LEFT\nUR = UP + RIGHT\nDL = DOWN + LEFT\nDR = DOWN + RIGHT\n\nTOP = FRAME_Y_RADIUS * UP\nBOTTOM = FRAME_Y_RADIUS * DOWN\nLEFT_SIDE = FRAME_X_RADIUS * LEFT\nRIGHT_SIDE = FRAME_X_RADIUS * RIGHT",
      "PI = np.pi\nTAU = 2 * PI\nDEGREES = TAU / 360",
      "NORMAL = \"NORMAL\"\nITALIC = \"ITALIC\"\nOBLIQUE = \"OBLIQUE\"\nBOLD = \"BOLD\"",
      "DEFAULT_STROKE_WIDTH = 4"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/documentation/constants.html#constants",
      "https://3b1b.github.io/manim/documentation/constants.html#text",
      "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
      "https://3b1b.github.io/manim/documentation/constants.html#colours",
      "https://3b1b.github.io/manim/documentation/constants.html#text",
      "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
      "https://3b1b.github.io/manim/documentation/constants.html#colours"
    ],
    "scraped_at": 1752428861.561772
  },
  "https://3b1b.github.io/manim/documentation/constants.html#text": {
    "url": "https://3b1b.github.io/manim/documentation/constants.html#text",
    "title": "constants - manim  documentation",
    "content": "constants\n¶\nThe\nconstants.py\nin the\nmanimlib\nfolder defines the constants\nneeded when running manim. Some constants are not explained here because\nthey are only used inside manim.\nFrame and pixel shape\n¶\nASPECT_RATIO\n=\n16.0\n/\n9.0\nFRAME_HEIGHT\n=\n8.0\nFRAME_WIDTH\n=\nFRAME_HEIGHT\n*\nASPECT_RATIO\nFRAME_Y_RADIUS\n=\nFRAME_HEIGHT\n/\n2\nFRAME_X_RADIUS\n=\nFRAME_WIDTH\n/\n2\nDEFAULT_PIXEL_HEIGHT\n=\n1080\nDEFAULT_PIXEL_WIDTH\n=\n1920\nDEFAULT_FPS\n=\n30\nBuffs\n¶\nSMALL_BUFF\n=\n0.1\nMED_SMALL_BUFF\n=\n0.25\nMED_LARGE_BUFF\n=\n0.5\nLARGE_BUFF\n=\n1\nDEFAULT_MOBJECT_TO_EDGE_BUFFER\n=\nMED_LARGE_BUFF\n# Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER\n=\nMED_SMALL_BUFF\n# Distance between objects\nRun times\n¶\nDEFAULT_POINTWISE_FUNCTION_RUN_TIME\n=\n3.0\nDEFAULT_WAIT_TIME\n=\n1.0\nCoordinates\n¶\nmanim uses three-dimensional coordinates and uses the type of\nndarray\nORIGIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n0.\n))\nUP\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nDOWN\n=\nnp\n.\narray\n((\n0.\n,\n-\n1.\n,\n0.\n))\nRIGHT\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nLEFT\n=\nnp\n.\narray\n((\n-\n1.\n,\n0.\n,\n0.\n))\nIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n-\n1.\n))\nOUT\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\nX_AXIS\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nY_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nZ_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\n# Useful abbreviations for diagonals\nUL\n=\nUP\n+\nLEFT\nUR\n=\nUP\n+\nRIGHT\nDL\n=\nDOWN\n+\nLEFT\nDR\n=\nDOWN\n+\nRIGHT\nTOP\n=\nFRAME_Y_RADIUS\n*\nUP\nBOTTOM\n=\nFRAME_Y_RADIUS\n*\nDOWN\nLEFT_SIDE\n=\nFRAME_X_RADIUS\n*\nLEFT\nRIGHT_SIDE\n=\nFRAME_X_RADIUS\n*\nRIGHT\nMathematical constant\n¶\nPI\n=\nnp\n.\npi\nTAU\n=\n2\n*\nPI\nDEGREES\n=\nTAU\n/\n360\nText\n¶\nNORMAL\n=\n\"NORMAL\"\nITALIC\n=\n\"ITALIC\"\nOBLIQUE\n=\n\"OBLIQUE\"\nBOLD\n=\n\"BOLD\"\nStroke width\n¶\nDEFAULT_STROKE_WIDTH\n=\n4\nColours\n¶\nHere are the preview of default colours. (Modified from\nelteoremadebeethoven\n)\nBLUE\nBLUE_E\nBLUE_D\nBLUE_C\nBLUE_B\nBLUE_A\nTEAL\nTEAL_E\nTEAL_D\nTEAL_C\nTEAL_B\nTEAL_A\nGREEN\nGREEN_E\nGREEN_D\nGREEN_C\nGREEN_B\nGREEN_A\nYELLOW\nYELLOW_E\nYELLOW_D\nYELLOW_C\nYELLOW_B\nYELLOW_A\nGOLD\nGOLD_E\nGOLD_D\nGOLD_C\nGOLD_B\nGOLD_A\nRED\nRED_E\nRED_D\nRED_C\nRED_B\nRED_A\nMAROON\nMAROON_E\nMAROON_D\nMAROON_C\nMAROON_B\nMAROON_A\nPURPLE\nPURPLE_E\nPURPLE_D\nPURPLE_C\nPURPLE_B\nPURPLE_A\nGREY\nGREY_E\nGREY_D\nGREY_C\nGREY_B\nGREY_A\nOthers\nWHITE\nBLACK\nGREY_BROWN\nDARK_BROWN\nLIGHT_BROWN\nPINK\nLIGHT_PINK\nGREEN_SCREEN\nORANGE\nContents\nconstants\nFrame and pixel shape\nBuffs\nRun times\nCoordinates\nMathematical constant\nText\nStroke width\nColours",
    "code_examples": [
      "constants.py",
      "ASPECT_RATIO = 16.0 / 9.0\nFRAME_HEIGHT = 8.0\nFRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO\nFRAME_Y_RADIUS = FRAME_HEIGHT / 2\nFRAME_X_RADIUS = FRAME_WIDTH / 2\n\nDEFAULT_PIXEL_HEIGHT = 1080\nDEFAULT_PIXEL_WIDTH = 1920\nDEFAULT_FPS = 30",
      "SMALL_BUFF = 0.1\nMED_SMALL_BUFF = 0.25\nMED_LARGE_BUFF = 0.5\nLARGE_BUFF = 1\n\nDEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects",
      "DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0\nDEFAULT_WAIT_TIME = 1.0",
      "ORIGIN = np.array((0., 0., 0.))\nUP = np.array((0., 1., 0.))\nDOWN = np.array((0., -1., 0.))\nRIGHT = np.array((1., 0., 0.))\nLEFT = np.array((-1., 0., 0.))\nIN = np.array((0., 0., -1.))\nOUT = np.array((0., 0., 1.))\nX_AXIS = np.array((1., 0., 0.))\nY_AXIS = np.array((0., 1., 0.))\nZ_AXIS = np.array((0., 0., 1.))\n\n# Useful abbreviations for diagonals\nUL = UP + LEFT\nUR = UP + RIGHT\nDL = DOWN + LEFT\nDR = DOWN + RIGHT\n\nTOP = FRAME_Y_RADIUS * UP\nBOTTOM = FRAME_Y_RADIUS * DOWN\nLEFT_SIDE = FRAME_X_RADIUS * LEFT\nRIGHT_SIDE = FRAME_X_RADIUS * RIGHT",
      "PI = np.pi\nTAU = 2 * PI\nDEGREES = TAU / 360",
      "NORMAL = \"NORMAL\"\nITALIC = \"ITALIC\"\nOBLIQUE = \"OBLIQUE\"\nBOLD = \"BOLD\"",
      "DEFAULT_STROKE_WIDTH = 4"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/documentation/constants.html#constants",
      "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
      "https://3b1b.github.io/manim/documentation/constants.html#colours",
      "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
      "https://3b1b.github.io/manim/documentation/constants.html#colours"
    ],
    "scraped_at": 1752428862.598624
  },
  "https://3b1b.github.io/manim/documentation/constants.html#stroke-width": {
    "url": "https://3b1b.github.io/manim/documentation/constants.html#stroke-width",
    "title": "constants - manim  documentation",
    "content": "constants\n¶\nThe\nconstants.py\nin the\nmanimlib\nfolder defines the constants\nneeded when running manim. Some constants are not explained here because\nthey are only used inside manim.\nFrame and pixel shape\n¶\nASPECT_RATIO\n=\n16.0\n/\n9.0\nFRAME_HEIGHT\n=\n8.0\nFRAME_WIDTH\n=\nFRAME_HEIGHT\n*\nASPECT_RATIO\nFRAME_Y_RADIUS\n=\nFRAME_HEIGHT\n/\n2\nFRAME_X_RADIUS\n=\nFRAME_WIDTH\n/\n2\nDEFAULT_PIXEL_HEIGHT\n=\n1080\nDEFAULT_PIXEL_WIDTH\n=\n1920\nDEFAULT_FPS\n=\n30\nBuffs\n¶\nSMALL_BUFF\n=\n0.1\nMED_SMALL_BUFF\n=\n0.25\nMED_LARGE_BUFF\n=\n0.5\nLARGE_BUFF\n=\n1\nDEFAULT_MOBJECT_TO_EDGE_BUFFER\n=\nMED_LARGE_BUFF\n# Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER\n=\nMED_SMALL_BUFF\n# Distance between objects\nRun times\n¶\nDEFAULT_POINTWISE_FUNCTION_RUN_TIME\n=\n3.0\nDEFAULT_WAIT_TIME\n=\n1.0\nCoordinates\n¶\nmanim uses three-dimensional coordinates and uses the type of\nndarray\nORIGIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n0.\n))\nUP\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nDOWN\n=\nnp\n.\narray\n((\n0.\n,\n-\n1.\n,\n0.\n))\nRIGHT\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nLEFT\n=\nnp\n.\narray\n((\n-\n1.\n,\n0.\n,\n0.\n))\nIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n-\n1.\n))\nOUT\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\nX_AXIS\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nY_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nZ_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\n# Useful abbreviations for diagonals\nUL\n=\nUP\n+\nLEFT\nUR\n=\nUP\n+\nRIGHT\nDL\n=\nDOWN\n+\nLEFT\nDR\n=\nDOWN\n+\nRIGHT\nTOP\n=\nFRAME_Y_RADIUS\n*\nUP\nBOTTOM\n=\nFRAME_Y_RADIUS\n*\nDOWN\nLEFT_SIDE\n=\nFRAME_X_RADIUS\n*\nLEFT\nRIGHT_SIDE\n=\nFRAME_X_RADIUS\n*\nRIGHT\nMathematical constant\n¶\nPI\n=\nnp\n.\npi\nTAU\n=\n2\n*\nPI\nDEGREES\n=\nTAU\n/\n360\nText\n¶\nNORMAL\n=\n\"NORMAL\"\nITALIC\n=\n\"ITALIC\"\nOBLIQUE\n=\n\"OBLIQUE\"\nBOLD\n=\n\"BOLD\"\nStroke width\n¶\nDEFAULT_STROKE_WIDTH\n=\n4\nColours\n¶\nHere are the preview of default colours. (Modified from\nelteoremadebeethoven\n)\nBLUE\nBLUE_E\nBLUE_D\nBLUE_C\nBLUE_B\nBLUE_A\nTEAL\nTEAL_E\nTEAL_D\nTEAL_C\nTEAL_B\nTEAL_A\nGREEN\nGREEN_E\nGREEN_D\nGREEN_C\nGREEN_B\nGREEN_A\nYELLOW\nYELLOW_E\nYELLOW_D\nYELLOW_C\nYELLOW_B\nYELLOW_A\nGOLD\nGOLD_E\nGOLD_D\nGOLD_C\nGOLD_B\nGOLD_A\nRED\nRED_E\nRED_D\nRED_C\nRED_B\nRED_A\nMAROON\nMAROON_E\nMAROON_D\nMAROON_C\nMAROON_B\nMAROON_A\nPURPLE\nPURPLE_E\nPURPLE_D\nPURPLE_C\nPURPLE_B\nPURPLE_A\nGREY\nGREY_E\nGREY_D\nGREY_C\nGREY_B\nGREY_A\nOthers\nWHITE\nBLACK\nGREY_BROWN\nDARK_BROWN\nLIGHT_BROWN\nPINK\nLIGHT_PINK\nGREEN_SCREEN\nORANGE\nContents\nconstants\nFrame and pixel shape\nBuffs\nRun times\nCoordinates\nMathematical constant\nText\nStroke width\nColours",
    "code_examples": [
      "constants.py",
      "ASPECT_RATIO = 16.0 / 9.0\nFRAME_HEIGHT = 8.0\nFRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO\nFRAME_Y_RADIUS = FRAME_HEIGHT / 2\nFRAME_X_RADIUS = FRAME_WIDTH / 2\n\nDEFAULT_PIXEL_HEIGHT = 1080\nDEFAULT_PIXEL_WIDTH = 1920\nDEFAULT_FPS = 30",
      "SMALL_BUFF = 0.1\nMED_SMALL_BUFF = 0.25\nMED_LARGE_BUFF = 0.5\nLARGE_BUFF = 1\n\nDEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects",
      "DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0\nDEFAULT_WAIT_TIME = 1.0",
      "ORIGIN = np.array((0., 0., 0.))\nUP = np.array((0., 1., 0.))\nDOWN = np.array((0., -1., 0.))\nRIGHT = np.array((1., 0., 0.))\nLEFT = np.array((-1., 0., 0.))\nIN = np.array((0., 0., -1.))\nOUT = np.array((0., 0., 1.))\nX_AXIS = np.array((1., 0., 0.))\nY_AXIS = np.array((0., 1., 0.))\nZ_AXIS = np.array((0., 0., 1.))\n\n# Useful abbreviations for diagonals\nUL = UP + LEFT\nUR = UP + RIGHT\nDL = DOWN + LEFT\nDR = DOWN + RIGHT\n\nTOP = FRAME_Y_RADIUS * UP\nBOTTOM = FRAME_Y_RADIUS * DOWN\nLEFT_SIDE = FRAME_X_RADIUS * LEFT\nRIGHT_SIDE = FRAME_X_RADIUS * RIGHT",
      "PI = np.pi\nTAU = 2 * PI\nDEGREES = TAU / 360",
      "NORMAL = \"NORMAL\"\nITALIC = \"ITALIC\"\nOBLIQUE = \"OBLIQUE\"\nBOLD = \"BOLD\"",
      "DEFAULT_STROKE_WIDTH = 4"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/documentation/constants.html#constants",
      "https://3b1b.github.io/manim/documentation/constants.html#colours",
      "https://3b1b.github.io/manim/documentation/constants.html#colours"
    ],
    "scraped_at": 1752428863.629554
  },
  "https://3b1b.github.io/manim/documentation/constants.html#colours": {
    "url": "https://3b1b.github.io/manim/documentation/constants.html#colours",
    "title": "constants - manim  documentation",
    "content": "constants\n¶\nThe\nconstants.py\nin the\nmanimlib\nfolder defines the constants\nneeded when running manim. Some constants are not explained here because\nthey are only used inside manim.\nFrame and pixel shape\n¶\nASPECT_RATIO\n=\n16.0\n/\n9.0\nFRAME_HEIGHT\n=\n8.0\nFRAME_WIDTH\n=\nFRAME_HEIGHT\n*\nASPECT_RATIO\nFRAME_Y_RADIUS\n=\nFRAME_HEIGHT\n/\n2\nFRAME_X_RADIUS\n=\nFRAME_WIDTH\n/\n2\nDEFAULT_PIXEL_HEIGHT\n=\n1080\nDEFAULT_PIXEL_WIDTH\n=\n1920\nDEFAULT_FPS\n=\n30\nBuffs\n¶\nSMALL_BUFF\n=\n0.1\nMED_SMALL_BUFF\n=\n0.25\nMED_LARGE_BUFF\n=\n0.5\nLARGE_BUFF\n=\n1\nDEFAULT_MOBJECT_TO_EDGE_BUFFER\n=\nMED_LARGE_BUFF\n# Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER\n=\nMED_SMALL_BUFF\n# Distance between objects\nRun times\n¶\nDEFAULT_POINTWISE_FUNCTION_RUN_TIME\n=\n3.0\nDEFAULT_WAIT_TIME\n=\n1.0\nCoordinates\n¶\nmanim uses three-dimensional coordinates and uses the type of\nndarray\nORIGIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n0.\n))\nUP\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nDOWN\n=\nnp\n.\narray\n((\n0.\n,\n-\n1.\n,\n0.\n))\nRIGHT\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nLEFT\n=\nnp\n.\narray\n((\n-\n1.\n,\n0.\n,\n0.\n))\nIN\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n-\n1.\n))\nOUT\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\nX_AXIS\n=\nnp\n.\narray\n((\n1.\n,\n0.\n,\n0.\n))\nY_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n1.\n,\n0.\n))\nZ_AXIS\n=\nnp\n.\narray\n((\n0.\n,\n0.\n,\n1.\n))\n# Useful abbreviations for diagonals\nUL\n=\nUP\n+\nLEFT\nUR\n=\nUP\n+\nRIGHT\nDL\n=\nDOWN\n+\nLEFT\nDR\n=\nDOWN\n+\nRIGHT\nTOP\n=\nFRAME_Y_RADIUS\n*\nUP\nBOTTOM\n=\nFRAME_Y_RADIUS\n*\nDOWN\nLEFT_SIDE\n=\nFRAME_X_RADIUS\n*\nLEFT\nRIGHT_SIDE\n=\nFRAME_X_RADIUS\n*\nRIGHT\nMathematical constant\n¶\nPI\n=\nnp\n.\npi\nTAU\n=\n2\n*\nPI\nDEGREES\n=\nTAU\n/\n360\nText\n¶\nNORMAL\n=\n\"NORMAL\"\nITALIC\n=\n\"ITALIC\"\nOBLIQUE\n=\n\"OBLIQUE\"\nBOLD\n=\n\"BOLD\"\nStroke width\n¶\nDEFAULT_STROKE_WIDTH\n=\n4\nColours\n¶\nHere are the preview of default colours. (Modified from\nelteoremadebeethoven\n)\nBLUE\nBLUE_E\nBLUE_D\nBLUE_C\nBLUE_B\nBLUE_A\nTEAL\nTEAL_E\nTEAL_D\nTEAL_C\nTEAL_B\nTEAL_A\nGREEN\nGREEN_E\nGREEN_D\nGREEN_C\nGREEN_B\nGREEN_A\nYELLOW\nYELLOW_E\nYELLOW_D\nYELLOW_C\nYELLOW_B\nYELLOW_A\nGOLD\nGOLD_E\nGOLD_D\nGOLD_C\nGOLD_B\nGOLD_A\nRED\nRED_E\nRED_D\nRED_C\nRED_B\nRED_A\nMAROON\nMAROON_E\nMAROON_D\nMAROON_C\nMAROON_B\nMAROON_A\nPURPLE\nPURPLE_E\nPURPLE_D\nPURPLE_C\nPURPLE_B\nPURPLE_A\nGREY\nGREY_E\nGREY_D\nGREY_C\nGREY_B\nGREY_A\nOthers\nWHITE\nBLACK\nGREY_BROWN\nDARK_BROWN\nLIGHT_BROWN\nPINK\nLIGHT_PINK\nGREEN_SCREEN\nORANGE\nContents\nconstants\nFrame and pixel shape\nBuffs\nRun times\nCoordinates\nMathematical constant\nText\nStroke width\nColours",
    "code_examples": [
      "constants.py",
      "ASPECT_RATIO = 16.0 / 9.0\nFRAME_HEIGHT = 8.0\nFRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO\nFRAME_Y_RADIUS = FRAME_HEIGHT / 2\nFRAME_X_RADIUS = FRAME_WIDTH / 2\n\nDEFAULT_PIXEL_HEIGHT = 1080\nDEFAULT_PIXEL_WIDTH = 1920\nDEFAULT_FPS = 30",
      "SMALL_BUFF = 0.1\nMED_SMALL_BUFF = 0.25\nMED_LARGE_BUFF = 0.5\nLARGE_BUFF = 1\n\nDEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects",
      "DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0\nDEFAULT_WAIT_TIME = 1.0",
      "ORIGIN = np.array((0., 0., 0.))\nUP = np.array((0., 1., 0.))\nDOWN = np.array((0., -1., 0.))\nRIGHT = np.array((1., 0., 0.))\nLEFT = np.array((-1., 0., 0.))\nIN = np.array((0., 0., -1.))\nOUT = np.array((0., 0., 1.))\nX_AXIS = np.array((1., 0., 0.))\nY_AXIS = np.array((0., 1., 0.))\nZ_AXIS = np.array((0., 0., 1.))\n\n# Useful abbreviations for diagonals\nUL = UP + LEFT\nUR = UP + RIGHT\nDL = DOWN + LEFT\nDR = DOWN + RIGHT\n\nTOP = FRAME_Y_RADIUS * UP\nBOTTOM = FRAME_Y_RADIUS * DOWN\nLEFT_SIDE = FRAME_X_RADIUS * LEFT\nRIGHT_SIDE = FRAME_X_RADIUS * RIGHT",
      "PI = np.pi\nTAU = 2 * PI\nDEGREES = TAU / 360",
      "NORMAL = \"NORMAL\"\nITALIC = \"ITALIC\"\nOBLIQUE = \"OBLIQUE\"\nBOLD = \"BOLD\"",
      "DEFAULT_STROKE_WIDTH = 4"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/documentation/constants.html#constants"
    ],
    "scraped_at": 1752428864.669739
  },
  "https://3b1b.github.io/manim/documentation/custom_config.html#directories": {
    "url": "https://3b1b.github.io/manim/documentation/custom_config.html#directories",
    "title": "custom_config - manim  documentation",
    "content": "custom_config\n¶\ndirectories\n¶\nmirror_module_path\n(\nTrue\nor\nFalse\n) Whether to create a folder named the name of the\nrunning file under the\noutput\npath, and save the output (\nimages/\nor\nvideos/\n) in it.\noutput\nOutput file path, the videos will be saved in the\nvideos/\nfolder under it,\nand the pictures will be saved in the\nimages/\nfolder under it.\nFor example, if you set\noutput\nto\n\"/.../manim/output\"\nand\nmirror_module_path\nto\nFalse\n, then you exported\nScene1\nin the code\nfile and saved the last frame, then the final directory structure will be like:\nmanim/\n    ├── manimlib/\n    │   ├── animation/\n    │   ├── ...\n    │   ├── default_config.yml\n    │   └── window.py\n    ├── output/\n    │   ├── images\n│   │   └── Scene1.png\n│   └── videos\n│       └── Scene1.mp4\n├── code.py\n    └── custom_config.yml\nBut if you set\nmirror_module_path\nto\nTrue\n, the directory structure will be:\nmanim/\n    ├── manimlib/\n    │   ├── animation/\n    │   ├── ...\n    │   ├── default_config.yml\n    │   └── window.py\n    ├── output/\n│   └── code/\n│       ├── images\n    │       │   └── Scene1.png\n    │       └── videos\n    │           └── Scene1.mp4\n    ├── code.py\n    └── custom_config.yml\nraster_images\nThe directory for storing raster images to be used in the code (including\n.jpg\n,\n.jpeg\n,\n.png\nand\n.gif\n), which will be read by\nImageMobject\n.\nvector_images\nThe directory for storing vector images to be used in the code (including\n.svg\nand\n.xdv\n), which will be read by\nSVGMobject\n.\nsounds\nThe directory for storing sound files to be used in\nScene.add_sound()\n(\nincluding\n.wav\nand\n.mp3\n).\ntemporary_storage\nThe directory for storing temporarily generated cache files, including\nTex\ncache,\nText\ncache and storage of object points.\ntex\n¶\nexecutable\nThe executable program used to compile LaTeX (\nlatex\nor\nxelatex\n-no-pdf\nis recommended)\ntemplate_file\nLaTeX template used, in\nmanimlib/tex_templates\nintermediate_filetype\nThe type of intermediate vector file generated after compilation (\ndvi\nif\nlatex\nis used,\nxdv\nif\nxelatex\nis used)\ntext_to_replace\nThe text to be replaced in the template (needn’t to change)\nuniversal_import_line\n¶\nImport line that need to execute when entering interactive mode directly.\nstyle\n¶\nfont\nDefault font of Text\ntext_alignment\nDefault text alignment for LaTeX\nbackground_color\nDefault background color\nwindow_position\n¶\nThe relative position of the playback window on the display (two characters,\nthe first character means upper(U) / middle(O) / lower(D), the second character\nmeans left(L) / middle(O) / right(R)).\nwindow_monitor\n¶\nThe number of the monitor you want the preview window to pop up on. (default is 0)\nfull_screen\n¶\nWhether open the window in full screen. (default is false)\nbreak_into_partial_movies\n¶\nIf this is set to\nTrue\n, then many small files will be written corresponding\nto each\nScene.play\nand\nScene.wait\ncall, and these files will then be combined\nto form the full scene.\nSometimes video-editing is made easier when working with the broken up scene, which\neffectively has cuts at all the places you might want.\ncamera_resolutions\n¶\nExport resolutions\nlow\nLow resolutions (default is 480p)\nmedium\nMedium resolutions (default is 720p)\nhigh\nHigh resolutions (default is 1080p)\nultra_high\nUltra high resolutions (default is 4K)\ndefault_resolutions\nDefault resolutions (one of the above four, default is high)\nfps\n¶\nExport frame rate. (default is 30)\nContents\ncustom_config\ndirectories\ntex\nuniversal_import_line\nstyle\nwindow_position\nwindow_monitor\nfull_screen\nbreak_into_partial_movies\ncamera_resolutions\nfps",
    "code_examples": [
      "directories",
      "mirror_module_path",
      "\"/.../manim/output\"",
      "mirror_module_path",
      "manim/\n    ├── manimlib/\n    │   ├── animation/\n    │   ├── ...\n    │   ├── default_config.yml\n    │   └── window.py\n    ├── output/\n    │   ├── images\n    │   │   └── Scene1.png\n    │   └── videos\n    │       └── Scene1.mp4\n    ├── code.py\n    └── custom_config.yml",
      "mirror_module_path",
      "manim/\n    ├── manimlib/\n    │   ├── animation/\n    │   ├── ...\n    │   ├── default_config.yml\n    │   └── window.py\n    ├── output/\n    │   └── code/\n    │       ├── images\n    │       │   └── Scene1.png\n    │       └── videos\n    │           └── Scene1.mp4\n    ├── code.py\n    └── custom_config.yml",
      "raster_images",
      "ImageMobject",
      "vector_images",
      "Scene.add_sound()",
      "temporary_storage",
      "xelatex -no-pdf",
      "template_file",
      "manimlib/tex_templates",
      "intermediate_filetype",
      "text_to_replace",
      "universal_import_line",
      "text_alignment",
      "background_color",
      "window_position",
      "window_monitor",
      "full_screen",
      "break_into_partial_movies",
      "camera_resolutions",
      "default_resolutions",
      "directories",
      "universal_import_line",
      "window_position",
      "window_monitor",
      "full_screen",
      "break_into_partial_movies",
      "camera_resolutions"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/documentation/custom_config.html#custom-config",
      "https://3b1b.github.io/manim/documentation/custom_config.html#tex",
      "https://3b1b.github.io/manim/documentation/custom_config.html#universal-import-line",
      "https://3b1b.github.io/manim/documentation/custom_config.html#style",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-position",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-monitor",
      "https://3b1b.github.io/manim/documentation/custom_config.html#full-screen",
      "https://3b1b.github.io/manim/documentation/custom_config.html#break-into-partial-movies",
      "https://3b1b.github.io/manim/documentation/custom_config.html#camera-resolutions",
      "https://3b1b.github.io/manim/documentation/custom_config.html#fps",
      "https://3b1b.github.io/manim/documentation/custom_config.html#tex",
      "https://3b1b.github.io/manim/documentation/custom_config.html#universal-import-line",
      "https://3b1b.github.io/manim/documentation/custom_config.html#style",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-position",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-monitor",
      "https://3b1b.github.io/manim/documentation/custom_config.html#full-screen",
      "https://3b1b.github.io/manim/documentation/custom_config.html#break-into-partial-movies",
      "https://3b1b.github.io/manim/documentation/custom_config.html#camera-resolutions",
      "https://3b1b.github.io/manim/documentation/custom_config.html#fps"
    ],
    "scraped_at": 1752428865.7967691
  },
  "https://3b1b.github.io/manim/documentation/custom_config.html#tex": {
    "url": "https://3b1b.github.io/manim/documentation/custom_config.html#tex",
    "title": "custom_config - manim  documentation",
    "content": "custom_config\n¶\ndirectories\n¶\nmirror_module_path\n(\nTrue\nor\nFalse\n) Whether to create a folder named the name of the\nrunning file under the\noutput\npath, and save the output (\nimages/\nor\nvideos/\n) in it.\noutput\nOutput file path, the videos will be saved in the\nvideos/\nfolder under it,\nand the pictures will be saved in the\nimages/\nfolder under it.\nFor example, if you set\noutput\nto\n\"/.../manim/output\"\nand\nmirror_module_path\nto\nFalse\n, then you exported\nScene1\nin the code\nfile and saved the last frame, then the final directory structure will be like:\nmanim/\n    ├── manimlib/\n    │   ├── animation/\n    │   ├── ...\n    │   ├── default_config.yml\n    │   └── window.py\n    ├── output/\n    │   ├── images\n│   │   └── Scene1.png\n│   └── videos\n│       └── Scene1.mp4\n├── code.py\n    └── custom_config.yml\nBut if you set\nmirror_module_path\nto\nTrue\n, the directory structure will be:\nmanim/\n    ├── manimlib/\n    │   ├── animation/\n    │   ├── ...\n    │   ├── default_config.yml\n    │   └── window.py\n    ├── output/\n│   └── code/\n│       ├── images\n    │       │   └── Scene1.png\n    │       └── videos\n    │           └── Scene1.mp4\n    ├── code.py\n    └── custom_config.yml\nraster_images\nThe directory for storing raster images to be used in the code (including\n.jpg\n,\n.jpeg\n,\n.png\nand\n.gif\n), which will be read by\nImageMobject\n.\nvector_images\nThe directory for storing vector images to be used in the code (including\n.svg\nand\n.xdv\n), which will be read by\nSVGMobject\n.\nsounds\nThe directory for storing sound files to be used in\nScene.add_sound()\n(\nincluding\n.wav\nand\n.mp3\n).\ntemporary_storage\nThe directory for storing temporarily generated cache files, including\nTex\ncache,\nText\ncache and storage of object points.\ntex\n¶\nexecutable\nThe executable program used to compile LaTeX (\nlatex\nor\nxelatex\n-no-pdf\nis recommended)\ntemplate_file\nLaTeX template used, in\nmanimlib/tex_templates\nintermediate_filetype\nThe type of intermediate vector file generated after compilation (\ndvi\nif\nlatex\nis used,\nxdv\nif\nxelatex\nis used)\ntext_to_replace\nThe text to be replaced in the template (needn’t to change)\nuniversal_import_line\n¶\nImport line that need to execute when entering interactive mode directly.\nstyle\n¶\nfont\nDefault font of Text\ntext_alignment\nDefault text alignment for LaTeX\nbackground_color\nDefault background color\nwindow_position\n¶\nThe relative position of the playback window on the display (two characters,\nthe first character means upper(U) / middle(O) / lower(D), the second character\nmeans left(L) / middle(O) / right(R)).\nwindow_monitor\n¶\nThe number of the monitor you want the preview window to pop up on. (default is 0)\nfull_screen\n¶\nWhether open the window in full screen. (default is false)\nbreak_into_partial_movies\n¶\nIf this is set to\nTrue\n, then many small files will be written corresponding\nto each\nScene.play\nand\nScene.wait\ncall, and these files will then be combined\nto form the full scene.\nSometimes video-editing is made easier when working with the broken up scene, which\neffectively has cuts at all the places you might want.\ncamera_resolutions\n¶\nExport resolutions\nlow\nLow resolutions (default is 480p)\nmedium\nMedium resolutions (default is 720p)\nhigh\nHigh resolutions (default is 1080p)\nultra_high\nUltra high resolutions (default is 4K)\ndefault_resolutions\nDefault resolutions (one of the above four, default is high)\nfps\n¶\nExport frame rate. (default is 30)\nContents\ncustom_config\ndirectories\ntex\nuniversal_import_line\nstyle\nwindow_position\nwindow_monitor\nfull_screen\nbreak_into_partial_movies\ncamera_resolutions\nfps",
    "code_examples": [
      "directories",
      "mirror_module_path",
      "\"/.../manim/output\"",
      "mirror_module_path",
      "manim/\n    ├── manimlib/\n    │   ├── animation/\n    │   ├── ...\n    │   ├── default_config.yml\n    │   └── window.py\n    ├── output/\n    │   ├── images\n    │   │   └── Scene1.png\n    │   └── videos\n    │       └── Scene1.mp4\n    ├── code.py\n    └── custom_config.yml",
      "mirror_module_path",
      "manim/\n    ├── manimlib/\n    │   ├── animation/\n    │   ├── ...\n    │   ├── default_config.yml\n    │   └── window.py\n    ├── output/\n    │   └── code/\n    │       ├── images\n    │       │   └── Scene1.png\n    │       └── videos\n    │           └── Scene1.mp4\n    ├── code.py\n    └── custom_config.yml",
      "raster_images",
      "ImageMobject",
      "vector_images",
      "Scene.add_sound()",
      "temporary_storage",
      "xelatex -no-pdf",
      "template_file",
      "manimlib/tex_templates",
      "intermediate_filetype",
      "text_to_replace",
      "universal_import_line",
      "text_alignment",
      "background_color",
      "window_position",
      "window_monitor",
      "full_screen",
      "break_into_partial_movies",
      "camera_resolutions",
      "default_resolutions",
      "directories",
      "universal_import_line",
      "window_position",
      "window_monitor",
      "full_screen",
      "break_into_partial_movies",
      "camera_resolutions"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/documentation/custom_config.html#custom-config",
      "https://3b1b.github.io/manim/documentation/custom_config.html#universal-import-line",
      "https://3b1b.github.io/manim/documentation/custom_config.html#style",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-position",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-monitor",
      "https://3b1b.github.io/manim/documentation/custom_config.html#full-screen",
      "https://3b1b.github.io/manim/documentation/custom_config.html#break-into-partial-movies",
      "https://3b1b.github.io/manim/documentation/custom_config.html#camera-resolutions",
      "https://3b1b.github.io/manim/documentation/custom_config.html#fps",
      "https://3b1b.github.io/manim/documentation/custom_config.html#universal-import-line",
      "https://3b1b.github.io/manim/documentation/custom_config.html#style",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-position",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-monitor",
      "https://3b1b.github.io/manim/documentation/custom_config.html#full-screen",
      "https://3b1b.github.io/manim/documentation/custom_config.html#break-into-partial-movies",
      "https://3b1b.github.io/manim/documentation/custom_config.html#camera-resolutions",
      "https://3b1b.github.io/manim/documentation/custom_config.html#fps"
    ],
    "scraped_at": 1752428866.820829
  },
  "https://3b1b.github.io/manim/documentation/custom_config.html#universal-import-line": {
    "url": "https://3b1b.github.io/manim/documentation/custom_config.html#universal-import-line",
    "title": "custom_config - manim  documentation",
    "content": "custom_config\n¶\ndirectories\n¶\nmirror_module_path\n(\nTrue\nor\nFalse\n) Whether to create a folder named the name of the\nrunning file under the\noutput\npath, and save the output (\nimages/\nor\nvideos/\n) in it.\noutput\nOutput file path, the videos will be saved in the\nvideos/\nfolder under it,\nand the pictures will be saved in the\nimages/\nfolder under it.\nFor example, if you set\noutput\nto\n\"/.../manim/output\"\nand\nmirror_module_path\nto\nFalse\n, then you exported\nScene1\nin the code\nfile and saved the last frame, then the final directory structure will be like:\nmanim/\n    ├── manimlib/\n    │   ├── animation/\n    │   ├── ...\n    │   ├── default_config.yml\n    │   └── window.py\n    ├── output/\n    │   ├── images\n│   │   └── Scene1.png\n│   └── videos\n│       └── Scene1.mp4\n├── code.py\n    └── custom_config.yml\nBut if you set\nmirror_module_path\nto\nTrue\n, the directory structure will be:\nmanim/\n    ├── manimlib/\n    │   ├── animation/\n    │   ├── ...\n    │   ├── default_config.yml\n    │   └── window.py\n    ├── output/\n│   └── code/\n│       ├── images\n    │       │   └── Scene1.png\n    │       └── videos\n    │           └── Scene1.mp4\n    ├── code.py\n    └── custom_config.yml\nraster_images\nThe directory for storing raster images to be used in the code (including\n.jpg\n,\n.jpeg\n,\n.png\nand\n.gif\n), which will be read by\nImageMobject\n.\nvector_images\nThe directory for storing vector images to be used in the code (including\n.svg\nand\n.xdv\n), which will be read by\nSVGMobject\n.\nsounds\nThe directory for storing sound files to be used in\nScene.add_sound()\n(\nincluding\n.wav\nand\n.mp3\n).\ntemporary_storage\nThe directory for storing temporarily generated cache files, including\nTex\ncache,\nText\ncache and storage of object points.\ntex\n¶\nexecutable\nThe executable program used to compile LaTeX (\nlatex\nor\nxelatex\n-no-pdf\nis recommended)\ntemplate_file\nLaTeX template used, in\nmanimlib/tex_templates\nintermediate_filetype\nThe type of intermediate vector file generated after compilation (\ndvi\nif\nlatex\nis used,\nxdv\nif\nxelatex\nis used)\ntext_to_replace\nThe text to be replaced in the template (needn’t to change)\nuniversal_import_line\n¶\nImport line that need to execute when entering interactive mode directly.\nstyle\n¶\nfont\nDefault font of Text\ntext_alignment\nDefault text alignment for LaTeX\nbackground_color\nDefault background color\nwindow_position\n¶\nThe relative position of the playback window on the display (two characters,\nthe first character means upper(U) / middle(O) / lower(D), the second character\nmeans left(L) / middle(O) / right(R)).\nwindow_monitor\n¶\nThe number of the monitor you want the preview window to pop up on. (default is 0)\nfull_screen\n¶\nWhether open the window in full screen. (default is false)\nbreak_into_partial_movies\n¶\nIf this is set to\nTrue\n, then many small files will be written corresponding\nto each\nScene.play\nand\nScene.wait\ncall, and these files will then be combined\nto form the full scene.\nSometimes video-editing is made easier when working with the broken up scene, which\neffectively has cuts at all the places you might want.\ncamera_resolutions\n¶\nExport resolutions\nlow\nLow resolutions (default is 480p)\nmedium\nMedium resolutions (default is 720p)\nhigh\nHigh resolutions (default is 1080p)\nultra_high\nUltra high resolutions (default is 4K)\ndefault_resolutions\nDefault resolutions (one of the above four, default is high)\nfps\n¶\nExport frame rate. (default is 30)\nContents\ncustom_config\ndirectories\ntex\nuniversal_import_line\nstyle\nwindow_position\nwindow_monitor\nfull_screen\nbreak_into_partial_movies\ncamera_resolutions\nfps",
    "code_examples": [
      "directories",
      "mirror_module_path",
      "\"/.../manim/output\"",
      "mirror_module_path",
      "manim/\n    ├── manimlib/\n    │   ├── animation/\n    │   ├── ...\n    │   ├── default_config.yml\n    │   └── window.py\n    ├── output/\n    │   ├── images\n    │   │   └── Scene1.png\n    │   └── videos\n    │       └── Scene1.mp4\n    ├── code.py\n    └── custom_config.yml",
      "mirror_module_path",
      "manim/\n    ├── manimlib/\n    │   ├── animation/\n    │   ├── ...\n    │   ├── default_config.yml\n    │   └── window.py\n    ├── output/\n    │   └── code/\n    │       ├── images\n    │       │   └── Scene1.png\n    │       └── videos\n    │           └── Scene1.mp4\n    ├── code.py\n    └── custom_config.yml",
      "raster_images",
      "ImageMobject",
      "vector_images",
      "Scene.add_sound()",
      "temporary_storage",
      "xelatex -no-pdf",
      "template_file",
      "manimlib/tex_templates",
      "intermediate_filetype",
      "text_to_replace",
      "universal_import_line",
      "text_alignment",
      "background_color",
      "window_position",
      "window_monitor",
      "full_screen",
      "break_into_partial_movies",
      "camera_resolutions",
      "default_resolutions",
      "directories",
      "universal_import_line",
      "window_position",
      "window_monitor",
      "full_screen",
      "break_into_partial_movies",
      "camera_resolutions"
    ],
    "links": [
      "https://3b1b.github.io/manim/index.html",
      "https://3b1b.github.io/manim/documentation/custom_config.html#custom-config",
      "https://3b1b.github.io/manim/documentation/custom_config.html#style",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-position",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-monitor",
      "https://3b1b.github.io/manim/documentation/custom_config.html#full-screen",
      "https://3b1b.github.io/manim/documentation/custom_config.html#break-into-partial-movies",
      "https://3b1b.github.io/manim/documentation/custom_config.html#camera-resolutions",
      "https://3b1b.github.io/manim/documentation/custom_config.html#fps",
      "https://3b1b.github.io/manim/documentation/custom_config.html#style",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-position",
      "https://3b1b.github.io/manim/documentation/custom_config.html#window-monitor",
      "https://3b1b.github.io/manim/documentation/custom_config.html#full-screen",
      "https://3b1b.github.io/manim/documentation/custom_config.html#break-into-partial-movies",
      "https://3b1b.github.io/manim/documentation/custom_config.html#camera-resolutions",
      "https://3b1b.github.io/manim/documentation/custom_config.html#fps"
    ],
    "scraped_at": 1752428867.8529642
  }
}