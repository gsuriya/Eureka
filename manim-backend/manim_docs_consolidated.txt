=== Home - manim  documentation ===
URL: https://3b1b.github.io/manim/
Content:
Manim’s documentation
¶
Manim is an animation engine for explanatory math videos. It’s used to create precise animations programmatically, as seen in the videos
at
3Blue1Brown
.
And here is a Chinese version of this documentation:
https://docs.manim.org.cn/
Getting Started
Installation
Install FFmpeg
Install FFmpeg Windows
# Install FFmepeg Linux
# Install FFmpeg MacOS
Directly
Directly (Windows)
For Anaconda
Quick Start
Make an image
Add animations
Enable interaction
You succeeded!
CLI flags and configuration
Command Line Interface
custom_config
Example Scenes
InteractiveDevlopment
AnimatingMethods
TextExample
TexTransformExample
UpdatersExample
CoordinateSystemExample
GraphExample
SurfaceExample
OpeningManimExample
Manim’s structure
Manim’s directory structure
Inheritance structure of manim’s classes
Manim execution process
What’s new
Usage changes of new version manim
Documentation
constants
Frame and pixel shape
Buffs
Run times
Coordinates
Mathematical constant
Text
Stroke width
Colours
custom_config
directories
tex
universal_import_line
style
window_position
window_monitor
full_screen
break_into_partial_movies
camera_resolutions
fps
Development
Changelog
Unreleased
v1.6.1
v1.6.0
v1.5.0
v1.4.1
v1.4.0
v1.3.0
v1.2.0
v1.1.0
Contributing
How to build this documentation
About
About Manim
About this documentation

Code Examples:
Example 1:
```python
directories
```
Example 2:
```python
universal_import_line
```
Example 3:
```python
window_position
```
Example 4:
```python
window_monitor
```
Example 5:
```python
full_screen
```
Example 6:
```python
break_into_partial_movies
```
Example 7:
```python
camera_resolutions
```

================================================================================

=== Installation - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/installation.html
Content:
Installation
¶
Manim runs on Python 3.7 or higher.
System requirements are：
FFmpeg
OpenGL
(included in python package
PyOpenGL
)
LaTeX
(optional, if you want to use LaTeX)
Pango
(only for Linux)
Install FFmpeg
¶
Install FFmpeg Windows
¶
choco install ffmpeg
# Install FFmepeg Linux
¶
$
sudo
apt
update
$
sudo
apt
install
ffmpeg
$
ffmpeg
-version
# Install FFmpeg MacOS
¶
Download This ZIP file
`
https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full
.7z`(if the link is not working download this zip file from there original website)
Directly
¶
# Install manimgl
pip
install
manimgl
# Try it out
manimgl
If you want to hack on manimlib itself, clone this repository and in
that directory execute:
# Install python requirements
pip
install
-e
.
# Try it out
manimgl
example_scenes.py
OpeningManimExample
# or
manim-render
example_scenes.py
OpeningManimExample
If you run the above command and no error message appears,
then you have successfully installed all the environments required by manim.
Directly (Windows)
¶
Install
FFmpeg
, and make sure that its path is in the PATH environment variable.
Install a LaTeX distribution.
TeXLive-full
is recommended.
Install the remaining Python packages.
git
clone
https://github.com/3b1b/manim.git
cd
manim
pip
install
-e
.
manimgl
example_scenes.py
OpeningManimExample
For Anaconda
¶
Install FFmpeg and LaTeX as above.
Create a conda environment using
git
clone
https://github.com/3b1b/manim.git
cd
manim
conda
create
-n
manim
python
=
3
.8
conda
activate
manim
pip
install
-e
.
Contents
Installation
Install FFmpeg
Install FFmpeg Windows
# Install FFmepeg Linux
# Install FFmpeg MacOS
Directly
Directly (Windows)
For Anaconda

Code Examples:
Example 1:
```python
choco install ffmpeg
```
Example 2:
```python
$ sudo apt update
$ sudo apt install ffmpeg
$ ffmpeg -version
```
Example 3:
```python
# Install manimgl
pip install manimgl

# Try it out
manimgl
```
Example 4:
```python
# Install python requirements
pip install -e .

# Try it out
manimgl example_scenes.py OpeningManimExample
# or
manim-render example_scenes.py OpeningManimExample
```
Example 5:
```python
git clone https://github.com/3b1b/manim.git
cd manim
pip install -e .
manimgl example_scenes.py OpeningManimExample
```
Example 6:
```python
git clone https://github.com/3b1b/manim.git
cd manim
conda create -n manim python=3.8
conda activate manim
pip install -e .
```

================================================================================

=== Quick Start - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/quickstart.html
Content:
Quick Start
¶
After installing the manim environment according to the instructions on the
Installation
page, you can try to make a scene yourself from scratch.
First, create a new
.py
file (such as
start.py
) according to the following
directory structure:
manim/
├── manimlib/
│   ├── animation/
│   ├── ...
│   ├── default_config.yml
│   └── window.py
├── custom_config.yml
└── start.py
And paste the following code (I will explain the function of each line in detail later):
1
2
3
4
5
6
7
8
9
from
manimlib
import
*
class
SquareToCircle
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
self
.
add
(
circle
)
And run this command:
manimgl
start.py
SquareToCircle
A window will pop up on the screen. And then you can :
scroll the middle mouse button to move the screen up and down
hold down the
z
on the keyboard while scrolling the middle mouse button to zoom the screen
hold down the
s
key on the keyboard and move the mouse to pan the screen
hold down the
d
key on the keyboard and move the mouse to change the three-dimensional perspective.
Finally, you can close the window and exit the program by pressing
q
.
Run this command again:
manimgl
start.py
SquareToCircle
-os
At this time, no window will pop up. When the program is finished, this rendered
image will be automatically opened (saved in the subdirectory
images/
of the same
level directory of
start.py
by default):
Make an image
¶
Next, let’s take a detailed look at what each row does.
Line 1
:
from
manimlib
import
*
This will import all the classes that may be used when using manim.
Line 3
:
class
SquareToCircle
(
Scene
):
Create a
Scene
subclass
SquareToCircle
, which will be
the scene you write and render.
Line 4
:
def
construct
(
self
):
Write the
construct()
method, the content of which will determine
how to create the mobjects in the screen and what operations need to be performed.
Line 5
:
circle
=
Circle
()
Create a circle (an instance of the
Circle
class), called
circle
Line 6~7
:
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
Set the circle style by calling the circle’s method.
The
.set_fill()
method sets the fill color of this circle to blue (
BLUE
, defined in
constants
), and the fill transparency to 0.5.
The
.set_stroke()
method sets the stroke color of this circle to dark blue (
BLUE_E
, defined in
constants
), and the stroke width to 4.
Line 9
:
self
.
add
(
circle
)
Add this circle to the screen through the
.add()
method of
Scene
.
Add animations
¶
Let’s change some codes and add some animations to make videos instead of just pictures.
1
2
3
4
5
6
7
8
9
10
11
12
13
from
manimlib
import
*
class
SquareToCircle
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
square
=
Square
()
self
.
play
(
ShowCreation
(
square
))
self
.
wait
()
self
.
play
(
ReplacementTransform
(
square
,
circle
))
self
.
wait
()
Run this command this time:
manimgl
start.py
SquareToCircle
The pop-up window will play animations of drawing a square and transforming
it into a circle. If you want to save this video, run:
manimgl
start.py
SquareToCircle
-o
This time there will be no pop-up window, but the video file (saved in the subdirectory
videos/
of the same level directory of
start.py
by default) will be automatically
opened after the operation is over:
Let’s take a look at the code this time. The first 7 lines are the same as the previous
ones, and the 8th line is similar to the 5th line, which creates an instance of the
Square
class and named it
square
.
Line 10
:
self
.
play
(
ShowCreation
(
square
))
An animation is played through
Scene
’s
.play()
method.
ShowCreation
is an animation that shows the process of creating a given mobject.
self.play(ShowCreation(square))
is to play the animation of creating
square
.
Line 11
:
self
.
wait
()
Use
Scene
’s
.wait()
method to pause (default 1s), you can pass in
parameters to indicate the pause time (for example,
self.wait(3)
means pause for 3s).
Line 12
:
self
.
play
(
ReplacementTransform
(
square
,
circle
))
Play the animation that transforms
square
into
circle
.
ReplacementTransform(A,
B)
means to transform A into B’s pattern and replace A with B.
Line 13
: Same as line 11, pause for 1s.
Enable interaction
¶
Interaction is a new feature of the new version. You can add the following line
at the end of the code to enable interaction:
self
.
embed
()
Then run
manimgl
start.py
SquareToCircle
.
After the previous animation is executed, the ipython terminal will be opened on
the command line. After that, you can continue to write code in it, and the statement
you entered will be executed immediately after pressing
Enter
.
For example: input the following lines (without comment lines) into it respectively
(
self.play
can be abbreviated as
play
in this mode):
# Stretched 4 times in the vertical direction
play
(
circle
.
animate
.
stretch
(
4
,
dim
=
0
))
# Rotate the ellipse 90°
play
(
Rotate
(
circle
,
TAU
/
4
))
# Move 2 units to the right and shrink to 1/4 of the original
play
(
circle
.
animate
.
shift
(
2
*
RIGHT
),
circle
.
animate
.
scale
(
0.25
))
# Insert 10 curves into circle for non-linear transformation (no animation will play)
circle
.
insert_n_curves
(
10
)
# Apply a complex transformation of f(z)=z^2 to all points on the circle
play
(
circle
.
animate
.
apply_complex_function
(
lambda
z
:
z
**
2
))
# Close the window and exit the program
exit
()
You will get an animation similar to the following:
If you want to enter the interactive mode directly, you don’t have to write an
empty scene containing only
self.embed()
, you can directly run the following command
(this will enter the ipython terminal while the window pops up):
manimgl
You succeeded!
¶
After reading the above content, you already know how to use manim.
Below you can see some examples, in the
Example Scenes
page.
But before that, you’d better have a look at the
CLI flags and configuration
of manim.
Contents
Quick Start
Make an image
Add animations
Enable interaction
You succeeded!

Code Examples:
Example 1:
```python
manim/
├── manimlib/
│   ├── animation/
│   ├── ...
│   ├── default_config.yml
│   └── window.py
├── custom_config.yml
└── start.py
```
Example 2:
```python
1
2
3
4
5
6
7
8
9
```
Example 3:
```python
from manimlib import *

class SquareToCircle(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)

        self.add(circle)
```
Example 4:
```python
manimgl start.py SquareToCircle
```
Example 5:
```python
manimgl start.py SquareToCircle -os
```
Example 6:
```python
from manimlib import *
```
Example 7:
```python
class SquareToCircle(Scene):
```
Example 8:
```python
SquareToCircle
```
Example 9:
```python
def construct(self):
```
Example 10:
```python
construct()
```
Example 11:
```python
circle = Circle()
```
Example 12:
```python
circle.set_fill(BLUE, opacity=0.5)
circle.set_stroke(BLUE_E, width=4)
```
Example 13:
```python
.set_fill()
```
Example 14:
```python
.set_stroke()
```
Example 15:
```python
self.add(circle)
```
Example 16:
```python
1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
```
Example 17:
```python
from manimlib import *

class SquareToCircle(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)
        square = Square()

        self.play(ShowCreation(square))
        self.wait()
        self.play(ReplacementTransform(square, circle))
        self.wait()
```
Example 18:
```python
manimgl start.py SquareToCircle
```
Example 19:
```python
manimgl start.py SquareToCircle -o
```
Example 20:
```python
self.play(ShowCreation(square))
```
Example 21:
```python
ShowCreation
```
Example 22:
```python
self.play(ShowCreation(square))
```
Example 23:
```python
self.wait()
```
Example 24:
```python
self.wait(3)
```
Example 25:
```python
self.play(ReplacementTransform(square, circle))
```
Example 26:
```python
ReplacementTransform(A, B)
```
Example 27:
```python
self.embed()
```
Example 28:
```python
manimgl start.py SquareToCircle
```
Example 29:
```python
# Stretched 4 times in the vertical direction
play(circle.animate.stretch(4, dim=0))
# Rotate the ellipse 90°
play(Rotate(circle, TAU / 4))
# Move 2 units to the right and shrink to 1/4 of the original
play(circle.animate.shift(2 * RIGHT), circle.animate.scale(0.25))
# Insert 10 curves into circle for non-linear transformation (no animation will play)
circle.insert_n_curves(10)
# Apply a complex transformation of f(z)=z^2 to all points on the circle
play(circle.animate.apply_complex_function(lambda z: z**2))
# Close the window and exit the program
exit()
```
Example 30:
```python
self.embed()
```

================================================================================

=== CLI flags and configuration - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/configuration.html
Content:
CLI flags and configuration
¶
Command Line Interface
¶
To run manim, you need to enter the directory at the same level as
manimlib/
and enter the command in the following format into terminal:
manimgl
<code>.py
<Scene>
<flags>
# or
manim-render
<code>.py
<Scene>
<flags>
<code>.py
: The python file you wrote. Needs to be at the same level as
manimlib/
, otherwise you need to use an absolute path or a relative path.
<Scene>
: The scene you want to render here. If it is not written or written incorrectly, it will list all for you to choose. And if there is only one
Scene
in the file, this class will be rendered directly.
<flags>
: CLI flags.
Some useful flags
¶
-w
to write the scene to a file.
-o
to write the scene to a file and open the result.
-s
to skip to the end and just show the final frame.
-so
will save the final frame to an image and show it.
-n
<number>
to skip ahead to the
n
’th animation of a scene.
-f
to make the playback window fullscreen.
All supported flags
¶
flag
abbr
function
--help
-h
Show the help message and exit
--version
-v
Display the version of manimgl
--write_file
-w
Render the scene as a movie file
--skip_animations
-s
Skip to the last frame
--low_quality
-l
Render at a low quality (for faster rendering)
--medium_quality
-m
Render at a medium quality
--hd
Render at a 1080p quality
--uhd
Render at a 4k quality
--full_screen
-f
Show window in full screen
--presenter_mode
-p
Scene will stay paused during wait calls until space bar or right arrow is hit, like a slide show
--save_pngs
-g
Save each frame as a png
--gif
-i
Save the video as gif
--transparent
-t
Render to a movie file with an alpha channel
--quiet
-q
--write_all
-a
Write all the scenes from a file
--open
-o
Automatically open the saved file once its done
--finder
Show the output file in finder
--config
Guide for automatic configuration
--file_name
FILE_NAME
Name for the movie or image file
--start_at_animation_number
START_AT_ANIMATION_NUMBER
-n
Start rendering not from the first animation, but from another, specified by its index. If you passing two comma separated values, e.g. “3,6”, it will end the rendering at the second value.
--embed
[EMBED]
-e
Creates a new file where the line
self.embed
is inserted into the Scenes construct method. If a string is passed in, the line will be inserted below the last line of code including that string.
--resolution
RESOLUTION
-r
Resolution, passed as “WxH”, e.g. “1920x1080”
--fps
FPS
Frame rate, as an integer
--color
COLOR
-c
Background color
--leave_progress_bars
Leave progress bars displayed in terminal
--video_dir
VIDEO_DIR
Directory to write video
--config_file
CONFIG_FILE
Path to the custom configuration file
--log-level
LOG_LEVEL
Level of messages to Display, can be DEBUG / INFO / WARNING / ERROR / CRITICAL
custom_config
¶
In order to perform more configuration (about directories, etc.) and permanently
change the default value (you don’t have to add flags to the command every time),
you can modify
custom_config.yml
. The meaning of each option is in
page
custom_config
.
You can also use different
custom_config.yml
for different directories, such as
following the directory structure:
manim/
├── manimlib/
│   ├── animation/
│   ├── ...
│   ├── default_config.yml
│   └── window.py
├── project/
│   ├── code.py
│   └── custom_config.yml
└── custom_config.yml
When you enter the
project/
folder and run
manimgl
code.py
<Scene>
,
it will overwrite
manim/default_config.yml
with
custom_config.yml
in the
project
folder.
Alternatively, you can use
--config_file
flag in CLI to specify configuration file manually.
manimgl
project/code.py
--config_file
/path/to/custom_config.yml
Contents
CLI flags and configuration
Command Line Interface
Some useful flags
All supported flags
custom_config

Code Examples:
Example 1:
```python
manimgl <code>.py <Scene> <flags>
# or
manim-render <code>.py <Scene> <flags>
```
Example 2:
```python
-n <number>
```
Example 3:
```python
--write_file
```
Example 4:
```python
--skip_animations
```
Example 5:
```python
--low_quality
```
Example 6:
```python
--medium_quality
```
Example 7:
```python
--full_screen
```
Example 8:
```python
--presenter_mode
```
Example 9:
```python
--save_pngs
```
Example 10:
```python
--transparent
```
Example 11:
```python
--write_all
```
Example 12:
```python
--file_name FILE_NAME
```
Example 13:
```python
--start_at_animation_number START_AT_ANIMATION_NUMBER
```
Example 14:
```python
--embed [EMBED]
```
Example 15:
```python
--resolution RESOLUTION
```
Example 16:
```python
--color COLOR
```
Example 17:
```python
--leave_progress_bars
```
Example 18:
```python
--video_dir VIDEO_DIR
```
Example 19:
```python
--config_file CONFIG_FILE
```
Example 20:
```python
--log-level LOG_LEVEL
```
Example 21:
```python
custom_config.yml
```
Example 22:
```python
custom_config.yml
```
Example 23:
```python
manim/
├── manimlib/
│   ├── animation/
│   ├── ...
│   ├── default_config.yml
│   └── window.py
├── project/
│   ├── code.py
│   └── custom_config.yml
└── custom_config.yml
```
Example 24:
```python
manimgl code.py <Scene>
```
Example 25:
```python
manim/default_config.yml
```
Example 26:
```python
custom_config.yml
```
Example 27:
```python
--config_file
```
Example 28:
```python
manimgl project/code.py --config_file /path/to/custom_config.yml
```

================================================================================

=== Example Scenes - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/example_scenes.html
Content:
Example Scenes
¶
After understanding the previous knowledge, we can understand more scenes.
Many example scenes are given in
example_scenes.py
, let’s start with
the simplest and one by one.
InteractiveDevlopment
¶
InteractiveDevelopment
¶
from
manimlib
import
*
class
InteractiveDevelopment
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
square
=
Square
()
self
.
play
(
ShowCreation
(
square
))
self
.
wait
()
# This opens an iPython terminal where you can keep writing
# lines as if they were part of this construct method.
# In particular, 'square', 'circle' and 'self' will all be
# part of the local namespace in that terminal.
self
.
embed
()
# Try copying and pasting some of the lines below into
# the interactive shell
self
.
play
(
ReplacementTransform
(
square
,
circle
))
self
.
wait
()
self
.
play
(
circle
.
animate
.
stretch
(
4
,
0
))
self
.
play
(
Rotate
(
circle
,
90
*
DEGREES
))
self
.
play
(
circle
.
animate
.
shift
(
2
*
RIGHT
)
.
scale
(
0.25
))
text
=
Text
(
"""
In general, using the interactive shell
is very helpful when developing new scenes
"""
)
self
.
play
(
Write
(
text
))
# In the interactive shell, you can just type
# play, add, remove, clear, wait, save_state and restore,
# instead of self.play, self.add, self.remove, etc.
# To interact with the window, type touch().  You can then
# scroll in the window, or zoom by holding down 'z' while scrolling,
# and change camera perspective by holding down 'd' while moving
# the mouse.  Press 'r' to reset to the standard camera position.
# Press 'q' to stop interacting with the window and go back to
# typing new commands into the shell.
# In principle you can customize a scene to be responsive to
# mouse and keyboard interactions
always
(
circle
.
move_to
,
self
.
mouse_point
)
This scene is similar to what we wrote in
Quick Start
.
And how to interact has been written in the comments.
No more explanation here.
AnimatingMethods
¶
AnimatingMethods
¶
class
AnimatingMethods
(
Scene
):
def
construct
(
self
):
grid
=
OldTex
(
r
"\pi"
)
.
get_grid
(
10
,
10
,
height
=
4
)
self
.
add
(
grid
)
# You can animate the application of mobject methods with the
# ".animate" syntax:
self
.
play
(
grid
.
animate
.
shift
(
LEFT
))
# Alternatively, you can use the older syntax by passing the
# method and then the arguments to the scene's "play" function:
self
.
play
(
grid
.
shift
,
LEFT
)
# Both of those will interpolate between the mobject's initial
# state and whatever happens when you apply that method.
# For this example, calling grid.shift(LEFT) would shift the
# grid one unit to the left, but both of the previous calls to
# "self.play" animate that motion.
# The same applies for any method, including those setting colors.
self
.
play
(
grid
.
animate
.
set_color
(
YELLOW
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_submobject_colors_by_gradient
(
BLUE
,
GREEN
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_height
(
TAU
-
MED_SMALL_BUFF
))
self
.
wait
()
# The method Mobject.apply_complex_function lets you apply arbitrary
# complex functions, treating the points defining the mobject as
# complex numbers.
self
.
play
(
grid
.
animate
.
apply_complex_function
(
np
.
exp
),
run_time
=
5
)
self
.
wait
()
# Even more generally, you could apply Mobject.apply_function,
# which takes in functions form R^3 to R^3
self
.
play
(
grid
.
animate
.
apply_function
(
lambda
p
:
[
p
[
0
]
+
0.5
*
math
.
sin
(
p
[
1
]),
p
[
1
]
+
0.5
*
math
.
sin
(
p
[
0
]),
p
[
2
]
]
),
run_time
=
5
,
)
self
.
wait
()
The new usage in this scene is
.get_grid()
and
self.play(mob.animate.method(args))
.
.get_grid()
method will return a new mobject containing multiple copies of this one arranged in a grid.
self.play(mob.animate.method(args))
animates the method, and the details are in the comments above.
TextExample
¶
TextExample
¶
class
TextExample
(
Scene
):
def
construct
(
self
):
# To run this scene properly, you should have "Consolas" font in your computer
# for full usage, you can see https://github.com/3b1b/manim/pull/680
text
=
Text
(
"Here is a text"
,
font
=
"Consolas"
,
font_size
=
90
)
difference
=
Text
(
"""
The most important difference between Text and TexText is that\n
you can change the font more easily, but can't use the LaTeX grammar
"""
,
font
=
"Arial"
,
font_size
=
24
,
# t2c is a dict that you can choose color for different text
t2c
=
{
"Text"
:
BLUE
,
"TexText"
:
BLUE
,
"LaTeX"
:
ORANGE
}
)
VGroup
(
text
,
difference
)
.
arrange
(
DOWN
,
buff
=
1
)
self
.
play
(
Write
(
text
))
self
.
play
(
FadeIn
(
difference
,
UP
))
self
.
wait
(
3
)
fonts
=
Text
(
"And you can also set the font according to different words"
,
font
=
"Arial"
,
t2f
=
{
"font"
:
"Consolas"
,
"words"
:
"Consolas"
},
t2c
=
{
"font"
:
BLUE
,
"words"
:
GREEN
}
)
fonts
.
set_width
(
FRAME_WIDTH
-
1
)
slant
=
Text
(
"And the same as slant and weight"
,
font
=
"Consolas"
,
t2s
=
{
"slant"
:
ITALIC
},
t2w
=
{
"weight"
:
BOLD
},
t2c
=
{
"slant"
:
ORANGE
,
"weight"
:
RED
}
)
VGroup
(
fonts
,
slant
)
.
arrange
(
DOWN
,
buff
=
0.8
)
self
.
play
(
FadeOut
(
text
),
FadeOut
(
difference
,
shift
=
DOWN
))
self
.
play
(
Write
(
fonts
))
self
.
wait
()
self
.
play
(
Write
(
slant
))
self
.
wait
()
The new classes in this scene are
Text
,
VGroup
,
Write
,
FadeIn
and
FadeOut
.
Text
can create text, define fonts, etc. The usage ais clearly reflected in the above examples.
VGroup
can put multiple
VMobject
together as a whole. In the example, the
.arrange()
method is called to arrange the sub-mobjects in sequence downward (
DOWN
), and the spacing is
buff
.
Write
is an animation that shows similar writing effects.
FadeIn
fades the object in, the second parameter indicates the direction of the fade in.
FadeOut
fades out the object, the second parameter indicates the direction of the fade out.
TexTransformExample
¶
TexTransformExample
¶
class
TexTransformExample
(
Scene
):
def
construct
(
self
):
to_isolate
=
[
"B"
,
"C"
,
"="
,
"("
,
")"
]
lines
=
VGroup
(
# Passing in muliple arguments to Tex will result
# in the same expression as if those arguments had
# been joined together, except that the submobject
# hierarchy of the resulting mobject ensure that the
# Tex mobject has a subject corresponding to
# each of these strings.  For example, the Tex mobject
# below will have 5 subjects, corresponding to the
# expressions [A^2, +, B^2, =, C^2]
OldTex
(
"A^2"
,
"+"
,
"B^2"
,
"="
,
"C^2"
),
# Likewise here
OldTex
(
"A^2"
,
"="
,
"C^2"
,
"-"
,
"B^2"
),
# Alternatively, you can pass in the keyword argument
# "isolate" with a list of strings that should be out as
# their own submobject.  So the line below is equivalent
# to the commented out line below it.
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A^2"
,
*
to_isolate
]),
# OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
OldTex
(
"A =
\\
sqrt{(C + B)(C - B)}"
,
isolate
=
[
"A"
,
*
to_isolate
])
)
lines
.
arrange
(
DOWN
,
buff
=
LARGE_BUFF
)
for
line
in
lines
:
line
.
set_color_by_tex_to_color_map
({
"A"
:
BLUE
,
"B"
:
TEAL
,
"C"
:
GREEN
,
})
play_kw
=
{
"run_time"
:
2
}
self
.
add
(
lines
[
0
])
# The animation TransformMatchingTex will line up parts
# of the source and target which have matching tex strings.
# Here, giving it a little path_arc makes each part sort of
# rotate into their final positions, which feels appropriate
# for the idea of rearranging an equation
self
.
play
(
TransformMatchingTex
(
lines
[
0
]
.
copy
(),
lines
[
1
],
path_arc
=
90
*
DEGREES
,
),
**
play_kw
)
self
.
wait
()
# Now, we could try this again on the next line...
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
]),
**
play_kw
)
self
.
wait
()
# ...and this looks nice enough, but since there's no tex
# in lines[2] which matches "C^2" or "B^2", those terms fade
# out to nothing while the C and B terms fade in from nothing.
# If, however, we want the C^2 to go to C, and B^2 to go to B,
# we can specify that with a key map.
self
.
play
(
FadeOut
(
lines
[
2
]))
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
],
key_map
=
{
"C^2"
:
"C"
,
"B^2"
:
"B"
,
}
),
**
play_kw
)
self
.
wait
()
# And to finish off, a simple TransformMatchingShapes would work
# just fine.  But perhaps we want that exponent on A^2 to transform into
# the square root symbol.  At the moment, lines[2] treats the expression
# A^2 as a unit, so we might create a new version of the same line which
# separates out just the A.  This way, when TransformMatchingTex lines up
# all matching parts, the only mismatch will be between the "^2" from
# new_line2 and the "\sqrt" from the final line.  By passing in,
# transform_mismatches=True, it will transform this "^2" part into
# the "\sqrt" part.
new_line2
=
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A"
,
*
to_isolate
])
new_line2
.
replace
(
lines
[
2
])
new_line2
.
match_style
(
lines
[
2
])
self
.
play
(
TransformMatchingTex
(
new_line2
,
lines
[
3
],
transform_mismatches
=
True
,
),
**
play_kw
)
self
.
wait
(
3
)
self
.
play
(
FadeOut
(
lines
,
RIGHT
))
# Alternatively, if you don't want to think about breaking up
# the tex strings deliberately, you can TransformMatchingShapes,
# which will try to line up all pieces of a source mobject with
# those of a target, regardless of the submobject hierarchy in
# each one, according to whether those pieces have the same
# shape (as best it can).
source
=
Text
(
"the morse code"
,
height
=
1
)
target
=
Text
(
"here come dots"
,
height
=
1
)
self
.
play
(
Write
(
source
))
self
.
wait
()
kw
=
{
"run_time"
:
3
,
"path_arc"
:
PI
/
2
}
self
.
play
(
TransformMatchingShapes
(
source
,
target
,
**
kw
))
self
.
wait
()
self
.
play
(
TransformMatchingShapes
(
target
,
source
,
**
kw
))
self
.
wait
()
The new classes in this scene are
Tex
,
TexText
,
TransformMatchingTex
and
TransformMatchingShapes
.
Tex
uses LaTeX to create mathematical formulas.
TexText
uses LaTeX to create text.
TransformMatchingTeX
automatically transforms sub-objects according to the similarities and differences of tex in
Tex
.
TransformMatchingShapes
automatically transform sub-objects directly based on the similarities and differences of the object point sets.
UpdatersExample
¶
UpdatersExample
¶
class
UpdatersExample
(
Scene
):
def
construct
(
self
):
square
=
Square
()
square
.
set_fill
(
BLUE_E
,
1
)
# On all all frames, the constructor Brace(square, UP) will
# be called, and the mobject brace will set its data to match
# that of the newly constructed object
brace
=
always_redraw
(
Brace
,
square
,
UP
)
text
,
number
=
label
=
VGroup
(
Text
(
"Width = "
),
DecimalNumber
(
0
,
show_ellipsis
=
True
,
num_decimal_places
=
2
,
include_sign
=
True
,
)
)
label
.
arrange
(
RIGHT
)
# This ensures that the method deicmal.next_to(square)
# is called on every frame
always
(
label
.
next_to
,
brace
,
UP
)
# You could also write the following equivalent line
# label.add_updater(lambda m: m.next_to(brace, UP))
# If the argument itself might change, you can use f_always,
# for which the arguments following the initial Mobject method
# should be functions returning arguments to that method.
# The following line ensures that decimal.set_value(square.get_y())
# is called every frame
f_always
(
number
.
set_value
,
square
.
get_width
)
# You could also write the following equivalent line
# number.add_updater(lambda m: m.set_value(square.get_width()))
self
.
add
(
square
,
brace
,
label
)
# Notice that the brace and label track with the square
self
.
play
(
square
.
animate
.
scale
(
2
),
rate_func
=
there_and_back
,
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
5
,
stretch
=
True
),
run_time
=
3
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
2
),
run_time
=
3
)
self
.
wait
()
# In general, you can alway call Mobject.add_updater, and pass in
# a function that you want to be called on every frame.  The function
# should take in either one argument, the mobject, or two arguments,
# the mobject and the amount of time since the last frame.
now
=
self
.
time
w0
=
square
.
get_width
()
square
.
add_updater
(
lambda
m
:
m
.
set_width
(
w0
*
math
.
cos
(
self
.
time
-
now
))
)
self
.
wait
(
4
*
PI
)
The new classes and usage in this scene are
always_redraw()
,
DecimalNumber
,
.to_edge()
,
.center()
,
always()
,
f_always()
,
.set_y()
and
.add_updater()
.
always_redraw()
function create a new mobject every frame.
DecimalNumber
is a variable number, speed it up by breaking it into
Text
characters.
.to_edge()
means to place the object on the edge of the screen.
.center()
means to place the object in the center of the screen.
always(f,
x)
means that a certain function (
f(x)
) is executed every frame.
f_always(f,
g)
is similar to
always
, executed
f(g())
every frame.
.set_y()
means to set the ordinate of the object on the screen.
.add_updater()
sets an update function for the object. For example:
mob1.add_updater(lambda
mob:
mob.next_to(mob2))
means
mob1.next_to(mob2)
is executed every frame.
CoordinateSystemExample
¶
CoordinateSystemExample
¶
class
CoordinateSystemExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
(
# x-axis ranges from -1 to 10, with a default step size of 1
x_range
=
(
-
1
,
10
),
# y-axis ranges from -2 to 2 with a step size of 0.5
y_range
=
(
-
2
,
2
,
0.5
),
# The axes will be stretched so as to match the specified
# height and width
height
=
6
,
width
=
10
,
# Axes is made of two NumberLine mobjects.  You can specify
# their configuration with axis_config
axis_config
=
{
"stroke_color"
:
GREY_A
,
"stroke_width"
:
2
,
},
# Alternatively, you can specify configuration for just one
# of them, like this.
y_axis_config
=
{
"include_tip"
:
False
,
}
)
# Keyword arguments of add_coordinate_labels can be used to
# configure the DecimalNumber mobjects which it creates and
# adds to the axes
axes
.
add_coordinate_labels
(
font_size
=
20
,
num_decimal_places
=
1
,
)
self
.
add
(
axes
)
# Axes descends from the CoordinateSystem class, meaning
# you can call call axes.coords_to_point, abbreviated to
# axes.c2p, to associate a set of coordinates with a point,
# like so:
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
c2p
(
0
,
0
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
5
,
0.5
)))
self
.
wait
()
# Similarly, you can call axes.point_to_coords, or axes.p2c
# print(axes.p2c(dot.get_center()))
# We can draw lines from the axes to better mark the coordinates
# of a given point.
# Here, the always_redraw command means that on each new frame
# the lines will be redrawn
h_line
=
always_redraw
(
lambda
:
axes
.
get_h_line
(
dot
.
get_left
()))
v_line
=
always_redraw
(
lambda
:
axes
.
get_v_line
(
dot
.
get_bottom
()))
self
.
play
(
ShowCreation
(
h_line
),
ShowCreation
(
v_line
),
)
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
-
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
1
,
1
)))
self
.
wait
()
# If we tie the dot to a particular set of coordinates, notice
# that as we move the axes around it respects the coordinate
# system defined by them.
f_always
(
dot
.
move_to
,
lambda
:
axes
.
c2p
(
1
,
1
))
self
.
play
(
axes
.
animate
.
scale
(
0.75
)
.
to_corner
(
UL
),
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
FadeOut
(
VGroup
(
axes
,
dot
,
h_line
,
v_line
)))
# Other coordinate systems you can play around with include
# ThreeDAxes, NumberPlane, and ComplexPlane.
GraphExample
¶
GraphExample
¶
class
GraphExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
((
-
3
,
10
),
(
-
1
,
8
))
axes
.
add_coordinate_labels
()
self
.
play
(
Write
(
axes
,
lag_ratio
=
0.01
,
run_time
=
1
))
# Axes.get_graph will return the graph of a function
sin_graph
=
axes
.
get_graph
(
lambda
x
:
2
*
math
.
sin
(
x
),
color
=
BLUE
,
)
# By default, it draws it so as to somewhat smoothly interpolate
# between sampled points (x, f(x)).  If the graph is meant to have
# a corner, though, you can set use_smoothing to False
relu_graph
=
axes
.
get_graph
(
lambda
x
:
max
(
x
,
0
),
use_smoothing
=
False
,
color
=
YELLOW
,
)
# For discontinuous functions, you can specify the point of
# discontinuity so that it does not try to draw over the gap.
step_graph
=
axes
.
get_graph
(
lambda
x
:
2.0
if
x
>
3
else
1.0
,
discontinuities
=
[
3
],
color
=
GREEN
,
)
# Axes.get_graph_label takes in either a string or a mobject.
# If it's a string, it treats it as a LaTeX expression.  By default
# it places the label next to the graph near the right side, and
# has it match the color of the graph
sin_label
=
axes
.
get_graph_label
(
sin_graph
,
"
\\
sin(x)"
)
relu_label
=
axes
.
get_graph_label
(
relu_graph
,
Text
(
"ReLU"
))
step_label
=
axes
.
get_graph_label
(
step_graph
,
Text
(
"Step"
),
x
=
4
)
self
.
play
(
ShowCreation
(
sin_graph
),
FadeIn
(
sin_label
,
RIGHT
),
)
self
.
wait
(
2
)
self
.
play
(
ReplacementTransform
(
sin_graph
,
relu_graph
),
FadeTransform
(
sin_label
,
relu_label
),
)
self
.
wait
()
self
.
play
(
ReplacementTransform
(
relu_graph
,
step_graph
),
FadeTransform
(
relu_label
,
step_label
),
)
self
.
wait
()
parabola
=
axes
.
get_graph
(
lambda
x
:
0.25
*
x
**
2
)
parabola
.
set_stroke
(
BLUE
)
self
.
play
(
FadeOut
(
step_graph
),
FadeOut
(
step_label
),
ShowCreation
(
parabola
)
)
self
.
wait
()
# You can use axes.input_to_graph_point, abbreviated
# to axes.i2gp, to find a particular point on a graph
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
i2gp
(
2
,
parabola
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
# A value tracker lets us animate a parameter, usually
# with the intent of having other mobjects update based
# on the parameter
x_tracker
=
ValueTracker
(
2
)
f_always
(
dot
.
move_to
,
lambda
:
axes
.
i2gp
(
x_tracker
.
get_value
(),
parabola
)
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
4
),
run_time
=
3
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
-
2
),
run_time
=
3
)
self
.
wait
()
SurfaceExample
¶
SurfaceExample
¶
class
SurfaceExample
(
Scene
):
CONFIG
=
{
"camera_class"
:
ThreeDCamera
,
}
def
construct
(
self
):
surface_text
=
Text
(
"For 3d scenes, try using surfaces"
)
surface_text
.
fix_in_frame
()
surface_text
.
to_edge
(
UP
)
self
.
add
(
surface_text
)
self
.
wait
(
0.1
)
torus1
=
Torus
(
r1
=
1
,
r2
=
1
)
torus2
=
Torus
(
r1
=
3
,
r2
=
1
)
sphere
=
Sphere
(
radius
=
3
,
resolution
=
torus1
.
resolution
)
# You can texture a surface with up to two images, which will
# be interpreted as the side towards the light, and away from
# the light.  These can be either urls, or paths to a local file
# in whatever you've set as the image directory in
# the custom_config.yml file
# day_texture = "EarthTextureMap"
# night_texture = "NightEarthTextureMap"
day_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
night_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"
surfaces
=
[
TexturedSurface
(
surface
,
day_texture
,
night_texture
)
for
surface
in
[
sphere
,
torus1
,
torus2
]
]
for
mob
in
surfaces
:
mob
.
shift
(
IN
)
mob
.
mesh
=
SurfaceMesh
(
mob
)
mob
.
mesh
.
set_stroke
(
BLUE
,
1
,
opacity
=
0.5
)
# Set perspective
frame
=
self
.
camera
.
frame
frame
.
set_euler_angles
(
theta
=-
30
*
DEGREES
,
phi
=
70
*
DEGREES
,
)
surface
=
surfaces
[
0
]
self
.
play
(
FadeIn
(
surface
),
ShowCreation
(
surface
.
mesh
,
lag_ratio
=
0.01
,
run_time
=
3
),
)
for
mob
in
surfaces
:
mob
.
add
(
mob
.
mesh
)
surface
.
save_state
()
self
.
play
(
Rotate
(
surface
,
PI
/
2
),
run_time
=
2
)
for
mob
in
surfaces
[
1
:]:
mob
.
rotate
(
PI
/
2
)
self
.
play
(
Transform
(
surface
,
surfaces
[
1
]),
run_time
=
3
)
self
.
play
(
Transform
(
surface
,
surfaces
[
2
]),
# Move camera frame during the transition
frame
.
animate
.
increment_phi
(
-
10
*
DEGREES
),
frame
.
animate
.
increment_theta
(
-
20
*
DEGREES
),
run_time
=
3
)
# Add ambient rotation
frame
.
add_updater
(
lambda
m
,
dt
:
m
.
increment_theta
(
-
0.1
*
dt
))
# Play around with where the light is
light_text
=
Text
(
"You can move around the light source"
)
light_text
.
move_to
(
surface_text
)
light_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
surface_text
,
light_text
))
light
=
self
.
camera
.
light_source
self
.
add
(
light
)
light
.
save_state
()
self
.
play
(
light
.
animate
.
move_to
(
3
*
IN
),
run_time
=
5
)
self
.
play
(
light
.
animate
.
shift
(
10
*
OUT
),
run_time
=
5
)
drag_text
=
Text
(
"Try moving the mouse while pressing d or s"
)
drag_text
.
move_to
(
light_text
)
drag_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
light_text
,
drag_text
))
self
.
wait
()
This scene shows an example of using a three-dimensional surface, and
the related usage has been briefly described in the notes.
.fix_in_frame()
makes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.
OpeningManimExample
¶
OpeningManimExample
¶
class
OpeningManimExample
(
Scene
):
def
construct
(
self
):
intro_words
=
Text
(
"""
The original motivation for manim was to
better illustrate mathematical functions
as transformations.
"""
)
intro_words
.
to_edge
(
UP
)
self
.
play
(
Write
(
intro_words
))
self
.
wait
(
2
)
# Linear transform
grid
=
NumberPlane
((
-
10
,
10
),
(
-
5
,
5
))
matrix
=
[[
1
,
1
],
[
0
,
1
]]
linear_transform_words
=
VGroup
(
Text
(
"This is what the matrix"
),
IntegerMatrix
(
matrix
,
include_background_rectangle
=
True
),
Text
(
"looks like"
)
)
linear_transform_words
.
arrange
(
RIGHT
)
linear_transform_words
.
to_edge
(
UP
)
linear_transform_words
.
set_stroke
(
BLACK
,
10
,
background
=
True
)
self
.
play
(
ShowCreation
(
grid
),
FadeTransform
(
intro_words
,
linear_transform_words
)
)
self
.
wait
()
self
.
play
(
grid
.
animate
.
apply_matrix
(
matrix
),
run_time
=
3
)
self
.
wait
()
# Complex map
c_grid
=
ComplexPlane
()
moving_c_grid
=
c_grid
.
copy
()
moving_c_grid
.
prepare_for_nonlinear_transform
()
c_grid
.
set_stroke
(
BLUE_E
,
1
)
c_grid
.
add_coordinate_labels
(
font_size
=
24
)
complex_map_words
=
TexText
(
"""
Or thinking of the plane as $
\\
mathds
{C}
$,
\\\\
this is the map $z
\\
rightarrow z^2$
"""
)
complex_map_words
.
to_corner
(
UR
)
complex_map_words
.
set_stroke
(
BLACK
,
5
,
background
=
True
)
self
.
play
(
FadeOut
(
grid
),
Write
(
c_grid
,
run_time
=
3
),
FadeIn
(
moving_c_grid
),
FadeTransform
(
linear_transform_words
,
complex_map_words
),
)
self
.
wait
()
self
.
play
(
moving_c_grid
.
animate
.
apply_complex_function
(
lambda
z
:
z
**
2
),
run_time
=
6
,
)
self
.
wait
(
2
)
This scene is a comprehensive application of a two-dimensional scene.
After seeing these scenes, you have already understood part of the
usage of manim. For more examples, see
the video code of 3b1b
.
Contents
Example Scenes
InteractiveDevlopment
AnimatingMethods
TextExample
TexTransformExample
UpdatersExample
CoordinateSystemExample
GraphExample
SurfaceExample
OpeningManimExample

Code Examples:
Example 1:
```python
example_scenes.py
```
Example 2:
```python
from manimlib import *

class InteractiveDevelopment(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)
        square = Square()

        self.play(ShowCreation(square))
        self.wait()

        # This opens an iPython terminal where you can keep writing
        # lines as if they were part of this construct method.
        # In particular, 'square', 'circle' and 'self' will all be
        # part of the local namespace in that terminal.
        self.embed()

        # Try copying and pasting some of the lines below into
        # the interactive shell
        self.play(ReplacementTransform(square, circle))
        self.wait()
        self.play(circle.animate.stretch(4, 0))
        self.play(Rotate(circle, 90 * DEGREES))
        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))

        text = Text("""
            In general, using the interactive shell
            is very helpful when developing new scenes
        """)
        self.play(Write(text))

        # In the interactive shell, you can just type
        # play, add, remove, clear, wait, save_state and restore,
        # instead of self.play, self.add, self.remove, etc.

        # To interact with the window, type touch().  You can then
        # scroll in the window, or zoom by holding down 'z' while scrolling,
        # and change camera perspective by holding down 'd' while moving
        # the mouse.  Press 'r' to reset to the standard camera position.
        # Press 'q' to stop interacting with the window and go back to
        # typing new commands into the shell.

        # In principle you can customize a scene to be responsive to
        # mouse and keyboard interactions
        always(circle.move_to, self.mouse_point)
```
Example 3:
```python
class AnimatingMethods(Scene):
    def construct(self):
        grid = OldTex(r"\pi").get_grid(10, 10, height=4)
        self.add(grid)

        # You can animate the application of mobject methods with the
        # ".animate" syntax:
        self.play(grid.animate.shift(LEFT))

        # Alternatively, you can use the older syntax by passing the
        # method and then the arguments to the scene's "play" function:
        self.play(grid.shift, LEFT)

        # Both of those will interpolate between the mobject's initial
        # state and whatever happens when you apply that method.
        # For this example, calling grid.shift(LEFT) would shift the
        # grid one unit to the left, but both of the previous calls to
        # "self.play" animate that motion.

        # The same applies for any method, including those setting colors.
        self.play(grid.animate.set_color(YELLOW))
        self.wait()
        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))
        self.wait()
        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))
        self.wait()

        # The method Mobject.apply_complex_function lets you apply arbitrary
        # complex functions, treating the points defining the mobject as
        # complex numbers.
        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)
        self.wait()

        # Even more generally, you could apply Mobject.apply_function,
        # which takes in functions form R^3 to R^3
        self.play(
            grid.animate.apply_function(
                lambda p: [
                    p[0] + 0.5 * math.sin(p[1]),
                    p[1] + 0.5 * math.sin(p[0]),
                    p[2]
                ]
            ),
            run_time=5,
        )
        self.wait()
```
Example 4:
```python
.get_grid()
```
Example 5:
```python
self.play(mob.animate.method(args))
```
Example 6:
```python
.get_grid()
```
Example 7:
```python
self.play(mob.animate.method(args))
```
Example 8:
```python
class TextExample(Scene):
    def construct(self):
        # To run this scene properly, you should have "Consolas" font in your computer
        # for full usage, you can see https://github.com/3b1b/manim/pull/680
        text = Text("Here is a text", font="Consolas", font_size=90)
        difference = Text(
            """
            The most important difference between Text and TexText is that\n
            you can change the font more easily, but can't use the LaTeX grammar
            """,
            font="Arial", font_size=24,
            # t2c is a dict that you can choose color for different text
            t2c={"Text": BLUE, "TexText": BLUE, "LaTeX": ORANGE}
        )
        VGroup(text, difference).arrange(DOWN, buff=1)
        self.play(Write(text))
        self.play(FadeIn(difference, UP))
        self.wait(3)

        fonts = Text(
            "And you can also set the font according to different words",
            font="Arial",
            t2f={"font": "Consolas", "words": "Consolas"},
            t2c={"font": BLUE, "words": GREEN}
        )
        fonts.set_width(FRAME_WIDTH - 1)
        slant = Text(
            "And the same as slant and weight",
            font="Consolas",
            t2s={"slant": ITALIC},
            t2w={"weight": BOLD},
            t2c={"slant": ORANGE, "weight": RED}
        )
        VGroup(fonts, slant).arrange(DOWN, buff=0.8)
        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))
        self.play(Write(fonts))
        self.wait()
        self.play(Write(slant))
        self.wait()
```
Example 9:
```python
class TexTransformExample(Scene):
    def construct(self):
        to_isolate = ["B", "C", "=", "(", ")"]
        lines = VGroup(
            # Passing in muliple arguments to Tex will result
            # in the same expression as if those arguments had
            # been joined together, except that the submobject
            # hierarchy of the resulting mobject ensure that the
            # Tex mobject has a subject corresponding to
            # each of these strings.  For example, the Tex mobject
            # below will have 5 subjects, corresponding to the
            # expressions [A^2, +, B^2, =, C^2]
            OldTex("A^2", "+", "B^2", "=", "C^2"),
            # Likewise here
            OldTex("A^2", "=", "C^2", "-", "B^2"),
            # Alternatively, you can pass in the keyword argument
            # "isolate" with a list of strings that should be out as
            # their own submobject.  So the line below is equivalent
            # to the commented out line below it.
            OldTex("A^2 = (C + B)(C - B)", isolate=["A^2", *to_isolate]),
            # OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
            OldTex("A = \\sqrt{(C + B)(C - B)}", isolate=["A", *to_isolate])
        )
        lines.arrange(DOWN, buff=LARGE_BUFF)
        for line in lines:
            line.set_color_by_tex_to_color_map({
                "A": BLUE,
                "B": TEAL,
                "C": GREEN,
            })

        play_kw = {"run_time": 2}
        self.add(lines[0])
        # The animation TransformMatchingTex will line up parts
        # of the source and target which have matching tex strings.
        # Here, giving it a little path_arc makes each part sort of
        # rotate into their final positions, which feels appropriate
        # for the idea of rearranging an equation
        self.play(
            TransformMatchingTex(
                lines[0].copy(), lines[1],
                path_arc=90 * DEGREES,
            ),
            **play_kw
        )
        self.wait()

        # Now, we could try this again on the next line...
        self.play(
            TransformMatchingTex(lines[1].copy(), lines[2]),
            **play_kw
        )
        self.wait()
        # ...and this looks nice enough, but since there's no tex
        # in lines[2] which matches "C^2" or "B^2", those terms fade
        # out to nothing while the C and B terms fade in from nothing.
        # If, however, we want the C^2 to go to C, and B^2 to go to B,
        # we can specify that with a key map.
        self.play(FadeOut(lines[2]))
        self.play(
            TransformMatchingTex(
                lines[1].copy(), lines[2],
                key_map={
                    "C^2": "C",
                    "B^2": "B",
                }
            ),
            **play_kw
        )
        self.wait()

        # And to finish off, a simple TransformMatchingShapes would work
        # just fine.  But perhaps we want that exponent on A^2 to transform into
        # the square root symbol.  At the moment, lines[2] treats the expression
        # A^2 as a unit, so we might create a new version of the same line which
        # separates out just the A.  This way, when TransformMatchingTex lines up
        # all matching parts, the only mismatch will be between the "^2" from
        # new_line2 and the "\sqrt" from the final line.  By passing in,
        # transform_mismatches=True, it will transform this "^2" part into
        # the "\sqrt" part.
        new_line2 = OldTex("A^2 = (C + B)(C - B)", isolate=["A", *to_isolate])
        new_line2.replace(lines[2])
        new_line2.match_style(lines[2])

        self.play(
            TransformMatchingTex(
                new_line2, lines[3],
                transform_mismatches=True,
            ),
            **play_kw
        )
        self.wait(3)
        self.play(FadeOut(lines, RIGHT))

        # Alternatively, if you don't want to think about breaking up
        # the tex strings deliberately, you can TransformMatchingShapes,
        # which will try to line up all pieces of a source mobject with
        # those of a target, regardless of the submobject hierarchy in
        # each one, according to whether those pieces have the same
        # shape (as best it can).
        source = Text("the morse code", height=1)
        target = Text("here come dots", height=1)

        self.play(Write(source))
        self.wait()
        kw = {"run_time": 3, "path_arc": PI / 2}
        self.play(TransformMatchingShapes(source, target, **kw))
        self.wait()
        self.play(TransformMatchingShapes(target, source, **kw))
        self.wait()
```
Example 10:
```python
TransformMatchingTex
```
Example 11:
```python
TransformMatchingShapes
```
Example 12:
```python
TransformMatchingTeX
```
Example 13:
```python
TransformMatchingShapes
```
Example 14:
```python
class UpdatersExample(Scene):
    def construct(self):
        square = Square()
        square.set_fill(BLUE_E, 1)

        # On all all frames, the constructor Brace(square, UP) will
        # be called, and the mobject brace will set its data to match
        # that of the newly constructed object
        brace = always_redraw(Brace, square, UP)

        text, number = label = VGroup(
            Text("Width = "),
            DecimalNumber(
                0,
                show_ellipsis=True,
                num_decimal_places=2,
                include_sign=True,
            )
        )
        label.arrange(RIGHT)

        # This ensures that the method deicmal.next_to(square)
        # is called on every frame
        always(label.next_to, brace, UP)
        # You could also write the following equivalent line
        # label.add_updater(lambda m: m.next_to(brace, UP))

        # If the argument itself might change, you can use f_always,
        # for which the arguments following the initial Mobject method
        # should be functions returning arguments to that method.
        # The following line ensures that decimal.set_value(square.get_y())
        # is called every frame
        f_always(number.set_value, square.get_width)
        # You could also write the following equivalent line
        # number.add_updater(lambda m: m.set_value(square.get_width()))

        self.add(square, brace, label)

        # Notice that the brace and label track with the square
        self.play(
            square.animate.scale(2),
            rate_func=there_and_back,
            run_time=2,
        )
        self.wait()
        self.play(
            square.animate.set_width(5, stretch=True),
            run_time=3,
        )
        self.wait()
        self.play(
            square.animate.set_width(2),
            run_time=3
        )
        self.wait()

        # In general, you can alway call Mobject.add_updater, and pass in
        # a function that you want to be called on every frame.  The function
        # should take in either one argument, the mobject, or two arguments,
        # the mobject and the amount of time since the last frame.
        now = self.time
        w0 = square.get_width()
        square.add_updater(
            lambda m: m.set_width(w0 * math.cos(self.time - now))
        )
        self.wait(4 * PI)
```
Example 15:
```python
always_redraw()
```
Example 16:
```python
DecimalNumber
```
Example 17:
```python
.add_updater()
```
Example 18:
```python
always_redraw()
```
Example 19:
```python
DecimalNumber
```
Example 20:
```python
always(f, x)
```
Example 21:
```python
f_always(f, g)
```
Example 22:
```python
.add_updater()
```
Example 23:
```python
mob1.add_updater(lambda mob: mob.next_to(mob2))
```
Example 24:
```python
mob1.next_to(mob2)
```
Example 25:
```python
class CoordinateSystemExample(Scene):
    def construct(self):
        axes = Axes(
            # x-axis ranges from -1 to 10, with a default step size of 1
            x_range=(-1, 10),
            # y-axis ranges from -2 to 2 with a step size of 0.5
            y_range=(-2, 2, 0.5),
            # The axes will be stretched so as to match the specified
            # height and width
            height=6,
            width=10,
            # Axes is made of two NumberLine mobjects.  You can specify
            # their configuration with axis_config
            axis_config={
                "stroke_color": GREY_A,
                "stroke_width": 2,
            },
            # Alternatively, you can specify configuration for just one
            # of them, like this.
            y_axis_config={
                "include_tip": False,
            }
        )
        # Keyword arguments of add_coordinate_labels can be used to
        # configure the DecimalNumber mobjects which it creates and
        # adds to the axes
        axes.add_coordinate_labels(
            font_size=20,
            num_decimal_places=1,
        )
        self.add(axes)

        # Axes descends from the CoordinateSystem class, meaning
        # you can call call axes.coords_to_point, abbreviated to
        # axes.c2p, to associate a set of coordinates with a point,
        # like so:
        dot = Dot(color=RED)
        dot.move_to(axes.c2p(0, 0))
        self.play(FadeIn(dot, scale=0.5))
        self.play(dot.animate.move_to(axes.c2p(3, 2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))
        self.wait()

        # Similarly, you can call axes.point_to_coords, or axes.p2c
        # print(axes.p2c(dot.get_center()))

        # We can draw lines from the axes to better mark the coordinates
        # of a given point.
        # Here, the always_redraw command means that on each new frame
        # the lines will be redrawn
        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))
        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))

        self.play(
            ShowCreation(h_line),
            ShowCreation(v_line),
        )
        self.play(dot.animate.move_to(axes.c2p(3, -2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(1, 1)))
        self.wait()

        # If we tie the dot to a particular set of coordinates, notice
        # that as we move the axes around it respects the coordinate
        # system defined by them.
        f_always(dot.move_to, lambda: axes.c2p(1, 1))
        self.play(
            axes.animate.scale(0.75).to_corner(UL),
            run_time=2,
        )
        self.wait()
        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))

        # Other coordinate systems you can play around with include
        # ThreeDAxes, NumberPlane, and ComplexPlane.
```
Example 26:
```python
class GraphExample(Scene):
    def construct(self):
        axes = Axes((-3, 10), (-1, 8))
        axes.add_coordinate_labels()

        self.play(Write(axes, lag_ratio=0.01, run_time=1))

        # Axes.get_graph will return the graph of a function
        sin_graph = axes.get_graph(
            lambda x: 2 * math.sin(x),
            color=BLUE,
        )
        # By default, it draws it so as to somewhat smoothly interpolate
        # between sampled points (x, f(x)).  If the graph is meant to have
        # a corner, though, you can set use_smoothing to False
        relu_graph = axes.get_graph(
            lambda x: max(x, 0),
            use_smoothing=False,
            color=YELLOW,
        )
        # For discontinuous functions, you can specify the point of
        # discontinuity so that it does not try to draw over the gap.
        step_graph = axes.get_graph(
            lambda x: 2.0 if x > 3 else 1.0,
            discontinuities=[3],
            color=GREEN,
        )

        # Axes.get_graph_label takes in either a string or a mobject.
        # If it's a string, it treats it as a LaTeX expression.  By default
        # it places the label next to the graph near the right side, and
        # has it match the color of the graph
        sin_label = axes.get_graph_label(sin_graph, "\\sin(x)")
        relu_label = axes.get_graph_label(relu_graph, Text("ReLU"))
        step_label = axes.get_graph_label(step_graph, Text("Step"), x=4)

        self.play(
            ShowCreation(sin_graph),
            FadeIn(sin_label, RIGHT),
        )
        self.wait(2)
        self.play(
            ReplacementTransform(sin_graph, relu_graph),
            FadeTransform(sin_label, relu_label),
        )
        self.wait()
        self.play(
            ReplacementTransform(relu_graph, step_graph),
            FadeTransform(relu_label, step_label),
        )
        self.wait()

        parabola = axes.get_graph(lambda x: 0.25 * x**2)
        parabola.set_stroke(BLUE)
        self.play(
            FadeOut(step_graph),
            FadeOut(step_label),
            ShowCreation(parabola)
        )
        self.wait()

        # You can use axes.input_to_graph_point, abbreviated
        # to axes.i2gp, to find a particular point on a graph
        dot = Dot(color=RED)
        dot.move_to(axes.i2gp(2, parabola))
        self.play(FadeIn(dot, scale=0.5))

        # A value tracker lets us animate a parameter, usually
        # with the intent of having other mobjects update based
        # on the parameter
        x_tracker = ValueTracker(2)
        f_always(
            dot.move_to,
            lambda: axes.i2gp(x_tracker.get_value(), parabola)
        )

        self.play(x_tracker.animate.set_value(4), run_time=3)
        self.play(x_tracker.animate.set_value(-2), run_time=3)
        self.wait()
```
Example 27:
```python
class SurfaceExample(Scene):
    CONFIG = {
        "camera_class": ThreeDCamera,
    }

    def construct(self):
        surface_text = Text("For 3d scenes, try using surfaces")
        surface_text.fix_in_frame()
        surface_text.to_edge(UP)
        self.add(surface_text)
        self.wait(0.1)

        torus1 = Torus(r1=1, r2=1)
        torus2 = Torus(r1=3, r2=1)
        sphere = Sphere(radius=3, resolution=torus1.resolution)
        # You can texture a surface with up to two images, which will
        # be interpreted as the side towards the light, and away from
        # the light.  These can be either urls, or paths to a local file
        # in whatever you've set as the image directory in
        # the custom_config.yml file

        # day_texture = "EarthTextureMap"
        # night_texture = "NightEarthTextureMap"
        day_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
        night_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"

        surfaces = [
            TexturedSurface(surface, day_texture, night_texture)
            for surface in [sphere, torus1, torus2]
        ]

        for mob in surfaces:
            mob.shift(IN)
            mob.mesh = SurfaceMesh(mob)
            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)

        # Set perspective
        frame = self.camera.frame
        frame.set_euler_angles(
            theta=-30 * DEGREES,
            phi=70 * DEGREES,
        )

        surface = surfaces[0]

        self.play(
            FadeIn(surface),
            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),
        )
        for mob in surfaces:
            mob.add(mob.mesh)
        surface.save_state()
        self.play(Rotate(surface, PI / 2), run_time=2)
        for mob in surfaces[1:]:
            mob.rotate(PI / 2)

        self.play(
            Transform(surface, surfaces[1]),
            run_time=3
        )

        self.play(
            Transform(surface, surfaces[2]),
            # Move camera frame during the transition
            frame.animate.increment_phi(-10 * DEGREES),
            frame.animate.increment_theta(-20 * DEGREES),
            run_time=3
        )
        # Add ambient rotation
        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))

        # Play around with where the light is
        light_text = Text("You can move around the light source")
        light_text.move_to(surface_text)
        light_text.fix_in_frame()

        self.play(FadeTransform(surface_text, light_text))
        light = self.camera.light_source
        self.add(light)
        light.save_state()
        self.play(light.animate.move_to(3 * IN), run_time=5)
        self.play(light.animate.shift(10 * OUT), run_time=5)

        drag_text = Text("Try moving the mouse while pressing d or s")
        drag_text.move_to(light_text)
        drag_text.fix_in_frame()

        self.play(FadeTransform(light_text, drag_text))
        self.wait()
```
Example 28:
```python
.fix_in_frame()
```
Example 29:
```python
class OpeningManimExample(Scene):
    def construct(self):
        intro_words = Text("""
            The original motivation for manim was to
            better illustrate mathematical functions
            as transformations.
        """)
        intro_words.to_edge(UP)

        self.play(Write(intro_words))
        self.wait(2)

        # Linear transform
        grid = NumberPlane((-10, 10), (-5, 5))
        matrix = [[1, 1], [0, 1]]
        linear_transform_words = VGroup(
            Text("This is what the matrix"),
            IntegerMatrix(matrix, include_background_rectangle=True),
            Text("looks like")
        )
        linear_transform_words.arrange(RIGHT)
        linear_transform_words.to_edge(UP)
        linear_transform_words.set_stroke(BLACK, 10, background=True)

        self.play(
            ShowCreation(grid),
            FadeTransform(intro_words, linear_transform_words)
        )
        self.wait()
        self.play(grid.animate.apply_matrix(matrix), run_time=3)
        self.wait()

        # Complex map
        c_grid = ComplexPlane()
        moving_c_grid = c_grid.copy()
        moving_c_grid.prepare_for_nonlinear_transform()
        c_grid.set_stroke(BLUE_E, 1)
        c_grid.add_coordinate_labels(font_size=24)
        complex_map_words = TexText("""
            Or thinking of the plane as $\\mathds{C}$,\\\\
            this is the map $z \\rightarrow z^2$
        """)
        complex_map_words.to_corner(UR)
        complex_map_words.set_stroke(BLACK, 5, background=True)

        self.play(
            FadeOut(grid),
            Write(c_grid, run_time=3),
            FadeIn(moving_c_grid),
            FadeTransform(linear_transform_words, complex_map_words),
        )
        self.wait()
        self.play(
            moving_c_grid.animate.apply_complex_function(lambda z: z**2),
            run_time=6,
        )
        self.wait(2)
```

================================================================================

=== Manim’s structure - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/structure.html
Content:
Manim’s structure
¶
Manim’s directory structure
¶
The manim directory looks very complicated, with a lot of files,
but the structure is clear.
Below is the directory structure of manim:
manimlib/ # manim library
├── __init__.py
├── __main__.py
├── default_config.yml   # Default configuration file
├── config.py            # Process CLI flags
├── constants.py         # Defined some constants
├── extract_scene.py     # Extract and run the scene
├── shader_wrapper.py    # Shaders' Wrapper for convenient control
├── window.py            # Playback window
├── tex_templates/ # Templates preset for LaTeX
│   ├── tex_templates.tex   # Tex template (will be compiled with latex, default)
│   └── ctex_templates.tex  # Tex template that support Chinese (will be compiled with xelatex)
├── camera/
│   └── camera.py        # Including Camera and CameraFrame
├── scene/
│   ├── scene_file_writer.py     # Used to write scene to video file
│   ├── scene.py                 # The basic Scene class
│   ├── three_d_scene.py         # Three-dimensional scene
│   ├── sample_space_scene.py    # Probability related sample space scene
│   └── vector_space_scene.py    # Vector field scene
├── animation/
│   ├── animation.py     # The basic class of animation
│   ├── composition.py   # Animation group
│   ├── creation.py      # Animation related to Create
│   ├── fading.py        # Fade related animation
│   ├── growing.py       # Animation related to Grow
│   ├── indication.py    # Some animations for emphasis
│   ├── movement.py      # Animation related to movement
│   ├── numbers.py       # Realize changes to DecimalNumber
│   ├── rotation.py      # Animation related to rotation
│   ├── specialized.py   # Some uncommon animations for special projects
│   ├── transform_matching_parts.py # Transform which can automatically match parts
│   ├── transform.py     # Some Transforms
│   └── update.py        # Realize update from function
├── mobject/
│   ├── mobject.py       # The basic class of all math object
│   ├── types/ # 4 types of mobject
│   │   ├── dot_cloud.py            # Dot cloud (an subclass of PMobject)
│   │   ├── image_mobject.py        # Insert pictures
│   │   ├── point_cloud_mobject.py  # PMobject (mobject composed of points)
│   │   ├── surface.py              # ParametricSurface
│   │   └── vectorized_mobject.py   # VMobject (vectorized mobject)
│   ├── svg/ # mobject related to svg
│   │   ├── svg_mobject.py          # SVGMobject
│   │   ├── brace.py                # Brace
│   │   ├── drawings.py             # Some special mobject of svg image
│   │   ├── tex_mobject.py          # Tex and TexText implemented by LaTeX
│   │   └── text_mobject.py         # Text implemented by manimpango
│   ├── changing.py             # Dynamically changing mobject
│   ├── coordinate_systems.py   # coordinate system
│   ├── frame.py                # mobject related to frame
│   ├── functions.py            # ParametricFunction
│   ├── geometry.py             # geometry mobjects
│   ├── matrix.py               # matrix
│   ├── mobject_update_utils.py # some defined updater
│   ├── number_line.py          # Number line
│   ├── numbers.py              # Numbers that can be changed
│   ├── probability.py          # mobject related to probability
│   ├── shape_matchers.py       # mobject adapted to the size of other objects
│   ├── three_dimensions.py     # Three-dimensional objects
│   ├── value_tracker.py        # ValueTracker which storage number
│   └── vector_field.py         # VectorField
├── once_useful_constructs/  # 3b1b's Common scenes written for some videos
│   └── ...
├── shaders/ # GLSL scripts for rendering
│   ├── simple_vert.glsl    # a simple glsl script for position
│   ├── insert/ # glsl scripts to be inserted in other glsl scripts
│   │   ├── NOTE.md   # explain how to insert glsl scripts
│   │   └── ...       # useful scripts
│   ├── image/ # glsl for images
│   │   └── ... # containing shaders for vertex and fragment
│   ├── quadratic_bezier_fill/ # glsl for the fill of quadratic bezier curve
│   │   └── ... # containing shaders for vertex, fragment and geometry
│   ├── quadratic_bezier_stroke/ # glsl for the stroke of quadratic bezier curve
│   │   └── ... # containing shaders for vertex, fragment and geometry
│   ├── surface/ # glsl for surfaces
│   │   └── ... # containing shaders for vertex and fragment
│   ├── textured_surface/ # glsl for textured_surface
│   │   └── ... # containing shaders for vertex and fragment
│   └── true_dot/ # glsl for a dot
│       └── ... # containing shaders for vertex, fragment and geometry
└── utils/ # Some useful utility functions
    ├── bezier.py             # For bezier curve
    ├── color.py              # For color
    ├── dict_ops.py           # Functions related to dictionary processing
    ├── customization.py      # Read from custom_config.yml
    ├── debug.py              # Utilities for debugging in program
    ├── directories.py        # Read directories from config file
    ├── family_ops.py         # Process family members
    ├── file_ops.py           # Process files and directories
    ├── images.py             # Read image
    ├── init_config.py        # Configuration guide
    ├── iterables.py          # Functions related to list/dictionary processing
    ├── paths.py              # Curve path
    ├── rate_functions.py     # Some defined rate_functions
    ├── simple_functions.py   # Some commonly used functions
    ├── sounds.py             # Process sounds
    ├── space_ops.py          # Space coordinate calculation
    ├── strings.py            # Process strings
    └── tex_file_writing.py   # Use LaTeX to write strings as svg
Inheritance structure of manim’s classes
¶
Here
is a pdf showed inheritance structure of manim’s classes, large,
but basically all classes have included:
Manim execution process
¶
Contents
Manim’s structure
Manim’s directory structure
Inheritance structure of manim’s classes
Manim execution process

Code Examples:
Example 1:
```python
manimlib/ # manim library
├── __init__.py
├── __main__.py
├── default_config.yml   # Default configuration file
├── config.py            # Process CLI flags
├── constants.py         # Defined some constants
├── extract_scene.py     # Extract and run the scene
├── shader_wrapper.py    # Shaders' Wrapper for convenient control
├── window.py            # Playback window
├── tex_templates/ # Templates preset for LaTeX
│   ├── tex_templates.tex   # Tex template (will be compiled with latex, default)
│   └── ctex_templates.tex  # Tex template that support Chinese (will be compiled with xelatex)
├── camera/
│   └── camera.py        # Including Camera and CameraFrame
├── scene/
│   ├── scene_file_writer.py     # Used to write scene to video file
│   ├── scene.py                 # The basic Scene class
│   ├── three_d_scene.py         # Three-dimensional scene
│   ├── sample_space_scene.py    # Probability related sample space scene
│   └── vector_space_scene.py    # Vector field scene
├── animation/
│   ├── animation.py     # The basic class of animation
│   ├── composition.py   # Animation group
│   ├── creation.py      # Animation related to Create
│   ├── fading.py        # Fade related animation
│   ├── growing.py       # Animation related to Grow
│   ├── indication.py    # Some animations for emphasis
│   ├── movement.py      # Animation related to movement
│   ├── numbers.py       # Realize changes to DecimalNumber
│   ├── rotation.py      # Animation related to rotation
│   ├── specialized.py   # Some uncommon animations for special projects
│   ├── transform_matching_parts.py # Transform which can automatically match parts
│   ├── transform.py     # Some Transforms
│   └── update.py        # Realize update from function
├── mobject/
│   ├── mobject.py       # The basic class of all math object
│   ├── types/ # 4 types of mobject
│   │   ├── dot_cloud.py            # Dot cloud (an subclass of PMobject)
│   │   ├── image_mobject.py        # Insert pictures
│   │   ├── point_cloud_mobject.py  # PMobject (mobject composed of points)
│   │   ├── surface.py              # ParametricSurface
│   │   └── vectorized_mobject.py   # VMobject (vectorized mobject)
│   ├── svg/ # mobject related to svg
│   │   ├── svg_mobject.py          # SVGMobject
│   │   ├── brace.py                # Brace
│   │   ├── drawings.py             # Some special mobject of svg image
│   │   ├── tex_mobject.py          # Tex and TexText implemented by LaTeX
│   │   └── text_mobject.py         # Text implemented by manimpango
│   ├── changing.py             # Dynamically changing mobject
│   ├── coordinate_systems.py   # coordinate system
│   ├── frame.py                # mobject related to frame
│   ├── functions.py            # ParametricFunction
│   ├── geometry.py             # geometry mobjects
│   ├── matrix.py               # matrix
│   ├── mobject_update_utils.py # some defined updater
│   ├── number_line.py          # Number line
│   ├── numbers.py              # Numbers that can be changed
│   ├── probability.py          # mobject related to probability
│   ├── shape_matchers.py       # mobject adapted to the size of other objects
│   ├── three_dimensions.py     # Three-dimensional objects
│   ├── value_tracker.py        # ValueTracker which storage number
│   └── vector_field.py         # VectorField
├── once_useful_constructs/  # 3b1b's Common scenes written for some videos
│   └── ...
├── shaders/ # GLSL scripts for rendering
│   ├── simple_vert.glsl    # a simple glsl script for position
│   ├── insert/ # glsl scripts to be inserted in other glsl scripts
│   │   ├── NOTE.md   # explain how to insert glsl scripts
│   │   └── ...       # useful scripts
│   ├── image/ # glsl for images
│   │   └── ... # containing shaders for vertex and fragment
│   ├── quadratic_bezier_fill/ # glsl for the fill of quadratic bezier curve
│   │   └── ... # containing shaders for vertex, fragment and geometry
│   ├── quadratic_bezier_stroke/ # glsl for the stroke of quadratic bezier curve
│   │   └── ... # containing shaders for vertex, fragment and geometry
│   ├── surface/ # glsl for surfaces
│   │   └── ... # containing shaders for vertex and fragment
│   ├── textured_surface/ # glsl for textured_surface
│   │   └── ... # containing shaders for vertex and fragment
│   └── true_dot/ # glsl for a dot
│       └── ... # containing shaders for vertex, fragment and geometry
└── utils/ # Some useful utility functions
    ├── bezier.py             # For bezier curve
    ├── color.py              # For color
    ├── dict_ops.py           # Functions related to dictionary processing
    ├── customization.py      # Read from custom_config.yml
    ├── debug.py              # Utilities for debugging in program
    ├── directories.py        # Read directories from config file
    ├── family_ops.py         # Process family members
    ├── file_ops.py           # Process files and directories
    ├── images.py             # Read image
    ├── init_config.py        # Configuration guide
    ├── iterables.py          # Functions related to list/dictionary processing
    ├── paths.py              # Curve path
    ├── rate_functions.py     # Some defined rate_functions
    ├── simple_functions.py   # Some commonly used functions
    ├── sounds.py             # Process sounds
    ├── space_ops.py          # Space coordinate calculation
    ├── strings.py            # Process strings
    └── tex_file_writing.py   # Use LaTeX to write strings as svg
```

================================================================================

=== What’s new - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/whatsnew.html
Content:
What’s new
¶
Usage changes of new version manim
¶
There are many changes in the new version of manim, and here are only the changes that
may have an impact at the code writing level.
Some of the changes here may not have any major impact on the use, and some changes
that affect the use are not mentioned below.
This document is for reference only, see the source code for details.
Animation
Added
Fade
as the parent class of
FadeIn
and
FadeOut
FadeIn
and
FadeOut
can be passed in
shift
and
scale
parameters
Deleted
FadeInFrom,
FadeInFromDown,
FadeOutAndShift,
FadeOutAndShiftDown,
FadeInFromLarge
, these can be used
FadeIn,
FadeOut
to achieve the same effect more easily
Added
FadeTransform
to cross fade between two objects, and subclass
FadeTransformPieces
Added
CountInFrom(decimal_mob,
source_number=0)
to count
decimal_mob
from
source_number
to the current value
Rotating
can directly pass in
angle
and
axis
without writing keywords
angle=,
axis=
Rotate
has become a subclass of
Rotating
, and the distortion effect in
Transform
will not appear
Removed
MoveCar
animation
Added
TransformMatchingShapes(mobject,
target_mobject)
and
TransformMatchingTex(mobject,
target_mobject)
Camera
Removed all camera classes except
Camera
(
MappingCamera
,
MovingCamera
,
MultiCamera
) and all functions in
ThreeDCamera
Implemented
CameraFrame
(as a
Mobject
)
Can be called by
self.camera.frame
in
Scene
All methods of
Mobject
can be used, such as
.shift()
,
.scale()
, etc.
Call
.to_default_state()
to place in the default position
Set the Euler angles of the camera by
.set_euler_angles(theta,
phi,
gamma)
Set three single Euler angles by
.set_theta(theta)
,
.set_phi(phi)
,
.set_gamma(gamma)
Use
.increment_theta(dtheta)
,
.increment_phi(dphi)
,
.increment_gamma(gamma)
to increase the three Euler angles by a certain value. Can be used to realize automatic rotation
self.camera.frame.add_updater(lambda
mob,
dt:
mob.increment_theta(0.1
*
dt))
Camera
adds a light source, which is a
Point
, which can be called by
self.camera.light_source
in
Scene
to move and so on. The default position is
(-
10,
10,
10)
Delete
Container
Mobject
svg
related
Added
Checkmark
and
Exmark
Some unnecessary classes have been removed from
drawings.py
Removed
Code
and
Paragraph
(by mistake)
TexMobject
is renamed to
Tex
,
TextMobject
is renamed to
TexText
font_size
has been added to
Tex
,
TexText
and
Text
Tex
and
TexText
added
isolate
, which is a list, which will be automatically split
Mobject
types
Added a new class
Surface
, which is the parent class of
ParametricSurface
and
TexturedSurface
.
Added the group
SGroup
for
Surface
Added
TexturedSurface(uv_surface,
image_file,
dark_image_file=None)
, where
uv_surface
is a
Surface
,
image_file
is the image to be posted, and
dark_image_file
is the image to be posted in the dark (default and
image_file
is the same)
Deleted
Mobject1D
,
Mobject2D
,
PointCloudDot
Added
DotCloud
(a
PMobject
), which has been greatly optimized
Removed
AbstractImageMobject
,
ImageMobjectFromCamera
Removed
sheen
from
VMobject
Mobject
Added
gloss
and
shadow
, which are the numbers between
[0,
1]
respectively. There are four methods of
.get_gloss()
,
.set_gloss(gloss)
,
.get_shadow()
,
.set_shadow(shadow)
Added
.get_grid(n_rows,
n_cols)
to copy into grid
Added
.set_color_by_code(glsl_code)
to use GLSL code to change the color
Added
.set_color_by_xyz_func(glsl_snippet,
min_value=-5.0,
max_value=5.0,
colormap="viridis")
to pass in GLSL expression in the form of
x,y,z
, the return value should be a floating point number
Coordinate system (including
Axes
,
ThreeDAxes
,
NumberPlane
,
ComplexPlane
)
No longer use
x_min
,
x_max
,
y_min
,
y_max
, but use
x_range
,
y_range
as a
np.array()
, containing three numbers
np.array([
Minimum,
maximum,
step
size])
Added the abbreviation
.i2gp(x,
graph)
of
.input_to_graph_point(x,
graph)
Added some functions of the original
GraphScene
Added
.get_v_line(point)
,
.get_h_line(point)
to return the line from
point
to the two coordinate axes, and specify the line type through the keyword argument of
line_func
(default
DashedLine
)
Added
.get_graph_label(graph,
label,
x,
direction,
buff,
color)
to return the label added to the image
Added
.get_v_line_to_graph(x,
graph)
,
.get_h_line_to_graph(x,
graph)
to return the line from the point with the abscissa of
x
on the
graph
to the two- axis line
Added
.angle_of_tangent(x,
graph,
dx=EPSILON)
, returns the inclination angle of
graph
at
x
Added
.slope_of_tangent(x,
graph,
dx=EPSILON)
, returns the slope of tangent line of
graph
at
x
Added
.get_tangent_line(x,
graph,
length=5)
to return the tangent line of
graph
at
x
Added
.get_riemann_rectangles(graph,
x_range,
dx,
input_sample_type,
...)
to return Riemann rectangles (a
VGroup
)
The attribute
number_line_config
of
Axes
is renamed to
axis_config
Axes
original
.get_coordinate_labels(x_values,
y_values)
method was renamed to
.add_coordinate_labels(x_values,
y_values)
(but it is not added to the screen)
.add_coordinate_labels(numbers)
of
ComplexPlane
will directly add the coordinates to the screen
NumberLine
No longer use
x_min
,
x_max
,
tick_frequency
, but use
x_range
, which is an array containing three numbers
[min,
max,
step]
The original
label_direction
attribute changed to the
line_to_number_direction
attribute
Replace
tip_width
and
tip_height
with
tip_config
(dictionary) attributes
The original
exclude_zero_from_default
attribute is modified to the
numbers_to_exclude
attribute (default is None)
The original
.add_tick_marks()
method was changed to the
.add_ticks()
method
Delete the
.get_number_mobjects(*numbers)
method, only use the
.add_numbers(x_values=None,
excluding=None)
method
Three-dimensional objects
Added
SurfaceMesh(uv_surface)
, pass in a
Surface
to generate its uv mesh
ParametricSurface
no longer uses
u_min,
u_max,
v_min,
v_max
, but instead uses
u_range,
v_range
, which is a tuple (
(min,
max)
), and
resolution
can be set larger, don’t worry Speed ​​issue
Added
Torus
, controlled by
r1,
r2
keyword parameters
Added
Cylinder
, controlled by
height,
radius
keyword parameters
Added
Line3D
(extremely thin cylinder), controlled by the
width
keyword parameter
Added
Disk3D
, controlled by
radius
keyword parameter
Add
Square3D
, controlled by
side_length
keyword parameter
Improved
Cube
and
Prism
, the usage remains unchanged
Other objects
ParametricFunction
is renamed to
ParametricCurve
. Instead of using
t_min,
t_max,
step_size
, use
t_range
, which is an array of three numbers (
[t_min,
t_max,
step_size]
).
dt
was renamed to
epsilon
. Other usage remains unchanged
All
TipableVMobject
can pass in
tip_length
to control the style of
tip
Line
adds
.set_points_by_ends(start,
end,
buff=0,
path_arc=0)
method
Line
added
.get_projection(point)
to return the projection position of
point
on a straight line
Arrow
adds three attributes of
thickness,
tip_width_ratio,
tip_angle
CubicBezier
is changed to
a0,
h0,
h1,
a1
, that is, only a third-order Bezier curve is supported
Square
can be initialized directly by passing in
side_length
instead of using the keyword
side_length=
always_redraw(func,
*args,
**kwargs)
supports incoming parameters
*args,
**kwargs
The
digit_to_digit_buff
property of
DecimalNumber
has been renamed to
digit_buff_per_font_unit
, and the
.scale()
method has been improved
ValueTracker
adds
value_type
attribute, the default is
np.float64
Scene
Removed all functions of
GraphScene
(moved to
once_useful_constructs
),
MovingCameraScene
,
ReconfigurableScene
,
SceneFromVideo
,
ZoomedScene
, and
ThreeDScene
. Because these can basically be achieved by adjusting
CameraFrame
(
self.camera.frame
)
Currently
SampleSpaceScene
and
VectorScene
have not been changed for the new version, so it is not recommended to use (only
Scene
is recommended)
Fix the export of gif, just use the
-i
option directly
Added the
.interact()
method, during which the mouse and keyboard can be used to continue the interaction, which will be executed by default after the scene ends
Added
.embed()
method, open iPython terminal to enter interactive mode
Added
.save_state()
method to save the current state of the scene
Added
.restore()
method to restore the entire scene to the saved state
utils
A series of functions related to second-order Bezier have been added to
utils/bezier.py
Added a function to read color map from
matplotlib
in
utils/color.py
Added a series of related functions for processing folders/custom styles/object families
resize_array
,
resize_preserving_order
,
resize_with_interpolation
three functions have been added to
utils/iterables.py
The definition of
smooth
is updated in
utils/rate_functions.py
clip(a,
min_a,
max_a)
function has been added to
utils/simple_functions.py
Some functions have been improved in
utils/space_ops.py
, some functions for space calculation, and functions for processing triangulation have been added
constants
Fixed the aspect ratio of the screen to 16:9
Deleted the old gray series (
LIGHT_GREY
,
GREY
,
DARK_GREY
,
DARKER_GREY
), added a new series of gray
GREY_A
~
GREY_E
Contents
What’s new
Usage changes of new version manim

Code Examples:
Example 1:
```python
FadeInFrom, FadeInFromDown, FadeOutAndShift, FadeOutAndShiftDown, FadeInFromLarge
```
Example 2:
```python
FadeIn, FadeOut
```
Example 3:
```python
FadeTransform
```
Example 4:
```python
FadeTransformPieces
```
Example 5:
```python
CountInFrom(decimal_mob, source_number=0)
```
Example 6:
```python
decimal_mob
```
Example 7:
```python
source_number
```
Example 8:
```python
angle=, axis=
```
Example 9:
```python
TransformMatchingShapes(mobject, target_mobject)
```
Example 10:
```python
TransformMatchingTex(mobject, target_mobject)
```
Example 11:
```python
MappingCamera
```
Example 12:
```python
MovingCamera
```
Example 13:
```python
MultiCamera
```
Example 14:
```python
ThreeDCamera
```
Example 15:
```python
CameraFrame
```
Example 16:
```python
self.camera.frame
```
Example 17:
```python
.to_default_state()
```
Example 18:
```python
.set_euler_angles(theta, phi, gamma)
```
Example 19:
```python
.set_theta(theta)
```
Example 20:
```python
.set_phi(phi)
```
Example 21:
```python
.set_gamma(gamma)
```
Example 22:
```python
.increment_theta(dtheta)
```
Example 23:
```python
.increment_phi(dphi)
```
Example 24:
```python
.increment_gamma(gamma)
```
Example 25:
```python
self.camera.frame.add_updater(lambda mob, dt: mob.increment_theta(0.1 * dt))
```
Example 26:
```python
self.camera.light_source
```
Example 27:
```python
(- 10, 10, 10)
```
Example 28:
```python
drawings.py
```
Example 29:
```python
TextMobject
```
Example 30:
```python
ParametricSurface
```
Example 31:
```python
TexturedSurface
```
Example 32:
```python
TexturedSurface(uv_surface, image_file, dark_image_file=None)
```
Example 33:
```python
dark_image_file
```
Example 34:
```python
PointCloudDot
```
Example 35:
```python
AbstractImageMobject
```
Example 36:
```python
ImageMobjectFromCamera
```
Example 37:
```python
.get_gloss()
```
Example 38:
```python
.set_gloss(gloss)
```
Example 39:
```python
.get_shadow()
```
Example 40:
```python
.set_shadow(shadow)
```
Example 41:
```python
.get_grid(n_rows, n_cols)
```
Example 42:
```python
.set_color_by_code(glsl_code)
```
Example 43:
```python
.set_color_by_xyz_func(glsl_snippet, min_value=-5.0, max_value=5.0, colormap="viridis")
```
Example 44:
```python
NumberPlane
```
Example 45:
```python
ComplexPlane
```
Example 46:
```python
np.array([ Minimum, maximum, step size])
```
Example 47:
```python
.i2gp(x, graph)
```
Example 48:
```python
.input_to_graph_point(x, graph)
```
Example 49:
```python
.get_v_line(point)
```
Example 50:
```python
.get_h_line(point)
```
Example 51:
```python
.get_graph_label(graph, label, x, direction, buff, color)
```
Example 52:
```python
.get_v_line_to_graph(x, graph)
```
Example 53:
```python
.get_h_line_to_graph(x, graph)
```
Example 54:
```python
.angle_of_tangent(x, graph, dx=EPSILON)
```
Example 55:
```python
.slope_of_tangent(x, graph, dx=EPSILON)
```
Example 56:
```python
.get_tangent_line(x, graph, length=5)
```
Example 57:
```python
.get_riemann_rectangles(graph, x_range, dx, input_sample_type, ...)
```
Example 58:
```python
number_line_config
```
Example 59:
```python
axis_config
```
Example 60:
```python
.get_coordinate_labels(x_values, y_values)
```
Example 61:
```python
.add_coordinate_labels(x_values, y_values)
```
Example 62:
```python
.add_coordinate_labels(numbers)
```
Example 63:
```python
ComplexPlane
```
Example 64:
```python
tick_frequency
```
Example 65:
```python
[min, max, step]
```
Example 66:
```python
label_direction
```
Example 67:
```python
line_to_number_direction
```
Example 68:
```python
exclude_zero_from_default
```
Example 69:
```python
numbers_to_exclude
```
Example 70:
```python
.add_tick_marks()
```
Example 71:
```python
.add_ticks()
```
Example 72:
```python
.get_number_mobjects(*numbers)
```
Example 73:
```python
.add_numbers(x_values=None, excluding=None)
```
Example 74:
```python
SurfaceMesh(uv_surface)
```
Example 75:
```python
ParametricSurface
```
Example 76:
```python
u_min, u_max, v_min, v_max
```
Example 77:
```python
u_range, v_range
```
Example 78:
```python
height, radius
```
Example 79:
```python
side_length
```
Example 80:
```python
ParametricFunction
```
Example 81:
```python
ParametricCurve
```
Example 82:
```python
t_min, t_max, step_size
```
Example 83:
```python
[t_min, t_max, step_size]
```
Example 84:
```python
TipableVMobject
```
Example 85:
```python
.set_points_by_ends(start, end, buff=0, path_arc=0)
```
Example 86:
```python
.get_projection(point)
```
Example 87:
```python
thickness, tip_width_ratio, tip_angle
```
Example 88:
```python
CubicBezier
```
Example 89:
```python
a0, h0, h1, a1
```
Example 90:
```python
side_length
```
Example 91:
```python
side_length=
```
Example 92:
```python
always_redraw(func, *args, **kwargs)
```
Example 93:
```python
*args, **kwargs
```
Example 94:
```python
digit_to_digit_buff
```
Example 95:
```python
DecimalNumber
```
Example 96:
```python
digit_buff_per_font_unit
```
Example 97:
```python
ValueTracker
```
Example 98:
```python
once_useful_constructs
```
Example 99:
```python
MovingCameraScene
```
Example 100:
```python
ReconfigurableScene
```
Example 101:
```python
SceneFromVideo
```
Example 102:
```python
ZoomedScene
```
Example 103:
```python
ThreeDScene
```
Example 104:
```python
CameraFrame
```
Example 105:
```python
self.camera.frame
```
Example 106:
```python
SampleSpaceScene
```
Example 107:
```python
VectorScene
```
Example 108:
```python
.interact()
```
Example 109:
```python
.save_state()
```
Example 110:
```python
utils/bezier.py
```
Example 111:
```python
utils/color.py
```
Example 112:
```python
resize_array
```
Example 113:
```python
resize_preserving_order
```
Example 114:
```python
resize_with_interpolation
```
Example 115:
```python
utils/iterables.py
```
Example 116:
```python
utils/rate_functions.py
```
Example 117:
```python
clip(a, min_a, max_a)
```
Example 118:
```python
utils/simple_functions.py
```
Example 119:
```python
utils/space_ops.py
```
Example 120:
```python
DARKER_GREY
```

================================================================================

=== constants - manim  documentation ===
URL: https://3b1b.github.io/manim/documentation/constants.html
Content:
constants
¶
The
constants.py
in the
manimlib
folder defines the constants
needed when running manim. Some constants are not explained here because
they are only used inside manim.
Frame and pixel shape
¶
ASPECT_RATIO
=
16.0
/
9.0
FRAME_HEIGHT
=
8.0
FRAME_WIDTH
=
FRAME_HEIGHT
*
ASPECT_RATIO
FRAME_Y_RADIUS
=
FRAME_HEIGHT
/
2
FRAME_X_RADIUS
=
FRAME_WIDTH
/
2
DEFAULT_PIXEL_HEIGHT
=
1080
DEFAULT_PIXEL_WIDTH
=
1920
DEFAULT_FPS
=
30
Buffs
¶
SMALL_BUFF
=
0.1
MED_SMALL_BUFF
=
0.25
MED_LARGE_BUFF
=
0.5
LARGE_BUFF
=
1
DEFAULT_MOBJECT_TO_EDGE_BUFFER
=
MED_LARGE_BUFF
# Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER
=
MED_SMALL_BUFF
# Distance between objects
Run times
¶
DEFAULT_POINTWISE_FUNCTION_RUN_TIME
=
3.0
DEFAULT_WAIT_TIME
=
1.0
Coordinates
¶
manim uses three-dimensional coordinates and uses the type of
ndarray
ORIGIN
=
np
.
array
((
0.
,
0.
,
0.
))
UP
=
np
.
array
((
0.
,
1.
,
0.
))
DOWN
=
np
.
array
((
0.
,
-
1.
,
0.
))
RIGHT
=
np
.
array
((
1.
,
0.
,
0.
))
LEFT
=
np
.
array
((
-
1.
,
0.
,
0.
))
IN
=
np
.
array
((
0.
,
0.
,
-
1.
))
OUT
=
np
.
array
((
0.
,
0.
,
1.
))
X_AXIS
=
np
.
array
((
1.
,
0.
,
0.
))
Y_AXIS
=
np
.
array
((
0.
,
1.
,
0.
))
Z_AXIS
=
np
.
array
((
0.
,
0.
,
1.
))
# Useful abbreviations for diagonals
UL
=
UP
+
LEFT
UR
=
UP
+
RIGHT
DL
=
DOWN
+
LEFT
DR
=
DOWN
+
RIGHT
TOP
=
FRAME_Y_RADIUS
*
UP
BOTTOM
=
FRAME_Y_RADIUS
*
DOWN
LEFT_SIDE
=
FRAME_X_RADIUS
*
LEFT
RIGHT_SIDE
=
FRAME_X_RADIUS
*
RIGHT
Mathematical constant
¶
PI
=
np
.
pi
TAU
=
2
*
PI
DEGREES
=
TAU
/
360
Text
¶
NORMAL
=
"NORMAL"
ITALIC
=
"ITALIC"
OBLIQUE
=
"OBLIQUE"
BOLD
=
"BOLD"
Stroke width
¶
DEFAULT_STROKE_WIDTH
=
4
Colours
¶
Here are the preview of default colours. (Modified from
elteoremadebeethoven
)
BLUE
BLUE_E
BLUE_D
BLUE_C
BLUE_B
BLUE_A
TEAL
TEAL_E
TEAL_D
TEAL_C
TEAL_B
TEAL_A
GREEN
GREEN_E
GREEN_D
GREEN_C
GREEN_B
GREEN_A
YELLOW
YELLOW_E
YELLOW_D
YELLOW_C
YELLOW_B
YELLOW_A
GOLD
GOLD_E
GOLD_D
GOLD_C
GOLD_B
GOLD_A
RED
RED_E
RED_D
RED_C
RED_B
RED_A
MAROON
MAROON_E
MAROON_D
MAROON_C
MAROON_B
MAROON_A
PURPLE
PURPLE_E
PURPLE_D
PURPLE_C
PURPLE_B
PURPLE_A
GREY
GREY_E
GREY_D
GREY_C
GREY_B
GREY_A
Others
WHITE
BLACK
GREY_BROWN
DARK_BROWN
LIGHT_BROWN
PINK
LIGHT_PINK
GREEN_SCREEN
ORANGE
Contents
constants
Frame and pixel shape
Buffs
Run times
Coordinates
Mathematical constant
Text
Stroke width
Colours

Code Examples:
Example 1:
```python
constants.py
```
Example 2:
```python
ASPECT_RATIO = 16.0 / 9.0
FRAME_HEIGHT = 8.0
FRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO
FRAME_Y_RADIUS = FRAME_HEIGHT / 2
FRAME_X_RADIUS = FRAME_WIDTH / 2

DEFAULT_PIXEL_HEIGHT = 1080
DEFAULT_PIXEL_WIDTH = 1920
DEFAULT_FPS = 30
```
Example 3:
```python
SMALL_BUFF = 0.1
MED_SMALL_BUFF = 0.25
MED_LARGE_BUFF = 0.5
LARGE_BUFF = 1

DEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects
```
Example 4:
```python
DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0
DEFAULT_WAIT_TIME = 1.0
```
Example 5:
```python
ORIGIN = np.array((0., 0., 0.))
UP = np.array((0., 1., 0.))
DOWN = np.array((0., -1., 0.))
RIGHT = np.array((1., 0., 0.))
LEFT = np.array((-1., 0., 0.))
IN = np.array((0., 0., -1.))
OUT = np.array((0., 0., 1.))
X_AXIS = np.array((1., 0., 0.))
Y_AXIS = np.array((0., 1., 0.))
Z_AXIS = np.array((0., 0., 1.))

# Useful abbreviations for diagonals
UL = UP + LEFT
UR = UP + RIGHT
DL = DOWN + LEFT
DR = DOWN + RIGHT

TOP = FRAME_Y_RADIUS * UP
BOTTOM = FRAME_Y_RADIUS * DOWN
LEFT_SIDE = FRAME_X_RADIUS * LEFT
RIGHT_SIDE = FRAME_X_RADIUS * RIGHT
```
Example 6:
```python
PI = np.pi
TAU = 2 * PI
DEGREES = TAU / 360
```
Example 7:
```python
NORMAL = "NORMAL"
ITALIC = "ITALIC"
OBLIQUE = "OBLIQUE"
BOLD = "BOLD"
```
Example 8:
```python
DEFAULT_STROKE_WIDTH = 4
```

================================================================================

=== custom_config - manim  documentation ===
URL: https://3b1b.github.io/manim/documentation/custom_config.html
Content:
custom_config
¶
directories
¶
mirror_module_path
(
True
or
False
) Whether to create a folder named the name of the
running file under the
output
path, and save the output (
images/
or
videos/
) in it.
output
Output file path, the videos will be saved in the
videos/
folder under it,
and the pictures will be saved in the
images/
folder under it.
For example, if you set
output
to
"/.../manim/output"
and
mirror_module_path
to
False
, then you exported
Scene1
in the code
file and saved the last frame, then the final directory structure will be like:
manim/
    ├── manimlib/
    │   ├── animation/
    │   ├── ...
    │   ├── default_config.yml
    │   └── window.py
    ├── output/
    │   ├── images
│   │   └── Scene1.png
│   └── videos
│       └── Scene1.mp4
├── code.py
    └── custom_config.yml
But if you set
mirror_module_path
to
True
, the directory structure will be:
manim/
    ├── manimlib/
    │   ├── animation/
    │   ├── ...
    │   ├── default_config.yml
    │   └── window.py
    ├── output/
│   └── code/
│       ├── images
    │       │   └── Scene1.png
    │       └── videos
    │           └── Scene1.mp4
    ├── code.py
    └── custom_config.yml
raster_images
The directory for storing raster images to be used in the code (including
.jpg
,
.jpeg
,
.png
and
.gif
), which will be read by
ImageMobject
.
vector_images
The directory for storing vector images to be used in the code (including
.svg
and
.xdv
), which will be read by
SVGMobject
.
sounds
The directory for storing sound files to be used in
Scene.add_sound()
(
including
.wav
and
.mp3
).
temporary_storage
The directory for storing temporarily generated cache files, including
Tex
cache,
Text
cache and storage of object points.
tex
¶
executable
The executable program used to compile LaTeX (
latex
or
xelatex
-no-pdf
is recommended)
template_file
LaTeX template used, in
manimlib/tex_templates
intermediate_filetype
The type of intermediate vector file generated after compilation (
dvi
if
latex
is used,
xdv
if
xelatex
is used)
text_to_replace
The text to be replaced in the template (needn’t to change)
universal_import_line
¶
Import line that need to execute when entering interactive mode directly.
style
¶
font
Default font of Text
text_alignment
Default text alignment for LaTeX
background_color
Default background color
window_position
¶
The relative position of the playback window on the display (two characters,
the first character means upper(U) / middle(O) / lower(D), the second character
means left(L) / middle(O) / right(R)).
window_monitor
¶
The number of the monitor you want the preview window to pop up on. (default is 0)
full_screen
¶
Whether open the window in full screen. (default is false)
break_into_partial_movies
¶
If this is set to
True
, then many small files will be written corresponding
to each
Scene.play
and
Scene.wait
call, and these files will then be combined
to form the full scene.
Sometimes video-editing is made easier when working with the broken up scene, which
effectively has cuts at all the places you might want.
camera_resolutions
¶
Export resolutions
low
Low resolutions (default is 480p)
medium
Medium resolutions (default is 720p)
high
High resolutions (default is 1080p)
ultra_high
Ultra high resolutions (default is 4K)
default_resolutions
Default resolutions (one of the above four, default is high)
fps
¶
Export frame rate. (default is 30)
Contents
custom_config
directories
tex
universal_import_line
style
window_position
window_monitor
full_screen
break_into_partial_movies
camera_resolutions
fps

Code Examples:
Example 1:
```python
directories
```
Example 2:
```python
mirror_module_path
```
Example 3:
```python
"/.../manim/output"
```
Example 4:
```python
mirror_module_path
```
Example 5:
```python
manim/
    ├── manimlib/
    │   ├── animation/
    │   ├── ...
    │   ├── default_config.yml
    │   └── window.py
    ├── output/
    │   ├── images
    │   │   └── Scene1.png
    │   └── videos
    │       └── Scene1.mp4
    ├── code.py
    └── custom_config.yml
```
Example 6:
```python
mirror_module_path
```
Example 7:
```python
manim/
    ├── manimlib/
    │   ├── animation/
    │   ├── ...
    │   ├── default_config.yml
    │   └── window.py
    ├── output/
    │   └── code/
    │       ├── images
    │       │   └── Scene1.png
    │       └── videos
    │           └── Scene1.mp4
    ├── code.py
    └── custom_config.yml
```
Example 8:
```python
raster_images
```
Example 9:
```python
ImageMobject
```
Example 10:
```python
vector_images
```
Example 11:
```python
Scene.add_sound()
```
Example 12:
```python
temporary_storage
```
Example 13:
```python
xelatex -no-pdf
```
Example 14:
```python
template_file
```
Example 15:
```python
manimlib/tex_templates
```
Example 16:
```python
intermediate_filetype
```
Example 17:
```python
text_to_replace
```
Example 18:
```python
universal_import_line
```
Example 19:
```python
text_alignment
```
Example 20:
```python
background_color
```
Example 21:
```python
window_position
```
Example 22:
```python
window_monitor
```
Example 23:
```python
full_screen
```
Example 24:
```python
break_into_partial_movies
```
Example 25:
```python
camera_resolutions
```
Example 26:
```python
default_resolutions
```
Example 27:
```python
directories
```
Example 28:
```python
universal_import_line
```
Example 29:
```python
window_position
```
Example 30:
```python
window_monitor
```
Example 31:
```python
full_screen
```
Example 32:
```python
break_into_partial_movies
```
Example 33:
```python
camera_resolutions
```

================================================================================

=== Changelog - manim  documentation ===
URL: https://3b1b.github.io/manim/development/changelog.html
Content:
Changelog
¶
Unreleased
¶
Breaking Changes
¶
Added
InteractiveScene
(
#1794
)
Fixed bugs
¶
Fixed
ImageMobject
by overriding
set_color
method (
#1791
)
Fixed bug with trying to close window during embed (
#1796
)
Fixed animating
Mobject.restore
bug (
#1796
)
Fixed
InteractiveScene.refresh_selection_highlight
(
#1802
)
Fixed
VMobject.match_style
(
#1821
)
New Features
¶
Added specific euler angle getters (
#1794
)
Added start angle option to
Circle
(
#1794
)
Added
Mobject.is_touching
(
#1794
)
Added
Mobject.get_highlight
(
#1794
)
Allowed for saving and loading mobjects from file (
#1794
)
Added
Mobject.get_all_corners
(
#1794
)
Added
Scene.id_to_mobject
and
Scene.ids_to_group
(
#1794
)
Added
Scene.save_mobject
and
Scene.load_mobject
to allow for saving and loading mobjects from file at the Scene level (
#1794
)
Added
InteractiveScene
(
#1794
)
Added
VHighlight
(
#1794
)
Allowed for sweeping selection (
#1796
)
Allowed stretched-resizing (
#1796
)
Added cursor location label (
#1796
)
Added
Mobject.deserialize
(
#1796
)
Added undo and redo stacks for scene (
#1796
)
Added
Mobject.looks_identical
(
#1802
)
Added equality for
ShaderWrapper
(
#1802
)
Added
Mobject.get_ancestors
(
#1802
)
Added smarter default radius to
Polygon.round_corners
(
#1802
)
Added checkpoints to
Scene
(
#1821
)
Added
crosshair
to
InteractiveScene
(
#1821
)
Added
SceneState
(
#1821
)
Added
time_span
option to
Animation
(
#1821
)
Added
Mobject.arrange_to_fit_dim
(
#1821
)
Added
DecimalNumber.get_tex
(
#1821
)
Refactor
¶
Updated parent updater status when adding updaters (
#1794
)
Added case for zero vectors on
angle_between_vectors
(
#1794
)
Refactored
Mobject.clear_updaters
(
#1794
)
Changed the way changing-vs-static mobjects are tracked (more details see
#1794
)
Refactored
Mobject.is_point_touching
(
#1794
)
Refactored
Mobject.make_movable
and
Mobject.set_animating_status
to recurse over family (
#1794
)
Refactored
AnimationGroup
(
#1794
)
Refactored
Scene.save_state
and
Scene.restore
(
#1794
)
Added
MANIM_COLORS
(
#1794
)
Changed default transparent background codec to be prores (
#1794
)
Simplified
Mobject.copy
(
#1794
)
Refactored
StringMobject
and relevant classes (
#1795
)
Updates to copying based on pickle serializing (
#1796 <https://github.com/3b1b/manim/commit/fe3e10acd29a3dd6f8b485c0e36ead819f2d937b>
)
Removed
refresh_shader_wrapper_id
from
Mobject.become
(
#1796
)
Refactored
Scene.embed
to play nicely with gui interactions (
#1796
)
Made
BlankScene
inherit from
InteractiveScene
(
#1796
)
Updated behavior of -e flag to take in (optional) strings as inputs (
#1796
)
Refactor -e flag (
#1796
)
Reverted to original copying scheme (
#1796
)
Renamed
Mobject.is_movable
to
Mobject.interaction_allowed
(
#1796
)
Refreshed static mobjects on undo’s and redo’s (
#1796
)
Factored out event handling (
#1796
)
Removed
Mobject.interaction_allowed
, in favor of using
_is_animating
for multiple purposes (
#1796
)
Moved Command + z and Command + shift + z behavior to Scene (
#1797
)
Slight copy refactor (
#1797
)
When scene saves state, have it only copy mobjects which have changed (
#1802
)
Cleaned up
Scene.remove
function (
#1802
)
Speed-ups to
Mobject.copy
(
#1802
)
Slight speed-up to
InteractiveScene.gather_selection
(
#1802
)
Only leave wait notes in presenter mode (
#1802
)
Refactored
remove_list_redundancies
and
list_update
(
#1821
)
Match updaters in
Mobject.become
(
#1821
)
Don’t show animation progress bar by default (
#1821
)
Handle quitting during scene more gracefully (
#1821
)
Made
selection_highlight
refresh with an updater (
#1821
)
Refactored
anims_from_play_args
to
prepare_animations
which deprecating old style
self.play(mob.method,
...)
(
#1821
)
Made presenter mode hold before first play call (
#1821
)
Update frame on all play calls when skipping animations, so as to provide a rapid preview during scene loading (
#1821
)
Renamed frame_rate to fps (
#1821
)
Let default text alignment be decided in default_config (
#1821
)
Dependencies
¶
Added dependency on
pyperclip
(
#1794
)
v1.6.1
¶
Fixed bugs
¶
Fixed the bug of
MTex
with multi-line tex string (
#1785
)
Fixed
interpolate
(
#1788
)
Fixed
ImageMobject
(
#1791
)
Refactor
¶
Added
\overset
as a special string in
Tex
(
#1783
)
Added
outer_interpolate
to perform interpolation using
np.outer
on arrays (
#1788
)
v1.6.0
¶
Breaking changes
¶
Python 3.6 is no longer supported
(
#1736
)
Fixed bugs
¶
Fixed the width of riemann rectangles (
#1762
)
Bug fixed in cases where empty array is passed to shader (
#1764
)
Fixed
AddTextWordByWord
(
#1772
)
Fixed
ControlsExample
(
#1781
)
New features
¶
Added more functions to
Text
(details:
#1751
)
Allowed
interpolate
to work on an array of alpha values (
#1764
)
Allowed
Numberline.number_to_point
and
CoordinateSystem.coords_to_point
to work on an array of inputs (
#1764
)
Added a basic
Prismify
to turn a flat
VMobject
into something with depth (
#1764
)
Added
GlowDots
, analogous to
GlowDot
(
#1764
)
Added
TransformMatchingStrings
which is compatible with
Text
and
MTex
(
#1772
)
Added support for
substring
and
case_sensitive
parameters for
LabelledString.get_parts_by_string
(
#1780
)
Refactor
¶
Added type hints (
#1736
)
Specifid UTF-8 encoding for tex files (
#1748
)
Refactored
Text
with the latest manimpango (
#1751
)
Reorganized getters for
ParametricCurve
(
#1757
)
Refactored
CameraFrame
to use
scipy.spatial.transform.Rotation
(
#1764
)
Refactored rotation methods to use
scipy.spatial.transform.Rotation
(
#1764
)
Used
stroke_color
to init
Arrow
(
#1764
)
Refactored
Mobject.set_rgba_array_by_color
(
#1764
)
Made panning more sensitive to mouse movements (
#1764
)
Added loading progress for large SVGs (
#1766
)
Added getter/setter of
field_of_view
for
CameraFrame
(
#1770
)
Renamed
focal_distance
to
focal_dist_to_height
and added getter/setter (
#1770
)
Added getter and setter for
VMobject.joint_type
(
#1770
)
Refactored
VCube
(
#1770
)
Refactored
Prism
to receive
width
height
depth
instead of
dimensions
(
#1770
)
Refactored
Text
,
MarkupText
and
MTex
based on
LabelledString
(
#1772
)
Refactored
LabelledString
and relevant classes (
#1779
)
v1.5.0
¶
Fixed bugs
¶
Bug fix for the case of calling
Write
on a null object (
#1740
)
New features
¶
Added
TransformMatchingMTex
(
#1725
)
Added
ImplicitFunction
(
#1727
)
Added
Polyline
(
#1731
)
Allowed
Mobject.set_points
to take in an empty list, and added
Mobject.add_point
(
#1739
)
Added
Scene.refresh_locked_data
(
#1739
)
Added presenter mode to scenes with
-p
option (
#1739
and
#1742
)
Allowed for an embed by hitting
ctrl+shift+e
during interaction (
#1739
and
#1746
)
Added
Mobject.set_min_width/height/depth
(
#1739
)
Allowed
Mobject.match_coord/x/y/z
to take in a point (
#1739
)
Added
text_config
to
DecimalNumber
(
#1744
)
Refactor
¶
Refactored
MTex
(
#1725
)
Refactored
SVGMobject
with svgelements (
#1731
)
Made sure
ParametricCurve
has at least one point (
#1739
)
Set default to no tips on
Axes
(
#1739
)
Stopped displaying when writing tex string is happening (
#1739
)
Reorganize inheriting order and refactor SVGMobject (
#1745
)
Dependencies
¶
Added dependency on
isosurfaces
(
#1727
)
Removed dependency on
argparse
since it’s a built-in module (
#1728
)
Removed dependency on
pyreadline
(
#1728
)
Removed dependency on
cssselect2
(
#1731
)
Added dependency on
svgelements
(
#1731
)
v1.4.1
¶
Fixed bugs
¶
Temporarily fixed boolean operations’ bug  (
#1724
)
Import
Iterable
from
collections.abc
instead of
collections
which is deprecated since python 3.9 (
d2e0811
)
v1.4.0
¶
Fixed bugs
¶
Temporarily fixed
Lightbulb
(
f1996f8
)
Fixed some bugs of
SVGMobject
(
#1712
)
Fixed some bugs of SVG path string parser (
#1717
)
Fixed some bugs of
MTex
(
#1720
)
New features
¶
Added option to add ticks on x-axis in
BarChart
(
#1694
)
Added
lable_buff
config parameter for
Brace
(
#1704
)
Added support for
rotate
skewX
skewY
transform in SVG  (
#1712
)
Added style support to
SVGMobject
(
#1717
)
Added parser to <style> element of SVG  (
#1719
)
Added support for <line> element in
SVGMobject
(
#1719
)
Refactor
¶
Used
FFMPEG_BIN
instead of
"ffmpeg"
for sound incorporation (
5aa8d15
)
Decorated
CoordinateSystem.get_axes
and
.get_all_ranges
as abstract method  (
#1709
)
Refactored SVG path string parser (
#1712
)
Allowed
Mobject.scale
to receive iterable
scale_factor
(
#1712
)
Refactored
MTex
(
#1716
)
Improved config helper (
manimgl
--config
) (
#1721
)
Refactored
MTex
(
#1723
)
Dependencies
¶
Added dependency on python package
cssselect2
(
#1719
)
v1.3.0
¶
Fixed bugs
¶
Fixed
Mobject.stretch_to_fit_depth
(
#1653
)
Fixed the bug of rotating camera (
#1655
)
Fixed
SurfaceMesh
to be evenly spaced (
c73d507
)
Fixed
angle_between_vectors
add
rotation_between_vectors
(
82bd02d
)
Fixed
VMobject.fade
(
a717314
)
Fixed
angle_between_vectors
(
fbc329d
)
Fixed bug in
ShowSubmobjectsOneByOne
(
bcd0990
)
Fixed bug in
TransformMatchingParts
(
7023548
)
New features
¶
Added CLI flag
--log-level
to specify log level (
e10f850
)
Added operations (
+
and
*
) for
Mobject
(
#1667
)
Added 4 boolean operations for
VMobject
in
manimlib/mobject/boolean_ops.py
(
#1675
)
Union(*vmobjects,
**kwargs)
Difference(subject,
clip,
**kwargs)
Intersection(*vmobjects,
**kwargs)
Exclusion(*vmobjects,
**kwargs)
Added reflectiveness (
81c3ae3
)
Enabled
glow_factor
on
DotCloud
(
2c7689e
)
Added option
-e
to insert embed line from the command line (
d065e19
)
Improved
point_from_proportion
to account for arc length (
0e78027
)
Added shortcut
set_backstroke
for setting black background stroke (
781a993
)
Added
Suface.always_sort_to_camera
(
0b898a5
)
Added getter methods for specific euler angles (
e899604
)
Hade
rotation_between_vectors
handle identical/similar vectors (
407c53f
)
Added
Mobject.insert_submobject
method (
49743da
)
Created single progress display for full scene render (
9dd1f47
)
Added
Circle.get_radius
(
264f7b1
)
Added
Dodecahedron
(
83841ae
)
Added
GlowDot
(
a1d5147
)
Added
MTex
, see
#1678
for details (
#1678
)
Refactor
¶
Refactored support for command
A
in path of SVG  (
#1662
)
Refactored
SingleStringTex.balance_braces
(
#1662
)
Slight tweaks to how saturation_factor works on newton-fractal (
8b454fb
)
Made it possible to set full screen preview as a default (
317a5d6
)
Used
quick_point_from_proportion
for graph points (
e764da3
)
Made sure
Line.set_length
returns self (
d2182b9
)
Better align
SurfaceMesh
to the corresponding surface polygons (
eea3c6b
)
Match
fix_in_frame
status for
FlashAround
mobject (
ee1594a
)
Made sure
Mobject.is_fixed_in_frame
stays updated with uniforms (
ba23fbe
)
Made sure
skip_animations
and
start_at_animation_number
play well together (
98b0d26
)
Updated progress display for full scene render (
f8e6e7d
)
VectorizedPoint
should call
__init__
for both super classes (
8f1dfab
)
Used array copy when checking need for refreshing triangulation (
758f329
)
Dependencies
¶
Added dependency on python package
skia-pathops
(
#1675
)
v1.2.0
¶
Fixed bugs
¶
Fixed
put_start_and_end_on
in 3D (
#1592
)
Fixed
DecimalNumber
’s scaling issue (
#1601
)
Fixed bug with common range array used for all coordinate systems (
56df154
)
Fixed
CoordinateSystem
init bug (
8645894
)
Fixed bug for single-valued
ValueTracker
(
0dc096b
)
Fixed bug with SVG rectangles (
54ad355
)
Fixed
DotCloud.set_radii
(
d45ea28
)
Temporarily fixed bug for
PMobject
array resizing (
b543cc0
)
Fixed
match_style
(
5f878a2
)
Fixed negative
path_arc
case (
719c81d
)
Fixed bug with
CoordinateSystem.get_lines_parallel_to_axis
(
c726eb7
)
Fixed
ComplexPlane
-i display bug (
7732d2f
)
New features
¶
Supported the elliptical arc command
A
for
SVGMobject
(
#1598
)
Added
FlashyFadeIn
(
#1607
)
Save triangulation  (
#1607
)
Added new
Code
mobject (
#1625
)
Add warnings and use rich to display log (
#1637
)
Added
VCube
(
bd356da
)
Supported
ValueTracker
to track vectors (
6d72893
)
Added
set_max_width
,
set_max_height
,
set_max_depth
to
Mobject
(
3bb8f3f
)
Added
TracgTail
(
a35dd5a
)
Added
Scene.point_to_mobject
(
acba13f
)
Added poly_fractal shader (
f84b8a6
)
Added kwargs to
TipableVMobject.set_length
(
b24ba19
)
Added
Mobject.replicate
(
17c2772
)
Added mandelbrot_fractal shader (
33fa76d
)
Saved state before each embed (
f22a341
)
Allowed releasing of Textures (
e10a752
)
Consolidated and renamed newton_fractal shader (
14fbed7
)
Hade
ImageMoject
remember the filepath to the Image (
6cdbe0d
)
Refactor
¶
Changed back to simpler
Mobject.scale
implementation (
#1601
)
Simplified
Square
(
b667db2
)
Removed unused parameter
triangulation_locked
(
40290ad
)
Reimplemented
Arrow
(
8647a64
)
Used
make_approximately_smooth
for
set_points_smoothly
by default (
d8378d8
)
Refactored to call
_handle_scale_side_effects
after scaling takes place (
7b4199c
)
Refactored to only call
throw_error_if_no_points
once for
get_start_and_end
(
7356a36
)
Made sure framerate is 30 for previewed scenes (
0787c4f
)
Pushed
pixel_coords_to_space_coords
to
Window
(
c635f19
)
Refactored to pass tuples and not arrays to uniforms (
d5a88d0
)
Refactored to copy uniform arrays in
Mobject.copy
(
9483f26
)
Added
bounding_box
as exceptional key to point_cloud mobject (
ed1fc4d
)
Made sure stroke width is always a float (
329d2c6
)
v1.1.0
¶
Fixed bugs
¶
Fixed the bug of
resize_with_interpolation()
in the case of
length=0
Fixed the bug of
__init__
in
Elbow
If chosen monitor is not available, choose one that does exist
Make sure mobject data gets unlocked after animations
Fixed a bug for off-center vector fields
Had
Mobject.match_points
return self
Fixed chaining animation in example scenes
Fixed the default color of tip
Fixed a typo in
ShowPassingFlashWithThinningStrokeWidth
Fixed the default size of
Text
Fixed a missing import line in
mobject.py
Fixed the bug in ControlsExample
Make sure frame is added to the scene when initialization
Fixed zooming directions
Rewrote
earclip_triangulation
to fix triangulation
Allowed sound_file_name to be taken in without extensions
New features
¶
Added
VShowPassingFlash
Added
COLORMAP_3B1B
Added some methods to coordinate system to access all axes ranges
get_origin()
get_all_ranges()
Added
set_color_by_rgba_func()
Updated
VectorField
and
StreamLines
Allow
3b1b_colormap
as an option for
get_colormap_list()
Return
stroke_width
as 1d array
Added
get_parts_by_text()
Use Text not TexText for Brace
Update to Cross to make it default to variable stroke width
Added
FlashAround
and
FlashUnder
Allowed configuration in
Brace.get_text
Added
reorient()
for quicker changes to frame angle
Added
units
to
set_euler_angles()
Allowed any
VMobject
to be passed into
TransformMatchingTex
Removed double brace convention in
Tex
and
TexText
Added support for debugger launch
Added CLI flag
--config_file
to load configuration file manually
Added
tip_style
to
tip_config
Added
MarkupText
Take in
u_range
and
v_range
as arguments to
ParametricSurface
Added
TrueDot
Contents
Changelog
Unreleased
Breaking Changes
Fixed bugs
New Features
Refactor
Dependencies
v1.6.1
Fixed bugs
Refactor
v1.6.0
Breaking changes
Fixed bugs
New features
Refactor
v1.5.0
Fixed bugs
New features
Refactor
Dependencies
v1.4.1
Fixed bugs
v1.4.0
Fixed bugs
New features
Refactor
Dependencies
v1.3.0
Fixed bugs
New features
Refactor
Dependencies
v1.2.0
Fixed bugs
New features
Refactor
v1.1.0
Fixed bugs
New features

Code Examples:
Example 1:
```python
InteractiveScene
```
Example 2:
```python
ImageMobject
```
Example 3:
```python
Mobject.restore
```
Example 4:
```python
InteractiveScene.refresh_selection_highlight
```
Example 5:
```python
VMobject.match_style
```
Example 6:
```python
Mobject.is_touching
```
Example 7:
```python
Mobject.get_highlight
```
Example 8:
```python
Mobject.get_all_corners
```
Example 9:
```python
Scene.id_to_mobject
```
Example 10:
```python
Scene.ids_to_group
```
Example 11:
```python
Scene.save_mobject
```
Example 12:
```python
Scene.load_mobject
```
Example 13:
```python
InteractiveScene
```
Example 14:
```python
Mobject.deserialize
```
Example 15:
```python
Mobject.looks_identical
```
Example 16:
```python
ShaderWrapper
```
Example 17:
```python
Mobject.get_ancestors
```
Example 18:
```python
Polygon.round_corners
```
Example 19:
```python
InteractiveScene
```
Example 20:
```python
Mobject.arrange_to_fit_dim
```
Example 21:
```python
DecimalNumber.get_tex
```
Example 22:
```python
angle_between_vectors
```
Example 23:
```python
Mobject.clear_updaters
```
Example 24:
```python
Mobject.is_point_touching
```
Example 25:
```python
Mobject.make_movable
```
Example 26:
```python
Mobject.set_animating_status
```
Example 27:
```python
AnimationGroup
```
Example 28:
```python
Scene.save_state
```
Example 29:
```python
Scene.restore
```
Example 30:
```python
MANIM_COLORS
```
Example 31:
```python
Mobject.copy
```
Example 32:
```python
StringMobject
```
Example 33:
```python
refresh_shader_wrapper_id
```
Example 34:
```python
Mobject.become
```
Example 35:
```python
Scene.embed
```
Example 36:
```python
InteractiveScene
```
Example 37:
```python
Mobject.is_movable
```
Example 38:
```python
Mobject.interaction_allowed
```
Example 39:
```python
Mobject.interaction_allowed
```
Example 40:
```python
_is_animating
```
Example 41:
```python
Scene.remove
```
Example 42:
```python
Mobject.copy
```
Example 43:
```python
InteractiveScene.gather_selection
```
Example 44:
```python
remove_list_redundancies
```
Example 45:
```python
list_update
```
Example 46:
```python
Mobject.become
```
Example 47:
```python
selection_highlight
```
Example 48:
```python
anims_from_play_args
```
Example 49:
```python
prepare_animations
```
Example 50:
```python
self.play(mob.method, ...)
```
Example 51:
```python
interpolate
```
Example 52:
```python
ImageMobject
```
Example 53:
```python
outer_interpolate
```
Example 54:
```python
AddTextWordByWord
```
Example 55:
```python
ControlsExample
```
Example 56:
```python
interpolate
```
Example 57:
```python
Numberline.number_to_point
```
Example 58:
```python
CoordinateSystem.coords_to_point
```
Example 59:
```python
TransformMatchingStrings
```
Example 60:
```python
case_sensitive
```
Example 61:
```python
LabelledString.get_parts_by_string
```
Example 62:
```python
ParametricCurve
```
Example 63:
```python
CameraFrame
```
Example 64:
```python
scipy.spatial.transform.Rotation
```
Example 65:
```python
scipy.spatial.transform.Rotation
```
Example 66:
```python
stroke_color
```
Example 67:
```python
Mobject.set_rgba_array_by_color
```
Example 68:
```python
field_of_view
```
Example 69:
```python
CameraFrame
```
Example 70:
```python
focal_distance
```
Example 71:
```python
focal_dist_to_height
```
Example 72:
```python
VMobject.joint_type
```
Example 73:
```python
width height depth
```
Example 74:
```python
LabelledString
```
Example 75:
```python
LabelledString
```
Example 76:
```python
TransformMatchingMTex
```
Example 77:
```python
ImplicitFunction
```
Example 78:
```python
Mobject.set_points
```
Example 79:
```python
Mobject.add_point
```
Example 80:
```python
Scene.refresh_locked_data
```
Example 81:
```python
ctrl+shift+e
```
Example 82:
```python
Mobject.set_min_width/height/depth
```
Example 83:
```python
Mobject.match_coord/x/y/z
```
Example 84:
```python
text_config
```
Example 85:
```python
DecimalNumber
```
Example 86:
```python
ParametricCurve
```
Example 87:
```python
isosurfaces
```
Example 88:
```python
svgelements
```
Example 89:
```python
collections.abc
```
Example 90:
```python
collections
```
Example 91:
```python
rotate skewX skewY
```
Example 92:
```python
CoordinateSystem.get_axes
```
Example 93:
```python
.get_all_ranges
```
Example 94:
```python
Mobject.scale
```
Example 95:
```python
scale_factor
```
Example 96:
```python
manimgl --config
```
Example 97:
```python
Mobject.stretch_to_fit_depth
```
Example 98:
```python
SurfaceMesh
```
Example 99:
```python
angle_between_vectors
```
Example 100:
```python
rotation_between_vectors
```
Example 101:
```python
VMobject.fade
```
Example 102:
```python
angle_between_vectors
```
Example 103:
```python
ShowSubmobjectsOneByOne
```
Example 104:
```python
TransformMatchingParts
```
Example 105:
```python
--log-level
```
Example 106:
```python
manimlib/mobject/boolean_ops.py
```
Example 107:
```python
Union(*vmobjects, **kwargs)
```
Example 108:
```python
Difference(subject, clip, **kwargs)
```
Example 109:
```python
Intersection(*vmobjects, **kwargs)
```
Example 110:
```python
Exclusion(*vmobjects, **kwargs)
```
Example 111:
```python
glow_factor
```
Example 112:
```python
point_from_proportion
```
Example 113:
```python
set_backstroke
```
Example 114:
```python
Suface.always_sort_to_camera
```
Example 115:
```python
rotation_between_vectors
```
Example 116:
```python
Mobject.insert_submobject
```
Example 117:
```python
Circle.get_radius
```
Example 118:
```python
Dodecahedron
```
Example 119:
```python
SingleStringTex.balance_braces
```
Example 120:
```python
quick_point_from_proportion
```
Example 121:
```python
Line.set_length
```
Example 122:
```python
SurfaceMesh
```
Example 123:
```python
fix_in_frame
```
Example 124:
```python
FlashAround
```
Example 125:
```python
Mobject.is_fixed_in_frame
```
Example 126:
```python
skip_animations
```
Example 127:
```python
start_at_animation_number
```
Example 128:
```python
VectorizedPoint
```
Example 129:
```python
put_start_and_end_on
```
Example 130:
```python
DecimalNumber
```
Example 131:
```python
CoordinateSystem
```
Example 132:
```python
ValueTracker
```
Example 133:
```python
DotCloud.set_radii
```
Example 134:
```python
match_style
```
Example 135:
```python
CoordinateSystem.get_lines_parallel_to_axis
```
Example 136:
```python
ComplexPlane
```
Example 137:
```python
FlashyFadeIn
```
Example 138:
```python
ValueTracker
```
Example 139:
```python
set_max_width
```
Example 140:
```python
set_max_height
```
Example 141:
```python
set_max_depth
```
Example 142:
```python
Scene.point_to_mobject
```
Example 143:
```python
TipableVMobject.set_length
```
Example 144:
```python
Mobject.replicate
```
Example 145:
```python
ImageMoject
```
Example 146:
```python
Mobject.scale
```
Example 147:
```python
triangulation_locked
```
Example 148:
```python
make_approximately_smooth
```
Example 149:
```python
set_points_smoothly
```
Example 150:
```python
_handle_scale_side_effects
```
Example 151:
```python
throw_error_if_no_points
```
Example 152:
```python
get_start_and_end
```
Example 153:
```python
pixel_coords_to_space_coords
```
Example 154:
```python
Mobject.copy
```
Example 155:
```python
bounding_box
```
Example 156:
```python
resize_with_interpolation()
```
Example 157:
```python
Mobject.match_points
```
Example 158:
```python
ShowPassingFlashWithThinningStrokeWidth
```
Example 159:
```python
earclip_triangulation
```
Example 160:
```python
VShowPassingFlash
```
Example 161:
```python
COLORMAP_3B1B
```
Example 162:
```python
get_origin()
```
Example 163:
```python
get_all_ranges()
```
Example 164:
```python
set_color_by_rgba_func()
```
Example 165:
```python
VectorField
```
Example 166:
```python
StreamLines
```
Example 167:
```python
3b1b_colormap
```
Example 168:
```python
get_colormap_list()
```
Example 169:
```python
stroke_width
```
Example 170:
```python
get_parts_by_text()
```
Example 171:
```python
FlashAround
```
Example 172:
```python
Brace.get_text
```
Example 173:
```python
set_euler_angles()
```
Example 174:
```python
TransformMatchingTex
```
Example 175:
```python
--config_file
```
Example 176:
```python
ParametricSurface
```

================================================================================

=== Contributing - manim  documentation ===
URL: https://3b1b.github.io/manim/development/contributing.html
Content:
Contributing
¶
Accept any contribution you make :)
Contribute to the manim source code
:
Please fork to your own repository and make changes, submit a pull request, and fill in
the motivation for the change following the instructions in the template. We will check
your pull request in detail (this usually takes a while, please be patient)
Contribute to the documentation
:
Also submit a pull request and write down the main changes.
If you find a bug in the code
:
Please open an issue and fill in the found problem and your environment according
to the template. (But please note that if you think this problem is just a problem
of yourself, rather than a problem of source code, it is recommended that you ask a
question in the
Q&A category
of the discussion page)
You are welcome to share the content you made with manim
:
Post it in the
show and tell category
of the discussion page.
You are also welcome to share some of your suggestions and ideas
:
Post them in the
ideas category
of the discussion page.
How to build this documentation
¶
Clone the 3b1b/manim repository
git
clone
https://github.com/3b1b/manim.git
# or your own repo
# git clone https://github.com/<your user name>/manim.git
cd
manim
Install python package dependencies
pip
install
-r
docs/requirements.txt
Go to the
docs/
folder and build
cd
docs/
make
html
The output document is located in
docs/build/html/
Contents
Contributing
How to build this documentation

Code Examples:
Example 1:
```python
git clone https://github.com/3b1b/manim.git
# or your own repo
# git clone https://github.com/<your user name>/manim.git
cd manim
```
Example 2:
```python
pip install -r docs/requirements.txt
```
Example 3:
```python
cd docs/
make html
```
Example 4:
```python
docs/build/html/
```

================================================================================

=== About - manim  documentation ===
URL: https://3b1b.github.io/manim/development/about.html
Content:
About
¶
About Manim
¶
Manim is an animation engine for explanatory math videos.
You can use it to make math videos (or other fields) like 3Blue1Brown.
There are mainly two versions here:
3b1b/manim
: Maintained by Grant Sanderson of 3Blue1Brown.
Using OpenGL and its GLSL language to use GPU for rendering. It has higher efficiency,
faster rendering speed, and supports real-time rendering and interaction.
ManimCommunity/manim
: Maintained by Manim Community Dev Team.
Using multiple backend rendering. There is better documentation and
a more open contribution community.
About this documentation
¶
This documentation is based on the version in
3b1b/manim
.
Created by
TonyCrane
(“鹤翔万里” in Chinese) and in production.
Among them, the
manim_example_ext
extension for Sphinx refers to
the documentation of ManimCommunity
.
If you want to contribute to manim or this document, please see:
Contributing
Contents
About
About Manim
About this documentation

Code Examples:
Example 1:
```python
manim_example_ext
```

================================================================================

=== Home - manim  documentation ===
URL: https://3b1b.github.io/manim/#manim-s-documentation
Content:
Manim’s documentation
¶
Manim is an animation engine for explanatory math videos. It’s used to create precise animations programmatically, as seen in the videos
at
3Blue1Brown
.
And here is a Chinese version of this documentation:
https://docs.manim.org.cn/
Getting Started
Installation
Install FFmpeg
Install FFmpeg Windows
# Install FFmepeg Linux
# Install FFmpeg MacOS
Directly
Directly (Windows)
For Anaconda
Quick Start
Make an image
Add animations
Enable interaction
You succeeded!
CLI flags and configuration
Command Line Interface
custom_config
Example Scenes
InteractiveDevlopment
AnimatingMethods
TextExample
TexTransformExample
UpdatersExample
CoordinateSystemExample
GraphExample
SurfaceExample
OpeningManimExample
Manim’s structure
Manim’s directory structure
Inheritance structure of manim’s classes
Manim execution process
What’s new
Usage changes of new version manim
Documentation
constants
Frame and pixel shape
Buffs
Run times
Coordinates
Mathematical constant
Text
Stroke width
Colours
custom_config
directories
tex
universal_import_line
style
window_position
window_monitor
full_screen
break_into_partial_movies
camera_resolutions
fps
Development
Changelog
Unreleased
v1.6.1
v1.6.0
v1.5.0
v1.4.1
v1.4.0
v1.3.0
v1.2.0
v1.1.0
Contributing
How to build this documentation
About
About Manim
About this documentation

Code Examples:
Example 1:
```python
directories
```
Example 2:
```python
universal_import_line
```
Example 3:
```python
window_position
```
Example 4:
```python
window_monitor
```
Example 5:
```python
full_screen
```
Example 6:
```python
break_into_partial_movies
```
Example 7:
```python
camera_resolutions
```

================================================================================

=== Installation - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg
Content:
Installation
¶
Manim runs on Python 3.7 or higher.
System requirements are：
FFmpeg
OpenGL
(included in python package
PyOpenGL
)
LaTeX
(optional, if you want to use LaTeX)
Pango
(only for Linux)
Install FFmpeg
¶
Install FFmpeg Windows
¶
choco install ffmpeg
# Install FFmepeg Linux
¶
$
sudo
apt
update
$
sudo
apt
install
ffmpeg
$
ffmpeg
-version
# Install FFmpeg MacOS
¶
Download This ZIP file
`
https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full
.7z`(if the link is not working download this zip file from there original website)
Directly
¶
# Install manimgl
pip
install
manimgl
# Try it out
manimgl
If you want to hack on manimlib itself, clone this repository and in
that directory execute:
# Install python requirements
pip
install
-e
.
# Try it out
manimgl
example_scenes.py
OpeningManimExample
# or
manim-render
example_scenes.py
OpeningManimExample
If you run the above command and no error message appears,
then you have successfully installed all the environments required by manim.
Directly (Windows)
¶
Install
FFmpeg
, and make sure that its path is in the PATH environment variable.
Install a LaTeX distribution.
TeXLive-full
is recommended.
Install the remaining Python packages.
git
clone
https://github.com/3b1b/manim.git
cd
manim
pip
install
-e
.
manimgl
example_scenes.py
OpeningManimExample
For Anaconda
¶
Install FFmpeg and LaTeX as above.
Create a conda environment using
git
clone
https://github.com/3b1b/manim.git
cd
manim
conda
create
-n
manim
python
=
3
.8
conda
activate
manim
pip
install
-e
.
Contents
Installation
Install FFmpeg
Install FFmpeg Windows
# Install FFmepeg Linux
# Install FFmpeg MacOS
Directly
Directly (Windows)
For Anaconda

Code Examples:
Example 1:
```python
choco install ffmpeg
```
Example 2:
```python
$ sudo apt update
$ sudo apt install ffmpeg
$ ffmpeg -version
```
Example 3:
```python
# Install manimgl
pip install manimgl

# Try it out
manimgl
```
Example 4:
```python
# Install python requirements
pip install -e .

# Try it out
manimgl example_scenes.py OpeningManimExample
# or
manim-render example_scenes.py OpeningManimExample
```
Example 5:
```python
git clone https://github.com/3b1b/manim.git
cd manim
pip install -e .
manimgl example_scenes.py OpeningManimExample
```
Example 6:
```python
git clone https://github.com/3b1b/manim.git
cd manim
conda create -n manim python=3.8
conda activate manim
pip install -e .
```

================================================================================

=== Installation - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-windows
Content:
Installation
¶
Manim runs on Python 3.7 or higher.
System requirements are：
FFmpeg
OpenGL
(included in python package
PyOpenGL
)
LaTeX
(optional, if you want to use LaTeX)
Pango
(only for Linux)
Install FFmpeg
¶
Install FFmpeg Windows
¶
choco install ffmpeg
# Install FFmepeg Linux
¶
$
sudo
apt
update
$
sudo
apt
install
ffmpeg
$
ffmpeg
-version
# Install FFmpeg MacOS
¶
Download This ZIP file
`
https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full
.7z`(if the link is not working download this zip file from there original website)
Directly
¶
# Install manimgl
pip
install
manimgl
# Try it out
manimgl
If you want to hack on manimlib itself, clone this repository and in
that directory execute:
# Install python requirements
pip
install
-e
.
# Try it out
manimgl
example_scenes.py
OpeningManimExample
# or
manim-render
example_scenes.py
OpeningManimExample
If you run the above command and no error message appears,
then you have successfully installed all the environments required by manim.
Directly (Windows)
¶
Install
FFmpeg
, and make sure that its path is in the PATH environment variable.
Install a LaTeX distribution.
TeXLive-full
is recommended.
Install the remaining Python packages.
git
clone
https://github.com/3b1b/manim.git
cd
manim
pip
install
-e
.
manimgl
example_scenes.py
OpeningManimExample
For Anaconda
¶
Install FFmpeg and LaTeX as above.
Create a conda environment using
git
clone
https://github.com/3b1b/manim.git
cd
manim
conda
create
-n
manim
python
=
3
.8
conda
activate
manim
pip
install
-e
.
Contents
Installation
Install FFmpeg
Install FFmpeg Windows
# Install FFmepeg Linux
# Install FFmpeg MacOS
Directly
Directly (Windows)
For Anaconda

Code Examples:
Example 1:
```python
choco install ffmpeg
```
Example 2:
```python
$ sudo apt update
$ sudo apt install ffmpeg
$ ffmpeg -version
```
Example 3:
```python
# Install manimgl
pip install manimgl

# Try it out
manimgl
```
Example 4:
```python
# Install python requirements
pip install -e .

# Try it out
manimgl example_scenes.py OpeningManimExample
# or
manim-render example_scenes.py OpeningManimExample
```
Example 5:
```python
git clone https://github.com/3b1b/manim.git
cd manim
pip install -e .
manimgl example_scenes.py OpeningManimExample
```
Example 6:
```python
git clone https://github.com/3b1b/manim.git
cd manim
conda create -n manim python=3.8
conda activate manim
pip install -e .
```

================================================================================

=== Installation - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/installation.html#install-ffmepeg-linux
Content:
Installation
¶
Manim runs on Python 3.7 or higher.
System requirements are：
FFmpeg
OpenGL
(included in python package
PyOpenGL
)
LaTeX
(optional, if you want to use LaTeX)
Pango
(only for Linux)
Install FFmpeg
¶
Install FFmpeg Windows
¶
choco install ffmpeg
# Install FFmepeg Linux
¶
$
sudo
apt
update
$
sudo
apt
install
ffmpeg
$
ffmpeg
-version
# Install FFmpeg MacOS
¶
Download This ZIP file
`
https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full
.7z`(if the link is not working download this zip file from there original website)
Directly
¶
# Install manimgl
pip
install
manimgl
# Try it out
manimgl
If you want to hack on manimlib itself, clone this repository and in
that directory execute:
# Install python requirements
pip
install
-e
.
# Try it out
manimgl
example_scenes.py
OpeningManimExample
# or
manim-render
example_scenes.py
OpeningManimExample
If you run the above command and no error message appears,
then you have successfully installed all the environments required by manim.
Directly (Windows)
¶
Install
FFmpeg
, and make sure that its path is in the PATH environment variable.
Install a LaTeX distribution.
TeXLive-full
is recommended.
Install the remaining Python packages.
git
clone
https://github.com/3b1b/manim.git
cd
manim
pip
install
-e
.
manimgl
example_scenes.py
OpeningManimExample
For Anaconda
¶
Install FFmpeg and LaTeX as above.
Create a conda environment using
git
clone
https://github.com/3b1b/manim.git
cd
manim
conda
create
-n
manim
python
=
3
.8
conda
activate
manim
pip
install
-e
.
Contents
Installation
Install FFmpeg
Install FFmpeg Windows
# Install FFmepeg Linux
# Install FFmpeg MacOS
Directly
Directly (Windows)
For Anaconda

Code Examples:
Example 1:
```python
choco install ffmpeg
```
Example 2:
```python
$ sudo apt update
$ sudo apt install ffmpeg
$ ffmpeg -version
```
Example 3:
```python
# Install manimgl
pip install manimgl

# Try it out
manimgl
```
Example 4:
```python
# Install python requirements
pip install -e .

# Try it out
manimgl example_scenes.py OpeningManimExample
# or
manim-render example_scenes.py OpeningManimExample
```
Example 5:
```python
git clone https://github.com/3b1b/manim.git
cd manim
pip install -e .
manimgl example_scenes.py OpeningManimExample
```
Example 6:
```python
git clone https://github.com/3b1b/manim.git
cd manim
conda create -n manim python=3.8
conda activate manim
pip install -e .
```

================================================================================

=== Installation - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/installation.html#install-ffmpeg-macos
Content:
Installation
¶
Manim runs on Python 3.7 or higher.
System requirements are：
FFmpeg
OpenGL
(included in python package
PyOpenGL
)
LaTeX
(optional, if you want to use LaTeX)
Pango
(only for Linux)
Install FFmpeg
¶
Install FFmpeg Windows
¶
choco install ffmpeg
# Install FFmepeg Linux
¶
$
sudo
apt
update
$
sudo
apt
install
ffmpeg
$
ffmpeg
-version
# Install FFmpeg MacOS
¶
Download This ZIP file
`
https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full
.7z`(if the link is not working download this zip file from there original website)
Directly
¶
# Install manimgl
pip
install
manimgl
# Try it out
manimgl
If you want to hack on manimlib itself, clone this repository and in
that directory execute:
# Install python requirements
pip
install
-e
.
# Try it out
manimgl
example_scenes.py
OpeningManimExample
# or
manim-render
example_scenes.py
OpeningManimExample
If you run the above command and no error message appears,
then you have successfully installed all the environments required by manim.
Directly (Windows)
¶
Install
FFmpeg
, and make sure that its path is in the PATH environment variable.
Install a LaTeX distribution.
TeXLive-full
is recommended.
Install the remaining Python packages.
git
clone
https://github.com/3b1b/manim.git
cd
manim
pip
install
-e
.
manimgl
example_scenes.py
OpeningManimExample
For Anaconda
¶
Install FFmpeg and LaTeX as above.
Create a conda environment using
git
clone
https://github.com/3b1b/manim.git
cd
manim
conda
create
-n
manim
python
=
3
.8
conda
activate
manim
pip
install
-e
.
Contents
Installation
Install FFmpeg
Install FFmpeg Windows
# Install FFmepeg Linux
# Install FFmpeg MacOS
Directly
Directly (Windows)
For Anaconda

Code Examples:
Example 1:
```python
choco install ffmpeg
```
Example 2:
```python
$ sudo apt update
$ sudo apt install ffmpeg
$ ffmpeg -version
```
Example 3:
```python
# Install manimgl
pip install manimgl

# Try it out
manimgl
```
Example 4:
```python
# Install python requirements
pip install -e .

# Try it out
manimgl example_scenes.py OpeningManimExample
# or
manim-render example_scenes.py OpeningManimExample
```
Example 5:
```python
git clone https://github.com/3b1b/manim.git
cd manim
pip install -e .
manimgl example_scenes.py OpeningManimExample
```
Example 6:
```python
git clone https://github.com/3b1b/manim.git
cd manim
conda create -n manim python=3.8
conda activate manim
pip install -e .
```

================================================================================

=== Installation - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/installation.html#directly
Content:
Installation
¶
Manim runs on Python 3.7 or higher.
System requirements are：
FFmpeg
OpenGL
(included in python package
PyOpenGL
)
LaTeX
(optional, if you want to use LaTeX)
Pango
(only for Linux)
Install FFmpeg
¶
Install FFmpeg Windows
¶
choco install ffmpeg
# Install FFmepeg Linux
¶
$
sudo
apt
update
$
sudo
apt
install
ffmpeg
$
ffmpeg
-version
# Install FFmpeg MacOS
¶
Download This ZIP file
`
https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full
.7z`(if the link is not working download this zip file from there original website)
Directly
¶
# Install manimgl
pip
install
manimgl
# Try it out
manimgl
If you want to hack on manimlib itself, clone this repository and in
that directory execute:
# Install python requirements
pip
install
-e
.
# Try it out
manimgl
example_scenes.py
OpeningManimExample
# or
manim-render
example_scenes.py
OpeningManimExample
If you run the above command and no error message appears,
then you have successfully installed all the environments required by manim.
Directly (Windows)
¶
Install
FFmpeg
, and make sure that its path is in the PATH environment variable.
Install a LaTeX distribution.
TeXLive-full
is recommended.
Install the remaining Python packages.
git
clone
https://github.com/3b1b/manim.git
cd
manim
pip
install
-e
.
manimgl
example_scenes.py
OpeningManimExample
For Anaconda
¶
Install FFmpeg and LaTeX as above.
Create a conda environment using
git
clone
https://github.com/3b1b/manim.git
cd
manim
conda
create
-n
manim
python
=
3
.8
conda
activate
manim
pip
install
-e
.
Contents
Installation
Install FFmpeg
Install FFmpeg Windows
# Install FFmepeg Linux
# Install FFmpeg MacOS
Directly
Directly (Windows)
For Anaconda

Code Examples:
Example 1:
```python
choco install ffmpeg
```
Example 2:
```python
$ sudo apt update
$ sudo apt install ffmpeg
$ ffmpeg -version
```
Example 3:
```python
# Install manimgl
pip install manimgl

# Try it out
manimgl
```
Example 4:
```python
# Install python requirements
pip install -e .

# Try it out
manimgl example_scenes.py OpeningManimExample
# or
manim-render example_scenes.py OpeningManimExample
```
Example 5:
```python
git clone https://github.com/3b1b/manim.git
cd manim
pip install -e .
manimgl example_scenes.py OpeningManimExample
```
Example 6:
```python
git clone https://github.com/3b1b/manim.git
cd manim
conda create -n manim python=3.8
conda activate manim
pip install -e .
```

================================================================================

=== Installation - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/installation.html#directly-windows
Content:
Installation
¶
Manim runs on Python 3.7 or higher.
System requirements are：
FFmpeg
OpenGL
(included in python package
PyOpenGL
)
LaTeX
(optional, if you want to use LaTeX)
Pango
(only for Linux)
Install FFmpeg
¶
Install FFmpeg Windows
¶
choco install ffmpeg
# Install FFmepeg Linux
¶
$
sudo
apt
update
$
sudo
apt
install
ffmpeg
$
ffmpeg
-version
# Install FFmpeg MacOS
¶
Download This ZIP file
`
https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full
.7z`(if the link is not working download this zip file from there original website)
Directly
¶
# Install manimgl
pip
install
manimgl
# Try it out
manimgl
If you want to hack on manimlib itself, clone this repository and in
that directory execute:
# Install python requirements
pip
install
-e
.
# Try it out
manimgl
example_scenes.py
OpeningManimExample
# or
manim-render
example_scenes.py
OpeningManimExample
If you run the above command and no error message appears,
then you have successfully installed all the environments required by manim.
Directly (Windows)
¶
Install
FFmpeg
, and make sure that its path is in the PATH environment variable.
Install a LaTeX distribution.
TeXLive-full
is recommended.
Install the remaining Python packages.
git
clone
https://github.com/3b1b/manim.git
cd
manim
pip
install
-e
.
manimgl
example_scenes.py
OpeningManimExample
For Anaconda
¶
Install FFmpeg and LaTeX as above.
Create a conda environment using
git
clone
https://github.com/3b1b/manim.git
cd
manim
conda
create
-n
manim
python
=
3
.8
conda
activate
manim
pip
install
-e
.
Contents
Installation
Install FFmpeg
Install FFmpeg Windows
# Install FFmepeg Linux
# Install FFmpeg MacOS
Directly
Directly (Windows)
For Anaconda

Code Examples:
Example 1:
```python
choco install ffmpeg
```
Example 2:
```python
$ sudo apt update
$ sudo apt install ffmpeg
$ ffmpeg -version
```
Example 3:
```python
# Install manimgl
pip install manimgl

# Try it out
manimgl
```
Example 4:
```python
# Install python requirements
pip install -e .

# Try it out
manimgl example_scenes.py OpeningManimExample
# or
manim-render example_scenes.py OpeningManimExample
```
Example 5:
```python
git clone https://github.com/3b1b/manim.git
cd manim
pip install -e .
manimgl example_scenes.py OpeningManimExample
```
Example 6:
```python
git clone https://github.com/3b1b/manim.git
cd manim
conda create -n manim python=3.8
conda activate manim
pip install -e .
```

================================================================================

=== Installation - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/installation.html#for-anaconda
Content:
Installation
¶
Manim runs on Python 3.7 or higher.
System requirements are：
FFmpeg
OpenGL
(included in python package
PyOpenGL
)
LaTeX
(optional, if you want to use LaTeX)
Pango
(only for Linux)
Install FFmpeg
¶
Install FFmpeg Windows
¶
choco install ffmpeg
# Install FFmepeg Linux
¶
$
sudo
apt
update
$
sudo
apt
install
ffmpeg
$
ffmpeg
-version
# Install FFmpeg MacOS
¶
Download This ZIP file
`
https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full
.7z`(if the link is not working download this zip file from there original website)
Directly
¶
# Install manimgl
pip
install
manimgl
# Try it out
manimgl
If you want to hack on manimlib itself, clone this repository and in
that directory execute:
# Install python requirements
pip
install
-e
.
# Try it out
manimgl
example_scenes.py
OpeningManimExample
# or
manim-render
example_scenes.py
OpeningManimExample
If you run the above command and no error message appears,
then you have successfully installed all the environments required by manim.
Directly (Windows)
¶
Install
FFmpeg
, and make sure that its path is in the PATH environment variable.
Install a LaTeX distribution.
TeXLive-full
is recommended.
Install the remaining Python packages.
git
clone
https://github.com/3b1b/manim.git
cd
manim
pip
install
-e
.
manimgl
example_scenes.py
OpeningManimExample
For Anaconda
¶
Install FFmpeg and LaTeX as above.
Create a conda environment using
git
clone
https://github.com/3b1b/manim.git
cd
manim
conda
create
-n
manim
python
=
3
.8
conda
activate
manim
pip
install
-e
.
Contents
Installation
Install FFmpeg
Install FFmpeg Windows
# Install FFmepeg Linux
# Install FFmpeg MacOS
Directly
Directly (Windows)
For Anaconda

Code Examples:
Example 1:
```python
choco install ffmpeg
```
Example 2:
```python
$ sudo apt update
$ sudo apt install ffmpeg
$ ffmpeg -version
```
Example 3:
```python
# Install manimgl
pip install manimgl

# Try it out
manimgl
```
Example 4:
```python
# Install python requirements
pip install -e .

# Try it out
manimgl example_scenes.py OpeningManimExample
# or
manim-render example_scenes.py OpeningManimExample
```
Example 5:
```python
git clone https://github.com/3b1b/manim.git
cd manim
pip install -e .
manimgl example_scenes.py OpeningManimExample
```
Example 6:
```python
git clone https://github.com/3b1b/manim.git
cd manim
conda create -n manim python=3.8
conda activate manim
pip install -e .
```

================================================================================

=== Quick Start - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/quickstart.html#make-an-image
Content:
Quick Start
¶
After installing the manim environment according to the instructions on the
Installation
page, you can try to make a scene yourself from scratch.
First, create a new
.py
file (such as
start.py
) according to the following
directory structure:
manim/
├── manimlib/
│   ├── animation/
│   ├── ...
│   ├── default_config.yml
│   └── window.py
├── custom_config.yml
└── start.py
And paste the following code (I will explain the function of each line in detail later):
1
2
3
4
5
6
7
8
9
from
manimlib
import
*
class
SquareToCircle
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
self
.
add
(
circle
)
And run this command:
manimgl
start.py
SquareToCircle
A window will pop up on the screen. And then you can :
scroll the middle mouse button to move the screen up and down
hold down the
z
on the keyboard while scrolling the middle mouse button to zoom the screen
hold down the
s
key on the keyboard and move the mouse to pan the screen
hold down the
d
key on the keyboard and move the mouse to change the three-dimensional perspective.
Finally, you can close the window and exit the program by pressing
q
.
Run this command again:
manimgl
start.py
SquareToCircle
-os
At this time, no window will pop up. When the program is finished, this rendered
image will be automatically opened (saved in the subdirectory
images/
of the same
level directory of
start.py
by default):
Make an image
¶
Next, let’s take a detailed look at what each row does.
Line 1
:
from
manimlib
import
*
This will import all the classes that may be used when using manim.
Line 3
:
class
SquareToCircle
(
Scene
):
Create a
Scene
subclass
SquareToCircle
, which will be
the scene you write and render.
Line 4
:
def
construct
(
self
):
Write the
construct()
method, the content of which will determine
how to create the mobjects in the screen and what operations need to be performed.
Line 5
:
circle
=
Circle
()
Create a circle (an instance of the
Circle
class), called
circle
Line 6~7
:
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
Set the circle style by calling the circle’s method.
The
.set_fill()
method sets the fill color of this circle to blue (
BLUE
, defined in
constants
), and the fill transparency to 0.5.
The
.set_stroke()
method sets the stroke color of this circle to dark blue (
BLUE_E
, defined in
constants
), and the stroke width to 4.
Line 9
:
self
.
add
(
circle
)
Add this circle to the screen through the
.add()
method of
Scene
.
Add animations
¶
Let’s change some codes and add some animations to make videos instead of just pictures.
1
2
3
4
5
6
7
8
9
10
11
12
13
from
manimlib
import
*
class
SquareToCircle
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
square
=
Square
()
self
.
play
(
ShowCreation
(
square
))
self
.
wait
()
self
.
play
(
ReplacementTransform
(
square
,
circle
))
self
.
wait
()
Run this command this time:
manimgl
start.py
SquareToCircle
The pop-up window will play animations of drawing a square and transforming
it into a circle. If you want to save this video, run:
manimgl
start.py
SquareToCircle
-o
This time there will be no pop-up window, but the video file (saved in the subdirectory
videos/
of the same level directory of
start.py
by default) will be automatically
opened after the operation is over:
Let’s take a look at the code this time. The first 7 lines are the same as the previous
ones, and the 8th line is similar to the 5th line, which creates an instance of the
Square
class and named it
square
.
Line 10
:
self
.
play
(
ShowCreation
(
square
))
An animation is played through
Scene
’s
.play()
method.
ShowCreation
is an animation that shows the process of creating a given mobject.
self.play(ShowCreation(square))
is to play the animation of creating
square
.
Line 11
:
self
.
wait
()
Use
Scene
’s
.wait()
method to pause (default 1s), you can pass in
parameters to indicate the pause time (for example,
self.wait(3)
means pause for 3s).
Line 12
:
self
.
play
(
ReplacementTransform
(
square
,
circle
))
Play the animation that transforms
square
into
circle
.
ReplacementTransform(A,
B)
means to transform A into B’s pattern and replace A with B.
Line 13
: Same as line 11, pause for 1s.
Enable interaction
¶
Interaction is a new feature of the new version. You can add the following line
at the end of the code to enable interaction:
self
.
embed
()
Then run
manimgl
start.py
SquareToCircle
.
After the previous animation is executed, the ipython terminal will be opened on
the command line. After that, you can continue to write code in it, and the statement
you entered will be executed immediately after pressing
Enter
.
For example: input the following lines (without comment lines) into it respectively
(
self.play
can be abbreviated as
play
in this mode):
# Stretched 4 times in the vertical direction
play
(
circle
.
animate
.
stretch
(
4
,
dim
=
0
))
# Rotate the ellipse 90°
play
(
Rotate
(
circle
,
TAU
/
4
))
# Move 2 units to the right and shrink to 1/4 of the original
play
(
circle
.
animate
.
shift
(
2
*
RIGHT
),
circle
.
animate
.
scale
(
0.25
))
# Insert 10 curves into circle for non-linear transformation (no animation will play)
circle
.
insert_n_curves
(
10
)
# Apply a complex transformation of f(z)=z^2 to all points on the circle
play
(
circle
.
animate
.
apply_complex_function
(
lambda
z
:
z
**
2
))
# Close the window and exit the program
exit
()
You will get an animation similar to the following:
If you want to enter the interactive mode directly, you don’t have to write an
empty scene containing only
self.embed()
, you can directly run the following command
(this will enter the ipython terminal while the window pops up):
manimgl
You succeeded!
¶
After reading the above content, you already know how to use manim.
Below you can see some examples, in the
Example Scenes
page.
But before that, you’d better have a look at the
CLI flags and configuration
of manim.
Contents
Quick Start
Make an image
Add animations
Enable interaction
You succeeded!

Code Examples:
Example 1:
```python
manim/
├── manimlib/
│   ├── animation/
│   ├── ...
│   ├── default_config.yml
│   └── window.py
├── custom_config.yml
└── start.py
```
Example 2:
```python
1
2
3
4
5
6
7
8
9
```
Example 3:
```python
from manimlib import *

class SquareToCircle(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)

        self.add(circle)
```
Example 4:
```python
manimgl start.py SquareToCircle
```
Example 5:
```python
manimgl start.py SquareToCircle -os
```
Example 6:
```python
from manimlib import *
```
Example 7:
```python
class SquareToCircle(Scene):
```
Example 8:
```python
SquareToCircle
```
Example 9:
```python
def construct(self):
```
Example 10:
```python
construct()
```
Example 11:
```python
circle = Circle()
```
Example 12:
```python
circle.set_fill(BLUE, opacity=0.5)
circle.set_stroke(BLUE_E, width=4)
```
Example 13:
```python
.set_fill()
```
Example 14:
```python
.set_stroke()
```
Example 15:
```python
self.add(circle)
```
Example 16:
```python
1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
```
Example 17:
```python
from manimlib import *

class SquareToCircle(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)
        square = Square()

        self.play(ShowCreation(square))
        self.wait()
        self.play(ReplacementTransform(square, circle))
        self.wait()
```
Example 18:
```python
manimgl start.py SquareToCircle
```
Example 19:
```python
manimgl start.py SquareToCircle -o
```
Example 20:
```python
self.play(ShowCreation(square))
```
Example 21:
```python
ShowCreation
```
Example 22:
```python
self.play(ShowCreation(square))
```
Example 23:
```python
self.wait()
```
Example 24:
```python
self.wait(3)
```
Example 25:
```python
self.play(ReplacementTransform(square, circle))
```
Example 26:
```python
ReplacementTransform(A, B)
```
Example 27:
```python
self.embed()
```
Example 28:
```python
manimgl start.py SquareToCircle
```
Example 29:
```python
# Stretched 4 times in the vertical direction
play(circle.animate.stretch(4, dim=0))
# Rotate the ellipse 90°
play(Rotate(circle, TAU / 4))
# Move 2 units to the right and shrink to 1/4 of the original
play(circle.animate.shift(2 * RIGHT), circle.animate.scale(0.25))
# Insert 10 curves into circle for non-linear transformation (no animation will play)
circle.insert_n_curves(10)
# Apply a complex transformation of f(z)=z^2 to all points on the circle
play(circle.animate.apply_complex_function(lambda z: z**2))
# Close the window and exit the program
exit()
```
Example 30:
```python
self.embed()
```

================================================================================

=== Quick Start - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/quickstart.html#add-animations
Content:
Quick Start
¶
After installing the manim environment according to the instructions on the
Installation
page, you can try to make a scene yourself from scratch.
First, create a new
.py
file (such as
start.py
) according to the following
directory structure:
manim/
├── manimlib/
│   ├── animation/
│   ├── ...
│   ├── default_config.yml
│   └── window.py
├── custom_config.yml
└── start.py
And paste the following code (I will explain the function of each line in detail later):
1
2
3
4
5
6
7
8
9
from
manimlib
import
*
class
SquareToCircle
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
self
.
add
(
circle
)
And run this command:
manimgl
start.py
SquareToCircle
A window will pop up on the screen. And then you can :
scroll the middle mouse button to move the screen up and down
hold down the
z
on the keyboard while scrolling the middle mouse button to zoom the screen
hold down the
s
key on the keyboard and move the mouse to pan the screen
hold down the
d
key on the keyboard and move the mouse to change the three-dimensional perspective.
Finally, you can close the window and exit the program by pressing
q
.
Run this command again:
manimgl
start.py
SquareToCircle
-os
At this time, no window will pop up. When the program is finished, this rendered
image will be automatically opened (saved in the subdirectory
images/
of the same
level directory of
start.py
by default):
Make an image
¶
Next, let’s take a detailed look at what each row does.
Line 1
:
from
manimlib
import
*
This will import all the classes that may be used when using manim.
Line 3
:
class
SquareToCircle
(
Scene
):
Create a
Scene
subclass
SquareToCircle
, which will be
the scene you write and render.
Line 4
:
def
construct
(
self
):
Write the
construct()
method, the content of which will determine
how to create the mobjects in the screen and what operations need to be performed.
Line 5
:
circle
=
Circle
()
Create a circle (an instance of the
Circle
class), called
circle
Line 6~7
:
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
Set the circle style by calling the circle’s method.
The
.set_fill()
method sets the fill color of this circle to blue (
BLUE
, defined in
constants
), and the fill transparency to 0.5.
The
.set_stroke()
method sets the stroke color of this circle to dark blue (
BLUE_E
, defined in
constants
), and the stroke width to 4.
Line 9
:
self
.
add
(
circle
)
Add this circle to the screen through the
.add()
method of
Scene
.
Add animations
¶
Let’s change some codes and add some animations to make videos instead of just pictures.
1
2
3
4
5
6
7
8
9
10
11
12
13
from
manimlib
import
*
class
SquareToCircle
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
square
=
Square
()
self
.
play
(
ShowCreation
(
square
))
self
.
wait
()
self
.
play
(
ReplacementTransform
(
square
,
circle
))
self
.
wait
()
Run this command this time:
manimgl
start.py
SquareToCircle
The pop-up window will play animations of drawing a square and transforming
it into a circle. If you want to save this video, run:
manimgl
start.py
SquareToCircle
-o
This time there will be no pop-up window, but the video file (saved in the subdirectory
videos/
of the same level directory of
start.py
by default) will be automatically
opened after the operation is over:
Let’s take a look at the code this time. The first 7 lines are the same as the previous
ones, and the 8th line is similar to the 5th line, which creates an instance of the
Square
class and named it
square
.
Line 10
:
self
.
play
(
ShowCreation
(
square
))
An animation is played through
Scene
’s
.play()
method.
ShowCreation
is an animation that shows the process of creating a given mobject.
self.play(ShowCreation(square))
is to play the animation of creating
square
.
Line 11
:
self
.
wait
()
Use
Scene
’s
.wait()
method to pause (default 1s), you can pass in
parameters to indicate the pause time (for example,
self.wait(3)
means pause for 3s).
Line 12
:
self
.
play
(
ReplacementTransform
(
square
,
circle
))
Play the animation that transforms
square
into
circle
.
ReplacementTransform(A,
B)
means to transform A into B’s pattern and replace A with B.
Line 13
: Same as line 11, pause for 1s.
Enable interaction
¶
Interaction is a new feature of the new version. You can add the following line
at the end of the code to enable interaction:
self
.
embed
()
Then run
manimgl
start.py
SquareToCircle
.
After the previous animation is executed, the ipython terminal will be opened on
the command line. After that, you can continue to write code in it, and the statement
you entered will be executed immediately after pressing
Enter
.
For example: input the following lines (without comment lines) into it respectively
(
self.play
can be abbreviated as
play
in this mode):
# Stretched 4 times in the vertical direction
play
(
circle
.
animate
.
stretch
(
4
,
dim
=
0
))
# Rotate the ellipse 90°
play
(
Rotate
(
circle
,
TAU
/
4
))
# Move 2 units to the right and shrink to 1/4 of the original
play
(
circle
.
animate
.
shift
(
2
*
RIGHT
),
circle
.
animate
.
scale
(
0.25
))
# Insert 10 curves into circle for non-linear transformation (no animation will play)
circle
.
insert_n_curves
(
10
)
# Apply a complex transformation of f(z)=z^2 to all points on the circle
play
(
circle
.
animate
.
apply_complex_function
(
lambda
z
:
z
**
2
))
# Close the window and exit the program
exit
()
You will get an animation similar to the following:
If you want to enter the interactive mode directly, you don’t have to write an
empty scene containing only
self.embed()
, you can directly run the following command
(this will enter the ipython terminal while the window pops up):
manimgl
You succeeded!
¶
After reading the above content, you already know how to use manim.
Below you can see some examples, in the
Example Scenes
page.
But before that, you’d better have a look at the
CLI flags and configuration
of manim.
Contents
Quick Start
Make an image
Add animations
Enable interaction
You succeeded!

Code Examples:
Example 1:
```python
manim/
├── manimlib/
│   ├── animation/
│   ├── ...
│   ├── default_config.yml
│   └── window.py
├── custom_config.yml
└── start.py
```
Example 2:
```python
1
2
3
4
5
6
7
8
9
```
Example 3:
```python
from manimlib import *

class SquareToCircle(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)

        self.add(circle)
```
Example 4:
```python
manimgl start.py SquareToCircle
```
Example 5:
```python
manimgl start.py SquareToCircle -os
```
Example 6:
```python
from manimlib import *
```
Example 7:
```python
class SquareToCircle(Scene):
```
Example 8:
```python
SquareToCircle
```
Example 9:
```python
def construct(self):
```
Example 10:
```python
construct()
```
Example 11:
```python
circle = Circle()
```
Example 12:
```python
circle.set_fill(BLUE, opacity=0.5)
circle.set_stroke(BLUE_E, width=4)
```
Example 13:
```python
.set_fill()
```
Example 14:
```python
.set_stroke()
```
Example 15:
```python
self.add(circle)
```
Example 16:
```python
1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
```
Example 17:
```python
from manimlib import *

class SquareToCircle(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)
        square = Square()

        self.play(ShowCreation(square))
        self.wait()
        self.play(ReplacementTransform(square, circle))
        self.wait()
```
Example 18:
```python
manimgl start.py SquareToCircle
```
Example 19:
```python
manimgl start.py SquareToCircle -o
```
Example 20:
```python
self.play(ShowCreation(square))
```
Example 21:
```python
ShowCreation
```
Example 22:
```python
self.play(ShowCreation(square))
```
Example 23:
```python
self.wait()
```
Example 24:
```python
self.wait(3)
```
Example 25:
```python
self.play(ReplacementTransform(square, circle))
```
Example 26:
```python
ReplacementTransform(A, B)
```
Example 27:
```python
self.embed()
```
Example 28:
```python
manimgl start.py SquareToCircle
```
Example 29:
```python
# Stretched 4 times in the vertical direction
play(circle.animate.stretch(4, dim=0))
# Rotate the ellipse 90°
play(Rotate(circle, TAU / 4))
# Move 2 units to the right and shrink to 1/4 of the original
play(circle.animate.shift(2 * RIGHT), circle.animate.scale(0.25))
# Insert 10 curves into circle for non-linear transformation (no animation will play)
circle.insert_n_curves(10)
# Apply a complex transformation of f(z)=z^2 to all points on the circle
play(circle.animate.apply_complex_function(lambda z: z**2))
# Close the window and exit the program
exit()
```
Example 30:
```python
self.embed()
```

================================================================================

=== Quick Start - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/quickstart.html#enable-interaction
Content:
Quick Start
¶
After installing the manim environment according to the instructions on the
Installation
page, you can try to make a scene yourself from scratch.
First, create a new
.py
file (such as
start.py
) according to the following
directory structure:
manim/
├── manimlib/
│   ├── animation/
│   ├── ...
│   ├── default_config.yml
│   └── window.py
├── custom_config.yml
└── start.py
And paste the following code (I will explain the function of each line in detail later):
1
2
3
4
5
6
7
8
9
from
manimlib
import
*
class
SquareToCircle
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
self
.
add
(
circle
)
And run this command:
manimgl
start.py
SquareToCircle
A window will pop up on the screen. And then you can :
scroll the middle mouse button to move the screen up and down
hold down the
z
on the keyboard while scrolling the middle mouse button to zoom the screen
hold down the
s
key on the keyboard and move the mouse to pan the screen
hold down the
d
key on the keyboard and move the mouse to change the three-dimensional perspective.
Finally, you can close the window and exit the program by pressing
q
.
Run this command again:
manimgl
start.py
SquareToCircle
-os
At this time, no window will pop up. When the program is finished, this rendered
image will be automatically opened (saved in the subdirectory
images/
of the same
level directory of
start.py
by default):
Make an image
¶
Next, let’s take a detailed look at what each row does.
Line 1
:
from
manimlib
import
*
This will import all the classes that may be used when using manim.
Line 3
:
class
SquareToCircle
(
Scene
):
Create a
Scene
subclass
SquareToCircle
, which will be
the scene you write and render.
Line 4
:
def
construct
(
self
):
Write the
construct()
method, the content of which will determine
how to create the mobjects in the screen and what operations need to be performed.
Line 5
:
circle
=
Circle
()
Create a circle (an instance of the
Circle
class), called
circle
Line 6~7
:
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
Set the circle style by calling the circle’s method.
The
.set_fill()
method sets the fill color of this circle to blue (
BLUE
, defined in
constants
), and the fill transparency to 0.5.
The
.set_stroke()
method sets the stroke color of this circle to dark blue (
BLUE_E
, defined in
constants
), and the stroke width to 4.
Line 9
:
self
.
add
(
circle
)
Add this circle to the screen through the
.add()
method of
Scene
.
Add animations
¶
Let’s change some codes and add some animations to make videos instead of just pictures.
1
2
3
4
5
6
7
8
9
10
11
12
13
from
manimlib
import
*
class
SquareToCircle
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
square
=
Square
()
self
.
play
(
ShowCreation
(
square
))
self
.
wait
()
self
.
play
(
ReplacementTransform
(
square
,
circle
))
self
.
wait
()
Run this command this time:
manimgl
start.py
SquareToCircle
The pop-up window will play animations of drawing a square and transforming
it into a circle. If you want to save this video, run:
manimgl
start.py
SquareToCircle
-o
This time there will be no pop-up window, but the video file (saved in the subdirectory
videos/
of the same level directory of
start.py
by default) will be automatically
opened after the operation is over:
Let’s take a look at the code this time. The first 7 lines are the same as the previous
ones, and the 8th line is similar to the 5th line, which creates an instance of the
Square
class and named it
square
.
Line 10
:
self
.
play
(
ShowCreation
(
square
))
An animation is played through
Scene
’s
.play()
method.
ShowCreation
is an animation that shows the process of creating a given mobject.
self.play(ShowCreation(square))
is to play the animation of creating
square
.
Line 11
:
self
.
wait
()
Use
Scene
’s
.wait()
method to pause (default 1s), you can pass in
parameters to indicate the pause time (for example,
self.wait(3)
means pause for 3s).
Line 12
:
self
.
play
(
ReplacementTransform
(
square
,
circle
))
Play the animation that transforms
square
into
circle
.
ReplacementTransform(A,
B)
means to transform A into B’s pattern and replace A with B.
Line 13
: Same as line 11, pause for 1s.
Enable interaction
¶
Interaction is a new feature of the new version. You can add the following line
at the end of the code to enable interaction:
self
.
embed
()
Then run
manimgl
start.py
SquareToCircle
.
After the previous animation is executed, the ipython terminal will be opened on
the command line. After that, you can continue to write code in it, and the statement
you entered will be executed immediately after pressing
Enter
.
For example: input the following lines (without comment lines) into it respectively
(
self.play
can be abbreviated as
play
in this mode):
# Stretched 4 times in the vertical direction
play
(
circle
.
animate
.
stretch
(
4
,
dim
=
0
))
# Rotate the ellipse 90°
play
(
Rotate
(
circle
,
TAU
/
4
))
# Move 2 units to the right and shrink to 1/4 of the original
play
(
circle
.
animate
.
shift
(
2
*
RIGHT
),
circle
.
animate
.
scale
(
0.25
))
# Insert 10 curves into circle for non-linear transformation (no animation will play)
circle
.
insert_n_curves
(
10
)
# Apply a complex transformation of f(z)=z^2 to all points on the circle
play
(
circle
.
animate
.
apply_complex_function
(
lambda
z
:
z
**
2
))
# Close the window and exit the program
exit
()
You will get an animation similar to the following:
If you want to enter the interactive mode directly, you don’t have to write an
empty scene containing only
self.embed()
, you can directly run the following command
(this will enter the ipython terminal while the window pops up):
manimgl
You succeeded!
¶
After reading the above content, you already know how to use manim.
Below you can see some examples, in the
Example Scenes
page.
But before that, you’d better have a look at the
CLI flags and configuration
of manim.
Contents
Quick Start
Make an image
Add animations
Enable interaction
You succeeded!

Code Examples:
Example 1:
```python
manim/
├── manimlib/
│   ├── animation/
│   ├── ...
│   ├── default_config.yml
│   └── window.py
├── custom_config.yml
└── start.py
```
Example 2:
```python
1
2
3
4
5
6
7
8
9
```
Example 3:
```python
from manimlib import *

class SquareToCircle(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)

        self.add(circle)
```
Example 4:
```python
manimgl start.py SquareToCircle
```
Example 5:
```python
manimgl start.py SquareToCircle -os
```
Example 6:
```python
from manimlib import *
```
Example 7:
```python
class SquareToCircle(Scene):
```
Example 8:
```python
SquareToCircle
```
Example 9:
```python
def construct(self):
```
Example 10:
```python
construct()
```
Example 11:
```python
circle = Circle()
```
Example 12:
```python
circle.set_fill(BLUE, opacity=0.5)
circle.set_stroke(BLUE_E, width=4)
```
Example 13:
```python
.set_fill()
```
Example 14:
```python
.set_stroke()
```
Example 15:
```python
self.add(circle)
```
Example 16:
```python
1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
```
Example 17:
```python
from manimlib import *

class SquareToCircle(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)
        square = Square()

        self.play(ShowCreation(square))
        self.wait()
        self.play(ReplacementTransform(square, circle))
        self.wait()
```
Example 18:
```python
manimgl start.py SquareToCircle
```
Example 19:
```python
manimgl start.py SquareToCircle -o
```
Example 20:
```python
self.play(ShowCreation(square))
```
Example 21:
```python
ShowCreation
```
Example 22:
```python
self.play(ShowCreation(square))
```
Example 23:
```python
self.wait()
```
Example 24:
```python
self.wait(3)
```
Example 25:
```python
self.play(ReplacementTransform(square, circle))
```
Example 26:
```python
ReplacementTransform(A, B)
```
Example 27:
```python
self.embed()
```
Example 28:
```python
manimgl start.py SquareToCircle
```
Example 29:
```python
# Stretched 4 times in the vertical direction
play(circle.animate.stretch(4, dim=0))
# Rotate the ellipse 90°
play(Rotate(circle, TAU / 4))
# Move 2 units to the right and shrink to 1/4 of the original
play(circle.animate.shift(2 * RIGHT), circle.animate.scale(0.25))
# Insert 10 curves into circle for non-linear transformation (no animation will play)
circle.insert_n_curves(10)
# Apply a complex transformation of f(z)=z^2 to all points on the circle
play(circle.animate.apply_complex_function(lambda z: z**2))
# Close the window and exit the program
exit()
```
Example 30:
```python
self.embed()
```

================================================================================

=== Quick Start - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/quickstart.html#you-succeeded
Content:
Quick Start
¶
After installing the manim environment according to the instructions on the
Installation
page, you can try to make a scene yourself from scratch.
First, create a new
.py
file (such as
start.py
) according to the following
directory structure:
manim/
├── manimlib/
│   ├── animation/
│   ├── ...
│   ├── default_config.yml
│   └── window.py
├── custom_config.yml
└── start.py
And paste the following code (I will explain the function of each line in detail later):
1
2
3
4
5
6
7
8
9
from
manimlib
import
*
class
SquareToCircle
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
self
.
add
(
circle
)
And run this command:
manimgl
start.py
SquareToCircle
A window will pop up on the screen. And then you can :
scroll the middle mouse button to move the screen up and down
hold down the
z
on the keyboard while scrolling the middle mouse button to zoom the screen
hold down the
s
key on the keyboard and move the mouse to pan the screen
hold down the
d
key on the keyboard and move the mouse to change the three-dimensional perspective.
Finally, you can close the window and exit the program by pressing
q
.
Run this command again:
manimgl
start.py
SquareToCircle
-os
At this time, no window will pop up. When the program is finished, this rendered
image will be automatically opened (saved in the subdirectory
images/
of the same
level directory of
start.py
by default):
Make an image
¶
Next, let’s take a detailed look at what each row does.
Line 1
:
from
manimlib
import
*
This will import all the classes that may be used when using manim.
Line 3
:
class
SquareToCircle
(
Scene
):
Create a
Scene
subclass
SquareToCircle
, which will be
the scene you write and render.
Line 4
:
def
construct
(
self
):
Write the
construct()
method, the content of which will determine
how to create the mobjects in the screen and what operations need to be performed.
Line 5
:
circle
=
Circle
()
Create a circle (an instance of the
Circle
class), called
circle
Line 6~7
:
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
Set the circle style by calling the circle’s method.
The
.set_fill()
method sets the fill color of this circle to blue (
BLUE
, defined in
constants
), and the fill transparency to 0.5.
The
.set_stroke()
method sets the stroke color of this circle to dark blue (
BLUE_E
, defined in
constants
), and the stroke width to 4.
Line 9
:
self
.
add
(
circle
)
Add this circle to the screen through the
.add()
method of
Scene
.
Add animations
¶
Let’s change some codes and add some animations to make videos instead of just pictures.
1
2
3
4
5
6
7
8
9
10
11
12
13
from
manimlib
import
*
class
SquareToCircle
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
square
=
Square
()
self
.
play
(
ShowCreation
(
square
))
self
.
wait
()
self
.
play
(
ReplacementTransform
(
square
,
circle
))
self
.
wait
()
Run this command this time:
manimgl
start.py
SquareToCircle
The pop-up window will play animations of drawing a square and transforming
it into a circle. If you want to save this video, run:
manimgl
start.py
SquareToCircle
-o
This time there will be no pop-up window, but the video file (saved in the subdirectory
videos/
of the same level directory of
start.py
by default) will be automatically
opened after the operation is over:
Let’s take a look at the code this time. The first 7 lines are the same as the previous
ones, and the 8th line is similar to the 5th line, which creates an instance of the
Square
class and named it
square
.
Line 10
:
self
.
play
(
ShowCreation
(
square
))
An animation is played through
Scene
’s
.play()
method.
ShowCreation
is an animation that shows the process of creating a given mobject.
self.play(ShowCreation(square))
is to play the animation of creating
square
.
Line 11
:
self
.
wait
()
Use
Scene
’s
.wait()
method to pause (default 1s), you can pass in
parameters to indicate the pause time (for example,
self.wait(3)
means pause for 3s).
Line 12
:
self
.
play
(
ReplacementTransform
(
square
,
circle
))
Play the animation that transforms
square
into
circle
.
ReplacementTransform(A,
B)
means to transform A into B’s pattern and replace A with B.
Line 13
: Same as line 11, pause for 1s.
Enable interaction
¶
Interaction is a new feature of the new version. You can add the following line
at the end of the code to enable interaction:
self
.
embed
()
Then run
manimgl
start.py
SquareToCircle
.
After the previous animation is executed, the ipython terminal will be opened on
the command line. After that, you can continue to write code in it, and the statement
you entered will be executed immediately after pressing
Enter
.
For example: input the following lines (without comment lines) into it respectively
(
self.play
can be abbreviated as
play
in this mode):
# Stretched 4 times in the vertical direction
play
(
circle
.
animate
.
stretch
(
4
,
dim
=
0
))
# Rotate the ellipse 90°
play
(
Rotate
(
circle
,
TAU
/
4
))
# Move 2 units to the right and shrink to 1/4 of the original
play
(
circle
.
animate
.
shift
(
2
*
RIGHT
),
circle
.
animate
.
scale
(
0.25
))
# Insert 10 curves into circle for non-linear transformation (no animation will play)
circle
.
insert_n_curves
(
10
)
# Apply a complex transformation of f(z)=z^2 to all points on the circle
play
(
circle
.
animate
.
apply_complex_function
(
lambda
z
:
z
**
2
))
# Close the window and exit the program
exit
()
You will get an animation similar to the following:
If you want to enter the interactive mode directly, you don’t have to write an
empty scene containing only
self.embed()
, you can directly run the following command
(this will enter the ipython terminal while the window pops up):
manimgl
You succeeded!
¶
After reading the above content, you already know how to use manim.
Below you can see some examples, in the
Example Scenes
page.
But before that, you’d better have a look at the
CLI flags and configuration
of manim.
Contents
Quick Start
Make an image
Add animations
Enable interaction
You succeeded!

Code Examples:
Example 1:
```python
manim/
├── manimlib/
│   ├── animation/
│   ├── ...
│   ├── default_config.yml
│   └── window.py
├── custom_config.yml
└── start.py
```
Example 2:
```python
1
2
3
4
5
6
7
8
9
```
Example 3:
```python
from manimlib import *

class SquareToCircle(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)

        self.add(circle)
```
Example 4:
```python
manimgl start.py SquareToCircle
```
Example 5:
```python
manimgl start.py SquareToCircle -os
```
Example 6:
```python
from manimlib import *
```
Example 7:
```python
class SquareToCircle(Scene):
```
Example 8:
```python
SquareToCircle
```
Example 9:
```python
def construct(self):
```
Example 10:
```python
construct()
```
Example 11:
```python
circle = Circle()
```
Example 12:
```python
circle.set_fill(BLUE, opacity=0.5)
circle.set_stroke(BLUE_E, width=4)
```
Example 13:
```python
.set_fill()
```
Example 14:
```python
.set_stroke()
```
Example 15:
```python
self.add(circle)
```
Example 16:
```python
1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
```
Example 17:
```python
from manimlib import *

class SquareToCircle(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)
        square = Square()

        self.play(ShowCreation(square))
        self.wait()
        self.play(ReplacementTransform(square, circle))
        self.wait()
```
Example 18:
```python
manimgl start.py SquareToCircle
```
Example 19:
```python
manimgl start.py SquareToCircle -o
```
Example 20:
```python
self.play(ShowCreation(square))
```
Example 21:
```python
ShowCreation
```
Example 22:
```python
self.play(ShowCreation(square))
```
Example 23:
```python
self.wait()
```
Example 24:
```python
self.wait(3)
```
Example 25:
```python
self.play(ReplacementTransform(square, circle))
```
Example 26:
```python
ReplacementTransform(A, B)
```
Example 27:
```python
self.embed()
```
Example 28:
```python
manimgl start.py SquareToCircle
```
Example 29:
```python
# Stretched 4 times in the vertical direction
play(circle.animate.stretch(4, dim=0))
# Rotate the ellipse 90°
play(Rotate(circle, TAU / 4))
# Move 2 units to the right and shrink to 1/4 of the original
play(circle.animate.shift(2 * RIGHT), circle.animate.scale(0.25))
# Insert 10 curves into circle for non-linear transformation (no animation will play)
circle.insert_n_curves(10)
# Apply a complex transformation of f(z)=z^2 to all points on the circle
play(circle.animate.apply_complex_function(lambda z: z**2))
# Close the window and exit the program
exit()
```
Example 30:
```python
self.embed()
```

================================================================================

=== CLI flags and configuration - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/configuration.html#command-line-interface
Content:
CLI flags and configuration
¶
Command Line Interface
¶
To run manim, you need to enter the directory at the same level as
manimlib/
and enter the command in the following format into terminal:
manimgl
<code>.py
<Scene>
<flags>
# or
manim-render
<code>.py
<Scene>
<flags>
<code>.py
: The python file you wrote. Needs to be at the same level as
manimlib/
, otherwise you need to use an absolute path or a relative path.
<Scene>
: The scene you want to render here. If it is not written or written incorrectly, it will list all for you to choose. And if there is only one
Scene
in the file, this class will be rendered directly.
<flags>
: CLI flags.
Some useful flags
¶
-w
to write the scene to a file.
-o
to write the scene to a file and open the result.
-s
to skip to the end and just show the final frame.
-so
will save the final frame to an image and show it.
-n
<number>
to skip ahead to the
n
’th animation of a scene.
-f
to make the playback window fullscreen.
All supported flags
¶
flag
abbr
function
--help
-h
Show the help message and exit
--version
-v
Display the version of manimgl
--write_file
-w
Render the scene as a movie file
--skip_animations
-s
Skip to the last frame
--low_quality
-l
Render at a low quality (for faster rendering)
--medium_quality
-m
Render at a medium quality
--hd
Render at a 1080p quality
--uhd
Render at a 4k quality
--full_screen
-f
Show window in full screen
--presenter_mode
-p
Scene will stay paused during wait calls until space bar or right arrow is hit, like a slide show
--save_pngs
-g
Save each frame as a png
--gif
-i
Save the video as gif
--transparent
-t
Render to a movie file with an alpha channel
--quiet
-q
--write_all
-a
Write all the scenes from a file
--open
-o
Automatically open the saved file once its done
--finder
Show the output file in finder
--config
Guide for automatic configuration
--file_name
FILE_NAME
Name for the movie or image file
--start_at_animation_number
START_AT_ANIMATION_NUMBER
-n
Start rendering not from the first animation, but from another, specified by its index. If you passing two comma separated values, e.g. “3,6”, it will end the rendering at the second value.
--embed
[EMBED]
-e
Creates a new file where the line
self.embed
is inserted into the Scenes construct method. If a string is passed in, the line will be inserted below the last line of code including that string.
--resolution
RESOLUTION
-r
Resolution, passed as “WxH”, e.g. “1920x1080”
--fps
FPS
Frame rate, as an integer
--color
COLOR
-c
Background color
--leave_progress_bars
Leave progress bars displayed in terminal
--video_dir
VIDEO_DIR
Directory to write video
--config_file
CONFIG_FILE
Path to the custom configuration file
--log-level
LOG_LEVEL
Level of messages to Display, can be DEBUG / INFO / WARNING / ERROR / CRITICAL
custom_config
¶
In order to perform more configuration (about directories, etc.) and permanently
change the default value (you don’t have to add flags to the command every time),
you can modify
custom_config.yml
. The meaning of each option is in
page
custom_config
.
You can also use different
custom_config.yml
for different directories, such as
following the directory structure:
manim/
├── manimlib/
│   ├── animation/
│   ├── ...
│   ├── default_config.yml
│   └── window.py
├── project/
│   ├── code.py
│   └── custom_config.yml
└── custom_config.yml
When you enter the
project/
folder and run
manimgl
code.py
<Scene>
,
it will overwrite
manim/default_config.yml
with
custom_config.yml
in the
project
folder.
Alternatively, you can use
--config_file
flag in CLI to specify configuration file manually.
manimgl
project/code.py
--config_file
/path/to/custom_config.yml
Contents
CLI flags and configuration
Command Line Interface
Some useful flags
All supported flags
custom_config

Code Examples:
Example 1:
```python
manimgl <code>.py <Scene> <flags>
# or
manim-render <code>.py <Scene> <flags>
```
Example 2:
```python
-n <number>
```
Example 3:
```python
--write_file
```
Example 4:
```python
--skip_animations
```
Example 5:
```python
--low_quality
```
Example 6:
```python
--medium_quality
```
Example 7:
```python
--full_screen
```
Example 8:
```python
--presenter_mode
```
Example 9:
```python
--save_pngs
```
Example 10:
```python
--transparent
```
Example 11:
```python
--write_all
```
Example 12:
```python
--file_name FILE_NAME
```
Example 13:
```python
--start_at_animation_number START_AT_ANIMATION_NUMBER
```
Example 14:
```python
--embed [EMBED]
```
Example 15:
```python
--resolution RESOLUTION
```
Example 16:
```python
--color COLOR
```
Example 17:
```python
--leave_progress_bars
```
Example 18:
```python
--video_dir VIDEO_DIR
```
Example 19:
```python
--config_file CONFIG_FILE
```
Example 20:
```python
--log-level LOG_LEVEL
```
Example 21:
```python
custom_config.yml
```
Example 22:
```python
custom_config.yml
```
Example 23:
```python
manim/
├── manimlib/
│   ├── animation/
│   ├── ...
│   ├── default_config.yml
│   └── window.py
├── project/
│   ├── code.py
│   └── custom_config.yml
└── custom_config.yml
```
Example 24:
```python
manimgl code.py <Scene>
```
Example 25:
```python
manim/default_config.yml
```
Example 26:
```python
custom_config.yml
```
Example 27:
```python
--config_file
```
Example 28:
```python
manimgl project/code.py --config_file /path/to/custom_config.yml
```

================================================================================

=== CLI flags and configuration - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/configuration.html#custom-config
Content:
CLI flags and configuration
¶
Command Line Interface
¶
To run manim, you need to enter the directory at the same level as
manimlib/
and enter the command in the following format into terminal:
manimgl
<code>.py
<Scene>
<flags>
# or
manim-render
<code>.py
<Scene>
<flags>
<code>.py
: The python file you wrote. Needs to be at the same level as
manimlib/
, otherwise you need to use an absolute path or a relative path.
<Scene>
: The scene you want to render here. If it is not written or written incorrectly, it will list all for you to choose. And if there is only one
Scene
in the file, this class will be rendered directly.
<flags>
: CLI flags.
Some useful flags
¶
-w
to write the scene to a file.
-o
to write the scene to a file and open the result.
-s
to skip to the end and just show the final frame.
-so
will save the final frame to an image and show it.
-n
<number>
to skip ahead to the
n
’th animation of a scene.
-f
to make the playback window fullscreen.
All supported flags
¶
flag
abbr
function
--help
-h
Show the help message and exit
--version
-v
Display the version of manimgl
--write_file
-w
Render the scene as a movie file
--skip_animations
-s
Skip to the last frame
--low_quality
-l
Render at a low quality (for faster rendering)
--medium_quality
-m
Render at a medium quality
--hd
Render at a 1080p quality
--uhd
Render at a 4k quality
--full_screen
-f
Show window in full screen
--presenter_mode
-p
Scene will stay paused during wait calls until space bar or right arrow is hit, like a slide show
--save_pngs
-g
Save each frame as a png
--gif
-i
Save the video as gif
--transparent
-t
Render to a movie file with an alpha channel
--quiet
-q
--write_all
-a
Write all the scenes from a file
--open
-o
Automatically open the saved file once its done
--finder
Show the output file in finder
--config
Guide for automatic configuration
--file_name
FILE_NAME
Name for the movie or image file
--start_at_animation_number
START_AT_ANIMATION_NUMBER
-n
Start rendering not from the first animation, but from another, specified by its index. If you passing two comma separated values, e.g. “3,6”, it will end the rendering at the second value.
--embed
[EMBED]
-e
Creates a new file where the line
self.embed
is inserted into the Scenes construct method. If a string is passed in, the line will be inserted below the last line of code including that string.
--resolution
RESOLUTION
-r
Resolution, passed as “WxH”, e.g. “1920x1080”
--fps
FPS
Frame rate, as an integer
--color
COLOR
-c
Background color
--leave_progress_bars
Leave progress bars displayed in terminal
--video_dir
VIDEO_DIR
Directory to write video
--config_file
CONFIG_FILE
Path to the custom configuration file
--log-level
LOG_LEVEL
Level of messages to Display, can be DEBUG / INFO / WARNING / ERROR / CRITICAL
custom_config
¶
In order to perform more configuration (about directories, etc.) and permanently
change the default value (you don’t have to add flags to the command every time),
you can modify
custom_config.yml
. The meaning of each option is in
page
custom_config
.
You can also use different
custom_config.yml
for different directories, such as
following the directory structure:
manim/
├── manimlib/
│   ├── animation/
│   ├── ...
│   ├── default_config.yml
│   └── window.py
├── project/
│   ├── code.py
│   └── custom_config.yml
└── custom_config.yml
When you enter the
project/
folder and run
manimgl
code.py
<Scene>
,
it will overwrite
manim/default_config.yml
with
custom_config.yml
in the
project
folder.
Alternatively, you can use
--config_file
flag in CLI to specify configuration file manually.
manimgl
project/code.py
--config_file
/path/to/custom_config.yml
Contents
CLI flags and configuration
Command Line Interface
Some useful flags
All supported flags
custom_config

Code Examples:
Example 1:
```python
manimgl <code>.py <Scene> <flags>
# or
manim-render <code>.py <Scene> <flags>
```
Example 2:
```python
-n <number>
```
Example 3:
```python
--write_file
```
Example 4:
```python
--skip_animations
```
Example 5:
```python
--low_quality
```
Example 6:
```python
--medium_quality
```
Example 7:
```python
--full_screen
```
Example 8:
```python
--presenter_mode
```
Example 9:
```python
--save_pngs
```
Example 10:
```python
--transparent
```
Example 11:
```python
--write_all
```
Example 12:
```python
--file_name FILE_NAME
```
Example 13:
```python
--start_at_animation_number START_AT_ANIMATION_NUMBER
```
Example 14:
```python
--embed [EMBED]
```
Example 15:
```python
--resolution RESOLUTION
```
Example 16:
```python
--color COLOR
```
Example 17:
```python
--leave_progress_bars
```
Example 18:
```python
--video_dir VIDEO_DIR
```
Example 19:
```python
--config_file CONFIG_FILE
```
Example 20:
```python
--log-level LOG_LEVEL
```
Example 21:
```python
custom_config.yml
```
Example 22:
```python
custom_config.yml
```
Example 23:
```python
manim/
├── manimlib/
│   ├── animation/
│   ├── ...
│   ├── default_config.yml
│   └── window.py
├── project/
│   ├── code.py
│   └── custom_config.yml
└── custom_config.yml
```
Example 24:
```python
manimgl code.py <Scene>
```
Example 25:
```python
manim/default_config.yml
```
Example 26:
```python
custom_config.yml
```
Example 27:
```python
--config_file
```
Example 28:
```python
manimgl project/code.py --config_file /path/to/custom_config.yml
```

================================================================================

=== Example Scenes - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/example_scenes.html#interactivedevlopment
Content:
Example Scenes
¶
After understanding the previous knowledge, we can understand more scenes.
Many example scenes are given in
example_scenes.py
, let’s start with
the simplest and one by one.
InteractiveDevlopment
¶
InteractiveDevelopment
¶
from
manimlib
import
*
class
InteractiveDevelopment
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
square
=
Square
()
self
.
play
(
ShowCreation
(
square
))
self
.
wait
()
# This opens an iPython terminal where you can keep writing
# lines as if they were part of this construct method.
# In particular, 'square', 'circle' and 'self' will all be
# part of the local namespace in that terminal.
self
.
embed
()
# Try copying and pasting some of the lines below into
# the interactive shell
self
.
play
(
ReplacementTransform
(
square
,
circle
))
self
.
wait
()
self
.
play
(
circle
.
animate
.
stretch
(
4
,
0
))
self
.
play
(
Rotate
(
circle
,
90
*
DEGREES
))
self
.
play
(
circle
.
animate
.
shift
(
2
*
RIGHT
)
.
scale
(
0.25
))
text
=
Text
(
"""
In general, using the interactive shell
is very helpful when developing new scenes
"""
)
self
.
play
(
Write
(
text
))
# In the interactive shell, you can just type
# play, add, remove, clear, wait, save_state and restore,
# instead of self.play, self.add, self.remove, etc.
# To interact with the window, type touch().  You can then
# scroll in the window, or zoom by holding down 'z' while scrolling,
# and change camera perspective by holding down 'd' while moving
# the mouse.  Press 'r' to reset to the standard camera position.
# Press 'q' to stop interacting with the window and go back to
# typing new commands into the shell.
# In principle you can customize a scene to be responsive to
# mouse and keyboard interactions
always
(
circle
.
move_to
,
self
.
mouse_point
)
This scene is similar to what we wrote in
Quick Start
.
And how to interact has been written in the comments.
No more explanation here.
AnimatingMethods
¶
AnimatingMethods
¶
class
AnimatingMethods
(
Scene
):
def
construct
(
self
):
grid
=
OldTex
(
r
"\pi"
)
.
get_grid
(
10
,
10
,
height
=
4
)
self
.
add
(
grid
)
# You can animate the application of mobject methods with the
# ".animate" syntax:
self
.
play
(
grid
.
animate
.
shift
(
LEFT
))
# Alternatively, you can use the older syntax by passing the
# method and then the arguments to the scene's "play" function:
self
.
play
(
grid
.
shift
,
LEFT
)
# Both of those will interpolate between the mobject's initial
# state and whatever happens when you apply that method.
# For this example, calling grid.shift(LEFT) would shift the
# grid one unit to the left, but both of the previous calls to
# "self.play" animate that motion.
# The same applies for any method, including those setting colors.
self
.
play
(
grid
.
animate
.
set_color
(
YELLOW
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_submobject_colors_by_gradient
(
BLUE
,
GREEN
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_height
(
TAU
-
MED_SMALL_BUFF
))
self
.
wait
()
# The method Mobject.apply_complex_function lets you apply arbitrary
# complex functions, treating the points defining the mobject as
# complex numbers.
self
.
play
(
grid
.
animate
.
apply_complex_function
(
np
.
exp
),
run_time
=
5
)
self
.
wait
()
# Even more generally, you could apply Mobject.apply_function,
# which takes in functions form R^3 to R^3
self
.
play
(
grid
.
animate
.
apply_function
(
lambda
p
:
[
p
[
0
]
+
0.5
*
math
.
sin
(
p
[
1
]),
p
[
1
]
+
0.5
*
math
.
sin
(
p
[
0
]),
p
[
2
]
]
),
run_time
=
5
,
)
self
.
wait
()
The new usage in this scene is
.get_grid()
and
self.play(mob.animate.method(args))
.
.get_grid()
method will return a new mobject containing multiple copies of this one arranged in a grid.
self.play(mob.animate.method(args))
animates the method, and the details are in the comments above.
TextExample
¶
TextExample
¶
class
TextExample
(
Scene
):
def
construct
(
self
):
# To run this scene properly, you should have "Consolas" font in your computer
# for full usage, you can see https://github.com/3b1b/manim/pull/680
text
=
Text
(
"Here is a text"
,
font
=
"Consolas"
,
font_size
=
90
)
difference
=
Text
(
"""
The most important difference between Text and TexText is that\n
you can change the font more easily, but can't use the LaTeX grammar
"""
,
font
=
"Arial"
,
font_size
=
24
,
# t2c is a dict that you can choose color for different text
t2c
=
{
"Text"
:
BLUE
,
"TexText"
:
BLUE
,
"LaTeX"
:
ORANGE
}
)
VGroup
(
text
,
difference
)
.
arrange
(
DOWN
,
buff
=
1
)
self
.
play
(
Write
(
text
))
self
.
play
(
FadeIn
(
difference
,
UP
))
self
.
wait
(
3
)
fonts
=
Text
(
"And you can also set the font according to different words"
,
font
=
"Arial"
,
t2f
=
{
"font"
:
"Consolas"
,
"words"
:
"Consolas"
},
t2c
=
{
"font"
:
BLUE
,
"words"
:
GREEN
}
)
fonts
.
set_width
(
FRAME_WIDTH
-
1
)
slant
=
Text
(
"And the same as slant and weight"
,
font
=
"Consolas"
,
t2s
=
{
"slant"
:
ITALIC
},
t2w
=
{
"weight"
:
BOLD
},
t2c
=
{
"slant"
:
ORANGE
,
"weight"
:
RED
}
)
VGroup
(
fonts
,
slant
)
.
arrange
(
DOWN
,
buff
=
0.8
)
self
.
play
(
FadeOut
(
text
),
FadeOut
(
difference
,
shift
=
DOWN
))
self
.
play
(
Write
(
fonts
))
self
.
wait
()
self
.
play
(
Write
(
slant
))
self
.
wait
()
The new classes in this scene are
Text
,
VGroup
,
Write
,
FadeIn
and
FadeOut
.
Text
can create text, define fonts, etc. The usage ais clearly reflected in the above examples.
VGroup
can put multiple
VMobject
together as a whole. In the example, the
.arrange()
method is called to arrange the sub-mobjects in sequence downward (
DOWN
), and the spacing is
buff
.
Write
is an animation that shows similar writing effects.
FadeIn
fades the object in, the second parameter indicates the direction of the fade in.
FadeOut
fades out the object, the second parameter indicates the direction of the fade out.
TexTransformExample
¶
TexTransformExample
¶
class
TexTransformExample
(
Scene
):
def
construct
(
self
):
to_isolate
=
[
"B"
,
"C"
,
"="
,
"("
,
")"
]
lines
=
VGroup
(
# Passing in muliple arguments to Tex will result
# in the same expression as if those arguments had
# been joined together, except that the submobject
# hierarchy of the resulting mobject ensure that the
# Tex mobject has a subject corresponding to
# each of these strings.  For example, the Tex mobject
# below will have 5 subjects, corresponding to the
# expressions [A^2, +, B^2, =, C^2]
OldTex
(
"A^2"
,
"+"
,
"B^2"
,
"="
,
"C^2"
),
# Likewise here
OldTex
(
"A^2"
,
"="
,
"C^2"
,
"-"
,
"B^2"
),
# Alternatively, you can pass in the keyword argument
# "isolate" with a list of strings that should be out as
# their own submobject.  So the line below is equivalent
# to the commented out line below it.
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A^2"
,
*
to_isolate
]),
# OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
OldTex
(
"A =
\\
sqrt{(C + B)(C - B)}"
,
isolate
=
[
"A"
,
*
to_isolate
])
)
lines
.
arrange
(
DOWN
,
buff
=
LARGE_BUFF
)
for
line
in
lines
:
line
.
set_color_by_tex_to_color_map
({
"A"
:
BLUE
,
"B"
:
TEAL
,
"C"
:
GREEN
,
})
play_kw
=
{
"run_time"
:
2
}
self
.
add
(
lines
[
0
])
# The animation TransformMatchingTex will line up parts
# of the source and target which have matching tex strings.
# Here, giving it a little path_arc makes each part sort of
# rotate into their final positions, which feels appropriate
# for the idea of rearranging an equation
self
.
play
(
TransformMatchingTex
(
lines
[
0
]
.
copy
(),
lines
[
1
],
path_arc
=
90
*
DEGREES
,
),
**
play_kw
)
self
.
wait
()
# Now, we could try this again on the next line...
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
]),
**
play_kw
)
self
.
wait
()
# ...and this looks nice enough, but since there's no tex
# in lines[2] which matches "C^2" or "B^2", those terms fade
# out to nothing while the C and B terms fade in from nothing.
# If, however, we want the C^2 to go to C, and B^2 to go to B,
# we can specify that with a key map.
self
.
play
(
FadeOut
(
lines
[
2
]))
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
],
key_map
=
{
"C^2"
:
"C"
,
"B^2"
:
"B"
,
}
),
**
play_kw
)
self
.
wait
()
# And to finish off, a simple TransformMatchingShapes would work
# just fine.  But perhaps we want that exponent on A^2 to transform into
# the square root symbol.  At the moment, lines[2] treats the expression
# A^2 as a unit, so we might create a new version of the same line which
# separates out just the A.  This way, when TransformMatchingTex lines up
# all matching parts, the only mismatch will be between the "^2" from
# new_line2 and the "\sqrt" from the final line.  By passing in,
# transform_mismatches=True, it will transform this "^2" part into
# the "\sqrt" part.
new_line2
=
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A"
,
*
to_isolate
])
new_line2
.
replace
(
lines
[
2
])
new_line2
.
match_style
(
lines
[
2
])
self
.
play
(
TransformMatchingTex
(
new_line2
,
lines
[
3
],
transform_mismatches
=
True
,
),
**
play_kw
)
self
.
wait
(
3
)
self
.
play
(
FadeOut
(
lines
,
RIGHT
))
# Alternatively, if you don't want to think about breaking up
# the tex strings deliberately, you can TransformMatchingShapes,
# which will try to line up all pieces of a source mobject with
# those of a target, regardless of the submobject hierarchy in
# each one, according to whether those pieces have the same
# shape (as best it can).
source
=
Text
(
"the morse code"
,
height
=
1
)
target
=
Text
(
"here come dots"
,
height
=
1
)
self
.
play
(
Write
(
source
))
self
.
wait
()
kw
=
{
"run_time"
:
3
,
"path_arc"
:
PI
/
2
}
self
.
play
(
TransformMatchingShapes
(
source
,
target
,
**
kw
))
self
.
wait
()
self
.
play
(
TransformMatchingShapes
(
target
,
source
,
**
kw
))
self
.
wait
()
The new classes in this scene are
Tex
,
TexText
,
TransformMatchingTex
and
TransformMatchingShapes
.
Tex
uses LaTeX to create mathematical formulas.
TexText
uses LaTeX to create text.
TransformMatchingTeX
automatically transforms sub-objects according to the similarities and differences of tex in
Tex
.
TransformMatchingShapes
automatically transform sub-objects directly based on the similarities and differences of the object point sets.
UpdatersExample
¶
UpdatersExample
¶
class
UpdatersExample
(
Scene
):
def
construct
(
self
):
square
=
Square
()
square
.
set_fill
(
BLUE_E
,
1
)
# On all all frames, the constructor Brace(square, UP) will
# be called, and the mobject brace will set its data to match
# that of the newly constructed object
brace
=
always_redraw
(
Brace
,
square
,
UP
)
text
,
number
=
label
=
VGroup
(
Text
(
"Width = "
),
DecimalNumber
(
0
,
show_ellipsis
=
True
,
num_decimal_places
=
2
,
include_sign
=
True
,
)
)
label
.
arrange
(
RIGHT
)
# This ensures that the method deicmal.next_to(square)
# is called on every frame
always
(
label
.
next_to
,
brace
,
UP
)
# You could also write the following equivalent line
# label.add_updater(lambda m: m.next_to(brace, UP))
# If the argument itself might change, you can use f_always,
# for which the arguments following the initial Mobject method
# should be functions returning arguments to that method.
# The following line ensures that decimal.set_value(square.get_y())
# is called every frame
f_always
(
number
.
set_value
,
square
.
get_width
)
# You could also write the following equivalent line
# number.add_updater(lambda m: m.set_value(square.get_width()))
self
.
add
(
square
,
brace
,
label
)
# Notice that the brace and label track with the square
self
.
play
(
square
.
animate
.
scale
(
2
),
rate_func
=
there_and_back
,
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
5
,
stretch
=
True
),
run_time
=
3
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
2
),
run_time
=
3
)
self
.
wait
()
# In general, you can alway call Mobject.add_updater, and pass in
# a function that you want to be called on every frame.  The function
# should take in either one argument, the mobject, or two arguments,
# the mobject and the amount of time since the last frame.
now
=
self
.
time
w0
=
square
.
get_width
()
square
.
add_updater
(
lambda
m
:
m
.
set_width
(
w0
*
math
.
cos
(
self
.
time
-
now
))
)
self
.
wait
(
4
*
PI
)
The new classes and usage in this scene are
always_redraw()
,
DecimalNumber
,
.to_edge()
,
.center()
,
always()
,
f_always()
,
.set_y()
and
.add_updater()
.
always_redraw()
function create a new mobject every frame.
DecimalNumber
is a variable number, speed it up by breaking it into
Text
characters.
.to_edge()
means to place the object on the edge of the screen.
.center()
means to place the object in the center of the screen.
always(f,
x)
means that a certain function (
f(x)
) is executed every frame.
f_always(f,
g)
is similar to
always
, executed
f(g())
every frame.
.set_y()
means to set the ordinate of the object on the screen.
.add_updater()
sets an update function for the object. For example:
mob1.add_updater(lambda
mob:
mob.next_to(mob2))
means
mob1.next_to(mob2)
is executed every frame.
CoordinateSystemExample
¶
CoordinateSystemExample
¶
class
CoordinateSystemExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
(
# x-axis ranges from -1 to 10, with a default step size of 1
x_range
=
(
-
1
,
10
),
# y-axis ranges from -2 to 2 with a step size of 0.5
y_range
=
(
-
2
,
2
,
0.5
),
# The axes will be stretched so as to match the specified
# height and width
height
=
6
,
width
=
10
,
# Axes is made of two NumberLine mobjects.  You can specify
# their configuration with axis_config
axis_config
=
{
"stroke_color"
:
GREY_A
,
"stroke_width"
:
2
,
},
# Alternatively, you can specify configuration for just one
# of them, like this.
y_axis_config
=
{
"include_tip"
:
False
,
}
)
# Keyword arguments of add_coordinate_labels can be used to
# configure the DecimalNumber mobjects which it creates and
# adds to the axes
axes
.
add_coordinate_labels
(
font_size
=
20
,
num_decimal_places
=
1
,
)
self
.
add
(
axes
)
# Axes descends from the CoordinateSystem class, meaning
# you can call call axes.coords_to_point, abbreviated to
# axes.c2p, to associate a set of coordinates with a point,
# like so:
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
c2p
(
0
,
0
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
5
,
0.5
)))
self
.
wait
()
# Similarly, you can call axes.point_to_coords, or axes.p2c
# print(axes.p2c(dot.get_center()))
# We can draw lines from the axes to better mark the coordinates
# of a given point.
# Here, the always_redraw command means that on each new frame
# the lines will be redrawn
h_line
=
always_redraw
(
lambda
:
axes
.
get_h_line
(
dot
.
get_left
()))
v_line
=
always_redraw
(
lambda
:
axes
.
get_v_line
(
dot
.
get_bottom
()))
self
.
play
(
ShowCreation
(
h_line
),
ShowCreation
(
v_line
),
)
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
-
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
1
,
1
)))
self
.
wait
()
# If we tie the dot to a particular set of coordinates, notice
# that as we move the axes around it respects the coordinate
# system defined by them.
f_always
(
dot
.
move_to
,
lambda
:
axes
.
c2p
(
1
,
1
))
self
.
play
(
axes
.
animate
.
scale
(
0.75
)
.
to_corner
(
UL
),
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
FadeOut
(
VGroup
(
axes
,
dot
,
h_line
,
v_line
)))
# Other coordinate systems you can play around with include
# ThreeDAxes, NumberPlane, and ComplexPlane.
GraphExample
¶
GraphExample
¶
class
GraphExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
((
-
3
,
10
),
(
-
1
,
8
))
axes
.
add_coordinate_labels
()
self
.
play
(
Write
(
axes
,
lag_ratio
=
0.01
,
run_time
=
1
))
# Axes.get_graph will return the graph of a function
sin_graph
=
axes
.
get_graph
(
lambda
x
:
2
*
math
.
sin
(
x
),
color
=
BLUE
,
)
# By default, it draws it so as to somewhat smoothly interpolate
# between sampled points (x, f(x)).  If the graph is meant to have
# a corner, though, you can set use_smoothing to False
relu_graph
=
axes
.
get_graph
(
lambda
x
:
max
(
x
,
0
),
use_smoothing
=
False
,
color
=
YELLOW
,
)
# For discontinuous functions, you can specify the point of
# discontinuity so that it does not try to draw over the gap.
step_graph
=
axes
.
get_graph
(
lambda
x
:
2.0
if
x
>
3
else
1.0
,
discontinuities
=
[
3
],
color
=
GREEN
,
)
# Axes.get_graph_label takes in either a string or a mobject.
# If it's a string, it treats it as a LaTeX expression.  By default
# it places the label next to the graph near the right side, and
# has it match the color of the graph
sin_label
=
axes
.
get_graph_label
(
sin_graph
,
"
\\
sin(x)"
)
relu_label
=
axes
.
get_graph_label
(
relu_graph
,
Text
(
"ReLU"
))
step_label
=
axes
.
get_graph_label
(
step_graph
,
Text
(
"Step"
),
x
=
4
)
self
.
play
(
ShowCreation
(
sin_graph
),
FadeIn
(
sin_label
,
RIGHT
),
)
self
.
wait
(
2
)
self
.
play
(
ReplacementTransform
(
sin_graph
,
relu_graph
),
FadeTransform
(
sin_label
,
relu_label
),
)
self
.
wait
()
self
.
play
(
ReplacementTransform
(
relu_graph
,
step_graph
),
FadeTransform
(
relu_label
,
step_label
),
)
self
.
wait
()
parabola
=
axes
.
get_graph
(
lambda
x
:
0.25
*
x
**
2
)
parabola
.
set_stroke
(
BLUE
)
self
.
play
(
FadeOut
(
step_graph
),
FadeOut
(
step_label
),
ShowCreation
(
parabola
)
)
self
.
wait
()
# You can use axes.input_to_graph_point, abbreviated
# to axes.i2gp, to find a particular point on a graph
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
i2gp
(
2
,
parabola
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
# A value tracker lets us animate a parameter, usually
# with the intent of having other mobjects update based
# on the parameter
x_tracker
=
ValueTracker
(
2
)
f_always
(
dot
.
move_to
,
lambda
:
axes
.
i2gp
(
x_tracker
.
get_value
(),
parabola
)
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
4
),
run_time
=
3
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
-
2
),
run_time
=
3
)
self
.
wait
()
SurfaceExample
¶
SurfaceExample
¶
class
SurfaceExample
(
Scene
):
CONFIG
=
{
"camera_class"
:
ThreeDCamera
,
}
def
construct
(
self
):
surface_text
=
Text
(
"For 3d scenes, try using surfaces"
)
surface_text
.
fix_in_frame
()
surface_text
.
to_edge
(
UP
)
self
.
add
(
surface_text
)
self
.
wait
(
0.1
)
torus1
=
Torus
(
r1
=
1
,
r2
=
1
)
torus2
=
Torus
(
r1
=
3
,
r2
=
1
)
sphere
=
Sphere
(
radius
=
3
,
resolution
=
torus1
.
resolution
)
# You can texture a surface with up to two images, which will
# be interpreted as the side towards the light, and away from
# the light.  These can be either urls, or paths to a local file
# in whatever you've set as the image directory in
# the custom_config.yml file
# day_texture = "EarthTextureMap"
# night_texture = "NightEarthTextureMap"
day_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
night_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"
surfaces
=
[
TexturedSurface
(
surface
,
day_texture
,
night_texture
)
for
surface
in
[
sphere
,
torus1
,
torus2
]
]
for
mob
in
surfaces
:
mob
.
shift
(
IN
)
mob
.
mesh
=
SurfaceMesh
(
mob
)
mob
.
mesh
.
set_stroke
(
BLUE
,
1
,
opacity
=
0.5
)
# Set perspective
frame
=
self
.
camera
.
frame
frame
.
set_euler_angles
(
theta
=-
30
*
DEGREES
,
phi
=
70
*
DEGREES
,
)
surface
=
surfaces
[
0
]
self
.
play
(
FadeIn
(
surface
),
ShowCreation
(
surface
.
mesh
,
lag_ratio
=
0.01
,
run_time
=
3
),
)
for
mob
in
surfaces
:
mob
.
add
(
mob
.
mesh
)
surface
.
save_state
()
self
.
play
(
Rotate
(
surface
,
PI
/
2
),
run_time
=
2
)
for
mob
in
surfaces
[
1
:]:
mob
.
rotate
(
PI
/
2
)
self
.
play
(
Transform
(
surface
,
surfaces
[
1
]),
run_time
=
3
)
self
.
play
(
Transform
(
surface
,
surfaces
[
2
]),
# Move camera frame during the transition
frame
.
animate
.
increment_phi
(
-
10
*
DEGREES
),
frame
.
animate
.
increment_theta
(
-
20
*
DEGREES
),
run_time
=
3
)
# Add ambient rotation
frame
.
add_updater
(
lambda
m
,
dt
:
m
.
increment_theta
(
-
0.1
*
dt
))
# Play around with where the light is
light_text
=
Text
(
"You can move around the light source"
)
light_text
.
move_to
(
surface_text
)
light_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
surface_text
,
light_text
))
light
=
self
.
camera
.
light_source
self
.
add
(
light
)
light
.
save_state
()
self
.
play
(
light
.
animate
.
move_to
(
3
*
IN
),
run_time
=
5
)
self
.
play
(
light
.
animate
.
shift
(
10
*
OUT
),
run_time
=
5
)
drag_text
=
Text
(
"Try moving the mouse while pressing d or s"
)
drag_text
.
move_to
(
light_text
)
drag_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
light_text
,
drag_text
))
self
.
wait
()
This scene shows an example of using a three-dimensional surface, and
the related usage has been briefly described in the notes.
.fix_in_frame()
makes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.
OpeningManimExample
¶
OpeningManimExample
¶
class
OpeningManimExample
(
Scene
):
def
construct
(
self
):
intro_words
=
Text
(
"""
The original motivation for manim was to
better illustrate mathematical functions
as transformations.
"""
)
intro_words
.
to_edge
(
UP
)
self
.
play
(
Write
(
intro_words
))
self
.
wait
(
2
)
# Linear transform
grid
=
NumberPlane
((
-
10
,
10
),
(
-
5
,
5
))
matrix
=
[[
1
,
1
],
[
0
,
1
]]
linear_transform_words
=
VGroup
(
Text
(
"This is what the matrix"
),
IntegerMatrix
(
matrix
,
include_background_rectangle
=
True
),
Text
(
"looks like"
)
)
linear_transform_words
.
arrange
(
RIGHT
)
linear_transform_words
.
to_edge
(
UP
)
linear_transform_words
.
set_stroke
(
BLACK
,
10
,
background
=
True
)
self
.
play
(
ShowCreation
(
grid
),
FadeTransform
(
intro_words
,
linear_transform_words
)
)
self
.
wait
()
self
.
play
(
grid
.
animate
.
apply_matrix
(
matrix
),
run_time
=
3
)
self
.
wait
()
# Complex map
c_grid
=
ComplexPlane
()
moving_c_grid
=
c_grid
.
copy
()
moving_c_grid
.
prepare_for_nonlinear_transform
()
c_grid
.
set_stroke
(
BLUE_E
,
1
)
c_grid
.
add_coordinate_labels
(
font_size
=
24
)
complex_map_words
=
TexText
(
"""
Or thinking of the plane as $
\\
mathds
{C}
$,
\\\\
this is the map $z
\\
rightarrow z^2$
"""
)
complex_map_words
.
to_corner
(
UR
)
complex_map_words
.
set_stroke
(
BLACK
,
5
,
background
=
True
)
self
.
play
(
FadeOut
(
grid
),
Write
(
c_grid
,
run_time
=
3
),
FadeIn
(
moving_c_grid
),
FadeTransform
(
linear_transform_words
,
complex_map_words
),
)
self
.
wait
()
self
.
play
(
moving_c_grid
.
animate
.
apply_complex_function
(
lambda
z
:
z
**
2
),
run_time
=
6
,
)
self
.
wait
(
2
)
This scene is a comprehensive application of a two-dimensional scene.
After seeing these scenes, you have already understood part of the
usage of manim. For more examples, see
the video code of 3b1b
.
Contents
Example Scenes
InteractiveDevlopment
AnimatingMethods
TextExample
TexTransformExample
UpdatersExample
CoordinateSystemExample
GraphExample
SurfaceExample
OpeningManimExample

Code Examples:
Example 1:
```python
example_scenes.py
```
Example 2:
```python
from manimlib import *

class InteractiveDevelopment(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)
        square = Square()

        self.play(ShowCreation(square))
        self.wait()

        # This opens an iPython terminal where you can keep writing
        # lines as if they were part of this construct method.
        # In particular, 'square', 'circle' and 'self' will all be
        # part of the local namespace in that terminal.
        self.embed()

        # Try copying and pasting some of the lines below into
        # the interactive shell
        self.play(ReplacementTransform(square, circle))
        self.wait()
        self.play(circle.animate.stretch(4, 0))
        self.play(Rotate(circle, 90 * DEGREES))
        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))

        text = Text("""
            In general, using the interactive shell
            is very helpful when developing new scenes
        """)
        self.play(Write(text))

        # In the interactive shell, you can just type
        # play, add, remove, clear, wait, save_state and restore,
        # instead of self.play, self.add, self.remove, etc.

        # To interact with the window, type touch().  You can then
        # scroll in the window, or zoom by holding down 'z' while scrolling,
        # and change camera perspective by holding down 'd' while moving
        # the mouse.  Press 'r' to reset to the standard camera position.
        # Press 'q' to stop interacting with the window and go back to
        # typing new commands into the shell.

        # In principle you can customize a scene to be responsive to
        # mouse and keyboard interactions
        always(circle.move_to, self.mouse_point)
```
Example 3:
```python
class AnimatingMethods(Scene):
    def construct(self):
        grid = OldTex(r"\pi").get_grid(10, 10, height=4)
        self.add(grid)

        # You can animate the application of mobject methods with the
        # ".animate" syntax:
        self.play(grid.animate.shift(LEFT))

        # Alternatively, you can use the older syntax by passing the
        # method and then the arguments to the scene's "play" function:
        self.play(grid.shift, LEFT)

        # Both of those will interpolate between the mobject's initial
        # state and whatever happens when you apply that method.
        # For this example, calling grid.shift(LEFT) would shift the
        # grid one unit to the left, but both of the previous calls to
        # "self.play" animate that motion.

        # The same applies for any method, including those setting colors.
        self.play(grid.animate.set_color(YELLOW))
        self.wait()
        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))
        self.wait()
        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))
        self.wait()

        # The method Mobject.apply_complex_function lets you apply arbitrary
        # complex functions, treating the points defining the mobject as
        # complex numbers.
        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)
        self.wait()

        # Even more generally, you could apply Mobject.apply_function,
        # which takes in functions form R^3 to R^3
        self.play(
            grid.animate.apply_function(
                lambda p: [
                    p[0] + 0.5 * math.sin(p[1]),
                    p[1] + 0.5 * math.sin(p[0]),
                    p[2]
                ]
            ),
            run_time=5,
        )
        self.wait()
```
Example 4:
```python
.get_grid()
```
Example 5:
```python
self.play(mob.animate.method(args))
```
Example 6:
```python
.get_grid()
```
Example 7:
```python
self.play(mob.animate.method(args))
```
Example 8:
```python
class TextExample(Scene):
    def construct(self):
        # To run this scene properly, you should have "Consolas" font in your computer
        # for full usage, you can see https://github.com/3b1b/manim/pull/680
        text = Text("Here is a text", font="Consolas", font_size=90)
        difference = Text(
            """
            The most important difference between Text and TexText is that\n
            you can change the font more easily, but can't use the LaTeX grammar
            """,
            font="Arial", font_size=24,
            # t2c is a dict that you can choose color for different text
            t2c={"Text": BLUE, "TexText": BLUE, "LaTeX": ORANGE}
        )
        VGroup(text, difference).arrange(DOWN, buff=1)
        self.play(Write(text))
        self.play(FadeIn(difference, UP))
        self.wait(3)

        fonts = Text(
            "And you can also set the font according to different words",
            font="Arial",
            t2f={"font": "Consolas", "words": "Consolas"},
            t2c={"font": BLUE, "words": GREEN}
        )
        fonts.set_width(FRAME_WIDTH - 1)
        slant = Text(
            "And the same as slant and weight",
            font="Consolas",
            t2s={"slant": ITALIC},
            t2w={"weight": BOLD},
            t2c={"slant": ORANGE, "weight": RED}
        )
        VGroup(fonts, slant).arrange(DOWN, buff=0.8)
        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))
        self.play(Write(fonts))
        self.wait()
        self.play(Write(slant))
        self.wait()
```
Example 9:
```python
class TexTransformExample(Scene):
    def construct(self):
        to_isolate = ["B", "C", "=", "(", ")"]
        lines = VGroup(
            # Passing in muliple arguments to Tex will result
            # in the same expression as if those arguments had
            # been joined together, except that the submobject
            # hierarchy of the resulting mobject ensure that the
            # Tex mobject has a subject corresponding to
            # each of these strings.  For example, the Tex mobject
            # below will have 5 subjects, corresponding to the
            # expressions [A^2, +, B^2, =, C^2]
            OldTex("A^2", "+", "B^2", "=", "C^2"),
            # Likewise here
            OldTex("A^2", "=", "C^2", "-", "B^2"),
            # Alternatively, you can pass in the keyword argument
            # "isolate" with a list of strings that should be out as
            # their own submobject.  So the line below is equivalent
            # to the commented out line below it.
            OldTex("A^2 = (C + B)(C - B)", isolate=["A^2", *to_isolate]),
            # OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
            OldTex("A = \\sqrt{(C + B)(C - B)}", isolate=["A", *to_isolate])
        )
        lines.arrange(DOWN, buff=LARGE_BUFF)
        for line in lines:
            line.set_color_by_tex_to_color_map({
                "A": BLUE,
                "B": TEAL,
                "C": GREEN,
            })

        play_kw = {"run_time": 2}
        self.add(lines[0])
        # The animation TransformMatchingTex will line up parts
        # of the source and target which have matching tex strings.
        # Here, giving it a little path_arc makes each part sort of
        # rotate into their final positions, which feels appropriate
        # for the idea of rearranging an equation
        self.play(
            TransformMatchingTex(
                lines[0].copy(), lines[1],
                path_arc=90 * DEGREES,
            ),
            **play_kw
        )
        self.wait()

        # Now, we could try this again on the next line...
        self.play(
            TransformMatchingTex(lines[1].copy(), lines[2]),
            **play_kw
        )
        self.wait()
        # ...and this looks nice enough, but since there's no tex
        # in lines[2] which matches "C^2" or "B^2", those terms fade
        # out to nothing while the C and B terms fade in from nothing.
        # If, however, we want the C^2 to go to C, and B^2 to go to B,
        # we can specify that with a key map.
        self.play(FadeOut(lines[2]))
        self.play(
            TransformMatchingTex(
                lines[1].copy(), lines[2],
                key_map={
                    "C^2": "C",
                    "B^2": "B",
                }
            ),
            **play_kw
        )
        self.wait()

        # And to finish off, a simple TransformMatchingShapes would work
        # just fine.  But perhaps we want that exponent on A^2 to transform into
        # the square root symbol.  At the moment, lines[2] treats the expression
        # A^2 as a unit, so we might create a new version of the same line which
        # separates out just the A.  This way, when TransformMatchingTex lines up
        # all matching parts, the only mismatch will be between the "^2" from
        # new_line2 and the "\sqrt" from the final line.  By passing in,
        # transform_mismatches=True, it will transform this "^2" part into
        # the "\sqrt" part.
        new_line2 = OldTex("A^2 = (C + B)(C - B)", isolate=["A", *to_isolate])
        new_line2.replace(lines[2])
        new_line2.match_style(lines[2])

        self.play(
            TransformMatchingTex(
                new_line2, lines[3],
                transform_mismatches=True,
            ),
            **play_kw
        )
        self.wait(3)
        self.play(FadeOut(lines, RIGHT))

        # Alternatively, if you don't want to think about breaking up
        # the tex strings deliberately, you can TransformMatchingShapes,
        # which will try to line up all pieces of a source mobject with
        # those of a target, regardless of the submobject hierarchy in
        # each one, according to whether those pieces have the same
        # shape (as best it can).
        source = Text("the morse code", height=1)
        target = Text("here come dots", height=1)

        self.play(Write(source))
        self.wait()
        kw = {"run_time": 3, "path_arc": PI / 2}
        self.play(TransformMatchingShapes(source, target, **kw))
        self.wait()
        self.play(TransformMatchingShapes(target, source, **kw))
        self.wait()
```
Example 10:
```python
TransformMatchingTex
```
Example 11:
```python
TransformMatchingShapes
```
Example 12:
```python
TransformMatchingTeX
```
Example 13:
```python
TransformMatchingShapes
```
Example 14:
```python
class UpdatersExample(Scene):
    def construct(self):
        square = Square()
        square.set_fill(BLUE_E, 1)

        # On all all frames, the constructor Brace(square, UP) will
        # be called, and the mobject brace will set its data to match
        # that of the newly constructed object
        brace = always_redraw(Brace, square, UP)

        text, number = label = VGroup(
            Text("Width = "),
            DecimalNumber(
                0,
                show_ellipsis=True,
                num_decimal_places=2,
                include_sign=True,
            )
        )
        label.arrange(RIGHT)

        # This ensures that the method deicmal.next_to(square)
        # is called on every frame
        always(label.next_to, brace, UP)
        # You could also write the following equivalent line
        # label.add_updater(lambda m: m.next_to(brace, UP))

        # If the argument itself might change, you can use f_always,
        # for which the arguments following the initial Mobject method
        # should be functions returning arguments to that method.
        # The following line ensures that decimal.set_value(square.get_y())
        # is called every frame
        f_always(number.set_value, square.get_width)
        # You could also write the following equivalent line
        # number.add_updater(lambda m: m.set_value(square.get_width()))

        self.add(square, brace, label)

        # Notice that the brace and label track with the square
        self.play(
            square.animate.scale(2),
            rate_func=there_and_back,
            run_time=2,
        )
        self.wait()
        self.play(
            square.animate.set_width(5, stretch=True),
            run_time=3,
        )
        self.wait()
        self.play(
            square.animate.set_width(2),
            run_time=3
        )
        self.wait()

        # In general, you can alway call Mobject.add_updater, and pass in
        # a function that you want to be called on every frame.  The function
        # should take in either one argument, the mobject, or two arguments,
        # the mobject and the amount of time since the last frame.
        now = self.time
        w0 = square.get_width()
        square.add_updater(
            lambda m: m.set_width(w0 * math.cos(self.time - now))
        )
        self.wait(4 * PI)
```
Example 15:
```python
always_redraw()
```
Example 16:
```python
DecimalNumber
```
Example 17:
```python
.add_updater()
```
Example 18:
```python
always_redraw()
```
Example 19:
```python
DecimalNumber
```
Example 20:
```python
always(f, x)
```
Example 21:
```python
f_always(f, g)
```
Example 22:
```python
.add_updater()
```
Example 23:
```python
mob1.add_updater(lambda mob: mob.next_to(mob2))
```
Example 24:
```python
mob1.next_to(mob2)
```
Example 25:
```python
class CoordinateSystemExample(Scene):
    def construct(self):
        axes = Axes(
            # x-axis ranges from -1 to 10, with a default step size of 1
            x_range=(-1, 10),
            # y-axis ranges from -2 to 2 with a step size of 0.5
            y_range=(-2, 2, 0.5),
            # The axes will be stretched so as to match the specified
            # height and width
            height=6,
            width=10,
            # Axes is made of two NumberLine mobjects.  You can specify
            # their configuration with axis_config
            axis_config={
                "stroke_color": GREY_A,
                "stroke_width": 2,
            },
            # Alternatively, you can specify configuration for just one
            # of them, like this.
            y_axis_config={
                "include_tip": False,
            }
        )
        # Keyword arguments of add_coordinate_labels can be used to
        # configure the DecimalNumber mobjects which it creates and
        # adds to the axes
        axes.add_coordinate_labels(
            font_size=20,
            num_decimal_places=1,
        )
        self.add(axes)

        # Axes descends from the CoordinateSystem class, meaning
        # you can call call axes.coords_to_point, abbreviated to
        # axes.c2p, to associate a set of coordinates with a point,
        # like so:
        dot = Dot(color=RED)
        dot.move_to(axes.c2p(0, 0))
        self.play(FadeIn(dot, scale=0.5))
        self.play(dot.animate.move_to(axes.c2p(3, 2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))
        self.wait()

        # Similarly, you can call axes.point_to_coords, or axes.p2c
        # print(axes.p2c(dot.get_center()))

        # We can draw lines from the axes to better mark the coordinates
        # of a given point.
        # Here, the always_redraw command means that on each new frame
        # the lines will be redrawn
        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))
        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))

        self.play(
            ShowCreation(h_line),
            ShowCreation(v_line),
        )
        self.play(dot.animate.move_to(axes.c2p(3, -2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(1, 1)))
        self.wait()

        # If we tie the dot to a particular set of coordinates, notice
        # that as we move the axes around it respects the coordinate
        # system defined by them.
        f_always(dot.move_to, lambda: axes.c2p(1, 1))
        self.play(
            axes.animate.scale(0.75).to_corner(UL),
            run_time=2,
        )
        self.wait()
        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))

        # Other coordinate systems you can play around with include
        # ThreeDAxes, NumberPlane, and ComplexPlane.
```
Example 26:
```python
class GraphExample(Scene):
    def construct(self):
        axes = Axes((-3, 10), (-1, 8))
        axes.add_coordinate_labels()

        self.play(Write(axes, lag_ratio=0.01, run_time=1))

        # Axes.get_graph will return the graph of a function
        sin_graph = axes.get_graph(
            lambda x: 2 * math.sin(x),
            color=BLUE,
        )
        # By default, it draws it so as to somewhat smoothly interpolate
        # between sampled points (x, f(x)).  If the graph is meant to have
        # a corner, though, you can set use_smoothing to False
        relu_graph = axes.get_graph(
            lambda x: max(x, 0),
            use_smoothing=False,
            color=YELLOW,
        )
        # For discontinuous functions, you can specify the point of
        # discontinuity so that it does not try to draw over the gap.
        step_graph = axes.get_graph(
            lambda x: 2.0 if x > 3 else 1.0,
            discontinuities=[3],
            color=GREEN,
        )

        # Axes.get_graph_label takes in either a string or a mobject.
        # If it's a string, it treats it as a LaTeX expression.  By default
        # it places the label next to the graph near the right side, and
        # has it match the color of the graph
        sin_label = axes.get_graph_label(sin_graph, "\\sin(x)")
        relu_label = axes.get_graph_label(relu_graph, Text("ReLU"))
        step_label = axes.get_graph_label(step_graph, Text("Step"), x=4)

        self.play(
            ShowCreation(sin_graph),
            FadeIn(sin_label, RIGHT),
        )
        self.wait(2)
        self.play(
            ReplacementTransform(sin_graph, relu_graph),
            FadeTransform(sin_label, relu_label),
        )
        self.wait()
        self.play(
            ReplacementTransform(relu_graph, step_graph),
            FadeTransform(relu_label, step_label),
        )
        self.wait()

        parabola = axes.get_graph(lambda x: 0.25 * x**2)
        parabola.set_stroke(BLUE)
        self.play(
            FadeOut(step_graph),
            FadeOut(step_label),
            ShowCreation(parabola)
        )
        self.wait()

        # You can use axes.input_to_graph_point, abbreviated
        # to axes.i2gp, to find a particular point on a graph
        dot = Dot(color=RED)
        dot.move_to(axes.i2gp(2, parabola))
        self.play(FadeIn(dot, scale=0.5))

        # A value tracker lets us animate a parameter, usually
        # with the intent of having other mobjects update based
        # on the parameter
        x_tracker = ValueTracker(2)
        f_always(
            dot.move_to,
            lambda: axes.i2gp(x_tracker.get_value(), parabola)
        )

        self.play(x_tracker.animate.set_value(4), run_time=3)
        self.play(x_tracker.animate.set_value(-2), run_time=3)
        self.wait()
```
Example 27:
```python
class SurfaceExample(Scene):
    CONFIG = {
        "camera_class": ThreeDCamera,
    }

    def construct(self):
        surface_text = Text("For 3d scenes, try using surfaces")
        surface_text.fix_in_frame()
        surface_text.to_edge(UP)
        self.add(surface_text)
        self.wait(0.1)

        torus1 = Torus(r1=1, r2=1)
        torus2 = Torus(r1=3, r2=1)
        sphere = Sphere(radius=3, resolution=torus1.resolution)
        # You can texture a surface with up to two images, which will
        # be interpreted as the side towards the light, and away from
        # the light.  These can be either urls, or paths to a local file
        # in whatever you've set as the image directory in
        # the custom_config.yml file

        # day_texture = "EarthTextureMap"
        # night_texture = "NightEarthTextureMap"
        day_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
        night_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"

        surfaces = [
            TexturedSurface(surface, day_texture, night_texture)
            for surface in [sphere, torus1, torus2]
        ]

        for mob in surfaces:
            mob.shift(IN)
            mob.mesh = SurfaceMesh(mob)
            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)

        # Set perspective
        frame = self.camera.frame
        frame.set_euler_angles(
            theta=-30 * DEGREES,
            phi=70 * DEGREES,
        )

        surface = surfaces[0]

        self.play(
            FadeIn(surface),
            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),
        )
        for mob in surfaces:
            mob.add(mob.mesh)
        surface.save_state()
        self.play(Rotate(surface, PI / 2), run_time=2)
        for mob in surfaces[1:]:
            mob.rotate(PI / 2)

        self.play(
            Transform(surface, surfaces[1]),
            run_time=3
        )

        self.play(
            Transform(surface, surfaces[2]),
            # Move camera frame during the transition
            frame.animate.increment_phi(-10 * DEGREES),
            frame.animate.increment_theta(-20 * DEGREES),
            run_time=3
        )
        # Add ambient rotation
        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))

        # Play around with where the light is
        light_text = Text("You can move around the light source")
        light_text.move_to(surface_text)
        light_text.fix_in_frame()

        self.play(FadeTransform(surface_text, light_text))
        light = self.camera.light_source
        self.add(light)
        light.save_state()
        self.play(light.animate.move_to(3 * IN), run_time=5)
        self.play(light.animate.shift(10 * OUT), run_time=5)

        drag_text = Text("Try moving the mouse while pressing d or s")
        drag_text.move_to(light_text)
        drag_text.fix_in_frame()

        self.play(FadeTransform(light_text, drag_text))
        self.wait()
```
Example 28:
```python
.fix_in_frame()
```
Example 29:
```python
class OpeningManimExample(Scene):
    def construct(self):
        intro_words = Text("""
            The original motivation for manim was to
            better illustrate mathematical functions
            as transformations.
        """)
        intro_words.to_edge(UP)

        self.play(Write(intro_words))
        self.wait(2)

        # Linear transform
        grid = NumberPlane((-10, 10), (-5, 5))
        matrix = [[1, 1], [0, 1]]
        linear_transform_words = VGroup(
            Text("This is what the matrix"),
            IntegerMatrix(matrix, include_background_rectangle=True),
            Text("looks like")
        )
        linear_transform_words.arrange(RIGHT)
        linear_transform_words.to_edge(UP)
        linear_transform_words.set_stroke(BLACK, 10, background=True)

        self.play(
            ShowCreation(grid),
            FadeTransform(intro_words, linear_transform_words)
        )
        self.wait()
        self.play(grid.animate.apply_matrix(matrix), run_time=3)
        self.wait()

        # Complex map
        c_grid = ComplexPlane()
        moving_c_grid = c_grid.copy()
        moving_c_grid.prepare_for_nonlinear_transform()
        c_grid.set_stroke(BLUE_E, 1)
        c_grid.add_coordinate_labels(font_size=24)
        complex_map_words = TexText("""
            Or thinking of the plane as $\\mathds{C}$,\\\\
            this is the map $z \\rightarrow z^2$
        """)
        complex_map_words.to_corner(UR)
        complex_map_words.set_stroke(BLACK, 5, background=True)

        self.play(
            FadeOut(grid),
            Write(c_grid, run_time=3),
            FadeIn(moving_c_grid),
            FadeTransform(linear_transform_words, complex_map_words),
        )
        self.wait()
        self.play(
            moving_c_grid.animate.apply_complex_function(lambda z: z**2),
            run_time=6,
        )
        self.wait(2)
```

================================================================================

=== Example Scenes - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/example_scenes.html#animatingmethods
Content:
Example Scenes
¶
After understanding the previous knowledge, we can understand more scenes.
Many example scenes are given in
example_scenes.py
, let’s start with
the simplest and one by one.
InteractiveDevlopment
¶
InteractiveDevelopment
¶
from
manimlib
import
*
class
InteractiveDevelopment
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
square
=
Square
()
self
.
play
(
ShowCreation
(
square
))
self
.
wait
()
# This opens an iPython terminal where you can keep writing
# lines as if they were part of this construct method.
# In particular, 'square', 'circle' and 'self' will all be
# part of the local namespace in that terminal.
self
.
embed
()
# Try copying and pasting some of the lines below into
# the interactive shell
self
.
play
(
ReplacementTransform
(
square
,
circle
))
self
.
wait
()
self
.
play
(
circle
.
animate
.
stretch
(
4
,
0
))
self
.
play
(
Rotate
(
circle
,
90
*
DEGREES
))
self
.
play
(
circle
.
animate
.
shift
(
2
*
RIGHT
)
.
scale
(
0.25
))
text
=
Text
(
"""
In general, using the interactive shell
is very helpful when developing new scenes
"""
)
self
.
play
(
Write
(
text
))
# In the interactive shell, you can just type
# play, add, remove, clear, wait, save_state and restore,
# instead of self.play, self.add, self.remove, etc.
# To interact with the window, type touch().  You can then
# scroll in the window, or zoom by holding down 'z' while scrolling,
# and change camera perspective by holding down 'd' while moving
# the mouse.  Press 'r' to reset to the standard camera position.
# Press 'q' to stop interacting with the window and go back to
# typing new commands into the shell.
# In principle you can customize a scene to be responsive to
# mouse and keyboard interactions
always
(
circle
.
move_to
,
self
.
mouse_point
)
This scene is similar to what we wrote in
Quick Start
.
And how to interact has been written in the comments.
No more explanation here.
AnimatingMethods
¶
AnimatingMethods
¶
class
AnimatingMethods
(
Scene
):
def
construct
(
self
):
grid
=
OldTex
(
r
"\pi"
)
.
get_grid
(
10
,
10
,
height
=
4
)
self
.
add
(
grid
)
# You can animate the application of mobject methods with the
# ".animate" syntax:
self
.
play
(
grid
.
animate
.
shift
(
LEFT
))
# Alternatively, you can use the older syntax by passing the
# method and then the arguments to the scene's "play" function:
self
.
play
(
grid
.
shift
,
LEFT
)
# Both of those will interpolate between the mobject's initial
# state and whatever happens when you apply that method.
# For this example, calling grid.shift(LEFT) would shift the
# grid one unit to the left, but both of the previous calls to
# "self.play" animate that motion.
# The same applies for any method, including those setting colors.
self
.
play
(
grid
.
animate
.
set_color
(
YELLOW
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_submobject_colors_by_gradient
(
BLUE
,
GREEN
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_height
(
TAU
-
MED_SMALL_BUFF
))
self
.
wait
()
# The method Mobject.apply_complex_function lets you apply arbitrary
# complex functions, treating the points defining the mobject as
# complex numbers.
self
.
play
(
grid
.
animate
.
apply_complex_function
(
np
.
exp
),
run_time
=
5
)
self
.
wait
()
# Even more generally, you could apply Mobject.apply_function,
# which takes in functions form R^3 to R^3
self
.
play
(
grid
.
animate
.
apply_function
(
lambda
p
:
[
p
[
0
]
+
0.5
*
math
.
sin
(
p
[
1
]),
p
[
1
]
+
0.5
*
math
.
sin
(
p
[
0
]),
p
[
2
]
]
),
run_time
=
5
,
)
self
.
wait
()
The new usage in this scene is
.get_grid()
and
self.play(mob.animate.method(args))
.
.get_grid()
method will return a new mobject containing multiple copies of this one arranged in a grid.
self.play(mob.animate.method(args))
animates the method, and the details are in the comments above.
TextExample
¶
TextExample
¶
class
TextExample
(
Scene
):
def
construct
(
self
):
# To run this scene properly, you should have "Consolas" font in your computer
# for full usage, you can see https://github.com/3b1b/manim/pull/680
text
=
Text
(
"Here is a text"
,
font
=
"Consolas"
,
font_size
=
90
)
difference
=
Text
(
"""
The most important difference between Text and TexText is that\n
you can change the font more easily, but can't use the LaTeX grammar
"""
,
font
=
"Arial"
,
font_size
=
24
,
# t2c is a dict that you can choose color for different text
t2c
=
{
"Text"
:
BLUE
,
"TexText"
:
BLUE
,
"LaTeX"
:
ORANGE
}
)
VGroup
(
text
,
difference
)
.
arrange
(
DOWN
,
buff
=
1
)
self
.
play
(
Write
(
text
))
self
.
play
(
FadeIn
(
difference
,
UP
))
self
.
wait
(
3
)
fonts
=
Text
(
"And you can also set the font according to different words"
,
font
=
"Arial"
,
t2f
=
{
"font"
:
"Consolas"
,
"words"
:
"Consolas"
},
t2c
=
{
"font"
:
BLUE
,
"words"
:
GREEN
}
)
fonts
.
set_width
(
FRAME_WIDTH
-
1
)
slant
=
Text
(
"And the same as slant and weight"
,
font
=
"Consolas"
,
t2s
=
{
"slant"
:
ITALIC
},
t2w
=
{
"weight"
:
BOLD
},
t2c
=
{
"slant"
:
ORANGE
,
"weight"
:
RED
}
)
VGroup
(
fonts
,
slant
)
.
arrange
(
DOWN
,
buff
=
0.8
)
self
.
play
(
FadeOut
(
text
),
FadeOut
(
difference
,
shift
=
DOWN
))
self
.
play
(
Write
(
fonts
))
self
.
wait
()
self
.
play
(
Write
(
slant
))
self
.
wait
()
The new classes in this scene are
Text
,
VGroup
,
Write
,
FadeIn
and
FadeOut
.
Text
can create text, define fonts, etc. The usage ais clearly reflected in the above examples.
VGroup
can put multiple
VMobject
together as a whole. In the example, the
.arrange()
method is called to arrange the sub-mobjects in sequence downward (
DOWN
), and the spacing is
buff
.
Write
is an animation that shows similar writing effects.
FadeIn
fades the object in, the second parameter indicates the direction of the fade in.
FadeOut
fades out the object, the second parameter indicates the direction of the fade out.
TexTransformExample
¶
TexTransformExample
¶
class
TexTransformExample
(
Scene
):
def
construct
(
self
):
to_isolate
=
[
"B"
,
"C"
,
"="
,
"("
,
")"
]
lines
=
VGroup
(
# Passing in muliple arguments to Tex will result
# in the same expression as if those arguments had
# been joined together, except that the submobject
# hierarchy of the resulting mobject ensure that the
# Tex mobject has a subject corresponding to
# each of these strings.  For example, the Tex mobject
# below will have 5 subjects, corresponding to the
# expressions [A^2, +, B^2, =, C^2]
OldTex
(
"A^2"
,
"+"
,
"B^2"
,
"="
,
"C^2"
),
# Likewise here
OldTex
(
"A^2"
,
"="
,
"C^2"
,
"-"
,
"B^2"
),
# Alternatively, you can pass in the keyword argument
# "isolate" with a list of strings that should be out as
# their own submobject.  So the line below is equivalent
# to the commented out line below it.
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A^2"
,
*
to_isolate
]),
# OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
OldTex
(
"A =
\\
sqrt{(C + B)(C - B)}"
,
isolate
=
[
"A"
,
*
to_isolate
])
)
lines
.
arrange
(
DOWN
,
buff
=
LARGE_BUFF
)
for
line
in
lines
:
line
.
set_color_by_tex_to_color_map
({
"A"
:
BLUE
,
"B"
:
TEAL
,
"C"
:
GREEN
,
})
play_kw
=
{
"run_time"
:
2
}
self
.
add
(
lines
[
0
])
# The animation TransformMatchingTex will line up parts
# of the source and target which have matching tex strings.
# Here, giving it a little path_arc makes each part sort of
# rotate into their final positions, which feels appropriate
# for the idea of rearranging an equation
self
.
play
(
TransformMatchingTex
(
lines
[
0
]
.
copy
(),
lines
[
1
],
path_arc
=
90
*
DEGREES
,
),
**
play_kw
)
self
.
wait
()
# Now, we could try this again on the next line...
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
]),
**
play_kw
)
self
.
wait
()
# ...and this looks nice enough, but since there's no tex
# in lines[2] which matches "C^2" or "B^2", those terms fade
# out to nothing while the C and B terms fade in from nothing.
# If, however, we want the C^2 to go to C, and B^2 to go to B,
# we can specify that with a key map.
self
.
play
(
FadeOut
(
lines
[
2
]))
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
],
key_map
=
{
"C^2"
:
"C"
,
"B^2"
:
"B"
,
}
),
**
play_kw
)
self
.
wait
()
# And to finish off, a simple TransformMatchingShapes would work
# just fine.  But perhaps we want that exponent on A^2 to transform into
# the square root symbol.  At the moment, lines[2] treats the expression
# A^2 as a unit, so we might create a new version of the same line which
# separates out just the A.  This way, when TransformMatchingTex lines up
# all matching parts, the only mismatch will be between the "^2" from
# new_line2 and the "\sqrt" from the final line.  By passing in,
# transform_mismatches=True, it will transform this "^2" part into
# the "\sqrt" part.
new_line2
=
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A"
,
*
to_isolate
])
new_line2
.
replace
(
lines
[
2
])
new_line2
.
match_style
(
lines
[
2
])
self
.
play
(
TransformMatchingTex
(
new_line2
,
lines
[
3
],
transform_mismatches
=
True
,
),
**
play_kw
)
self
.
wait
(
3
)
self
.
play
(
FadeOut
(
lines
,
RIGHT
))
# Alternatively, if you don't want to think about breaking up
# the tex strings deliberately, you can TransformMatchingShapes,
# which will try to line up all pieces of a source mobject with
# those of a target, regardless of the submobject hierarchy in
# each one, according to whether those pieces have the same
# shape (as best it can).
source
=
Text
(
"the morse code"
,
height
=
1
)
target
=
Text
(
"here come dots"
,
height
=
1
)
self
.
play
(
Write
(
source
))
self
.
wait
()
kw
=
{
"run_time"
:
3
,
"path_arc"
:
PI
/
2
}
self
.
play
(
TransformMatchingShapes
(
source
,
target
,
**
kw
))
self
.
wait
()
self
.
play
(
TransformMatchingShapes
(
target
,
source
,
**
kw
))
self
.
wait
()
The new classes in this scene are
Tex
,
TexText
,
TransformMatchingTex
and
TransformMatchingShapes
.
Tex
uses LaTeX to create mathematical formulas.
TexText
uses LaTeX to create text.
TransformMatchingTeX
automatically transforms sub-objects according to the similarities and differences of tex in
Tex
.
TransformMatchingShapes
automatically transform sub-objects directly based on the similarities and differences of the object point sets.
UpdatersExample
¶
UpdatersExample
¶
class
UpdatersExample
(
Scene
):
def
construct
(
self
):
square
=
Square
()
square
.
set_fill
(
BLUE_E
,
1
)
# On all all frames, the constructor Brace(square, UP) will
# be called, and the mobject brace will set its data to match
# that of the newly constructed object
brace
=
always_redraw
(
Brace
,
square
,
UP
)
text
,
number
=
label
=
VGroup
(
Text
(
"Width = "
),
DecimalNumber
(
0
,
show_ellipsis
=
True
,
num_decimal_places
=
2
,
include_sign
=
True
,
)
)
label
.
arrange
(
RIGHT
)
# This ensures that the method deicmal.next_to(square)
# is called on every frame
always
(
label
.
next_to
,
brace
,
UP
)
# You could also write the following equivalent line
# label.add_updater(lambda m: m.next_to(brace, UP))
# If the argument itself might change, you can use f_always,
# for which the arguments following the initial Mobject method
# should be functions returning arguments to that method.
# The following line ensures that decimal.set_value(square.get_y())
# is called every frame
f_always
(
number
.
set_value
,
square
.
get_width
)
# You could also write the following equivalent line
# number.add_updater(lambda m: m.set_value(square.get_width()))
self
.
add
(
square
,
brace
,
label
)
# Notice that the brace and label track with the square
self
.
play
(
square
.
animate
.
scale
(
2
),
rate_func
=
there_and_back
,
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
5
,
stretch
=
True
),
run_time
=
3
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
2
),
run_time
=
3
)
self
.
wait
()
# In general, you can alway call Mobject.add_updater, and pass in
# a function that you want to be called on every frame.  The function
# should take in either one argument, the mobject, or two arguments,
# the mobject and the amount of time since the last frame.
now
=
self
.
time
w0
=
square
.
get_width
()
square
.
add_updater
(
lambda
m
:
m
.
set_width
(
w0
*
math
.
cos
(
self
.
time
-
now
))
)
self
.
wait
(
4
*
PI
)
The new classes and usage in this scene are
always_redraw()
,
DecimalNumber
,
.to_edge()
,
.center()
,
always()
,
f_always()
,
.set_y()
and
.add_updater()
.
always_redraw()
function create a new mobject every frame.
DecimalNumber
is a variable number, speed it up by breaking it into
Text
characters.
.to_edge()
means to place the object on the edge of the screen.
.center()
means to place the object in the center of the screen.
always(f,
x)
means that a certain function (
f(x)
) is executed every frame.
f_always(f,
g)
is similar to
always
, executed
f(g())
every frame.
.set_y()
means to set the ordinate of the object on the screen.
.add_updater()
sets an update function for the object. For example:
mob1.add_updater(lambda
mob:
mob.next_to(mob2))
means
mob1.next_to(mob2)
is executed every frame.
CoordinateSystemExample
¶
CoordinateSystemExample
¶
class
CoordinateSystemExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
(
# x-axis ranges from -1 to 10, with a default step size of 1
x_range
=
(
-
1
,
10
),
# y-axis ranges from -2 to 2 with a step size of 0.5
y_range
=
(
-
2
,
2
,
0.5
),
# The axes will be stretched so as to match the specified
# height and width
height
=
6
,
width
=
10
,
# Axes is made of two NumberLine mobjects.  You can specify
# their configuration with axis_config
axis_config
=
{
"stroke_color"
:
GREY_A
,
"stroke_width"
:
2
,
},
# Alternatively, you can specify configuration for just one
# of them, like this.
y_axis_config
=
{
"include_tip"
:
False
,
}
)
# Keyword arguments of add_coordinate_labels can be used to
# configure the DecimalNumber mobjects which it creates and
# adds to the axes
axes
.
add_coordinate_labels
(
font_size
=
20
,
num_decimal_places
=
1
,
)
self
.
add
(
axes
)
# Axes descends from the CoordinateSystem class, meaning
# you can call call axes.coords_to_point, abbreviated to
# axes.c2p, to associate a set of coordinates with a point,
# like so:
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
c2p
(
0
,
0
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
5
,
0.5
)))
self
.
wait
()
# Similarly, you can call axes.point_to_coords, or axes.p2c
# print(axes.p2c(dot.get_center()))
# We can draw lines from the axes to better mark the coordinates
# of a given point.
# Here, the always_redraw command means that on each new frame
# the lines will be redrawn
h_line
=
always_redraw
(
lambda
:
axes
.
get_h_line
(
dot
.
get_left
()))
v_line
=
always_redraw
(
lambda
:
axes
.
get_v_line
(
dot
.
get_bottom
()))
self
.
play
(
ShowCreation
(
h_line
),
ShowCreation
(
v_line
),
)
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
-
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
1
,
1
)))
self
.
wait
()
# If we tie the dot to a particular set of coordinates, notice
# that as we move the axes around it respects the coordinate
# system defined by them.
f_always
(
dot
.
move_to
,
lambda
:
axes
.
c2p
(
1
,
1
))
self
.
play
(
axes
.
animate
.
scale
(
0.75
)
.
to_corner
(
UL
),
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
FadeOut
(
VGroup
(
axes
,
dot
,
h_line
,
v_line
)))
# Other coordinate systems you can play around with include
# ThreeDAxes, NumberPlane, and ComplexPlane.
GraphExample
¶
GraphExample
¶
class
GraphExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
((
-
3
,
10
),
(
-
1
,
8
))
axes
.
add_coordinate_labels
()
self
.
play
(
Write
(
axes
,
lag_ratio
=
0.01
,
run_time
=
1
))
# Axes.get_graph will return the graph of a function
sin_graph
=
axes
.
get_graph
(
lambda
x
:
2
*
math
.
sin
(
x
),
color
=
BLUE
,
)
# By default, it draws it so as to somewhat smoothly interpolate
# between sampled points (x, f(x)).  If the graph is meant to have
# a corner, though, you can set use_smoothing to False
relu_graph
=
axes
.
get_graph
(
lambda
x
:
max
(
x
,
0
),
use_smoothing
=
False
,
color
=
YELLOW
,
)
# For discontinuous functions, you can specify the point of
# discontinuity so that it does not try to draw over the gap.
step_graph
=
axes
.
get_graph
(
lambda
x
:
2.0
if
x
>
3
else
1.0
,
discontinuities
=
[
3
],
color
=
GREEN
,
)
# Axes.get_graph_label takes in either a string or a mobject.
# If it's a string, it treats it as a LaTeX expression.  By default
# it places the label next to the graph near the right side, and
# has it match the color of the graph
sin_label
=
axes
.
get_graph_label
(
sin_graph
,
"
\\
sin(x)"
)
relu_label
=
axes
.
get_graph_label
(
relu_graph
,
Text
(
"ReLU"
))
step_label
=
axes
.
get_graph_label
(
step_graph
,
Text
(
"Step"
),
x
=
4
)
self
.
play
(
ShowCreation
(
sin_graph
),
FadeIn
(
sin_label
,
RIGHT
),
)
self
.
wait
(
2
)
self
.
play
(
ReplacementTransform
(
sin_graph
,
relu_graph
),
FadeTransform
(
sin_label
,
relu_label
),
)
self
.
wait
()
self
.
play
(
ReplacementTransform
(
relu_graph
,
step_graph
),
FadeTransform
(
relu_label
,
step_label
),
)
self
.
wait
()
parabola
=
axes
.
get_graph
(
lambda
x
:
0.25
*
x
**
2
)
parabola
.
set_stroke
(
BLUE
)
self
.
play
(
FadeOut
(
step_graph
),
FadeOut
(
step_label
),
ShowCreation
(
parabola
)
)
self
.
wait
()
# You can use axes.input_to_graph_point, abbreviated
# to axes.i2gp, to find a particular point on a graph
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
i2gp
(
2
,
parabola
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
# A value tracker lets us animate a parameter, usually
# with the intent of having other mobjects update based
# on the parameter
x_tracker
=
ValueTracker
(
2
)
f_always
(
dot
.
move_to
,
lambda
:
axes
.
i2gp
(
x_tracker
.
get_value
(),
parabola
)
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
4
),
run_time
=
3
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
-
2
),
run_time
=
3
)
self
.
wait
()
SurfaceExample
¶
SurfaceExample
¶
class
SurfaceExample
(
Scene
):
CONFIG
=
{
"camera_class"
:
ThreeDCamera
,
}
def
construct
(
self
):
surface_text
=
Text
(
"For 3d scenes, try using surfaces"
)
surface_text
.
fix_in_frame
()
surface_text
.
to_edge
(
UP
)
self
.
add
(
surface_text
)
self
.
wait
(
0.1
)
torus1
=
Torus
(
r1
=
1
,
r2
=
1
)
torus2
=
Torus
(
r1
=
3
,
r2
=
1
)
sphere
=
Sphere
(
radius
=
3
,
resolution
=
torus1
.
resolution
)
# You can texture a surface with up to two images, which will
# be interpreted as the side towards the light, and away from
# the light.  These can be either urls, or paths to a local file
# in whatever you've set as the image directory in
# the custom_config.yml file
# day_texture = "EarthTextureMap"
# night_texture = "NightEarthTextureMap"
day_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
night_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"
surfaces
=
[
TexturedSurface
(
surface
,
day_texture
,
night_texture
)
for
surface
in
[
sphere
,
torus1
,
torus2
]
]
for
mob
in
surfaces
:
mob
.
shift
(
IN
)
mob
.
mesh
=
SurfaceMesh
(
mob
)
mob
.
mesh
.
set_stroke
(
BLUE
,
1
,
opacity
=
0.5
)
# Set perspective
frame
=
self
.
camera
.
frame
frame
.
set_euler_angles
(
theta
=-
30
*
DEGREES
,
phi
=
70
*
DEGREES
,
)
surface
=
surfaces
[
0
]
self
.
play
(
FadeIn
(
surface
),
ShowCreation
(
surface
.
mesh
,
lag_ratio
=
0.01
,
run_time
=
3
),
)
for
mob
in
surfaces
:
mob
.
add
(
mob
.
mesh
)
surface
.
save_state
()
self
.
play
(
Rotate
(
surface
,
PI
/
2
),
run_time
=
2
)
for
mob
in
surfaces
[
1
:]:
mob
.
rotate
(
PI
/
2
)
self
.
play
(
Transform
(
surface
,
surfaces
[
1
]),
run_time
=
3
)
self
.
play
(
Transform
(
surface
,
surfaces
[
2
]),
# Move camera frame during the transition
frame
.
animate
.
increment_phi
(
-
10
*
DEGREES
),
frame
.
animate
.
increment_theta
(
-
20
*
DEGREES
),
run_time
=
3
)
# Add ambient rotation
frame
.
add_updater
(
lambda
m
,
dt
:
m
.
increment_theta
(
-
0.1
*
dt
))
# Play around with where the light is
light_text
=
Text
(
"You can move around the light source"
)
light_text
.
move_to
(
surface_text
)
light_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
surface_text
,
light_text
))
light
=
self
.
camera
.
light_source
self
.
add
(
light
)
light
.
save_state
()
self
.
play
(
light
.
animate
.
move_to
(
3
*
IN
),
run_time
=
5
)
self
.
play
(
light
.
animate
.
shift
(
10
*
OUT
),
run_time
=
5
)
drag_text
=
Text
(
"Try moving the mouse while pressing d or s"
)
drag_text
.
move_to
(
light_text
)
drag_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
light_text
,
drag_text
))
self
.
wait
()
This scene shows an example of using a three-dimensional surface, and
the related usage has been briefly described in the notes.
.fix_in_frame()
makes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.
OpeningManimExample
¶
OpeningManimExample
¶
class
OpeningManimExample
(
Scene
):
def
construct
(
self
):
intro_words
=
Text
(
"""
The original motivation for manim was to
better illustrate mathematical functions
as transformations.
"""
)
intro_words
.
to_edge
(
UP
)
self
.
play
(
Write
(
intro_words
))
self
.
wait
(
2
)
# Linear transform
grid
=
NumberPlane
((
-
10
,
10
),
(
-
5
,
5
))
matrix
=
[[
1
,
1
],
[
0
,
1
]]
linear_transform_words
=
VGroup
(
Text
(
"This is what the matrix"
),
IntegerMatrix
(
matrix
,
include_background_rectangle
=
True
),
Text
(
"looks like"
)
)
linear_transform_words
.
arrange
(
RIGHT
)
linear_transform_words
.
to_edge
(
UP
)
linear_transform_words
.
set_stroke
(
BLACK
,
10
,
background
=
True
)
self
.
play
(
ShowCreation
(
grid
),
FadeTransform
(
intro_words
,
linear_transform_words
)
)
self
.
wait
()
self
.
play
(
grid
.
animate
.
apply_matrix
(
matrix
),
run_time
=
3
)
self
.
wait
()
# Complex map
c_grid
=
ComplexPlane
()
moving_c_grid
=
c_grid
.
copy
()
moving_c_grid
.
prepare_for_nonlinear_transform
()
c_grid
.
set_stroke
(
BLUE_E
,
1
)
c_grid
.
add_coordinate_labels
(
font_size
=
24
)
complex_map_words
=
TexText
(
"""
Or thinking of the plane as $
\\
mathds
{C}
$,
\\\\
this is the map $z
\\
rightarrow z^2$
"""
)
complex_map_words
.
to_corner
(
UR
)
complex_map_words
.
set_stroke
(
BLACK
,
5
,
background
=
True
)
self
.
play
(
FadeOut
(
grid
),
Write
(
c_grid
,
run_time
=
3
),
FadeIn
(
moving_c_grid
),
FadeTransform
(
linear_transform_words
,
complex_map_words
),
)
self
.
wait
()
self
.
play
(
moving_c_grid
.
animate
.
apply_complex_function
(
lambda
z
:
z
**
2
),
run_time
=
6
,
)
self
.
wait
(
2
)
This scene is a comprehensive application of a two-dimensional scene.
After seeing these scenes, you have already understood part of the
usage of manim. For more examples, see
the video code of 3b1b
.
Contents
Example Scenes
InteractiveDevlopment
AnimatingMethods
TextExample
TexTransformExample
UpdatersExample
CoordinateSystemExample
GraphExample
SurfaceExample
OpeningManimExample

Code Examples:
Example 1:
```python
example_scenes.py
```
Example 2:
```python
from manimlib import *

class InteractiveDevelopment(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)
        square = Square()

        self.play(ShowCreation(square))
        self.wait()

        # This opens an iPython terminal where you can keep writing
        # lines as if they were part of this construct method.
        # In particular, 'square', 'circle' and 'self' will all be
        # part of the local namespace in that terminal.
        self.embed()

        # Try copying and pasting some of the lines below into
        # the interactive shell
        self.play(ReplacementTransform(square, circle))
        self.wait()
        self.play(circle.animate.stretch(4, 0))
        self.play(Rotate(circle, 90 * DEGREES))
        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))

        text = Text("""
            In general, using the interactive shell
            is very helpful when developing new scenes
        """)
        self.play(Write(text))

        # In the interactive shell, you can just type
        # play, add, remove, clear, wait, save_state and restore,
        # instead of self.play, self.add, self.remove, etc.

        # To interact with the window, type touch().  You can then
        # scroll in the window, or zoom by holding down 'z' while scrolling,
        # and change camera perspective by holding down 'd' while moving
        # the mouse.  Press 'r' to reset to the standard camera position.
        # Press 'q' to stop interacting with the window and go back to
        # typing new commands into the shell.

        # In principle you can customize a scene to be responsive to
        # mouse and keyboard interactions
        always(circle.move_to, self.mouse_point)
```
Example 3:
```python
class AnimatingMethods(Scene):
    def construct(self):
        grid = OldTex(r"\pi").get_grid(10, 10, height=4)
        self.add(grid)

        # You can animate the application of mobject methods with the
        # ".animate" syntax:
        self.play(grid.animate.shift(LEFT))

        # Alternatively, you can use the older syntax by passing the
        # method and then the arguments to the scene's "play" function:
        self.play(grid.shift, LEFT)

        # Both of those will interpolate between the mobject's initial
        # state and whatever happens when you apply that method.
        # For this example, calling grid.shift(LEFT) would shift the
        # grid one unit to the left, but both of the previous calls to
        # "self.play" animate that motion.

        # The same applies for any method, including those setting colors.
        self.play(grid.animate.set_color(YELLOW))
        self.wait()
        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))
        self.wait()
        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))
        self.wait()

        # The method Mobject.apply_complex_function lets you apply arbitrary
        # complex functions, treating the points defining the mobject as
        # complex numbers.
        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)
        self.wait()

        # Even more generally, you could apply Mobject.apply_function,
        # which takes in functions form R^3 to R^3
        self.play(
            grid.animate.apply_function(
                lambda p: [
                    p[0] + 0.5 * math.sin(p[1]),
                    p[1] + 0.5 * math.sin(p[0]),
                    p[2]
                ]
            ),
            run_time=5,
        )
        self.wait()
```
Example 4:
```python
.get_grid()
```
Example 5:
```python
self.play(mob.animate.method(args))
```
Example 6:
```python
.get_grid()
```
Example 7:
```python
self.play(mob.animate.method(args))
```
Example 8:
```python
class TextExample(Scene):
    def construct(self):
        # To run this scene properly, you should have "Consolas" font in your computer
        # for full usage, you can see https://github.com/3b1b/manim/pull/680
        text = Text("Here is a text", font="Consolas", font_size=90)
        difference = Text(
            """
            The most important difference between Text and TexText is that\n
            you can change the font more easily, but can't use the LaTeX grammar
            """,
            font="Arial", font_size=24,
            # t2c is a dict that you can choose color for different text
            t2c={"Text": BLUE, "TexText": BLUE, "LaTeX": ORANGE}
        )
        VGroup(text, difference).arrange(DOWN, buff=1)
        self.play(Write(text))
        self.play(FadeIn(difference, UP))
        self.wait(3)

        fonts = Text(
            "And you can also set the font according to different words",
            font="Arial",
            t2f={"font": "Consolas", "words": "Consolas"},
            t2c={"font": BLUE, "words": GREEN}
        )
        fonts.set_width(FRAME_WIDTH - 1)
        slant = Text(
            "And the same as slant and weight",
            font="Consolas",
            t2s={"slant": ITALIC},
            t2w={"weight": BOLD},
            t2c={"slant": ORANGE, "weight": RED}
        )
        VGroup(fonts, slant).arrange(DOWN, buff=0.8)
        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))
        self.play(Write(fonts))
        self.wait()
        self.play(Write(slant))
        self.wait()
```
Example 9:
```python
class TexTransformExample(Scene):
    def construct(self):
        to_isolate = ["B", "C", "=", "(", ")"]
        lines = VGroup(
            # Passing in muliple arguments to Tex will result
            # in the same expression as if those arguments had
            # been joined together, except that the submobject
            # hierarchy of the resulting mobject ensure that the
            # Tex mobject has a subject corresponding to
            # each of these strings.  For example, the Tex mobject
            # below will have 5 subjects, corresponding to the
            # expressions [A^2, +, B^2, =, C^2]
            OldTex("A^2", "+", "B^2", "=", "C^2"),
            # Likewise here
            OldTex("A^2", "=", "C^2", "-", "B^2"),
            # Alternatively, you can pass in the keyword argument
            # "isolate" with a list of strings that should be out as
            # their own submobject.  So the line below is equivalent
            # to the commented out line below it.
            OldTex("A^2 = (C + B)(C - B)", isolate=["A^2", *to_isolate]),
            # OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
            OldTex("A = \\sqrt{(C + B)(C - B)}", isolate=["A", *to_isolate])
        )
        lines.arrange(DOWN, buff=LARGE_BUFF)
        for line in lines:
            line.set_color_by_tex_to_color_map({
                "A": BLUE,
                "B": TEAL,
                "C": GREEN,
            })

        play_kw = {"run_time": 2}
        self.add(lines[0])
        # The animation TransformMatchingTex will line up parts
        # of the source and target which have matching tex strings.
        # Here, giving it a little path_arc makes each part sort of
        # rotate into their final positions, which feels appropriate
        # for the idea of rearranging an equation
        self.play(
            TransformMatchingTex(
                lines[0].copy(), lines[1],
                path_arc=90 * DEGREES,
            ),
            **play_kw
        )
        self.wait()

        # Now, we could try this again on the next line...
        self.play(
            TransformMatchingTex(lines[1].copy(), lines[2]),
            **play_kw
        )
        self.wait()
        # ...and this looks nice enough, but since there's no tex
        # in lines[2] which matches "C^2" or "B^2", those terms fade
        # out to nothing while the C and B terms fade in from nothing.
        # If, however, we want the C^2 to go to C, and B^2 to go to B,
        # we can specify that with a key map.
        self.play(FadeOut(lines[2]))
        self.play(
            TransformMatchingTex(
                lines[1].copy(), lines[2],
                key_map={
                    "C^2": "C",
                    "B^2": "B",
                }
            ),
            **play_kw
        )
        self.wait()

        # And to finish off, a simple TransformMatchingShapes would work
        # just fine.  But perhaps we want that exponent on A^2 to transform into
        # the square root symbol.  At the moment, lines[2] treats the expression
        # A^2 as a unit, so we might create a new version of the same line which
        # separates out just the A.  This way, when TransformMatchingTex lines up
        # all matching parts, the only mismatch will be between the "^2" from
        # new_line2 and the "\sqrt" from the final line.  By passing in,
        # transform_mismatches=True, it will transform this "^2" part into
        # the "\sqrt" part.
        new_line2 = OldTex("A^2 = (C + B)(C - B)", isolate=["A", *to_isolate])
        new_line2.replace(lines[2])
        new_line2.match_style(lines[2])

        self.play(
            TransformMatchingTex(
                new_line2, lines[3],
                transform_mismatches=True,
            ),
            **play_kw
        )
        self.wait(3)
        self.play(FadeOut(lines, RIGHT))

        # Alternatively, if you don't want to think about breaking up
        # the tex strings deliberately, you can TransformMatchingShapes,
        # which will try to line up all pieces of a source mobject with
        # those of a target, regardless of the submobject hierarchy in
        # each one, according to whether those pieces have the same
        # shape (as best it can).
        source = Text("the morse code", height=1)
        target = Text("here come dots", height=1)

        self.play(Write(source))
        self.wait()
        kw = {"run_time": 3, "path_arc": PI / 2}
        self.play(TransformMatchingShapes(source, target, **kw))
        self.wait()
        self.play(TransformMatchingShapes(target, source, **kw))
        self.wait()
```
Example 10:
```python
TransformMatchingTex
```
Example 11:
```python
TransformMatchingShapes
```
Example 12:
```python
TransformMatchingTeX
```
Example 13:
```python
TransformMatchingShapes
```
Example 14:
```python
class UpdatersExample(Scene):
    def construct(self):
        square = Square()
        square.set_fill(BLUE_E, 1)

        # On all all frames, the constructor Brace(square, UP) will
        # be called, and the mobject brace will set its data to match
        # that of the newly constructed object
        brace = always_redraw(Brace, square, UP)

        text, number = label = VGroup(
            Text("Width = "),
            DecimalNumber(
                0,
                show_ellipsis=True,
                num_decimal_places=2,
                include_sign=True,
            )
        )
        label.arrange(RIGHT)

        # This ensures that the method deicmal.next_to(square)
        # is called on every frame
        always(label.next_to, brace, UP)
        # You could also write the following equivalent line
        # label.add_updater(lambda m: m.next_to(brace, UP))

        # If the argument itself might change, you can use f_always,
        # for which the arguments following the initial Mobject method
        # should be functions returning arguments to that method.
        # The following line ensures that decimal.set_value(square.get_y())
        # is called every frame
        f_always(number.set_value, square.get_width)
        # You could also write the following equivalent line
        # number.add_updater(lambda m: m.set_value(square.get_width()))

        self.add(square, brace, label)

        # Notice that the brace and label track with the square
        self.play(
            square.animate.scale(2),
            rate_func=there_and_back,
            run_time=2,
        )
        self.wait()
        self.play(
            square.animate.set_width(5, stretch=True),
            run_time=3,
        )
        self.wait()
        self.play(
            square.animate.set_width(2),
            run_time=3
        )
        self.wait()

        # In general, you can alway call Mobject.add_updater, and pass in
        # a function that you want to be called on every frame.  The function
        # should take in either one argument, the mobject, or two arguments,
        # the mobject and the amount of time since the last frame.
        now = self.time
        w0 = square.get_width()
        square.add_updater(
            lambda m: m.set_width(w0 * math.cos(self.time - now))
        )
        self.wait(4 * PI)
```
Example 15:
```python
always_redraw()
```
Example 16:
```python
DecimalNumber
```
Example 17:
```python
.add_updater()
```
Example 18:
```python
always_redraw()
```
Example 19:
```python
DecimalNumber
```
Example 20:
```python
always(f, x)
```
Example 21:
```python
f_always(f, g)
```
Example 22:
```python
.add_updater()
```
Example 23:
```python
mob1.add_updater(lambda mob: mob.next_to(mob2))
```
Example 24:
```python
mob1.next_to(mob2)
```
Example 25:
```python
class CoordinateSystemExample(Scene):
    def construct(self):
        axes = Axes(
            # x-axis ranges from -1 to 10, with a default step size of 1
            x_range=(-1, 10),
            # y-axis ranges from -2 to 2 with a step size of 0.5
            y_range=(-2, 2, 0.5),
            # The axes will be stretched so as to match the specified
            # height and width
            height=6,
            width=10,
            # Axes is made of two NumberLine mobjects.  You can specify
            # their configuration with axis_config
            axis_config={
                "stroke_color": GREY_A,
                "stroke_width": 2,
            },
            # Alternatively, you can specify configuration for just one
            # of them, like this.
            y_axis_config={
                "include_tip": False,
            }
        )
        # Keyword arguments of add_coordinate_labels can be used to
        # configure the DecimalNumber mobjects which it creates and
        # adds to the axes
        axes.add_coordinate_labels(
            font_size=20,
            num_decimal_places=1,
        )
        self.add(axes)

        # Axes descends from the CoordinateSystem class, meaning
        # you can call call axes.coords_to_point, abbreviated to
        # axes.c2p, to associate a set of coordinates with a point,
        # like so:
        dot = Dot(color=RED)
        dot.move_to(axes.c2p(0, 0))
        self.play(FadeIn(dot, scale=0.5))
        self.play(dot.animate.move_to(axes.c2p(3, 2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))
        self.wait()

        # Similarly, you can call axes.point_to_coords, or axes.p2c
        # print(axes.p2c(dot.get_center()))

        # We can draw lines from the axes to better mark the coordinates
        # of a given point.
        # Here, the always_redraw command means that on each new frame
        # the lines will be redrawn
        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))
        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))

        self.play(
            ShowCreation(h_line),
            ShowCreation(v_line),
        )
        self.play(dot.animate.move_to(axes.c2p(3, -2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(1, 1)))
        self.wait()

        # If we tie the dot to a particular set of coordinates, notice
        # that as we move the axes around it respects the coordinate
        # system defined by them.
        f_always(dot.move_to, lambda: axes.c2p(1, 1))
        self.play(
            axes.animate.scale(0.75).to_corner(UL),
            run_time=2,
        )
        self.wait()
        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))

        # Other coordinate systems you can play around with include
        # ThreeDAxes, NumberPlane, and ComplexPlane.
```
Example 26:
```python
class GraphExample(Scene):
    def construct(self):
        axes = Axes((-3, 10), (-1, 8))
        axes.add_coordinate_labels()

        self.play(Write(axes, lag_ratio=0.01, run_time=1))

        # Axes.get_graph will return the graph of a function
        sin_graph = axes.get_graph(
            lambda x: 2 * math.sin(x),
            color=BLUE,
        )
        # By default, it draws it so as to somewhat smoothly interpolate
        # between sampled points (x, f(x)).  If the graph is meant to have
        # a corner, though, you can set use_smoothing to False
        relu_graph = axes.get_graph(
            lambda x: max(x, 0),
            use_smoothing=False,
            color=YELLOW,
        )
        # For discontinuous functions, you can specify the point of
        # discontinuity so that it does not try to draw over the gap.
        step_graph = axes.get_graph(
            lambda x: 2.0 if x > 3 else 1.0,
            discontinuities=[3],
            color=GREEN,
        )

        # Axes.get_graph_label takes in either a string or a mobject.
        # If it's a string, it treats it as a LaTeX expression.  By default
        # it places the label next to the graph near the right side, and
        # has it match the color of the graph
        sin_label = axes.get_graph_label(sin_graph, "\\sin(x)")
        relu_label = axes.get_graph_label(relu_graph, Text("ReLU"))
        step_label = axes.get_graph_label(step_graph, Text("Step"), x=4)

        self.play(
            ShowCreation(sin_graph),
            FadeIn(sin_label, RIGHT),
        )
        self.wait(2)
        self.play(
            ReplacementTransform(sin_graph, relu_graph),
            FadeTransform(sin_label, relu_label),
        )
        self.wait()
        self.play(
            ReplacementTransform(relu_graph, step_graph),
            FadeTransform(relu_label, step_label),
        )
        self.wait()

        parabola = axes.get_graph(lambda x: 0.25 * x**2)
        parabola.set_stroke(BLUE)
        self.play(
            FadeOut(step_graph),
            FadeOut(step_label),
            ShowCreation(parabola)
        )
        self.wait()

        # You can use axes.input_to_graph_point, abbreviated
        # to axes.i2gp, to find a particular point on a graph
        dot = Dot(color=RED)
        dot.move_to(axes.i2gp(2, parabola))
        self.play(FadeIn(dot, scale=0.5))

        # A value tracker lets us animate a parameter, usually
        # with the intent of having other mobjects update based
        # on the parameter
        x_tracker = ValueTracker(2)
        f_always(
            dot.move_to,
            lambda: axes.i2gp(x_tracker.get_value(), parabola)
        )

        self.play(x_tracker.animate.set_value(4), run_time=3)
        self.play(x_tracker.animate.set_value(-2), run_time=3)
        self.wait()
```
Example 27:
```python
class SurfaceExample(Scene):
    CONFIG = {
        "camera_class": ThreeDCamera,
    }

    def construct(self):
        surface_text = Text("For 3d scenes, try using surfaces")
        surface_text.fix_in_frame()
        surface_text.to_edge(UP)
        self.add(surface_text)
        self.wait(0.1)

        torus1 = Torus(r1=1, r2=1)
        torus2 = Torus(r1=3, r2=1)
        sphere = Sphere(radius=3, resolution=torus1.resolution)
        # You can texture a surface with up to two images, which will
        # be interpreted as the side towards the light, and away from
        # the light.  These can be either urls, or paths to a local file
        # in whatever you've set as the image directory in
        # the custom_config.yml file

        # day_texture = "EarthTextureMap"
        # night_texture = "NightEarthTextureMap"
        day_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
        night_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"

        surfaces = [
            TexturedSurface(surface, day_texture, night_texture)
            for surface in [sphere, torus1, torus2]
        ]

        for mob in surfaces:
            mob.shift(IN)
            mob.mesh = SurfaceMesh(mob)
            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)

        # Set perspective
        frame = self.camera.frame
        frame.set_euler_angles(
            theta=-30 * DEGREES,
            phi=70 * DEGREES,
        )

        surface = surfaces[0]

        self.play(
            FadeIn(surface),
            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),
        )
        for mob in surfaces:
            mob.add(mob.mesh)
        surface.save_state()
        self.play(Rotate(surface, PI / 2), run_time=2)
        for mob in surfaces[1:]:
            mob.rotate(PI / 2)

        self.play(
            Transform(surface, surfaces[1]),
            run_time=3
        )

        self.play(
            Transform(surface, surfaces[2]),
            # Move camera frame during the transition
            frame.animate.increment_phi(-10 * DEGREES),
            frame.animate.increment_theta(-20 * DEGREES),
            run_time=3
        )
        # Add ambient rotation
        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))

        # Play around with where the light is
        light_text = Text("You can move around the light source")
        light_text.move_to(surface_text)
        light_text.fix_in_frame()

        self.play(FadeTransform(surface_text, light_text))
        light = self.camera.light_source
        self.add(light)
        light.save_state()
        self.play(light.animate.move_to(3 * IN), run_time=5)
        self.play(light.animate.shift(10 * OUT), run_time=5)

        drag_text = Text("Try moving the mouse while pressing d or s")
        drag_text.move_to(light_text)
        drag_text.fix_in_frame()

        self.play(FadeTransform(light_text, drag_text))
        self.wait()
```
Example 28:
```python
.fix_in_frame()
```
Example 29:
```python
class OpeningManimExample(Scene):
    def construct(self):
        intro_words = Text("""
            The original motivation for manim was to
            better illustrate mathematical functions
            as transformations.
        """)
        intro_words.to_edge(UP)

        self.play(Write(intro_words))
        self.wait(2)

        # Linear transform
        grid = NumberPlane((-10, 10), (-5, 5))
        matrix = [[1, 1], [0, 1]]
        linear_transform_words = VGroup(
            Text("This is what the matrix"),
            IntegerMatrix(matrix, include_background_rectangle=True),
            Text("looks like")
        )
        linear_transform_words.arrange(RIGHT)
        linear_transform_words.to_edge(UP)
        linear_transform_words.set_stroke(BLACK, 10, background=True)

        self.play(
            ShowCreation(grid),
            FadeTransform(intro_words, linear_transform_words)
        )
        self.wait()
        self.play(grid.animate.apply_matrix(matrix), run_time=3)
        self.wait()

        # Complex map
        c_grid = ComplexPlane()
        moving_c_grid = c_grid.copy()
        moving_c_grid.prepare_for_nonlinear_transform()
        c_grid.set_stroke(BLUE_E, 1)
        c_grid.add_coordinate_labels(font_size=24)
        complex_map_words = TexText("""
            Or thinking of the plane as $\\mathds{C}$,\\\\
            this is the map $z \\rightarrow z^2$
        """)
        complex_map_words.to_corner(UR)
        complex_map_words.set_stroke(BLACK, 5, background=True)

        self.play(
            FadeOut(grid),
            Write(c_grid, run_time=3),
            FadeIn(moving_c_grid),
            FadeTransform(linear_transform_words, complex_map_words),
        )
        self.wait()
        self.play(
            moving_c_grid.animate.apply_complex_function(lambda z: z**2),
            run_time=6,
        )
        self.wait(2)
```

================================================================================

=== Example Scenes - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/example_scenes.html#textexample
Content:
Example Scenes
¶
After understanding the previous knowledge, we can understand more scenes.
Many example scenes are given in
example_scenes.py
, let’s start with
the simplest and one by one.
InteractiveDevlopment
¶
InteractiveDevelopment
¶
from
manimlib
import
*
class
InteractiveDevelopment
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
square
=
Square
()
self
.
play
(
ShowCreation
(
square
))
self
.
wait
()
# This opens an iPython terminal where you can keep writing
# lines as if they were part of this construct method.
# In particular, 'square', 'circle' and 'self' will all be
# part of the local namespace in that terminal.
self
.
embed
()
# Try copying and pasting some of the lines below into
# the interactive shell
self
.
play
(
ReplacementTransform
(
square
,
circle
))
self
.
wait
()
self
.
play
(
circle
.
animate
.
stretch
(
4
,
0
))
self
.
play
(
Rotate
(
circle
,
90
*
DEGREES
))
self
.
play
(
circle
.
animate
.
shift
(
2
*
RIGHT
)
.
scale
(
0.25
))
text
=
Text
(
"""
In general, using the interactive shell
is very helpful when developing new scenes
"""
)
self
.
play
(
Write
(
text
))
# In the interactive shell, you can just type
# play, add, remove, clear, wait, save_state and restore,
# instead of self.play, self.add, self.remove, etc.
# To interact with the window, type touch().  You can then
# scroll in the window, or zoom by holding down 'z' while scrolling,
# and change camera perspective by holding down 'd' while moving
# the mouse.  Press 'r' to reset to the standard camera position.
# Press 'q' to stop interacting with the window and go back to
# typing new commands into the shell.
# In principle you can customize a scene to be responsive to
# mouse and keyboard interactions
always
(
circle
.
move_to
,
self
.
mouse_point
)
This scene is similar to what we wrote in
Quick Start
.
And how to interact has been written in the comments.
No more explanation here.
AnimatingMethods
¶
AnimatingMethods
¶
class
AnimatingMethods
(
Scene
):
def
construct
(
self
):
grid
=
OldTex
(
r
"\pi"
)
.
get_grid
(
10
,
10
,
height
=
4
)
self
.
add
(
grid
)
# You can animate the application of mobject methods with the
# ".animate" syntax:
self
.
play
(
grid
.
animate
.
shift
(
LEFT
))
# Alternatively, you can use the older syntax by passing the
# method and then the arguments to the scene's "play" function:
self
.
play
(
grid
.
shift
,
LEFT
)
# Both of those will interpolate between the mobject's initial
# state and whatever happens when you apply that method.
# For this example, calling grid.shift(LEFT) would shift the
# grid one unit to the left, but both of the previous calls to
# "self.play" animate that motion.
# The same applies for any method, including those setting colors.
self
.
play
(
grid
.
animate
.
set_color
(
YELLOW
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_submobject_colors_by_gradient
(
BLUE
,
GREEN
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_height
(
TAU
-
MED_SMALL_BUFF
))
self
.
wait
()
# The method Mobject.apply_complex_function lets you apply arbitrary
# complex functions, treating the points defining the mobject as
# complex numbers.
self
.
play
(
grid
.
animate
.
apply_complex_function
(
np
.
exp
),
run_time
=
5
)
self
.
wait
()
# Even more generally, you could apply Mobject.apply_function,
# which takes in functions form R^3 to R^3
self
.
play
(
grid
.
animate
.
apply_function
(
lambda
p
:
[
p
[
0
]
+
0.5
*
math
.
sin
(
p
[
1
]),
p
[
1
]
+
0.5
*
math
.
sin
(
p
[
0
]),
p
[
2
]
]
),
run_time
=
5
,
)
self
.
wait
()
The new usage in this scene is
.get_grid()
and
self.play(mob.animate.method(args))
.
.get_grid()
method will return a new mobject containing multiple copies of this one arranged in a grid.
self.play(mob.animate.method(args))
animates the method, and the details are in the comments above.
TextExample
¶
TextExample
¶
class
TextExample
(
Scene
):
def
construct
(
self
):
# To run this scene properly, you should have "Consolas" font in your computer
# for full usage, you can see https://github.com/3b1b/manim/pull/680
text
=
Text
(
"Here is a text"
,
font
=
"Consolas"
,
font_size
=
90
)
difference
=
Text
(
"""
The most important difference between Text and TexText is that\n
you can change the font more easily, but can't use the LaTeX grammar
"""
,
font
=
"Arial"
,
font_size
=
24
,
# t2c is a dict that you can choose color for different text
t2c
=
{
"Text"
:
BLUE
,
"TexText"
:
BLUE
,
"LaTeX"
:
ORANGE
}
)
VGroup
(
text
,
difference
)
.
arrange
(
DOWN
,
buff
=
1
)
self
.
play
(
Write
(
text
))
self
.
play
(
FadeIn
(
difference
,
UP
))
self
.
wait
(
3
)
fonts
=
Text
(
"And you can also set the font according to different words"
,
font
=
"Arial"
,
t2f
=
{
"font"
:
"Consolas"
,
"words"
:
"Consolas"
},
t2c
=
{
"font"
:
BLUE
,
"words"
:
GREEN
}
)
fonts
.
set_width
(
FRAME_WIDTH
-
1
)
slant
=
Text
(
"And the same as slant and weight"
,
font
=
"Consolas"
,
t2s
=
{
"slant"
:
ITALIC
},
t2w
=
{
"weight"
:
BOLD
},
t2c
=
{
"slant"
:
ORANGE
,
"weight"
:
RED
}
)
VGroup
(
fonts
,
slant
)
.
arrange
(
DOWN
,
buff
=
0.8
)
self
.
play
(
FadeOut
(
text
),
FadeOut
(
difference
,
shift
=
DOWN
))
self
.
play
(
Write
(
fonts
))
self
.
wait
()
self
.
play
(
Write
(
slant
))
self
.
wait
()
The new classes in this scene are
Text
,
VGroup
,
Write
,
FadeIn
and
FadeOut
.
Text
can create text, define fonts, etc. The usage ais clearly reflected in the above examples.
VGroup
can put multiple
VMobject
together as a whole. In the example, the
.arrange()
method is called to arrange the sub-mobjects in sequence downward (
DOWN
), and the spacing is
buff
.
Write
is an animation that shows similar writing effects.
FadeIn
fades the object in, the second parameter indicates the direction of the fade in.
FadeOut
fades out the object, the second parameter indicates the direction of the fade out.
TexTransformExample
¶
TexTransformExample
¶
class
TexTransformExample
(
Scene
):
def
construct
(
self
):
to_isolate
=
[
"B"
,
"C"
,
"="
,
"("
,
")"
]
lines
=
VGroup
(
# Passing in muliple arguments to Tex will result
# in the same expression as if those arguments had
# been joined together, except that the submobject
# hierarchy of the resulting mobject ensure that the
# Tex mobject has a subject corresponding to
# each of these strings.  For example, the Tex mobject
# below will have 5 subjects, corresponding to the
# expressions [A^2, +, B^2, =, C^2]
OldTex
(
"A^2"
,
"+"
,
"B^2"
,
"="
,
"C^2"
),
# Likewise here
OldTex
(
"A^2"
,
"="
,
"C^2"
,
"-"
,
"B^2"
),
# Alternatively, you can pass in the keyword argument
# "isolate" with a list of strings that should be out as
# their own submobject.  So the line below is equivalent
# to the commented out line below it.
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A^2"
,
*
to_isolate
]),
# OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
OldTex
(
"A =
\\
sqrt{(C + B)(C - B)}"
,
isolate
=
[
"A"
,
*
to_isolate
])
)
lines
.
arrange
(
DOWN
,
buff
=
LARGE_BUFF
)
for
line
in
lines
:
line
.
set_color_by_tex_to_color_map
({
"A"
:
BLUE
,
"B"
:
TEAL
,
"C"
:
GREEN
,
})
play_kw
=
{
"run_time"
:
2
}
self
.
add
(
lines
[
0
])
# The animation TransformMatchingTex will line up parts
# of the source and target which have matching tex strings.
# Here, giving it a little path_arc makes each part sort of
# rotate into their final positions, which feels appropriate
# for the idea of rearranging an equation
self
.
play
(
TransformMatchingTex
(
lines
[
0
]
.
copy
(),
lines
[
1
],
path_arc
=
90
*
DEGREES
,
),
**
play_kw
)
self
.
wait
()
# Now, we could try this again on the next line...
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
]),
**
play_kw
)
self
.
wait
()
# ...and this looks nice enough, but since there's no tex
# in lines[2] which matches "C^2" or "B^2", those terms fade
# out to nothing while the C and B terms fade in from nothing.
# If, however, we want the C^2 to go to C, and B^2 to go to B,
# we can specify that with a key map.
self
.
play
(
FadeOut
(
lines
[
2
]))
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
],
key_map
=
{
"C^2"
:
"C"
,
"B^2"
:
"B"
,
}
),
**
play_kw
)
self
.
wait
()
# And to finish off, a simple TransformMatchingShapes would work
# just fine.  But perhaps we want that exponent on A^2 to transform into
# the square root symbol.  At the moment, lines[2] treats the expression
# A^2 as a unit, so we might create a new version of the same line which
# separates out just the A.  This way, when TransformMatchingTex lines up
# all matching parts, the only mismatch will be between the "^2" from
# new_line2 and the "\sqrt" from the final line.  By passing in,
# transform_mismatches=True, it will transform this "^2" part into
# the "\sqrt" part.
new_line2
=
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A"
,
*
to_isolate
])
new_line2
.
replace
(
lines
[
2
])
new_line2
.
match_style
(
lines
[
2
])
self
.
play
(
TransformMatchingTex
(
new_line2
,
lines
[
3
],
transform_mismatches
=
True
,
),
**
play_kw
)
self
.
wait
(
3
)
self
.
play
(
FadeOut
(
lines
,
RIGHT
))
# Alternatively, if you don't want to think about breaking up
# the tex strings deliberately, you can TransformMatchingShapes,
# which will try to line up all pieces of a source mobject with
# those of a target, regardless of the submobject hierarchy in
# each one, according to whether those pieces have the same
# shape (as best it can).
source
=
Text
(
"the morse code"
,
height
=
1
)
target
=
Text
(
"here come dots"
,
height
=
1
)
self
.
play
(
Write
(
source
))
self
.
wait
()
kw
=
{
"run_time"
:
3
,
"path_arc"
:
PI
/
2
}
self
.
play
(
TransformMatchingShapes
(
source
,
target
,
**
kw
))
self
.
wait
()
self
.
play
(
TransformMatchingShapes
(
target
,
source
,
**
kw
))
self
.
wait
()
The new classes in this scene are
Tex
,
TexText
,
TransformMatchingTex
and
TransformMatchingShapes
.
Tex
uses LaTeX to create mathematical formulas.
TexText
uses LaTeX to create text.
TransformMatchingTeX
automatically transforms sub-objects according to the similarities and differences of tex in
Tex
.
TransformMatchingShapes
automatically transform sub-objects directly based on the similarities and differences of the object point sets.
UpdatersExample
¶
UpdatersExample
¶
class
UpdatersExample
(
Scene
):
def
construct
(
self
):
square
=
Square
()
square
.
set_fill
(
BLUE_E
,
1
)
# On all all frames, the constructor Brace(square, UP) will
# be called, and the mobject brace will set its data to match
# that of the newly constructed object
brace
=
always_redraw
(
Brace
,
square
,
UP
)
text
,
number
=
label
=
VGroup
(
Text
(
"Width = "
),
DecimalNumber
(
0
,
show_ellipsis
=
True
,
num_decimal_places
=
2
,
include_sign
=
True
,
)
)
label
.
arrange
(
RIGHT
)
# This ensures that the method deicmal.next_to(square)
# is called on every frame
always
(
label
.
next_to
,
brace
,
UP
)
# You could also write the following equivalent line
# label.add_updater(lambda m: m.next_to(brace, UP))
# If the argument itself might change, you can use f_always,
# for which the arguments following the initial Mobject method
# should be functions returning arguments to that method.
# The following line ensures that decimal.set_value(square.get_y())
# is called every frame
f_always
(
number
.
set_value
,
square
.
get_width
)
# You could also write the following equivalent line
# number.add_updater(lambda m: m.set_value(square.get_width()))
self
.
add
(
square
,
brace
,
label
)
# Notice that the brace and label track with the square
self
.
play
(
square
.
animate
.
scale
(
2
),
rate_func
=
there_and_back
,
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
5
,
stretch
=
True
),
run_time
=
3
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
2
),
run_time
=
3
)
self
.
wait
()
# In general, you can alway call Mobject.add_updater, and pass in
# a function that you want to be called on every frame.  The function
# should take in either one argument, the mobject, or two arguments,
# the mobject and the amount of time since the last frame.
now
=
self
.
time
w0
=
square
.
get_width
()
square
.
add_updater
(
lambda
m
:
m
.
set_width
(
w0
*
math
.
cos
(
self
.
time
-
now
))
)
self
.
wait
(
4
*
PI
)
The new classes and usage in this scene are
always_redraw()
,
DecimalNumber
,
.to_edge()
,
.center()
,
always()
,
f_always()
,
.set_y()
and
.add_updater()
.
always_redraw()
function create a new mobject every frame.
DecimalNumber
is a variable number, speed it up by breaking it into
Text
characters.
.to_edge()
means to place the object on the edge of the screen.
.center()
means to place the object in the center of the screen.
always(f,
x)
means that a certain function (
f(x)
) is executed every frame.
f_always(f,
g)
is similar to
always
, executed
f(g())
every frame.
.set_y()
means to set the ordinate of the object on the screen.
.add_updater()
sets an update function for the object. For example:
mob1.add_updater(lambda
mob:
mob.next_to(mob2))
means
mob1.next_to(mob2)
is executed every frame.
CoordinateSystemExample
¶
CoordinateSystemExample
¶
class
CoordinateSystemExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
(
# x-axis ranges from -1 to 10, with a default step size of 1
x_range
=
(
-
1
,
10
),
# y-axis ranges from -2 to 2 with a step size of 0.5
y_range
=
(
-
2
,
2
,
0.5
),
# The axes will be stretched so as to match the specified
# height and width
height
=
6
,
width
=
10
,
# Axes is made of two NumberLine mobjects.  You can specify
# their configuration with axis_config
axis_config
=
{
"stroke_color"
:
GREY_A
,
"stroke_width"
:
2
,
},
# Alternatively, you can specify configuration for just one
# of them, like this.
y_axis_config
=
{
"include_tip"
:
False
,
}
)
# Keyword arguments of add_coordinate_labels can be used to
# configure the DecimalNumber mobjects which it creates and
# adds to the axes
axes
.
add_coordinate_labels
(
font_size
=
20
,
num_decimal_places
=
1
,
)
self
.
add
(
axes
)
# Axes descends from the CoordinateSystem class, meaning
# you can call call axes.coords_to_point, abbreviated to
# axes.c2p, to associate a set of coordinates with a point,
# like so:
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
c2p
(
0
,
0
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
5
,
0.5
)))
self
.
wait
()
# Similarly, you can call axes.point_to_coords, or axes.p2c
# print(axes.p2c(dot.get_center()))
# We can draw lines from the axes to better mark the coordinates
# of a given point.
# Here, the always_redraw command means that on each new frame
# the lines will be redrawn
h_line
=
always_redraw
(
lambda
:
axes
.
get_h_line
(
dot
.
get_left
()))
v_line
=
always_redraw
(
lambda
:
axes
.
get_v_line
(
dot
.
get_bottom
()))
self
.
play
(
ShowCreation
(
h_line
),
ShowCreation
(
v_line
),
)
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
-
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
1
,
1
)))
self
.
wait
()
# If we tie the dot to a particular set of coordinates, notice
# that as we move the axes around it respects the coordinate
# system defined by them.
f_always
(
dot
.
move_to
,
lambda
:
axes
.
c2p
(
1
,
1
))
self
.
play
(
axes
.
animate
.
scale
(
0.75
)
.
to_corner
(
UL
),
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
FadeOut
(
VGroup
(
axes
,
dot
,
h_line
,
v_line
)))
# Other coordinate systems you can play around with include
# ThreeDAxes, NumberPlane, and ComplexPlane.
GraphExample
¶
GraphExample
¶
class
GraphExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
((
-
3
,
10
),
(
-
1
,
8
))
axes
.
add_coordinate_labels
()
self
.
play
(
Write
(
axes
,
lag_ratio
=
0.01
,
run_time
=
1
))
# Axes.get_graph will return the graph of a function
sin_graph
=
axes
.
get_graph
(
lambda
x
:
2
*
math
.
sin
(
x
),
color
=
BLUE
,
)
# By default, it draws it so as to somewhat smoothly interpolate
# between sampled points (x, f(x)).  If the graph is meant to have
# a corner, though, you can set use_smoothing to False
relu_graph
=
axes
.
get_graph
(
lambda
x
:
max
(
x
,
0
),
use_smoothing
=
False
,
color
=
YELLOW
,
)
# For discontinuous functions, you can specify the point of
# discontinuity so that it does not try to draw over the gap.
step_graph
=
axes
.
get_graph
(
lambda
x
:
2.0
if
x
>
3
else
1.0
,
discontinuities
=
[
3
],
color
=
GREEN
,
)
# Axes.get_graph_label takes in either a string or a mobject.
# If it's a string, it treats it as a LaTeX expression.  By default
# it places the label next to the graph near the right side, and
# has it match the color of the graph
sin_label
=
axes
.
get_graph_label
(
sin_graph
,
"
\\
sin(x)"
)
relu_label
=
axes
.
get_graph_label
(
relu_graph
,
Text
(
"ReLU"
))
step_label
=
axes
.
get_graph_label
(
step_graph
,
Text
(
"Step"
),
x
=
4
)
self
.
play
(
ShowCreation
(
sin_graph
),
FadeIn
(
sin_label
,
RIGHT
),
)
self
.
wait
(
2
)
self
.
play
(
ReplacementTransform
(
sin_graph
,
relu_graph
),
FadeTransform
(
sin_label
,
relu_label
),
)
self
.
wait
()
self
.
play
(
ReplacementTransform
(
relu_graph
,
step_graph
),
FadeTransform
(
relu_label
,
step_label
),
)
self
.
wait
()
parabola
=
axes
.
get_graph
(
lambda
x
:
0.25
*
x
**
2
)
parabola
.
set_stroke
(
BLUE
)
self
.
play
(
FadeOut
(
step_graph
),
FadeOut
(
step_label
),
ShowCreation
(
parabola
)
)
self
.
wait
()
# You can use axes.input_to_graph_point, abbreviated
# to axes.i2gp, to find a particular point on a graph
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
i2gp
(
2
,
parabola
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
# A value tracker lets us animate a parameter, usually
# with the intent of having other mobjects update based
# on the parameter
x_tracker
=
ValueTracker
(
2
)
f_always
(
dot
.
move_to
,
lambda
:
axes
.
i2gp
(
x_tracker
.
get_value
(),
parabola
)
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
4
),
run_time
=
3
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
-
2
),
run_time
=
3
)
self
.
wait
()
SurfaceExample
¶
SurfaceExample
¶
class
SurfaceExample
(
Scene
):
CONFIG
=
{
"camera_class"
:
ThreeDCamera
,
}
def
construct
(
self
):
surface_text
=
Text
(
"For 3d scenes, try using surfaces"
)
surface_text
.
fix_in_frame
()
surface_text
.
to_edge
(
UP
)
self
.
add
(
surface_text
)
self
.
wait
(
0.1
)
torus1
=
Torus
(
r1
=
1
,
r2
=
1
)
torus2
=
Torus
(
r1
=
3
,
r2
=
1
)
sphere
=
Sphere
(
radius
=
3
,
resolution
=
torus1
.
resolution
)
# You can texture a surface with up to two images, which will
# be interpreted as the side towards the light, and away from
# the light.  These can be either urls, or paths to a local file
# in whatever you've set as the image directory in
# the custom_config.yml file
# day_texture = "EarthTextureMap"
# night_texture = "NightEarthTextureMap"
day_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
night_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"
surfaces
=
[
TexturedSurface
(
surface
,
day_texture
,
night_texture
)
for
surface
in
[
sphere
,
torus1
,
torus2
]
]
for
mob
in
surfaces
:
mob
.
shift
(
IN
)
mob
.
mesh
=
SurfaceMesh
(
mob
)
mob
.
mesh
.
set_stroke
(
BLUE
,
1
,
opacity
=
0.5
)
# Set perspective
frame
=
self
.
camera
.
frame
frame
.
set_euler_angles
(
theta
=-
30
*
DEGREES
,
phi
=
70
*
DEGREES
,
)
surface
=
surfaces
[
0
]
self
.
play
(
FadeIn
(
surface
),
ShowCreation
(
surface
.
mesh
,
lag_ratio
=
0.01
,
run_time
=
3
),
)
for
mob
in
surfaces
:
mob
.
add
(
mob
.
mesh
)
surface
.
save_state
()
self
.
play
(
Rotate
(
surface
,
PI
/
2
),
run_time
=
2
)
for
mob
in
surfaces
[
1
:]:
mob
.
rotate
(
PI
/
2
)
self
.
play
(
Transform
(
surface
,
surfaces
[
1
]),
run_time
=
3
)
self
.
play
(
Transform
(
surface
,
surfaces
[
2
]),
# Move camera frame during the transition
frame
.
animate
.
increment_phi
(
-
10
*
DEGREES
),
frame
.
animate
.
increment_theta
(
-
20
*
DEGREES
),
run_time
=
3
)
# Add ambient rotation
frame
.
add_updater
(
lambda
m
,
dt
:
m
.
increment_theta
(
-
0.1
*
dt
))
# Play around with where the light is
light_text
=
Text
(
"You can move around the light source"
)
light_text
.
move_to
(
surface_text
)
light_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
surface_text
,
light_text
))
light
=
self
.
camera
.
light_source
self
.
add
(
light
)
light
.
save_state
()
self
.
play
(
light
.
animate
.
move_to
(
3
*
IN
),
run_time
=
5
)
self
.
play
(
light
.
animate
.
shift
(
10
*
OUT
),
run_time
=
5
)
drag_text
=
Text
(
"Try moving the mouse while pressing d or s"
)
drag_text
.
move_to
(
light_text
)
drag_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
light_text
,
drag_text
))
self
.
wait
()
This scene shows an example of using a three-dimensional surface, and
the related usage has been briefly described in the notes.
.fix_in_frame()
makes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.
OpeningManimExample
¶
OpeningManimExample
¶
class
OpeningManimExample
(
Scene
):
def
construct
(
self
):
intro_words
=
Text
(
"""
The original motivation for manim was to
better illustrate mathematical functions
as transformations.
"""
)
intro_words
.
to_edge
(
UP
)
self
.
play
(
Write
(
intro_words
))
self
.
wait
(
2
)
# Linear transform
grid
=
NumberPlane
((
-
10
,
10
),
(
-
5
,
5
))
matrix
=
[[
1
,
1
],
[
0
,
1
]]
linear_transform_words
=
VGroup
(
Text
(
"This is what the matrix"
),
IntegerMatrix
(
matrix
,
include_background_rectangle
=
True
),
Text
(
"looks like"
)
)
linear_transform_words
.
arrange
(
RIGHT
)
linear_transform_words
.
to_edge
(
UP
)
linear_transform_words
.
set_stroke
(
BLACK
,
10
,
background
=
True
)
self
.
play
(
ShowCreation
(
grid
),
FadeTransform
(
intro_words
,
linear_transform_words
)
)
self
.
wait
()
self
.
play
(
grid
.
animate
.
apply_matrix
(
matrix
),
run_time
=
3
)
self
.
wait
()
# Complex map
c_grid
=
ComplexPlane
()
moving_c_grid
=
c_grid
.
copy
()
moving_c_grid
.
prepare_for_nonlinear_transform
()
c_grid
.
set_stroke
(
BLUE_E
,
1
)
c_grid
.
add_coordinate_labels
(
font_size
=
24
)
complex_map_words
=
TexText
(
"""
Or thinking of the plane as $
\\
mathds
{C}
$,
\\\\
this is the map $z
\\
rightarrow z^2$
"""
)
complex_map_words
.
to_corner
(
UR
)
complex_map_words
.
set_stroke
(
BLACK
,
5
,
background
=
True
)
self
.
play
(
FadeOut
(
grid
),
Write
(
c_grid
,
run_time
=
3
),
FadeIn
(
moving_c_grid
),
FadeTransform
(
linear_transform_words
,
complex_map_words
),
)
self
.
wait
()
self
.
play
(
moving_c_grid
.
animate
.
apply_complex_function
(
lambda
z
:
z
**
2
),
run_time
=
6
,
)
self
.
wait
(
2
)
This scene is a comprehensive application of a two-dimensional scene.
After seeing these scenes, you have already understood part of the
usage of manim. For more examples, see
the video code of 3b1b
.
Contents
Example Scenes
InteractiveDevlopment
AnimatingMethods
TextExample
TexTransformExample
UpdatersExample
CoordinateSystemExample
GraphExample
SurfaceExample
OpeningManimExample

Code Examples:
Example 1:
```python
example_scenes.py
```
Example 2:
```python
from manimlib import *

class InteractiveDevelopment(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)
        square = Square()

        self.play(ShowCreation(square))
        self.wait()

        # This opens an iPython terminal where you can keep writing
        # lines as if they were part of this construct method.
        # In particular, 'square', 'circle' and 'self' will all be
        # part of the local namespace in that terminal.
        self.embed()

        # Try copying and pasting some of the lines below into
        # the interactive shell
        self.play(ReplacementTransform(square, circle))
        self.wait()
        self.play(circle.animate.stretch(4, 0))
        self.play(Rotate(circle, 90 * DEGREES))
        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))

        text = Text("""
            In general, using the interactive shell
            is very helpful when developing new scenes
        """)
        self.play(Write(text))

        # In the interactive shell, you can just type
        # play, add, remove, clear, wait, save_state and restore,
        # instead of self.play, self.add, self.remove, etc.

        # To interact with the window, type touch().  You can then
        # scroll in the window, or zoom by holding down 'z' while scrolling,
        # and change camera perspective by holding down 'd' while moving
        # the mouse.  Press 'r' to reset to the standard camera position.
        # Press 'q' to stop interacting with the window and go back to
        # typing new commands into the shell.

        # In principle you can customize a scene to be responsive to
        # mouse and keyboard interactions
        always(circle.move_to, self.mouse_point)
```
Example 3:
```python
class AnimatingMethods(Scene):
    def construct(self):
        grid = OldTex(r"\pi").get_grid(10, 10, height=4)
        self.add(grid)

        # You can animate the application of mobject methods with the
        # ".animate" syntax:
        self.play(grid.animate.shift(LEFT))

        # Alternatively, you can use the older syntax by passing the
        # method and then the arguments to the scene's "play" function:
        self.play(grid.shift, LEFT)

        # Both of those will interpolate between the mobject's initial
        # state and whatever happens when you apply that method.
        # For this example, calling grid.shift(LEFT) would shift the
        # grid one unit to the left, but both of the previous calls to
        # "self.play" animate that motion.

        # The same applies for any method, including those setting colors.
        self.play(grid.animate.set_color(YELLOW))
        self.wait()
        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))
        self.wait()
        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))
        self.wait()

        # The method Mobject.apply_complex_function lets you apply arbitrary
        # complex functions, treating the points defining the mobject as
        # complex numbers.
        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)
        self.wait()

        # Even more generally, you could apply Mobject.apply_function,
        # which takes in functions form R^3 to R^3
        self.play(
            grid.animate.apply_function(
                lambda p: [
                    p[0] + 0.5 * math.sin(p[1]),
                    p[1] + 0.5 * math.sin(p[0]),
                    p[2]
                ]
            ),
            run_time=5,
        )
        self.wait()
```
Example 4:
```python
.get_grid()
```
Example 5:
```python
self.play(mob.animate.method(args))
```
Example 6:
```python
.get_grid()
```
Example 7:
```python
self.play(mob.animate.method(args))
```
Example 8:
```python
class TextExample(Scene):
    def construct(self):
        # To run this scene properly, you should have "Consolas" font in your computer
        # for full usage, you can see https://github.com/3b1b/manim/pull/680
        text = Text("Here is a text", font="Consolas", font_size=90)
        difference = Text(
            """
            The most important difference between Text and TexText is that\n
            you can change the font more easily, but can't use the LaTeX grammar
            """,
            font="Arial", font_size=24,
            # t2c is a dict that you can choose color for different text
            t2c={"Text": BLUE, "TexText": BLUE, "LaTeX": ORANGE}
        )
        VGroup(text, difference).arrange(DOWN, buff=1)
        self.play(Write(text))
        self.play(FadeIn(difference, UP))
        self.wait(3)

        fonts = Text(
            "And you can also set the font according to different words",
            font="Arial",
            t2f={"font": "Consolas", "words": "Consolas"},
            t2c={"font": BLUE, "words": GREEN}
        )
        fonts.set_width(FRAME_WIDTH - 1)
        slant = Text(
            "And the same as slant and weight",
            font="Consolas",
            t2s={"slant": ITALIC},
            t2w={"weight": BOLD},
            t2c={"slant": ORANGE, "weight": RED}
        )
        VGroup(fonts, slant).arrange(DOWN, buff=0.8)
        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))
        self.play(Write(fonts))
        self.wait()
        self.play(Write(slant))
        self.wait()
```
Example 9:
```python
class TexTransformExample(Scene):
    def construct(self):
        to_isolate = ["B", "C", "=", "(", ")"]
        lines = VGroup(
            # Passing in muliple arguments to Tex will result
            # in the same expression as if those arguments had
            # been joined together, except that the submobject
            # hierarchy of the resulting mobject ensure that the
            # Tex mobject has a subject corresponding to
            # each of these strings.  For example, the Tex mobject
            # below will have 5 subjects, corresponding to the
            # expressions [A^2, +, B^2, =, C^2]
            OldTex("A^2", "+", "B^2", "=", "C^2"),
            # Likewise here
            OldTex("A^2", "=", "C^2", "-", "B^2"),
            # Alternatively, you can pass in the keyword argument
            # "isolate" with a list of strings that should be out as
            # their own submobject.  So the line below is equivalent
            # to the commented out line below it.
            OldTex("A^2 = (C + B)(C - B)", isolate=["A^2", *to_isolate]),
            # OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
            OldTex("A = \\sqrt{(C + B)(C - B)}", isolate=["A", *to_isolate])
        )
        lines.arrange(DOWN, buff=LARGE_BUFF)
        for line in lines:
            line.set_color_by_tex_to_color_map({
                "A": BLUE,
                "B": TEAL,
                "C": GREEN,
            })

        play_kw = {"run_time": 2}
        self.add(lines[0])
        # The animation TransformMatchingTex will line up parts
        # of the source and target which have matching tex strings.
        # Here, giving it a little path_arc makes each part sort of
        # rotate into their final positions, which feels appropriate
        # for the idea of rearranging an equation
        self.play(
            TransformMatchingTex(
                lines[0].copy(), lines[1],
                path_arc=90 * DEGREES,
            ),
            **play_kw
        )
        self.wait()

        # Now, we could try this again on the next line...
        self.play(
            TransformMatchingTex(lines[1].copy(), lines[2]),
            **play_kw
        )
        self.wait()
        # ...and this looks nice enough, but since there's no tex
        # in lines[2] which matches "C^2" or "B^2", those terms fade
        # out to nothing while the C and B terms fade in from nothing.
        # If, however, we want the C^2 to go to C, and B^2 to go to B,
        # we can specify that with a key map.
        self.play(FadeOut(lines[2]))
        self.play(
            TransformMatchingTex(
                lines[1].copy(), lines[2],
                key_map={
                    "C^2": "C",
                    "B^2": "B",
                }
            ),
            **play_kw
        )
        self.wait()

        # And to finish off, a simple TransformMatchingShapes would work
        # just fine.  But perhaps we want that exponent on A^2 to transform into
        # the square root symbol.  At the moment, lines[2] treats the expression
        # A^2 as a unit, so we might create a new version of the same line which
        # separates out just the A.  This way, when TransformMatchingTex lines up
        # all matching parts, the only mismatch will be between the "^2" from
        # new_line2 and the "\sqrt" from the final line.  By passing in,
        # transform_mismatches=True, it will transform this "^2" part into
        # the "\sqrt" part.
        new_line2 = OldTex("A^2 = (C + B)(C - B)", isolate=["A", *to_isolate])
        new_line2.replace(lines[2])
        new_line2.match_style(lines[2])

        self.play(
            TransformMatchingTex(
                new_line2, lines[3],
                transform_mismatches=True,
            ),
            **play_kw
        )
        self.wait(3)
        self.play(FadeOut(lines, RIGHT))

        # Alternatively, if you don't want to think about breaking up
        # the tex strings deliberately, you can TransformMatchingShapes,
        # which will try to line up all pieces of a source mobject with
        # those of a target, regardless of the submobject hierarchy in
        # each one, according to whether those pieces have the same
        # shape (as best it can).
        source = Text("the morse code", height=1)
        target = Text("here come dots", height=1)

        self.play(Write(source))
        self.wait()
        kw = {"run_time": 3, "path_arc": PI / 2}
        self.play(TransformMatchingShapes(source, target, **kw))
        self.wait()
        self.play(TransformMatchingShapes(target, source, **kw))
        self.wait()
```
Example 10:
```python
TransformMatchingTex
```
Example 11:
```python
TransformMatchingShapes
```
Example 12:
```python
TransformMatchingTeX
```
Example 13:
```python
TransformMatchingShapes
```
Example 14:
```python
class UpdatersExample(Scene):
    def construct(self):
        square = Square()
        square.set_fill(BLUE_E, 1)

        # On all all frames, the constructor Brace(square, UP) will
        # be called, and the mobject brace will set its data to match
        # that of the newly constructed object
        brace = always_redraw(Brace, square, UP)

        text, number = label = VGroup(
            Text("Width = "),
            DecimalNumber(
                0,
                show_ellipsis=True,
                num_decimal_places=2,
                include_sign=True,
            )
        )
        label.arrange(RIGHT)

        # This ensures that the method deicmal.next_to(square)
        # is called on every frame
        always(label.next_to, brace, UP)
        # You could also write the following equivalent line
        # label.add_updater(lambda m: m.next_to(brace, UP))

        # If the argument itself might change, you can use f_always,
        # for which the arguments following the initial Mobject method
        # should be functions returning arguments to that method.
        # The following line ensures that decimal.set_value(square.get_y())
        # is called every frame
        f_always(number.set_value, square.get_width)
        # You could also write the following equivalent line
        # number.add_updater(lambda m: m.set_value(square.get_width()))

        self.add(square, brace, label)

        # Notice that the brace and label track with the square
        self.play(
            square.animate.scale(2),
            rate_func=there_and_back,
            run_time=2,
        )
        self.wait()
        self.play(
            square.animate.set_width(5, stretch=True),
            run_time=3,
        )
        self.wait()
        self.play(
            square.animate.set_width(2),
            run_time=3
        )
        self.wait()

        # In general, you can alway call Mobject.add_updater, and pass in
        # a function that you want to be called on every frame.  The function
        # should take in either one argument, the mobject, or two arguments,
        # the mobject and the amount of time since the last frame.
        now = self.time
        w0 = square.get_width()
        square.add_updater(
            lambda m: m.set_width(w0 * math.cos(self.time - now))
        )
        self.wait(4 * PI)
```
Example 15:
```python
always_redraw()
```
Example 16:
```python
DecimalNumber
```
Example 17:
```python
.add_updater()
```
Example 18:
```python
always_redraw()
```
Example 19:
```python
DecimalNumber
```
Example 20:
```python
always(f, x)
```
Example 21:
```python
f_always(f, g)
```
Example 22:
```python
.add_updater()
```
Example 23:
```python
mob1.add_updater(lambda mob: mob.next_to(mob2))
```
Example 24:
```python
mob1.next_to(mob2)
```
Example 25:
```python
class CoordinateSystemExample(Scene):
    def construct(self):
        axes = Axes(
            # x-axis ranges from -1 to 10, with a default step size of 1
            x_range=(-1, 10),
            # y-axis ranges from -2 to 2 with a step size of 0.5
            y_range=(-2, 2, 0.5),
            # The axes will be stretched so as to match the specified
            # height and width
            height=6,
            width=10,
            # Axes is made of two NumberLine mobjects.  You can specify
            # their configuration with axis_config
            axis_config={
                "stroke_color": GREY_A,
                "stroke_width": 2,
            },
            # Alternatively, you can specify configuration for just one
            # of them, like this.
            y_axis_config={
                "include_tip": False,
            }
        )
        # Keyword arguments of add_coordinate_labels can be used to
        # configure the DecimalNumber mobjects which it creates and
        # adds to the axes
        axes.add_coordinate_labels(
            font_size=20,
            num_decimal_places=1,
        )
        self.add(axes)

        # Axes descends from the CoordinateSystem class, meaning
        # you can call call axes.coords_to_point, abbreviated to
        # axes.c2p, to associate a set of coordinates with a point,
        # like so:
        dot = Dot(color=RED)
        dot.move_to(axes.c2p(0, 0))
        self.play(FadeIn(dot, scale=0.5))
        self.play(dot.animate.move_to(axes.c2p(3, 2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))
        self.wait()

        # Similarly, you can call axes.point_to_coords, or axes.p2c
        # print(axes.p2c(dot.get_center()))

        # We can draw lines from the axes to better mark the coordinates
        # of a given point.
        # Here, the always_redraw command means that on each new frame
        # the lines will be redrawn
        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))
        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))

        self.play(
            ShowCreation(h_line),
            ShowCreation(v_line),
        )
        self.play(dot.animate.move_to(axes.c2p(3, -2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(1, 1)))
        self.wait()

        # If we tie the dot to a particular set of coordinates, notice
        # that as we move the axes around it respects the coordinate
        # system defined by them.
        f_always(dot.move_to, lambda: axes.c2p(1, 1))
        self.play(
            axes.animate.scale(0.75).to_corner(UL),
            run_time=2,
        )
        self.wait()
        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))

        # Other coordinate systems you can play around with include
        # ThreeDAxes, NumberPlane, and ComplexPlane.
```
Example 26:
```python
class GraphExample(Scene):
    def construct(self):
        axes = Axes((-3, 10), (-1, 8))
        axes.add_coordinate_labels()

        self.play(Write(axes, lag_ratio=0.01, run_time=1))

        # Axes.get_graph will return the graph of a function
        sin_graph = axes.get_graph(
            lambda x: 2 * math.sin(x),
            color=BLUE,
        )
        # By default, it draws it so as to somewhat smoothly interpolate
        # between sampled points (x, f(x)).  If the graph is meant to have
        # a corner, though, you can set use_smoothing to False
        relu_graph = axes.get_graph(
            lambda x: max(x, 0),
            use_smoothing=False,
            color=YELLOW,
        )
        # For discontinuous functions, you can specify the point of
        # discontinuity so that it does not try to draw over the gap.
        step_graph = axes.get_graph(
            lambda x: 2.0 if x > 3 else 1.0,
            discontinuities=[3],
            color=GREEN,
        )

        # Axes.get_graph_label takes in either a string or a mobject.
        # If it's a string, it treats it as a LaTeX expression.  By default
        # it places the label next to the graph near the right side, and
        # has it match the color of the graph
        sin_label = axes.get_graph_label(sin_graph, "\\sin(x)")
        relu_label = axes.get_graph_label(relu_graph, Text("ReLU"))
        step_label = axes.get_graph_label(step_graph, Text("Step"), x=4)

        self.play(
            ShowCreation(sin_graph),
            FadeIn(sin_label, RIGHT),
        )
        self.wait(2)
        self.play(
            ReplacementTransform(sin_graph, relu_graph),
            FadeTransform(sin_label, relu_label),
        )
        self.wait()
        self.play(
            ReplacementTransform(relu_graph, step_graph),
            FadeTransform(relu_label, step_label),
        )
        self.wait()

        parabola = axes.get_graph(lambda x: 0.25 * x**2)
        parabola.set_stroke(BLUE)
        self.play(
            FadeOut(step_graph),
            FadeOut(step_label),
            ShowCreation(parabola)
        )
        self.wait()

        # You can use axes.input_to_graph_point, abbreviated
        # to axes.i2gp, to find a particular point on a graph
        dot = Dot(color=RED)
        dot.move_to(axes.i2gp(2, parabola))
        self.play(FadeIn(dot, scale=0.5))

        # A value tracker lets us animate a parameter, usually
        # with the intent of having other mobjects update based
        # on the parameter
        x_tracker = ValueTracker(2)
        f_always(
            dot.move_to,
            lambda: axes.i2gp(x_tracker.get_value(), parabola)
        )

        self.play(x_tracker.animate.set_value(4), run_time=3)
        self.play(x_tracker.animate.set_value(-2), run_time=3)
        self.wait()
```
Example 27:
```python
class SurfaceExample(Scene):
    CONFIG = {
        "camera_class": ThreeDCamera,
    }

    def construct(self):
        surface_text = Text("For 3d scenes, try using surfaces")
        surface_text.fix_in_frame()
        surface_text.to_edge(UP)
        self.add(surface_text)
        self.wait(0.1)

        torus1 = Torus(r1=1, r2=1)
        torus2 = Torus(r1=3, r2=1)
        sphere = Sphere(radius=3, resolution=torus1.resolution)
        # You can texture a surface with up to two images, which will
        # be interpreted as the side towards the light, and away from
        # the light.  These can be either urls, or paths to a local file
        # in whatever you've set as the image directory in
        # the custom_config.yml file

        # day_texture = "EarthTextureMap"
        # night_texture = "NightEarthTextureMap"
        day_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
        night_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"

        surfaces = [
            TexturedSurface(surface, day_texture, night_texture)
            for surface in [sphere, torus1, torus2]
        ]

        for mob in surfaces:
            mob.shift(IN)
            mob.mesh = SurfaceMesh(mob)
            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)

        # Set perspective
        frame = self.camera.frame
        frame.set_euler_angles(
            theta=-30 * DEGREES,
            phi=70 * DEGREES,
        )

        surface = surfaces[0]

        self.play(
            FadeIn(surface),
            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),
        )
        for mob in surfaces:
            mob.add(mob.mesh)
        surface.save_state()
        self.play(Rotate(surface, PI / 2), run_time=2)
        for mob in surfaces[1:]:
            mob.rotate(PI / 2)

        self.play(
            Transform(surface, surfaces[1]),
            run_time=3
        )

        self.play(
            Transform(surface, surfaces[2]),
            # Move camera frame during the transition
            frame.animate.increment_phi(-10 * DEGREES),
            frame.animate.increment_theta(-20 * DEGREES),
            run_time=3
        )
        # Add ambient rotation
        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))

        # Play around with where the light is
        light_text = Text("You can move around the light source")
        light_text.move_to(surface_text)
        light_text.fix_in_frame()

        self.play(FadeTransform(surface_text, light_text))
        light = self.camera.light_source
        self.add(light)
        light.save_state()
        self.play(light.animate.move_to(3 * IN), run_time=5)
        self.play(light.animate.shift(10 * OUT), run_time=5)

        drag_text = Text("Try moving the mouse while pressing d or s")
        drag_text.move_to(light_text)
        drag_text.fix_in_frame()

        self.play(FadeTransform(light_text, drag_text))
        self.wait()
```
Example 28:
```python
.fix_in_frame()
```
Example 29:
```python
class OpeningManimExample(Scene):
    def construct(self):
        intro_words = Text("""
            The original motivation for manim was to
            better illustrate mathematical functions
            as transformations.
        """)
        intro_words.to_edge(UP)

        self.play(Write(intro_words))
        self.wait(2)

        # Linear transform
        grid = NumberPlane((-10, 10), (-5, 5))
        matrix = [[1, 1], [0, 1]]
        linear_transform_words = VGroup(
            Text("This is what the matrix"),
            IntegerMatrix(matrix, include_background_rectangle=True),
            Text("looks like")
        )
        linear_transform_words.arrange(RIGHT)
        linear_transform_words.to_edge(UP)
        linear_transform_words.set_stroke(BLACK, 10, background=True)

        self.play(
            ShowCreation(grid),
            FadeTransform(intro_words, linear_transform_words)
        )
        self.wait()
        self.play(grid.animate.apply_matrix(matrix), run_time=3)
        self.wait()

        # Complex map
        c_grid = ComplexPlane()
        moving_c_grid = c_grid.copy()
        moving_c_grid.prepare_for_nonlinear_transform()
        c_grid.set_stroke(BLUE_E, 1)
        c_grid.add_coordinate_labels(font_size=24)
        complex_map_words = TexText("""
            Or thinking of the plane as $\\mathds{C}$,\\\\
            this is the map $z \\rightarrow z^2$
        """)
        complex_map_words.to_corner(UR)
        complex_map_words.set_stroke(BLACK, 5, background=True)

        self.play(
            FadeOut(grid),
            Write(c_grid, run_time=3),
            FadeIn(moving_c_grid),
            FadeTransform(linear_transform_words, complex_map_words),
        )
        self.wait()
        self.play(
            moving_c_grid.animate.apply_complex_function(lambda z: z**2),
            run_time=6,
        )
        self.wait(2)
```

================================================================================

=== Example Scenes - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/example_scenes.html#textransformexample
Content:
Example Scenes
¶
After understanding the previous knowledge, we can understand more scenes.
Many example scenes are given in
example_scenes.py
, let’s start with
the simplest and one by one.
InteractiveDevlopment
¶
InteractiveDevelopment
¶
from
manimlib
import
*
class
InteractiveDevelopment
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
square
=
Square
()
self
.
play
(
ShowCreation
(
square
))
self
.
wait
()
# This opens an iPython terminal where you can keep writing
# lines as if they were part of this construct method.
# In particular, 'square', 'circle' and 'self' will all be
# part of the local namespace in that terminal.
self
.
embed
()
# Try copying and pasting some of the lines below into
# the interactive shell
self
.
play
(
ReplacementTransform
(
square
,
circle
))
self
.
wait
()
self
.
play
(
circle
.
animate
.
stretch
(
4
,
0
))
self
.
play
(
Rotate
(
circle
,
90
*
DEGREES
))
self
.
play
(
circle
.
animate
.
shift
(
2
*
RIGHT
)
.
scale
(
0.25
))
text
=
Text
(
"""
In general, using the interactive shell
is very helpful when developing new scenes
"""
)
self
.
play
(
Write
(
text
))
# In the interactive shell, you can just type
# play, add, remove, clear, wait, save_state and restore,
# instead of self.play, self.add, self.remove, etc.
# To interact with the window, type touch().  You can then
# scroll in the window, or zoom by holding down 'z' while scrolling,
# and change camera perspective by holding down 'd' while moving
# the mouse.  Press 'r' to reset to the standard camera position.
# Press 'q' to stop interacting with the window and go back to
# typing new commands into the shell.
# In principle you can customize a scene to be responsive to
# mouse and keyboard interactions
always
(
circle
.
move_to
,
self
.
mouse_point
)
This scene is similar to what we wrote in
Quick Start
.
And how to interact has been written in the comments.
No more explanation here.
AnimatingMethods
¶
AnimatingMethods
¶
class
AnimatingMethods
(
Scene
):
def
construct
(
self
):
grid
=
OldTex
(
r
"\pi"
)
.
get_grid
(
10
,
10
,
height
=
4
)
self
.
add
(
grid
)
# You can animate the application of mobject methods with the
# ".animate" syntax:
self
.
play
(
grid
.
animate
.
shift
(
LEFT
))
# Alternatively, you can use the older syntax by passing the
# method and then the arguments to the scene's "play" function:
self
.
play
(
grid
.
shift
,
LEFT
)
# Both of those will interpolate between the mobject's initial
# state and whatever happens when you apply that method.
# For this example, calling grid.shift(LEFT) would shift the
# grid one unit to the left, but both of the previous calls to
# "self.play" animate that motion.
# The same applies for any method, including those setting colors.
self
.
play
(
grid
.
animate
.
set_color
(
YELLOW
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_submobject_colors_by_gradient
(
BLUE
,
GREEN
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_height
(
TAU
-
MED_SMALL_BUFF
))
self
.
wait
()
# The method Mobject.apply_complex_function lets you apply arbitrary
# complex functions, treating the points defining the mobject as
# complex numbers.
self
.
play
(
grid
.
animate
.
apply_complex_function
(
np
.
exp
),
run_time
=
5
)
self
.
wait
()
# Even more generally, you could apply Mobject.apply_function,
# which takes in functions form R^3 to R^3
self
.
play
(
grid
.
animate
.
apply_function
(
lambda
p
:
[
p
[
0
]
+
0.5
*
math
.
sin
(
p
[
1
]),
p
[
1
]
+
0.5
*
math
.
sin
(
p
[
0
]),
p
[
2
]
]
),
run_time
=
5
,
)
self
.
wait
()
The new usage in this scene is
.get_grid()
and
self.play(mob.animate.method(args))
.
.get_grid()
method will return a new mobject containing multiple copies of this one arranged in a grid.
self.play(mob.animate.method(args))
animates the method, and the details are in the comments above.
TextExample
¶
TextExample
¶
class
TextExample
(
Scene
):
def
construct
(
self
):
# To run this scene properly, you should have "Consolas" font in your computer
# for full usage, you can see https://github.com/3b1b/manim/pull/680
text
=
Text
(
"Here is a text"
,
font
=
"Consolas"
,
font_size
=
90
)
difference
=
Text
(
"""
The most important difference between Text and TexText is that\n
you can change the font more easily, but can't use the LaTeX grammar
"""
,
font
=
"Arial"
,
font_size
=
24
,
# t2c is a dict that you can choose color for different text
t2c
=
{
"Text"
:
BLUE
,
"TexText"
:
BLUE
,
"LaTeX"
:
ORANGE
}
)
VGroup
(
text
,
difference
)
.
arrange
(
DOWN
,
buff
=
1
)
self
.
play
(
Write
(
text
))
self
.
play
(
FadeIn
(
difference
,
UP
))
self
.
wait
(
3
)
fonts
=
Text
(
"And you can also set the font according to different words"
,
font
=
"Arial"
,
t2f
=
{
"font"
:
"Consolas"
,
"words"
:
"Consolas"
},
t2c
=
{
"font"
:
BLUE
,
"words"
:
GREEN
}
)
fonts
.
set_width
(
FRAME_WIDTH
-
1
)
slant
=
Text
(
"And the same as slant and weight"
,
font
=
"Consolas"
,
t2s
=
{
"slant"
:
ITALIC
},
t2w
=
{
"weight"
:
BOLD
},
t2c
=
{
"slant"
:
ORANGE
,
"weight"
:
RED
}
)
VGroup
(
fonts
,
slant
)
.
arrange
(
DOWN
,
buff
=
0.8
)
self
.
play
(
FadeOut
(
text
),
FadeOut
(
difference
,
shift
=
DOWN
))
self
.
play
(
Write
(
fonts
))
self
.
wait
()
self
.
play
(
Write
(
slant
))
self
.
wait
()
The new classes in this scene are
Text
,
VGroup
,
Write
,
FadeIn
and
FadeOut
.
Text
can create text, define fonts, etc. The usage ais clearly reflected in the above examples.
VGroup
can put multiple
VMobject
together as a whole. In the example, the
.arrange()
method is called to arrange the sub-mobjects in sequence downward (
DOWN
), and the spacing is
buff
.
Write
is an animation that shows similar writing effects.
FadeIn
fades the object in, the second parameter indicates the direction of the fade in.
FadeOut
fades out the object, the second parameter indicates the direction of the fade out.
TexTransformExample
¶
TexTransformExample
¶
class
TexTransformExample
(
Scene
):
def
construct
(
self
):
to_isolate
=
[
"B"
,
"C"
,
"="
,
"("
,
")"
]
lines
=
VGroup
(
# Passing in muliple arguments to Tex will result
# in the same expression as if those arguments had
# been joined together, except that the submobject
# hierarchy of the resulting mobject ensure that the
# Tex mobject has a subject corresponding to
# each of these strings.  For example, the Tex mobject
# below will have 5 subjects, corresponding to the
# expressions [A^2, +, B^2, =, C^2]
OldTex
(
"A^2"
,
"+"
,
"B^2"
,
"="
,
"C^2"
),
# Likewise here
OldTex
(
"A^2"
,
"="
,
"C^2"
,
"-"
,
"B^2"
),
# Alternatively, you can pass in the keyword argument
# "isolate" with a list of strings that should be out as
# their own submobject.  So the line below is equivalent
# to the commented out line below it.
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A^2"
,
*
to_isolate
]),
# OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
OldTex
(
"A =
\\
sqrt{(C + B)(C - B)}"
,
isolate
=
[
"A"
,
*
to_isolate
])
)
lines
.
arrange
(
DOWN
,
buff
=
LARGE_BUFF
)
for
line
in
lines
:
line
.
set_color_by_tex_to_color_map
({
"A"
:
BLUE
,
"B"
:
TEAL
,
"C"
:
GREEN
,
})
play_kw
=
{
"run_time"
:
2
}
self
.
add
(
lines
[
0
])
# The animation TransformMatchingTex will line up parts
# of the source and target which have matching tex strings.
# Here, giving it a little path_arc makes each part sort of
# rotate into their final positions, which feels appropriate
# for the idea of rearranging an equation
self
.
play
(
TransformMatchingTex
(
lines
[
0
]
.
copy
(),
lines
[
1
],
path_arc
=
90
*
DEGREES
,
),
**
play_kw
)
self
.
wait
()
# Now, we could try this again on the next line...
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
]),
**
play_kw
)
self
.
wait
()
# ...and this looks nice enough, but since there's no tex
# in lines[2] which matches "C^2" or "B^2", those terms fade
# out to nothing while the C and B terms fade in from nothing.
# If, however, we want the C^2 to go to C, and B^2 to go to B,
# we can specify that with a key map.
self
.
play
(
FadeOut
(
lines
[
2
]))
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
],
key_map
=
{
"C^2"
:
"C"
,
"B^2"
:
"B"
,
}
),
**
play_kw
)
self
.
wait
()
# And to finish off, a simple TransformMatchingShapes would work
# just fine.  But perhaps we want that exponent on A^2 to transform into
# the square root symbol.  At the moment, lines[2] treats the expression
# A^2 as a unit, so we might create a new version of the same line which
# separates out just the A.  This way, when TransformMatchingTex lines up
# all matching parts, the only mismatch will be between the "^2" from
# new_line2 and the "\sqrt" from the final line.  By passing in,
# transform_mismatches=True, it will transform this "^2" part into
# the "\sqrt" part.
new_line2
=
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A"
,
*
to_isolate
])
new_line2
.
replace
(
lines
[
2
])
new_line2
.
match_style
(
lines
[
2
])
self
.
play
(
TransformMatchingTex
(
new_line2
,
lines
[
3
],
transform_mismatches
=
True
,
),
**
play_kw
)
self
.
wait
(
3
)
self
.
play
(
FadeOut
(
lines
,
RIGHT
))
# Alternatively, if you don't want to think about breaking up
# the tex strings deliberately, you can TransformMatchingShapes,
# which will try to line up all pieces of a source mobject with
# those of a target, regardless of the submobject hierarchy in
# each one, according to whether those pieces have the same
# shape (as best it can).
source
=
Text
(
"the morse code"
,
height
=
1
)
target
=
Text
(
"here come dots"
,
height
=
1
)
self
.
play
(
Write
(
source
))
self
.
wait
()
kw
=
{
"run_time"
:
3
,
"path_arc"
:
PI
/
2
}
self
.
play
(
TransformMatchingShapes
(
source
,
target
,
**
kw
))
self
.
wait
()
self
.
play
(
TransformMatchingShapes
(
target
,
source
,
**
kw
))
self
.
wait
()
The new classes in this scene are
Tex
,
TexText
,
TransformMatchingTex
and
TransformMatchingShapes
.
Tex
uses LaTeX to create mathematical formulas.
TexText
uses LaTeX to create text.
TransformMatchingTeX
automatically transforms sub-objects according to the similarities and differences of tex in
Tex
.
TransformMatchingShapes
automatically transform sub-objects directly based on the similarities and differences of the object point sets.
UpdatersExample
¶
UpdatersExample
¶
class
UpdatersExample
(
Scene
):
def
construct
(
self
):
square
=
Square
()
square
.
set_fill
(
BLUE_E
,
1
)
# On all all frames, the constructor Brace(square, UP) will
# be called, and the mobject brace will set its data to match
# that of the newly constructed object
brace
=
always_redraw
(
Brace
,
square
,
UP
)
text
,
number
=
label
=
VGroup
(
Text
(
"Width = "
),
DecimalNumber
(
0
,
show_ellipsis
=
True
,
num_decimal_places
=
2
,
include_sign
=
True
,
)
)
label
.
arrange
(
RIGHT
)
# This ensures that the method deicmal.next_to(square)
# is called on every frame
always
(
label
.
next_to
,
brace
,
UP
)
# You could also write the following equivalent line
# label.add_updater(lambda m: m.next_to(brace, UP))
# If the argument itself might change, you can use f_always,
# for which the arguments following the initial Mobject method
# should be functions returning arguments to that method.
# The following line ensures that decimal.set_value(square.get_y())
# is called every frame
f_always
(
number
.
set_value
,
square
.
get_width
)
# You could also write the following equivalent line
# number.add_updater(lambda m: m.set_value(square.get_width()))
self
.
add
(
square
,
brace
,
label
)
# Notice that the brace and label track with the square
self
.
play
(
square
.
animate
.
scale
(
2
),
rate_func
=
there_and_back
,
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
5
,
stretch
=
True
),
run_time
=
3
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
2
),
run_time
=
3
)
self
.
wait
()
# In general, you can alway call Mobject.add_updater, and pass in
# a function that you want to be called on every frame.  The function
# should take in either one argument, the mobject, or two arguments,
# the mobject and the amount of time since the last frame.
now
=
self
.
time
w0
=
square
.
get_width
()
square
.
add_updater
(
lambda
m
:
m
.
set_width
(
w0
*
math
.
cos
(
self
.
time
-
now
))
)
self
.
wait
(
4
*
PI
)
The new classes and usage in this scene are
always_redraw()
,
DecimalNumber
,
.to_edge()
,
.center()
,
always()
,
f_always()
,
.set_y()
and
.add_updater()
.
always_redraw()
function create a new mobject every frame.
DecimalNumber
is a variable number, speed it up by breaking it into
Text
characters.
.to_edge()
means to place the object on the edge of the screen.
.center()
means to place the object in the center of the screen.
always(f,
x)
means that a certain function (
f(x)
) is executed every frame.
f_always(f,
g)
is similar to
always
, executed
f(g())
every frame.
.set_y()
means to set the ordinate of the object on the screen.
.add_updater()
sets an update function for the object. For example:
mob1.add_updater(lambda
mob:
mob.next_to(mob2))
means
mob1.next_to(mob2)
is executed every frame.
CoordinateSystemExample
¶
CoordinateSystemExample
¶
class
CoordinateSystemExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
(
# x-axis ranges from -1 to 10, with a default step size of 1
x_range
=
(
-
1
,
10
),
# y-axis ranges from -2 to 2 with a step size of 0.5
y_range
=
(
-
2
,
2
,
0.5
),
# The axes will be stretched so as to match the specified
# height and width
height
=
6
,
width
=
10
,
# Axes is made of two NumberLine mobjects.  You can specify
# their configuration with axis_config
axis_config
=
{
"stroke_color"
:
GREY_A
,
"stroke_width"
:
2
,
},
# Alternatively, you can specify configuration for just one
# of them, like this.
y_axis_config
=
{
"include_tip"
:
False
,
}
)
# Keyword arguments of add_coordinate_labels can be used to
# configure the DecimalNumber mobjects which it creates and
# adds to the axes
axes
.
add_coordinate_labels
(
font_size
=
20
,
num_decimal_places
=
1
,
)
self
.
add
(
axes
)
# Axes descends from the CoordinateSystem class, meaning
# you can call call axes.coords_to_point, abbreviated to
# axes.c2p, to associate a set of coordinates with a point,
# like so:
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
c2p
(
0
,
0
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
5
,
0.5
)))
self
.
wait
()
# Similarly, you can call axes.point_to_coords, or axes.p2c
# print(axes.p2c(dot.get_center()))
# We can draw lines from the axes to better mark the coordinates
# of a given point.
# Here, the always_redraw command means that on each new frame
# the lines will be redrawn
h_line
=
always_redraw
(
lambda
:
axes
.
get_h_line
(
dot
.
get_left
()))
v_line
=
always_redraw
(
lambda
:
axes
.
get_v_line
(
dot
.
get_bottom
()))
self
.
play
(
ShowCreation
(
h_line
),
ShowCreation
(
v_line
),
)
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
-
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
1
,
1
)))
self
.
wait
()
# If we tie the dot to a particular set of coordinates, notice
# that as we move the axes around it respects the coordinate
# system defined by them.
f_always
(
dot
.
move_to
,
lambda
:
axes
.
c2p
(
1
,
1
))
self
.
play
(
axes
.
animate
.
scale
(
0.75
)
.
to_corner
(
UL
),
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
FadeOut
(
VGroup
(
axes
,
dot
,
h_line
,
v_line
)))
# Other coordinate systems you can play around with include
# ThreeDAxes, NumberPlane, and ComplexPlane.
GraphExample
¶
GraphExample
¶
class
GraphExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
((
-
3
,
10
),
(
-
1
,
8
))
axes
.
add_coordinate_labels
()
self
.
play
(
Write
(
axes
,
lag_ratio
=
0.01
,
run_time
=
1
))
# Axes.get_graph will return the graph of a function
sin_graph
=
axes
.
get_graph
(
lambda
x
:
2
*
math
.
sin
(
x
),
color
=
BLUE
,
)
# By default, it draws it so as to somewhat smoothly interpolate
# between sampled points (x, f(x)).  If the graph is meant to have
# a corner, though, you can set use_smoothing to False
relu_graph
=
axes
.
get_graph
(
lambda
x
:
max
(
x
,
0
),
use_smoothing
=
False
,
color
=
YELLOW
,
)
# For discontinuous functions, you can specify the point of
# discontinuity so that it does not try to draw over the gap.
step_graph
=
axes
.
get_graph
(
lambda
x
:
2.0
if
x
>
3
else
1.0
,
discontinuities
=
[
3
],
color
=
GREEN
,
)
# Axes.get_graph_label takes in either a string or a mobject.
# If it's a string, it treats it as a LaTeX expression.  By default
# it places the label next to the graph near the right side, and
# has it match the color of the graph
sin_label
=
axes
.
get_graph_label
(
sin_graph
,
"
\\
sin(x)"
)
relu_label
=
axes
.
get_graph_label
(
relu_graph
,
Text
(
"ReLU"
))
step_label
=
axes
.
get_graph_label
(
step_graph
,
Text
(
"Step"
),
x
=
4
)
self
.
play
(
ShowCreation
(
sin_graph
),
FadeIn
(
sin_label
,
RIGHT
),
)
self
.
wait
(
2
)
self
.
play
(
ReplacementTransform
(
sin_graph
,
relu_graph
),
FadeTransform
(
sin_label
,
relu_label
),
)
self
.
wait
()
self
.
play
(
ReplacementTransform
(
relu_graph
,
step_graph
),
FadeTransform
(
relu_label
,
step_label
),
)
self
.
wait
()
parabola
=
axes
.
get_graph
(
lambda
x
:
0.25
*
x
**
2
)
parabola
.
set_stroke
(
BLUE
)
self
.
play
(
FadeOut
(
step_graph
),
FadeOut
(
step_label
),
ShowCreation
(
parabola
)
)
self
.
wait
()
# You can use axes.input_to_graph_point, abbreviated
# to axes.i2gp, to find a particular point on a graph
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
i2gp
(
2
,
parabola
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
# A value tracker lets us animate a parameter, usually
# with the intent of having other mobjects update based
# on the parameter
x_tracker
=
ValueTracker
(
2
)
f_always
(
dot
.
move_to
,
lambda
:
axes
.
i2gp
(
x_tracker
.
get_value
(),
parabola
)
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
4
),
run_time
=
3
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
-
2
),
run_time
=
3
)
self
.
wait
()
SurfaceExample
¶
SurfaceExample
¶
class
SurfaceExample
(
Scene
):
CONFIG
=
{
"camera_class"
:
ThreeDCamera
,
}
def
construct
(
self
):
surface_text
=
Text
(
"For 3d scenes, try using surfaces"
)
surface_text
.
fix_in_frame
()
surface_text
.
to_edge
(
UP
)
self
.
add
(
surface_text
)
self
.
wait
(
0.1
)
torus1
=
Torus
(
r1
=
1
,
r2
=
1
)
torus2
=
Torus
(
r1
=
3
,
r2
=
1
)
sphere
=
Sphere
(
radius
=
3
,
resolution
=
torus1
.
resolution
)
# You can texture a surface with up to two images, which will
# be interpreted as the side towards the light, and away from
# the light.  These can be either urls, or paths to a local file
# in whatever you've set as the image directory in
# the custom_config.yml file
# day_texture = "EarthTextureMap"
# night_texture = "NightEarthTextureMap"
day_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
night_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"
surfaces
=
[
TexturedSurface
(
surface
,
day_texture
,
night_texture
)
for
surface
in
[
sphere
,
torus1
,
torus2
]
]
for
mob
in
surfaces
:
mob
.
shift
(
IN
)
mob
.
mesh
=
SurfaceMesh
(
mob
)
mob
.
mesh
.
set_stroke
(
BLUE
,
1
,
opacity
=
0.5
)
# Set perspective
frame
=
self
.
camera
.
frame
frame
.
set_euler_angles
(
theta
=-
30
*
DEGREES
,
phi
=
70
*
DEGREES
,
)
surface
=
surfaces
[
0
]
self
.
play
(
FadeIn
(
surface
),
ShowCreation
(
surface
.
mesh
,
lag_ratio
=
0.01
,
run_time
=
3
),
)
for
mob
in
surfaces
:
mob
.
add
(
mob
.
mesh
)
surface
.
save_state
()
self
.
play
(
Rotate
(
surface
,
PI
/
2
),
run_time
=
2
)
for
mob
in
surfaces
[
1
:]:
mob
.
rotate
(
PI
/
2
)
self
.
play
(
Transform
(
surface
,
surfaces
[
1
]),
run_time
=
3
)
self
.
play
(
Transform
(
surface
,
surfaces
[
2
]),
# Move camera frame during the transition
frame
.
animate
.
increment_phi
(
-
10
*
DEGREES
),
frame
.
animate
.
increment_theta
(
-
20
*
DEGREES
),
run_time
=
3
)
# Add ambient rotation
frame
.
add_updater
(
lambda
m
,
dt
:
m
.
increment_theta
(
-
0.1
*
dt
))
# Play around with where the light is
light_text
=
Text
(
"You can move around the light source"
)
light_text
.
move_to
(
surface_text
)
light_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
surface_text
,
light_text
))
light
=
self
.
camera
.
light_source
self
.
add
(
light
)
light
.
save_state
()
self
.
play
(
light
.
animate
.
move_to
(
3
*
IN
),
run_time
=
5
)
self
.
play
(
light
.
animate
.
shift
(
10
*
OUT
),
run_time
=
5
)
drag_text
=
Text
(
"Try moving the mouse while pressing d or s"
)
drag_text
.
move_to
(
light_text
)
drag_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
light_text
,
drag_text
))
self
.
wait
()
This scene shows an example of using a three-dimensional surface, and
the related usage has been briefly described in the notes.
.fix_in_frame()
makes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.
OpeningManimExample
¶
OpeningManimExample
¶
class
OpeningManimExample
(
Scene
):
def
construct
(
self
):
intro_words
=
Text
(
"""
The original motivation for manim was to
better illustrate mathematical functions
as transformations.
"""
)
intro_words
.
to_edge
(
UP
)
self
.
play
(
Write
(
intro_words
))
self
.
wait
(
2
)
# Linear transform
grid
=
NumberPlane
((
-
10
,
10
),
(
-
5
,
5
))
matrix
=
[[
1
,
1
],
[
0
,
1
]]
linear_transform_words
=
VGroup
(
Text
(
"This is what the matrix"
),
IntegerMatrix
(
matrix
,
include_background_rectangle
=
True
),
Text
(
"looks like"
)
)
linear_transform_words
.
arrange
(
RIGHT
)
linear_transform_words
.
to_edge
(
UP
)
linear_transform_words
.
set_stroke
(
BLACK
,
10
,
background
=
True
)
self
.
play
(
ShowCreation
(
grid
),
FadeTransform
(
intro_words
,
linear_transform_words
)
)
self
.
wait
()
self
.
play
(
grid
.
animate
.
apply_matrix
(
matrix
),
run_time
=
3
)
self
.
wait
()
# Complex map
c_grid
=
ComplexPlane
()
moving_c_grid
=
c_grid
.
copy
()
moving_c_grid
.
prepare_for_nonlinear_transform
()
c_grid
.
set_stroke
(
BLUE_E
,
1
)
c_grid
.
add_coordinate_labels
(
font_size
=
24
)
complex_map_words
=
TexText
(
"""
Or thinking of the plane as $
\\
mathds
{C}
$,
\\\\
this is the map $z
\\
rightarrow z^2$
"""
)
complex_map_words
.
to_corner
(
UR
)
complex_map_words
.
set_stroke
(
BLACK
,
5
,
background
=
True
)
self
.
play
(
FadeOut
(
grid
),
Write
(
c_grid
,
run_time
=
3
),
FadeIn
(
moving_c_grid
),
FadeTransform
(
linear_transform_words
,
complex_map_words
),
)
self
.
wait
()
self
.
play
(
moving_c_grid
.
animate
.
apply_complex_function
(
lambda
z
:
z
**
2
),
run_time
=
6
,
)
self
.
wait
(
2
)
This scene is a comprehensive application of a two-dimensional scene.
After seeing these scenes, you have already understood part of the
usage of manim. For more examples, see
the video code of 3b1b
.
Contents
Example Scenes
InteractiveDevlopment
AnimatingMethods
TextExample
TexTransformExample
UpdatersExample
CoordinateSystemExample
GraphExample
SurfaceExample
OpeningManimExample

Code Examples:
Example 1:
```python
example_scenes.py
```
Example 2:
```python
from manimlib import *

class InteractiveDevelopment(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)
        square = Square()

        self.play(ShowCreation(square))
        self.wait()

        # This opens an iPython terminal where you can keep writing
        # lines as if they were part of this construct method.
        # In particular, 'square', 'circle' and 'self' will all be
        # part of the local namespace in that terminal.
        self.embed()

        # Try copying and pasting some of the lines below into
        # the interactive shell
        self.play(ReplacementTransform(square, circle))
        self.wait()
        self.play(circle.animate.stretch(4, 0))
        self.play(Rotate(circle, 90 * DEGREES))
        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))

        text = Text("""
            In general, using the interactive shell
            is very helpful when developing new scenes
        """)
        self.play(Write(text))

        # In the interactive shell, you can just type
        # play, add, remove, clear, wait, save_state and restore,
        # instead of self.play, self.add, self.remove, etc.

        # To interact with the window, type touch().  You can then
        # scroll in the window, or zoom by holding down 'z' while scrolling,
        # and change camera perspective by holding down 'd' while moving
        # the mouse.  Press 'r' to reset to the standard camera position.
        # Press 'q' to stop interacting with the window and go back to
        # typing new commands into the shell.

        # In principle you can customize a scene to be responsive to
        # mouse and keyboard interactions
        always(circle.move_to, self.mouse_point)
```
Example 3:
```python
class AnimatingMethods(Scene):
    def construct(self):
        grid = OldTex(r"\pi").get_grid(10, 10, height=4)
        self.add(grid)

        # You can animate the application of mobject methods with the
        # ".animate" syntax:
        self.play(grid.animate.shift(LEFT))

        # Alternatively, you can use the older syntax by passing the
        # method and then the arguments to the scene's "play" function:
        self.play(grid.shift, LEFT)

        # Both of those will interpolate between the mobject's initial
        # state and whatever happens when you apply that method.
        # For this example, calling grid.shift(LEFT) would shift the
        # grid one unit to the left, but both of the previous calls to
        # "self.play" animate that motion.

        # The same applies for any method, including those setting colors.
        self.play(grid.animate.set_color(YELLOW))
        self.wait()
        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))
        self.wait()
        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))
        self.wait()

        # The method Mobject.apply_complex_function lets you apply arbitrary
        # complex functions, treating the points defining the mobject as
        # complex numbers.
        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)
        self.wait()

        # Even more generally, you could apply Mobject.apply_function,
        # which takes in functions form R^3 to R^3
        self.play(
            grid.animate.apply_function(
                lambda p: [
                    p[0] + 0.5 * math.sin(p[1]),
                    p[1] + 0.5 * math.sin(p[0]),
                    p[2]
                ]
            ),
            run_time=5,
        )
        self.wait()
```
Example 4:
```python
.get_grid()
```
Example 5:
```python
self.play(mob.animate.method(args))
```
Example 6:
```python
.get_grid()
```
Example 7:
```python
self.play(mob.animate.method(args))
```
Example 8:
```python
class TextExample(Scene):
    def construct(self):
        # To run this scene properly, you should have "Consolas" font in your computer
        # for full usage, you can see https://github.com/3b1b/manim/pull/680
        text = Text("Here is a text", font="Consolas", font_size=90)
        difference = Text(
            """
            The most important difference between Text and TexText is that\n
            you can change the font more easily, but can't use the LaTeX grammar
            """,
            font="Arial", font_size=24,
            # t2c is a dict that you can choose color for different text
            t2c={"Text": BLUE, "TexText": BLUE, "LaTeX": ORANGE}
        )
        VGroup(text, difference).arrange(DOWN, buff=1)
        self.play(Write(text))
        self.play(FadeIn(difference, UP))
        self.wait(3)

        fonts = Text(
            "And you can also set the font according to different words",
            font="Arial",
            t2f={"font": "Consolas", "words": "Consolas"},
            t2c={"font": BLUE, "words": GREEN}
        )
        fonts.set_width(FRAME_WIDTH - 1)
        slant = Text(
            "And the same as slant and weight",
            font="Consolas",
            t2s={"slant": ITALIC},
            t2w={"weight": BOLD},
            t2c={"slant": ORANGE, "weight": RED}
        )
        VGroup(fonts, slant).arrange(DOWN, buff=0.8)
        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))
        self.play(Write(fonts))
        self.wait()
        self.play(Write(slant))
        self.wait()
```
Example 9:
```python
class TexTransformExample(Scene):
    def construct(self):
        to_isolate = ["B", "C", "=", "(", ")"]
        lines = VGroup(
            # Passing in muliple arguments to Tex will result
            # in the same expression as if those arguments had
            # been joined together, except that the submobject
            # hierarchy of the resulting mobject ensure that the
            # Tex mobject has a subject corresponding to
            # each of these strings.  For example, the Tex mobject
            # below will have 5 subjects, corresponding to the
            # expressions [A^2, +, B^2, =, C^2]
            OldTex("A^2", "+", "B^2", "=", "C^2"),
            # Likewise here
            OldTex("A^2", "=", "C^2", "-", "B^2"),
            # Alternatively, you can pass in the keyword argument
            # "isolate" with a list of strings that should be out as
            # their own submobject.  So the line below is equivalent
            # to the commented out line below it.
            OldTex("A^2 = (C + B)(C - B)", isolate=["A^2", *to_isolate]),
            # OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
            OldTex("A = \\sqrt{(C + B)(C - B)}", isolate=["A", *to_isolate])
        )
        lines.arrange(DOWN, buff=LARGE_BUFF)
        for line in lines:
            line.set_color_by_tex_to_color_map({
                "A": BLUE,
                "B": TEAL,
                "C": GREEN,
            })

        play_kw = {"run_time": 2}
        self.add(lines[0])
        # The animation TransformMatchingTex will line up parts
        # of the source and target which have matching tex strings.
        # Here, giving it a little path_arc makes each part sort of
        # rotate into their final positions, which feels appropriate
        # for the idea of rearranging an equation
        self.play(
            TransformMatchingTex(
                lines[0].copy(), lines[1],
                path_arc=90 * DEGREES,
            ),
            **play_kw
        )
        self.wait()

        # Now, we could try this again on the next line...
        self.play(
            TransformMatchingTex(lines[1].copy(), lines[2]),
            **play_kw
        )
        self.wait()
        # ...and this looks nice enough, but since there's no tex
        # in lines[2] which matches "C^2" or "B^2", those terms fade
        # out to nothing while the C and B terms fade in from nothing.
        # If, however, we want the C^2 to go to C, and B^2 to go to B,
        # we can specify that with a key map.
        self.play(FadeOut(lines[2]))
        self.play(
            TransformMatchingTex(
                lines[1].copy(), lines[2],
                key_map={
                    "C^2": "C",
                    "B^2": "B",
                }
            ),
            **play_kw
        )
        self.wait()

        # And to finish off, a simple TransformMatchingShapes would work
        # just fine.  But perhaps we want that exponent on A^2 to transform into
        # the square root symbol.  At the moment, lines[2] treats the expression
        # A^2 as a unit, so we might create a new version of the same line which
        # separates out just the A.  This way, when TransformMatchingTex lines up
        # all matching parts, the only mismatch will be between the "^2" from
        # new_line2 and the "\sqrt" from the final line.  By passing in,
        # transform_mismatches=True, it will transform this "^2" part into
        # the "\sqrt" part.
        new_line2 = OldTex("A^2 = (C + B)(C - B)", isolate=["A", *to_isolate])
        new_line2.replace(lines[2])
        new_line2.match_style(lines[2])

        self.play(
            TransformMatchingTex(
                new_line2, lines[3],
                transform_mismatches=True,
            ),
            **play_kw
        )
        self.wait(3)
        self.play(FadeOut(lines, RIGHT))

        # Alternatively, if you don't want to think about breaking up
        # the tex strings deliberately, you can TransformMatchingShapes,
        # which will try to line up all pieces of a source mobject with
        # those of a target, regardless of the submobject hierarchy in
        # each one, according to whether those pieces have the same
        # shape (as best it can).
        source = Text("the morse code", height=1)
        target = Text("here come dots", height=1)

        self.play(Write(source))
        self.wait()
        kw = {"run_time": 3, "path_arc": PI / 2}
        self.play(TransformMatchingShapes(source, target, **kw))
        self.wait()
        self.play(TransformMatchingShapes(target, source, **kw))
        self.wait()
```
Example 10:
```python
TransformMatchingTex
```
Example 11:
```python
TransformMatchingShapes
```
Example 12:
```python
TransformMatchingTeX
```
Example 13:
```python
TransformMatchingShapes
```
Example 14:
```python
class UpdatersExample(Scene):
    def construct(self):
        square = Square()
        square.set_fill(BLUE_E, 1)

        # On all all frames, the constructor Brace(square, UP) will
        # be called, and the mobject brace will set its data to match
        # that of the newly constructed object
        brace = always_redraw(Brace, square, UP)

        text, number = label = VGroup(
            Text("Width = "),
            DecimalNumber(
                0,
                show_ellipsis=True,
                num_decimal_places=2,
                include_sign=True,
            )
        )
        label.arrange(RIGHT)

        # This ensures that the method deicmal.next_to(square)
        # is called on every frame
        always(label.next_to, brace, UP)
        # You could also write the following equivalent line
        # label.add_updater(lambda m: m.next_to(brace, UP))

        # If the argument itself might change, you can use f_always,
        # for which the arguments following the initial Mobject method
        # should be functions returning arguments to that method.
        # The following line ensures that decimal.set_value(square.get_y())
        # is called every frame
        f_always(number.set_value, square.get_width)
        # You could also write the following equivalent line
        # number.add_updater(lambda m: m.set_value(square.get_width()))

        self.add(square, brace, label)

        # Notice that the brace and label track with the square
        self.play(
            square.animate.scale(2),
            rate_func=there_and_back,
            run_time=2,
        )
        self.wait()
        self.play(
            square.animate.set_width(5, stretch=True),
            run_time=3,
        )
        self.wait()
        self.play(
            square.animate.set_width(2),
            run_time=3
        )
        self.wait()

        # In general, you can alway call Mobject.add_updater, and pass in
        # a function that you want to be called on every frame.  The function
        # should take in either one argument, the mobject, or two arguments,
        # the mobject and the amount of time since the last frame.
        now = self.time
        w0 = square.get_width()
        square.add_updater(
            lambda m: m.set_width(w0 * math.cos(self.time - now))
        )
        self.wait(4 * PI)
```
Example 15:
```python
always_redraw()
```
Example 16:
```python
DecimalNumber
```
Example 17:
```python
.add_updater()
```
Example 18:
```python
always_redraw()
```
Example 19:
```python
DecimalNumber
```
Example 20:
```python
always(f, x)
```
Example 21:
```python
f_always(f, g)
```
Example 22:
```python
.add_updater()
```
Example 23:
```python
mob1.add_updater(lambda mob: mob.next_to(mob2))
```
Example 24:
```python
mob1.next_to(mob2)
```
Example 25:
```python
class CoordinateSystemExample(Scene):
    def construct(self):
        axes = Axes(
            # x-axis ranges from -1 to 10, with a default step size of 1
            x_range=(-1, 10),
            # y-axis ranges from -2 to 2 with a step size of 0.5
            y_range=(-2, 2, 0.5),
            # The axes will be stretched so as to match the specified
            # height and width
            height=6,
            width=10,
            # Axes is made of two NumberLine mobjects.  You can specify
            # their configuration with axis_config
            axis_config={
                "stroke_color": GREY_A,
                "stroke_width": 2,
            },
            # Alternatively, you can specify configuration for just one
            # of them, like this.
            y_axis_config={
                "include_tip": False,
            }
        )
        # Keyword arguments of add_coordinate_labels can be used to
        # configure the DecimalNumber mobjects which it creates and
        # adds to the axes
        axes.add_coordinate_labels(
            font_size=20,
            num_decimal_places=1,
        )
        self.add(axes)

        # Axes descends from the CoordinateSystem class, meaning
        # you can call call axes.coords_to_point, abbreviated to
        # axes.c2p, to associate a set of coordinates with a point,
        # like so:
        dot = Dot(color=RED)
        dot.move_to(axes.c2p(0, 0))
        self.play(FadeIn(dot, scale=0.5))
        self.play(dot.animate.move_to(axes.c2p(3, 2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))
        self.wait()

        # Similarly, you can call axes.point_to_coords, or axes.p2c
        # print(axes.p2c(dot.get_center()))

        # We can draw lines from the axes to better mark the coordinates
        # of a given point.
        # Here, the always_redraw command means that on each new frame
        # the lines will be redrawn
        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))
        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))

        self.play(
            ShowCreation(h_line),
            ShowCreation(v_line),
        )
        self.play(dot.animate.move_to(axes.c2p(3, -2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(1, 1)))
        self.wait()

        # If we tie the dot to a particular set of coordinates, notice
        # that as we move the axes around it respects the coordinate
        # system defined by them.
        f_always(dot.move_to, lambda: axes.c2p(1, 1))
        self.play(
            axes.animate.scale(0.75).to_corner(UL),
            run_time=2,
        )
        self.wait()
        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))

        # Other coordinate systems you can play around with include
        # ThreeDAxes, NumberPlane, and ComplexPlane.
```
Example 26:
```python
class GraphExample(Scene):
    def construct(self):
        axes = Axes((-3, 10), (-1, 8))
        axes.add_coordinate_labels()

        self.play(Write(axes, lag_ratio=0.01, run_time=1))

        # Axes.get_graph will return the graph of a function
        sin_graph = axes.get_graph(
            lambda x: 2 * math.sin(x),
            color=BLUE,
        )
        # By default, it draws it so as to somewhat smoothly interpolate
        # between sampled points (x, f(x)).  If the graph is meant to have
        # a corner, though, you can set use_smoothing to False
        relu_graph = axes.get_graph(
            lambda x: max(x, 0),
            use_smoothing=False,
            color=YELLOW,
        )
        # For discontinuous functions, you can specify the point of
        # discontinuity so that it does not try to draw over the gap.
        step_graph = axes.get_graph(
            lambda x: 2.0 if x > 3 else 1.0,
            discontinuities=[3],
            color=GREEN,
        )

        # Axes.get_graph_label takes in either a string or a mobject.
        # If it's a string, it treats it as a LaTeX expression.  By default
        # it places the label next to the graph near the right side, and
        # has it match the color of the graph
        sin_label = axes.get_graph_label(sin_graph, "\\sin(x)")
        relu_label = axes.get_graph_label(relu_graph, Text("ReLU"))
        step_label = axes.get_graph_label(step_graph, Text("Step"), x=4)

        self.play(
            ShowCreation(sin_graph),
            FadeIn(sin_label, RIGHT),
        )
        self.wait(2)
        self.play(
            ReplacementTransform(sin_graph, relu_graph),
            FadeTransform(sin_label, relu_label),
        )
        self.wait()
        self.play(
            ReplacementTransform(relu_graph, step_graph),
            FadeTransform(relu_label, step_label),
        )
        self.wait()

        parabola = axes.get_graph(lambda x: 0.25 * x**2)
        parabola.set_stroke(BLUE)
        self.play(
            FadeOut(step_graph),
            FadeOut(step_label),
            ShowCreation(parabola)
        )
        self.wait()

        # You can use axes.input_to_graph_point, abbreviated
        # to axes.i2gp, to find a particular point on a graph
        dot = Dot(color=RED)
        dot.move_to(axes.i2gp(2, parabola))
        self.play(FadeIn(dot, scale=0.5))

        # A value tracker lets us animate a parameter, usually
        # with the intent of having other mobjects update based
        # on the parameter
        x_tracker = ValueTracker(2)
        f_always(
            dot.move_to,
            lambda: axes.i2gp(x_tracker.get_value(), parabola)
        )

        self.play(x_tracker.animate.set_value(4), run_time=3)
        self.play(x_tracker.animate.set_value(-2), run_time=3)
        self.wait()
```
Example 27:
```python
class SurfaceExample(Scene):
    CONFIG = {
        "camera_class": ThreeDCamera,
    }

    def construct(self):
        surface_text = Text("For 3d scenes, try using surfaces")
        surface_text.fix_in_frame()
        surface_text.to_edge(UP)
        self.add(surface_text)
        self.wait(0.1)

        torus1 = Torus(r1=1, r2=1)
        torus2 = Torus(r1=3, r2=1)
        sphere = Sphere(radius=3, resolution=torus1.resolution)
        # You can texture a surface with up to two images, which will
        # be interpreted as the side towards the light, and away from
        # the light.  These can be either urls, or paths to a local file
        # in whatever you've set as the image directory in
        # the custom_config.yml file

        # day_texture = "EarthTextureMap"
        # night_texture = "NightEarthTextureMap"
        day_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
        night_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"

        surfaces = [
            TexturedSurface(surface, day_texture, night_texture)
            for surface in [sphere, torus1, torus2]
        ]

        for mob in surfaces:
            mob.shift(IN)
            mob.mesh = SurfaceMesh(mob)
            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)

        # Set perspective
        frame = self.camera.frame
        frame.set_euler_angles(
            theta=-30 * DEGREES,
            phi=70 * DEGREES,
        )

        surface = surfaces[0]

        self.play(
            FadeIn(surface),
            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),
        )
        for mob in surfaces:
            mob.add(mob.mesh)
        surface.save_state()
        self.play(Rotate(surface, PI / 2), run_time=2)
        for mob in surfaces[1:]:
            mob.rotate(PI / 2)

        self.play(
            Transform(surface, surfaces[1]),
            run_time=3
        )

        self.play(
            Transform(surface, surfaces[2]),
            # Move camera frame during the transition
            frame.animate.increment_phi(-10 * DEGREES),
            frame.animate.increment_theta(-20 * DEGREES),
            run_time=3
        )
        # Add ambient rotation
        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))

        # Play around with where the light is
        light_text = Text("You can move around the light source")
        light_text.move_to(surface_text)
        light_text.fix_in_frame()

        self.play(FadeTransform(surface_text, light_text))
        light = self.camera.light_source
        self.add(light)
        light.save_state()
        self.play(light.animate.move_to(3 * IN), run_time=5)
        self.play(light.animate.shift(10 * OUT), run_time=5)

        drag_text = Text("Try moving the mouse while pressing d or s")
        drag_text.move_to(light_text)
        drag_text.fix_in_frame()

        self.play(FadeTransform(light_text, drag_text))
        self.wait()
```
Example 28:
```python
.fix_in_frame()
```
Example 29:
```python
class OpeningManimExample(Scene):
    def construct(self):
        intro_words = Text("""
            The original motivation for manim was to
            better illustrate mathematical functions
            as transformations.
        """)
        intro_words.to_edge(UP)

        self.play(Write(intro_words))
        self.wait(2)

        # Linear transform
        grid = NumberPlane((-10, 10), (-5, 5))
        matrix = [[1, 1], [0, 1]]
        linear_transform_words = VGroup(
            Text("This is what the matrix"),
            IntegerMatrix(matrix, include_background_rectangle=True),
            Text("looks like")
        )
        linear_transform_words.arrange(RIGHT)
        linear_transform_words.to_edge(UP)
        linear_transform_words.set_stroke(BLACK, 10, background=True)

        self.play(
            ShowCreation(grid),
            FadeTransform(intro_words, linear_transform_words)
        )
        self.wait()
        self.play(grid.animate.apply_matrix(matrix), run_time=3)
        self.wait()

        # Complex map
        c_grid = ComplexPlane()
        moving_c_grid = c_grid.copy()
        moving_c_grid.prepare_for_nonlinear_transform()
        c_grid.set_stroke(BLUE_E, 1)
        c_grid.add_coordinate_labels(font_size=24)
        complex_map_words = TexText("""
            Or thinking of the plane as $\\mathds{C}$,\\\\
            this is the map $z \\rightarrow z^2$
        """)
        complex_map_words.to_corner(UR)
        complex_map_words.set_stroke(BLACK, 5, background=True)

        self.play(
            FadeOut(grid),
            Write(c_grid, run_time=3),
            FadeIn(moving_c_grid),
            FadeTransform(linear_transform_words, complex_map_words),
        )
        self.wait()
        self.play(
            moving_c_grid.animate.apply_complex_function(lambda z: z**2),
            run_time=6,
        )
        self.wait(2)
```

================================================================================

=== Example Scenes - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/example_scenes.html#updatersexample
Content:
Example Scenes
¶
After understanding the previous knowledge, we can understand more scenes.
Many example scenes are given in
example_scenes.py
, let’s start with
the simplest and one by one.
InteractiveDevlopment
¶
InteractiveDevelopment
¶
from
manimlib
import
*
class
InteractiveDevelopment
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
square
=
Square
()
self
.
play
(
ShowCreation
(
square
))
self
.
wait
()
# This opens an iPython terminal where you can keep writing
# lines as if they were part of this construct method.
# In particular, 'square', 'circle' and 'self' will all be
# part of the local namespace in that terminal.
self
.
embed
()
# Try copying and pasting some of the lines below into
# the interactive shell
self
.
play
(
ReplacementTransform
(
square
,
circle
))
self
.
wait
()
self
.
play
(
circle
.
animate
.
stretch
(
4
,
0
))
self
.
play
(
Rotate
(
circle
,
90
*
DEGREES
))
self
.
play
(
circle
.
animate
.
shift
(
2
*
RIGHT
)
.
scale
(
0.25
))
text
=
Text
(
"""
In general, using the interactive shell
is very helpful when developing new scenes
"""
)
self
.
play
(
Write
(
text
))
# In the interactive shell, you can just type
# play, add, remove, clear, wait, save_state and restore,
# instead of self.play, self.add, self.remove, etc.
# To interact with the window, type touch().  You can then
# scroll in the window, or zoom by holding down 'z' while scrolling,
# and change camera perspective by holding down 'd' while moving
# the mouse.  Press 'r' to reset to the standard camera position.
# Press 'q' to stop interacting with the window and go back to
# typing new commands into the shell.
# In principle you can customize a scene to be responsive to
# mouse and keyboard interactions
always
(
circle
.
move_to
,
self
.
mouse_point
)
This scene is similar to what we wrote in
Quick Start
.
And how to interact has been written in the comments.
No more explanation here.
AnimatingMethods
¶
AnimatingMethods
¶
class
AnimatingMethods
(
Scene
):
def
construct
(
self
):
grid
=
OldTex
(
r
"\pi"
)
.
get_grid
(
10
,
10
,
height
=
4
)
self
.
add
(
grid
)
# You can animate the application of mobject methods with the
# ".animate" syntax:
self
.
play
(
grid
.
animate
.
shift
(
LEFT
))
# Alternatively, you can use the older syntax by passing the
# method and then the arguments to the scene's "play" function:
self
.
play
(
grid
.
shift
,
LEFT
)
# Both of those will interpolate between the mobject's initial
# state and whatever happens when you apply that method.
# For this example, calling grid.shift(LEFT) would shift the
# grid one unit to the left, but both of the previous calls to
# "self.play" animate that motion.
# The same applies for any method, including those setting colors.
self
.
play
(
grid
.
animate
.
set_color
(
YELLOW
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_submobject_colors_by_gradient
(
BLUE
,
GREEN
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_height
(
TAU
-
MED_SMALL_BUFF
))
self
.
wait
()
# The method Mobject.apply_complex_function lets you apply arbitrary
# complex functions, treating the points defining the mobject as
# complex numbers.
self
.
play
(
grid
.
animate
.
apply_complex_function
(
np
.
exp
),
run_time
=
5
)
self
.
wait
()
# Even more generally, you could apply Mobject.apply_function,
# which takes in functions form R^3 to R^3
self
.
play
(
grid
.
animate
.
apply_function
(
lambda
p
:
[
p
[
0
]
+
0.5
*
math
.
sin
(
p
[
1
]),
p
[
1
]
+
0.5
*
math
.
sin
(
p
[
0
]),
p
[
2
]
]
),
run_time
=
5
,
)
self
.
wait
()
The new usage in this scene is
.get_grid()
and
self.play(mob.animate.method(args))
.
.get_grid()
method will return a new mobject containing multiple copies of this one arranged in a grid.
self.play(mob.animate.method(args))
animates the method, and the details are in the comments above.
TextExample
¶
TextExample
¶
class
TextExample
(
Scene
):
def
construct
(
self
):
# To run this scene properly, you should have "Consolas" font in your computer
# for full usage, you can see https://github.com/3b1b/manim/pull/680
text
=
Text
(
"Here is a text"
,
font
=
"Consolas"
,
font_size
=
90
)
difference
=
Text
(
"""
The most important difference between Text and TexText is that\n
you can change the font more easily, but can't use the LaTeX grammar
"""
,
font
=
"Arial"
,
font_size
=
24
,
# t2c is a dict that you can choose color for different text
t2c
=
{
"Text"
:
BLUE
,
"TexText"
:
BLUE
,
"LaTeX"
:
ORANGE
}
)
VGroup
(
text
,
difference
)
.
arrange
(
DOWN
,
buff
=
1
)
self
.
play
(
Write
(
text
))
self
.
play
(
FadeIn
(
difference
,
UP
))
self
.
wait
(
3
)
fonts
=
Text
(
"And you can also set the font according to different words"
,
font
=
"Arial"
,
t2f
=
{
"font"
:
"Consolas"
,
"words"
:
"Consolas"
},
t2c
=
{
"font"
:
BLUE
,
"words"
:
GREEN
}
)
fonts
.
set_width
(
FRAME_WIDTH
-
1
)
slant
=
Text
(
"And the same as slant and weight"
,
font
=
"Consolas"
,
t2s
=
{
"slant"
:
ITALIC
},
t2w
=
{
"weight"
:
BOLD
},
t2c
=
{
"slant"
:
ORANGE
,
"weight"
:
RED
}
)
VGroup
(
fonts
,
slant
)
.
arrange
(
DOWN
,
buff
=
0.8
)
self
.
play
(
FadeOut
(
text
),
FadeOut
(
difference
,
shift
=
DOWN
))
self
.
play
(
Write
(
fonts
))
self
.
wait
()
self
.
play
(
Write
(
slant
))
self
.
wait
()
The new classes in this scene are
Text
,
VGroup
,
Write
,
FadeIn
and
FadeOut
.
Text
can create text, define fonts, etc. The usage ais clearly reflected in the above examples.
VGroup
can put multiple
VMobject
together as a whole. In the example, the
.arrange()
method is called to arrange the sub-mobjects in sequence downward (
DOWN
), and the spacing is
buff
.
Write
is an animation that shows similar writing effects.
FadeIn
fades the object in, the second parameter indicates the direction of the fade in.
FadeOut
fades out the object, the second parameter indicates the direction of the fade out.
TexTransformExample
¶
TexTransformExample
¶
class
TexTransformExample
(
Scene
):
def
construct
(
self
):
to_isolate
=
[
"B"
,
"C"
,
"="
,
"("
,
")"
]
lines
=
VGroup
(
# Passing in muliple arguments to Tex will result
# in the same expression as if those arguments had
# been joined together, except that the submobject
# hierarchy of the resulting mobject ensure that the
# Tex mobject has a subject corresponding to
# each of these strings.  For example, the Tex mobject
# below will have 5 subjects, corresponding to the
# expressions [A^2, +, B^2, =, C^2]
OldTex
(
"A^2"
,
"+"
,
"B^2"
,
"="
,
"C^2"
),
# Likewise here
OldTex
(
"A^2"
,
"="
,
"C^2"
,
"-"
,
"B^2"
),
# Alternatively, you can pass in the keyword argument
# "isolate" with a list of strings that should be out as
# their own submobject.  So the line below is equivalent
# to the commented out line below it.
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A^2"
,
*
to_isolate
]),
# OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
OldTex
(
"A =
\\
sqrt{(C + B)(C - B)}"
,
isolate
=
[
"A"
,
*
to_isolate
])
)
lines
.
arrange
(
DOWN
,
buff
=
LARGE_BUFF
)
for
line
in
lines
:
line
.
set_color_by_tex_to_color_map
({
"A"
:
BLUE
,
"B"
:
TEAL
,
"C"
:
GREEN
,
})
play_kw
=
{
"run_time"
:
2
}
self
.
add
(
lines
[
0
])
# The animation TransformMatchingTex will line up parts
# of the source and target which have matching tex strings.
# Here, giving it a little path_arc makes each part sort of
# rotate into their final positions, which feels appropriate
# for the idea of rearranging an equation
self
.
play
(
TransformMatchingTex
(
lines
[
0
]
.
copy
(),
lines
[
1
],
path_arc
=
90
*
DEGREES
,
),
**
play_kw
)
self
.
wait
()
# Now, we could try this again on the next line...
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
]),
**
play_kw
)
self
.
wait
()
# ...and this looks nice enough, but since there's no tex
# in lines[2] which matches "C^2" or "B^2", those terms fade
# out to nothing while the C and B terms fade in from nothing.
# If, however, we want the C^2 to go to C, and B^2 to go to B,
# we can specify that with a key map.
self
.
play
(
FadeOut
(
lines
[
2
]))
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
],
key_map
=
{
"C^2"
:
"C"
,
"B^2"
:
"B"
,
}
),
**
play_kw
)
self
.
wait
()
# And to finish off, a simple TransformMatchingShapes would work
# just fine.  But perhaps we want that exponent on A^2 to transform into
# the square root symbol.  At the moment, lines[2] treats the expression
# A^2 as a unit, so we might create a new version of the same line which
# separates out just the A.  This way, when TransformMatchingTex lines up
# all matching parts, the only mismatch will be between the "^2" from
# new_line2 and the "\sqrt" from the final line.  By passing in,
# transform_mismatches=True, it will transform this "^2" part into
# the "\sqrt" part.
new_line2
=
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A"
,
*
to_isolate
])
new_line2
.
replace
(
lines
[
2
])
new_line2
.
match_style
(
lines
[
2
])
self
.
play
(
TransformMatchingTex
(
new_line2
,
lines
[
3
],
transform_mismatches
=
True
,
),
**
play_kw
)
self
.
wait
(
3
)
self
.
play
(
FadeOut
(
lines
,
RIGHT
))
# Alternatively, if you don't want to think about breaking up
# the tex strings deliberately, you can TransformMatchingShapes,
# which will try to line up all pieces of a source mobject with
# those of a target, regardless of the submobject hierarchy in
# each one, according to whether those pieces have the same
# shape (as best it can).
source
=
Text
(
"the morse code"
,
height
=
1
)
target
=
Text
(
"here come dots"
,
height
=
1
)
self
.
play
(
Write
(
source
))
self
.
wait
()
kw
=
{
"run_time"
:
3
,
"path_arc"
:
PI
/
2
}
self
.
play
(
TransformMatchingShapes
(
source
,
target
,
**
kw
))
self
.
wait
()
self
.
play
(
TransformMatchingShapes
(
target
,
source
,
**
kw
))
self
.
wait
()
The new classes in this scene are
Tex
,
TexText
,
TransformMatchingTex
and
TransformMatchingShapes
.
Tex
uses LaTeX to create mathematical formulas.
TexText
uses LaTeX to create text.
TransformMatchingTeX
automatically transforms sub-objects according to the similarities and differences of tex in
Tex
.
TransformMatchingShapes
automatically transform sub-objects directly based on the similarities and differences of the object point sets.
UpdatersExample
¶
UpdatersExample
¶
class
UpdatersExample
(
Scene
):
def
construct
(
self
):
square
=
Square
()
square
.
set_fill
(
BLUE_E
,
1
)
# On all all frames, the constructor Brace(square, UP) will
# be called, and the mobject brace will set its data to match
# that of the newly constructed object
brace
=
always_redraw
(
Brace
,
square
,
UP
)
text
,
number
=
label
=
VGroup
(
Text
(
"Width = "
),
DecimalNumber
(
0
,
show_ellipsis
=
True
,
num_decimal_places
=
2
,
include_sign
=
True
,
)
)
label
.
arrange
(
RIGHT
)
# This ensures that the method deicmal.next_to(square)
# is called on every frame
always
(
label
.
next_to
,
brace
,
UP
)
# You could also write the following equivalent line
# label.add_updater(lambda m: m.next_to(brace, UP))
# If the argument itself might change, you can use f_always,
# for which the arguments following the initial Mobject method
# should be functions returning arguments to that method.
# The following line ensures that decimal.set_value(square.get_y())
# is called every frame
f_always
(
number
.
set_value
,
square
.
get_width
)
# You could also write the following equivalent line
# number.add_updater(lambda m: m.set_value(square.get_width()))
self
.
add
(
square
,
brace
,
label
)
# Notice that the brace and label track with the square
self
.
play
(
square
.
animate
.
scale
(
2
),
rate_func
=
there_and_back
,
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
5
,
stretch
=
True
),
run_time
=
3
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
2
),
run_time
=
3
)
self
.
wait
()
# In general, you can alway call Mobject.add_updater, and pass in
# a function that you want to be called on every frame.  The function
# should take in either one argument, the mobject, or two arguments,
# the mobject and the amount of time since the last frame.
now
=
self
.
time
w0
=
square
.
get_width
()
square
.
add_updater
(
lambda
m
:
m
.
set_width
(
w0
*
math
.
cos
(
self
.
time
-
now
))
)
self
.
wait
(
4
*
PI
)
The new classes and usage in this scene are
always_redraw()
,
DecimalNumber
,
.to_edge()
,
.center()
,
always()
,
f_always()
,
.set_y()
and
.add_updater()
.
always_redraw()
function create a new mobject every frame.
DecimalNumber
is a variable number, speed it up by breaking it into
Text
characters.
.to_edge()
means to place the object on the edge of the screen.
.center()
means to place the object in the center of the screen.
always(f,
x)
means that a certain function (
f(x)
) is executed every frame.
f_always(f,
g)
is similar to
always
, executed
f(g())
every frame.
.set_y()
means to set the ordinate of the object on the screen.
.add_updater()
sets an update function for the object. For example:
mob1.add_updater(lambda
mob:
mob.next_to(mob2))
means
mob1.next_to(mob2)
is executed every frame.
CoordinateSystemExample
¶
CoordinateSystemExample
¶
class
CoordinateSystemExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
(
# x-axis ranges from -1 to 10, with a default step size of 1
x_range
=
(
-
1
,
10
),
# y-axis ranges from -2 to 2 with a step size of 0.5
y_range
=
(
-
2
,
2
,
0.5
),
# The axes will be stretched so as to match the specified
# height and width
height
=
6
,
width
=
10
,
# Axes is made of two NumberLine mobjects.  You can specify
# their configuration with axis_config
axis_config
=
{
"stroke_color"
:
GREY_A
,
"stroke_width"
:
2
,
},
# Alternatively, you can specify configuration for just one
# of them, like this.
y_axis_config
=
{
"include_tip"
:
False
,
}
)
# Keyword arguments of add_coordinate_labels can be used to
# configure the DecimalNumber mobjects which it creates and
# adds to the axes
axes
.
add_coordinate_labels
(
font_size
=
20
,
num_decimal_places
=
1
,
)
self
.
add
(
axes
)
# Axes descends from the CoordinateSystem class, meaning
# you can call call axes.coords_to_point, abbreviated to
# axes.c2p, to associate a set of coordinates with a point,
# like so:
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
c2p
(
0
,
0
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
5
,
0.5
)))
self
.
wait
()
# Similarly, you can call axes.point_to_coords, or axes.p2c
# print(axes.p2c(dot.get_center()))
# We can draw lines from the axes to better mark the coordinates
# of a given point.
# Here, the always_redraw command means that on each new frame
# the lines will be redrawn
h_line
=
always_redraw
(
lambda
:
axes
.
get_h_line
(
dot
.
get_left
()))
v_line
=
always_redraw
(
lambda
:
axes
.
get_v_line
(
dot
.
get_bottom
()))
self
.
play
(
ShowCreation
(
h_line
),
ShowCreation
(
v_line
),
)
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
-
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
1
,
1
)))
self
.
wait
()
# If we tie the dot to a particular set of coordinates, notice
# that as we move the axes around it respects the coordinate
# system defined by them.
f_always
(
dot
.
move_to
,
lambda
:
axes
.
c2p
(
1
,
1
))
self
.
play
(
axes
.
animate
.
scale
(
0.75
)
.
to_corner
(
UL
),
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
FadeOut
(
VGroup
(
axes
,
dot
,
h_line
,
v_line
)))
# Other coordinate systems you can play around with include
# ThreeDAxes, NumberPlane, and ComplexPlane.
GraphExample
¶
GraphExample
¶
class
GraphExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
((
-
3
,
10
),
(
-
1
,
8
))
axes
.
add_coordinate_labels
()
self
.
play
(
Write
(
axes
,
lag_ratio
=
0.01
,
run_time
=
1
))
# Axes.get_graph will return the graph of a function
sin_graph
=
axes
.
get_graph
(
lambda
x
:
2
*
math
.
sin
(
x
),
color
=
BLUE
,
)
# By default, it draws it so as to somewhat smoothly interpolate
# between sampled points (x, f(x)).  If the graph is meant to have
# a corner, though, you can set use_smoothing to False
relu_graph
=
axes
.
get_graph
(
lambda
x
:
max
(
x
,
0
),
use_smoothing
=
False
,
color
=
YELLOW
,
)
# For discontinuous functions, you can specify the point of
# discontinuity so that it does not try to draw over the gap.
step_graph
=
axes
.
get_graph
(
lambda
x
:
2.0
if
x
>
3
else
1.0
,
discontinuities
=
[
3
],
color
=
GREEN
,
)
# Axes.get_graph_label takes in either a string or a mobject.
# If it's a string, it treats it as a LaTeX expression.  By default
# it places the label next to the graph near the right side, and
# has it match the color of the graph
sin_label
=
axes
.
get_graph_label
(
sin_graph
,
"
\\
sin(x)"
)
relu_label
=
axes
.
get_graph_label
(
relu_graph
,
Text
(
"ReLU"
))
step_label
=
axes
.
get_graph_label
(
step_graph
,
Text
(
"Step"
),
x
=
4
)
self
.
play
(
ShowCreation
(
sin_graph
),
FadeIn
(
sin_label
,
RIGHT
),
)
self
.
wait
(
2
)
self
.
play
(
ReplacementTransform
(
sin_graph
,
relu_graph
),
FadeTransform
(
sin_label
,
relu_label
),
)
self
.
wait
()
self
.
play
(
ReplacementTransform
(
relu_graph
,
step_graph
),
FadeTransform
(
relu_label
,
step_label
),
)
self
.
wait
()
parabola
=
axes
.
get_graph
(
lambda
x
:
0.25
*
x
**
2
)
parabola
.
set_stroke
(
BLUE
)
self
.
play
(
FadeOut
(
step_graph
),
FadeOut
(
step_label
),
ShowCreation
(
parabola
)
)
self
.
wait
()
# You can use axes.input_to_graph_point, abbreviated
# to axes.i2gp, to find a particular point on a graph
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
i2gp
(
2
,
parabola
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
# A value tracker lets us animate a parameter, usually
# with the intent of having other mobjects update based
# on the parameter
x_tracker
=
ValueTracker
(
2
)
f_always
(
dot
.
move_to
,
lambda
:
axes
.
i2gp
(
x_tracker
.
get_value
(),
parabola
)
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
4
),
run_time
=
3
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
-
2
),
run_time
=
3
)
self
.
wait
()
SurfaceExample
¶
SurfaceExample
¶
class
SurfaceExample
(
Scene
):
CONFIG
=
{
"camera_class"
:
ThreeDCamera
,
}
def
construct
(
self
):
surface_text
=
Text
(
"For 3d scenes, try using surfaces"
)
surface_text
.
fix_in_frame
()
surface_text
.
to_edge
(
UP
)
self
.
add
(
surface_text
)
self
.
wait
(
0.1
)
torus1
=
Torus
(
r1
=
1
,
r2
=
1
)
torus2
=
Torus
(
r1
=
3
,
r2
=
1
)
sphere
=
Sphere
(
radius
=
3
,
resolution
=
torus1
.
resolution
)
# You can texture a surface with up to two images, which will
# be interpreted as the side towards the light, and away from
# the light.  These can be either urls, or paths to a local file
# in whatever you've set as the image directory in
# the custom_config.yml file
# day_texture = "EarthTextureMap"
# night_texture = "NightEarthTextureMap"
day_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
night_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"
surfaces
=
[
TexturedSurface
(
surface
,
day_texture
,
night_texture
)
for
surface
in
[
sphere
,
torus1
,
torus2
]
]
for
mob
in
surfaces
:
mob
.
shift
(
IN
)
mob
.
mesh
=
SurfaceMesh
(
mob
)
mob
.
mesh
.
set_stroke
(
BLUE
,
1
,
opacity
=
0.5
)
# Set perspective
frame
=
self
.
camera
.
frame
frame
.
set_euler_angles
(
theta
=-
30
*
DEGREES
,
phi
=
70
*
DEGREES
,
)
surface
=
surfaces
[
0
]
self
.
play
(
FadeIn
(
surface
),
ShowCreation
(
surface
.
mesh
,
lag_ratio
=
0.01
,
run_time
=
3
),
)
for
mob
in
surfaces
:
mob
.
add
(
mob
.
mesh
)
surface
.
save_state
()
self
.
play
(
Rotate
(
surface
,
PI
/
2
),
run_time
=
2
)
for
mob
in
surfaces
[
1
:]:
mob
.
rotate
(
PI
/
2
)
self
.
play
(
Transform
(
surface
,
surfaces
[
1
]),
run_time
=
3
)
self
.
play
(
Transform
(
surface
,
surfaces
[
2
]),
# Move camera frame during the transition
frame
.
animate
.
increment_phi
(
-
10
*
DEGREES
),
frame
.
animate
.
increment_theta
(
-
20
*
DEGREES
),
run_time
=
3
)
# Add ambient rotation
frame
.
add_updater
(
lambda
m
,
dt
:
m
.
increment_theta
(
-
0.1
*
dt
))
# Play around with where the light is
light_text
=
Text
(
"You can move around the light source"
)
light_text
.
move_to
(
surface_text
)
light_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
surface_text
,
light_text
))
light
=
self
.
camera
.
light_source
self
.
add
(
light
)
light
.
save_state
()
self
.
play
(
light
.
animate
.
move_to
(
3
*
IN
),
run_time
=
5
)
self
.
play
(
light
.
animate
.
shift
(
10
*
OUT
),
run_time
=
5
)
drag_text
=
Text
(
"Try moving the mouse while pressing d or s"
)
drag_text
.
move_to
(
light_text
)
drag_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
light_text
,
drag_text
))
self
.
wait
()
This scene shows an example of using a three-dimensional surface, and
the related usage has been briefly described in the notes.
.fix_in_frame()
makes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.
OpeningManimExample
¶
OpeningManimExample
¶
class
OpeningManimExample
(
Scene
):
def
construct
(
self
):
intro_words
=
Text
(
"""
The original motivation for manim was to
better illustrate mathematical functions
as transformations.
"""
)
intro_words
.
to_edge
(
UP
)
self
.
play
(
Write
(
intro_words
))
self
.
wait
(
2
)
# Linear transform
grid
=
NumberPlane
((
-
10
,
10
),
(
-
5
,
5
))
matrix
=
[[
1
,
1
],
[
0
,
1
]]
linear_transform_words
=
VGroup
(
Text
(
"This is what the matrix"
),
IntegerMatrix
(
matrix
,
include_background_rectangle
=
True
),
Text
(
"looks like"
)
)
linear_transform_words
.
arrange
(
RIGHT
)
linear_transform_words
.
to_edge
(
UP
)
linear_transform_words
.
set_stroke
(
BLACK
,
10
,
background
=
True
)
self
.
play
(
ShowCreation
(
grid
),
FadeTransform
(
intro_words
,
linear_transform_words
)
)
self
.
wait
()
self
.
play
(
grid
.
animate
.
apply_matrix
(
matrix
),
run_time
=
3
)
self
.
wait
()
# Complex map
c_grid
=
ComplexPlane
()
moving_c_grid
=
c_grid
.
copy
()
moving_c_grid
.
prepare_for_nonlinear_transform
()
c_grid
.
set_stroke
(
BLUE_E
,
1
)
c_grid
.
add_coordinate_labels
(
font_size
=
24
)
complex_map_words
=
TexText
(
"""
Or thinking of the plane as $
\\
mathds
{C}
$,
\\\\
this is the map $z
\\
rightarrow z^2$
"""
)
complex_map_words
.
to_corner
(
UR
)
complex_map_words
.
set_stroke
(
BLACK
,
5
,
background
=
True
)
self
.
play
(
FadeOut
(
grid
),
Write
(
c_grid
,
run_time
=
3
),
FadeIn
(
moving_c_grid
),
FadeTransform
(
linear_transform_words
,
complex_map_words
),
)
self
.
wait
()
self
.
play
(
moving_c_grid
.
animate
.
apply_complex_function
(
lambda
z
:
z
**
2
),
run_time
=
6
,
)
self
.
wait
(
2
)
This scene is a comprehensive application of a two-dimensional scene.
After seeing these scenes, you have already understood part of the
usage of manim. For more examples, see
the video code of 3b1b
.
Contents
Example Scenes
InteractiveDevlopment
AnimatingMethods
TextExample
TexTransformExample
UpdatersExample
CoordinateSystemExample
GraphExample
SurfaceExample
OpeningManimExample

Code Examples:
Example 1:
```python
example_scenes.py
```
Example 2:
```python
from manimlib import *

class InteractiveDevelopment(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)
        square = Square()

        self.play(ShowCreation(square))
        self.wait()

        # This opens an iPython terminal where you can keep writing
        # lines as if they were part of this construct method.
        # In particular, 'square', 'circle' and 'self' will all be
        # part of the local namespace in that terminal.
        self.embed()

        # Try copying and pasting some of the lines below into
        # the interactive shell
        self.play(ReplacementTransform(square, circle))
        self.wait()
        self.play(circle.animate.stretch(4, 0))
        self.play(Rotate(circle, 90 * DEGREES))
        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))

        text = Text("""
            In general, using the interactive shell
            is very helpful when developing new scenes
        """)
        self.play(Write(text))

        # In the interactive shell, you can just type
        # play, add, remove, clear, wait, save_state and restore,
        # instead of self.play, self.add, self.remove, etc.

        # To interact with the window, type touch().  You can then
        # scroll in the window, or zoom by holding down 'z' while scrolling,
        # and change camera perspective by holding down 'd' while moving
        # the mouse.  Press 'r' to reset to the standard camera position.
        # Press 'q' to stop interacting with the window and go back to
        # typing new commands into the shell.

        # In principle you can customize a scene to be responsive to
        # mouse and keyboard interactions
        always(circle.move_to, self.mouse_point)
```
Example 3:
```python
class AnimatingMethods(Scene):
    def construct(self):
        grid = OldTex(r"\pi").get_grid(10, 10, height=4)
        self.add(grid)

        # You can animate the application of mobject methods with the
        # ".animate" syntax:
        self.play(grid.animate.shift(LEFT))

        # Alternatively, you can use the older syntax by passing the
        # method and then the arguments to the scene's "play" function:
        self.play(grid.shift, LEFT)

        # Both of those will interpolate between the mobject's initial
        # state and whatever happens when you apply that method.
        # For this example, calling grid.shift(LEFT) would shift the
        # grid one unit to the left, but both of the previous calls to
        # "self.play" animate that motion.

        # The same applies for any method, including those setting colors.
        self.play(grid.animate.set_color(YELLOW))
        self.wait()
        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))
        self.wait()
        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))
        self.wait()

        # The method Mobject.apply_complex_function lets you apply arbitrary
        # complex functions, treating the points defining the mobject as
        # complex numbers.
        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)
        self.wait()

        # Even more generally, you could apply Mobject.apply_function,
        # which takes in functions form R^3 to R^3
        self.play(
            grid.animate.apply_function(
                lambda p: [
                    p[0] + 0.5 * math.sin(p[1]),
                    p[1] + 0.5 * math.sin(p[0]),
                    p[2]
                ]
            ),
            run_time=5,
        )
        self.wait()
```
Example 4:
```python
.get_grid()
```
Example 5:
```python
self.play(mob.animate.method(args))
```
Example 6:
```python
.get_grid()
```
Example 7:
```python
self.play(mob.animate.method(args))
```
Example 8:
```python
class TextExample(Scene):
    def construct(self):
        # To run this scene properly, you should have "Consolas" font in your computer
        # for full usage, you can see https://github.com/3b1b/manim/pull/680
        text = Text("Here is a text", font="Consolas", font_size=90)
        difference = Text(
            """
            The most important difference between Text and TexText is that\n
            you can change the font more easily, but can't use the LaTeX grammar
            """,
            font="Arial", font_size=24,
            # t2c is a dict that you can choose color for different text
            t2c={"Text": BLUE, "TexText": BLUE, "LaTeX": ORANGE}
        )
        VGroup(text, difference).arrange(DOWN, buff=1)
        self.play(Write(text))
        self.play(FadeIn(difference, UP))
        self.wait(3)

        fonts = Text(
            "And you can also set the font according to different words",
            font="Arial",
            t2f={"font": "Consolas", "words": "Consolas"},
            t2c={"font": BLUE, "words": GREEN}
        )
        fonts.set_width(FRAME_WIDTH - 1)
        slant = Text(
            "And the same as slant and weight",
            font="Consolas",
            t2s={"slant": ITALIC},
            t2w={"weight": BOLD},
            t2c={"slant": ORANGE, "weight": RED}
        )
        VGroup(fonts, slant).arrange(DOWN, buff=0.8)
        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))
        self.play(Write(fonts))
        self.wait()
        self.play(Write(slant))
        self.wait()
```
Example 9:
```python
class TexTransformExample(Scene):
    def construct(self):
        to_isolate = ["B", "C", "=", "(", ")"]
        lines = VGroup(
            # Passing in muliple arguments to Tex will result
            # in the same expression as if those arguments had
            # been joined together, except that the submobject
            # hierarchy of the resulting mobject ensure that the
            # Tex mobject has a subject corresponding to
            # each of these strings.  For example, the Tex mobject
            # below will have 5 subjects, corresponding to the
            # expressions [A^2, +, B^2, =, C^2]
            OldTex("A^2", "+", "B^2", "=", "C^2"),
            # Likewise here
            OldTex("A^2", "=", "C^2", "-", "B^2"),
            # Alternatively, you can pass in the keyword argument
            # "isolate" with a list of strings that should be out as
            # their own submobject.  So the line below is equivalent
            # to the commented out line below it.
            OldTex("A^2 = (C + B)(C - B)", isolate=["A^2", *to_isolate]),
            # OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
            OldTex("A = \\sqrt{(C + B)(C - B)}", isolate=["A", *to_isolate])
        )
        lines.arrange(DOWN, buff=LARGE_BUFF)
        for line in lines:
            line.set_color_by_tex_to_color_map({
                "A": BLUE,
                "B": TEAL,
                "C": GREEN,
            })

        play_kw = {"run_time": 2}
        self.add(lines[0])
        # The animation TransformMatchingTex will line up parts
        # of the source and target which have matching tex strings.
        # Here, giving it a little path_arc makes each part sort of
        # rotate into their final positions, which feels appropriate
        # for the idea of rearranging an equation
        self.play(
            TransformMatchingTex(
                lines[0].copy(), lines[1],
                path_arc=90 * DEGREES,
            ),
            **play_kw
        )
        self.wait()

        # Now, we could try this again on the next line...
        self.play(
            TransformMatchingTex(lines[1].copy(), lines[2]),
            **play_kw
        )
        self.wait()
        # ...and this looks nice enough, but since there's no tex
        # in lines[2] which matches "C^2" or "B^2", those terms fade
        # out to nothing while the C and B terms fade in from nothing.
        # If, however, we want the C^2 to go to C, and B^2 to go to B,
        # we can specify that with a key map.
        self.play(FadeOut(lines[2]))
        self.play(
            TransformMatchingTex(
                lines[1].copy(), lines[2],
                key_map={
                    "C^2": "C",
                    "B^2": "B",
                }
            ),
            **play_kw
        )
        self.wait()

        # And to finish off, a simple TransformMatchingShapes would work
        # just fine.  But perhaps we want that exponent on A^2 to transform into
        # the square root symbol.  At the moment, lines[2] treats the expression
        # A^2 as a unit, so we might create a new version of the same line which
        # separates out just the A.  This way, when TransformMatchingTex lines up
        # all matching parts, the only mismatch will be between the "^2" from
        # new_line2 and the "\sqrt" from the final line.  By passing in,
        # transform_mismatches=True, it will transform this "^2" part into
        # the "\sqrt" part.
        new_line2 = OldTex("A^2 = (C + B)(C - B)", isolate=["A", *to_isolate])
        new_line2.replace(lines[2])
        new_line2.match_style(lines[2])

        self.play(
            TransformMatchingTex(
                new_line2, lines[3],
                transform_mismatches=True,
            ),
            **play_kw
        )
        self.wait(3)
        self.play(FadeOut(lines, RIGHT))

        # Alternatively, if you don't want to think about breaking up
        # the tex strings deliberately, you can TransformMatchingShapes,
        # which will try to line up all pieces of a source mobject with
        # those of a target, regardless of the submobject hierarchy in
        # each one, according to whether those pieces have the same
        # shape (as best it can).
        source = Text("the morse code", height=1)
        target = Text("here come dots", height=1)

        self.play(Write(source))
        self.wait()
        kw = {"run_time": 3, "path_arc": PI / 2}
        self.play(TransformMatchingShapes(source, target, **kw))
        self.wait()
        self.play(TransformMatchingShapes(target, source, **kw))
        self.wait()
```
Example 10:
```python
TransformMatchingTex
```
Example 11:
```python
TransformMatchingShapes
```
Example 12:
```python
TransformMatchingTeX
```
Example 13:
```python
TransformMatchingShapes
```
Example 14:
```python
class UpdatersExample(Scene):
    def construct(self):
        square = Square()
        square.set_fill(BLUE_E, 1)

        # On all all frames, the constructor Brace(square, UP) will
        # be called, and the mobject brace will set its data to match
        # that of the newly constructed object
        brace = always_redraw(Brace, square, UP)

        text, number = label = VGroup(
            Text("Width = "),
            DecimalNumber(
                0,
                show_ellipsis=True,
                num_decimal_places=2,
                include_sign=True,
            )
        )
        label.arrange(RIGHT)

        # This ensures that the method deicmal.next_to(square)
        # is called on every frame
        always(label.next_to, brace, UP)
        # You could also write the following equivalent line
        # label.add_updater(lambda m: m.next_to(brace, UP))

        # If the argument itself might change, you can use f_always,
        # for which the arguments following the initial Mobject method
        # should be functions returning arguments to that method.
        # The following line ensures that decimal.set_value(square.get_y())
        # is called every frame
        f_always(number.set_value, square.get_width)
        # You could also write the following equivalent line
        # number.add_updater(lambda m: m.set_value(square.get_width()))

        self.add(square, brace, label)

        # Notice that the brace and label track with the square
        self.play(
            square.animate.scale(2),
            rate_func=there_and_back,
            run_time=2,
        )
        self.wait()
        self.play(
            square.animate.set_width(5, stretch=True),
            run_time=3,
        )
        self.wait()
        self.play(
            square.animate.set_width(2),
            run_time=3
        )
        self.wait()

        # In general, you can alway call Mobject.add_updater, and pass in
        # a function that you want to be called on every frame.  The function
        # should take in either one argument, the mobject, or two arguments,
        # the mobject and the amount of time since the last frame.
        now = self.time
        w0 = square.get_width()
        square.add_updater(
            lambda m: m.set_width(w0 * math.cos(self.time - now))
        )
        self.wait(4 * PI)
```
Example 15:
```python
always_redraw()
```
Example 16:
```python
DecimalNumber
```
Example 17:
```python
.add_updater()
```
Example 18:
```python
always_redraw()
```
Example 19:
```python
DecimalNumber
```
Example 20:
```python
always(f, x)
```
Example 21:
```python
f_always(f, g)
```
Example 22:
```python
.add_updater()
```
Example 23:
```python
mob1.add_updater(lambda mob: mob.next_to(mob2))
```
Example 24:
```python
mob1.next_to(mob2)
```
Example 25:
```python
class CoordinateSystemExample(Scene):
    def construct(self):
        axes = Axes(
            # x-axis ranges from -1 to 10, with a default step size of 1
            x_range=(-1, 10),
            # y-axis ranges from -2 to 2 with a step size of 0.5
            y_range=(-2, 2, 0.5),
            # The axes will be stretched so as to match the specified
            # height and width
            height=6,
            width=10,
            # Axes is made of two NumberLine mobjects.  You can specify
            # their configuration with axis_config
            axis_config={
                "stroke_color": GREY_A,
                "stroke_width": 2,
            },
            # Alternatively, you can specify configuration for just one
            # of them, like this.
            y_axis_config={
                "include_tip": False,
            }
        )
        # Keyword arguments of add_coordinate_labels can be used to
        # configure the DecimalNumber mobjects which it creates and
        # adds to the axes
        axes.add_coordinate_labels(
            font_size=20,
            num_decimal_places=1,
        )
        self.add(axes)

        # Axes descends from the CoordinateSystem class, meaning
        # you can call call axes.coords_to_point, abbreviated to
        # axes.c2p, to associate a set of coordinates with a point,
        # like so:
        dot = Dot(color=RED)
        dot.move_to(axes.c2p(0, 0))
        self.play(FadeIn(dot, scale=0.5))
        self.play(dot.animate.move_to(axes.c2p(3, 2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))
        self.wait()

        # Similarly, you can call axes.point_to_coords, or axes.p2c
        # print(axes.p2c(dot.get_center()))

        # We can draw lines from the axes to better mark the coordinates
        # of a given point.
        # Here, the always_redraw command means that on each new frame
        # the lines will be redrawn
        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))
        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))

        self.play(
            ShowCreation(h_line),
            ShowCreation(v_line),
        )
        self.play(dot.animate.move_to(axes.c2p(3, -2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(1, 1)))
        self.wait()

        # If we tie the dot to a particular set of coordinates, notice
        # that as we move the axes around it respects the coordinate
        # system defined by them.
        f_always(dot.move_to, lambda: axes.c2p(1, 1))
        self.play(
            axes.animate.scale(0.75).to_corner(UL),
            run_time=2,
        )
        self.wait()
        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))

        # Other coordinate systems you can play around with include
        # ThreeDAxes, NumberPlane, and ComplexPlane.
```
Example 26:
```python
class GraphExample(Scene):
    def construct(self):
        axes = Axes((-3, 10), (-1, 8))
        axes.add_coordinate_labels()

        self.play(Write(axes, lag_ratio=0.01, run_time=1))

        # Axes.get_graph will return the graph of a function
        sin_graph = axes.get_graph(
            lambda x: 2 * math.sin(x),
            color=BLUE,
        )
        # By default, it draws it so as to somewhat smoothly interpolate
        # between sampled points (x, f(x)).  If the graph is meant to have
        # a corner, though, you can set use_smoothing to False
        relu_graph = axes.get_graph(
            lambda x: max(x, 0),
            use_smoothing=False,
            color=YELLOW,
        )
        # For discontinuous functions, you can specify the point of
        # discontinuity so that it does not try to draw over the gap.
        step_graph = axes.get_graph(
            lambda x: 2.0 if x > 3 else 1.0,
            discontinuities=[3],
            color=GREEN,
        )

        # Axes.get_graph_label takes in either a string or a mobject.
        # If it's a string, it treats it as a LaTeX expression.  By default
        # it places the label next to the graph near the right side, and
        # has it match the color of the graph
        sin_label = axes.get_graph_label(sin_graph, "\\sin(x)")
        relu_label = axes.get_graph_label(relu_graph, Text("ReLU"))
        step_label = axes.get_graph_label(step_graph, Text("Step"), x=4)

        self.play(
            ShowCreation(sin_graph),
            FadeIn(sin_label, RIGHT),
        )
        self.wait(2)
        self.play(
            ReplacementTransform(sin_graph, relu_graph),
            FadeTransform(sin_label, relu_label),
        )
        self.wait()
        self.play(
            ReplacementTransform(relu_graph, step_graph),
            FadeTransform(relu_label, step_label),
        )
        self.wait()

        parabola = axes.get_graph(lambda x: 0.25 * x**2)
        parabola.set_stroke(BLUE)
        self.play(
            FadeOut(step_graph),
            FadeOut(step_label),
            ShowCreation(parabola)
        )
        self.wait()

        # You can use axes.input_to_graph_point, abbreviated
        # to axes.i2gp, to find a particular point on a graph
        dot = Dot(color=RED)
        dot.move_to(axes.i2gp(2, parabola))
        self.play(FadeIn(dot, scale=0.5))

        # A value tracker lets us animate a parameter, usually
        # with the intent of having other mobjects update based
        # on the parameter
        x_tracker = ValueTracker(2)
        f_always(
            dot.move_to,
            lambda: axes.i2gp(x_tracker.get_value(), parabola)
        )

        self.play(x_tracker.animate.set_value(4), run_time=3)
        self.play(x_tracker.animate.set_value(-2), run_time=3)
        self.wait()
```
Example 27:
```python
class SurfaceExample(Scene):
    CONFIG = {
        "camera_class": ThreeDCamera,
    }

    def construct(self):
        surface_text = Text("For 3d scenes, try using surfaces")
        surface_text.fix_in_frame()
        surface_text.to_edge(UP)
        self.add(surface_text)
        self.wait(0.1)

        torus1 = Torus(r1=1, r2=1)
        torus2 = Torus(r1=3, r2=1)
        sphere = Sphere(radius=3, resolution=torus1.resolution)
        # You can texture a surface with up to two images, which will
        # be interpreted as the side towards the light, and away from
        # the light.  These can be either urls, or paths to a local file
        # in whatever you've set as the image directory in
        # the custom_config.yml file

        # day_texture = "EarthTextureMap"
        # night_texture = "NightEarthTextureMap"
        day_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
        night_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"

        surfaces = [
            TexturedSurface(surface, day_texture, night_texture)
            for surface in [sphere, torus1, torus2]
        ]

        for mob in surfaces:
            mob.shift(IN)
            mob.mesh = SurfaceMesh(mob)
            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)

        # Set perspective
        frame = self.camera.frame
        frame.set_euler_angles(
            theta=-30 * DEGREES,
            phi=70 * DEGREES,
        )

        surface = surfaces[0]

        self.play(
            FadeIn(surface),
            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),
        )
        for mob in surfaces:
            mob.add(mob.mesh)
        surface.save_state()
        self.play(Rotate(surface, PI / 2), run_time=2)
        for mob in surfaces[1:]:
            mob.rotate(PI / 2)

        self.play(
            Transform(surface, surfaces[1]),
            run_time=3
        )

        self.play(
            Transform(surface, surfaces[2]),
            # Move camera frame during the transition
            frame.animate.increment_phi(-10 * DEGREES),
            frame.animate.increment_theta(-20 * DEGREES),
            run_time=3
        )
        # Add ambient rotation
        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))

        # Play around with where the light is
        light_text = Text("You can move around the light source")
        light_text.move_to(surface_text)
        light_text.fix_in_frame()

        self.play(FadeTransform(surface_text, light_text))
        light = self.camera.light_source
        self.add(light)
        light.save_state()
        self.play(light.animate.move_to(3 * IN), run_time=5)
        self.play(light.animate.shift(10 * OUT), run_time=5)

        drag_text = Text("Try moving the mouse while pressing d or s")
        drag_text.move_to(light_text)
        drag_text.fix_in_frame()

        self.play(FadeTransform(light_text, drag_text))
        self.wait()
```
Example 28:
```python
.fix_in_frame()
```
Example 29:
```python
class OpeningManimExample(Scene):
    def construct(self):
        intro_words = Text("""
            The original motivation for manim was to
            better illustrate mathematical functions
            as transformations.
        """)
        intro_words.to_edge(UP)

        self.play(Write(intro_words))
        self.wait(2)

        # Linear transform
        grid = NumberPlane((-10, 10), (-5, 5))
        matrix = [[1, 1], [0, 1]]
        linear_transform_words = VGroup(
            Text("This is what the matrix"),
            IntegerMatrix(matrix, include_background_rectangle=True),
            Text("looks like")
        )
        linear_transform_words.arrange(RIGHT)
        linear_transform_words.to_edge(UP)
        linear_transform_words.set_stroke(BLACK, 10, background=True)

        self.play(
            ShowCreation(grid),
            FadeTransform(intro_words, linear_transform_words)
        )
        self.wait()
        self.play(grid.animate.apply_matrix(matrix), run_time=3)
        self.wait()

        # Complex map
        c_grid = ComplexPlane()
        moving_c_grid = c_grid.copy()
        moving_c_grid.prepare_for_nonlinear_transform()
        c_grid.set_stroke(BLUE_E, 1)
        c_grid.add_coordinate_labels(font_size=24)
        complex_map_words = TexText("""
            Or thinking of the plane as $\\mathds{C}$,\\\\
            this is the map $z \\rightarrow z^2$
        """)
        complex_map_words.to_corner(UR)
        complex_map_words.set_stroke(BLACK, 5, background=True)

        self.play(
            FadeOut(grid),
            Write(c_grid, run_time=3),
            FadeIn(moving_c_grid),
            FadeTransform(linear_transform_words, complex_map_words),
        )
        self.wait()
        self.play(
            moving_c_grid.animate.apply_complex_function(lambda z: z**2),
            run_time=6,
        )
        self.wait(2)
```

================================================================================

=== Example Scenes - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/example_scenes.html#coordinatesystemexample
Content:
Example Scenes
¶
After understanding the previous knowledge, we can understand more scenes.
Many example scenes are given in
example_scenes.py
, let’s start with
the simplest and one by one.
InteractiveDevlopment
¶
InteractiveDevelopment
¶
from
manimlib
import
*
class
InteractiveDevelopment
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
square
=
Square
()
self
.
play
(
ShowCreation
(
square
))
self
.
wait
()
# This opens an iPython terminal where you can keep writing
# lines as if they were part of this construct method.
# In particular, 'square', 'circle' and 'self' will all be
# part of the local namespace in that terminal.
self
.
embed
()
# Try copying and pasting some of the lines below into
# the interactive shell
self
.
play
(
ReplacementTransform
(
square
,
circle
))
self
.
wait
()
self
.
play
(
circle
.
animate
.
stretch
(
4
,
0
))
self
.
play
(
Rotate
(
circle
,
90
*
DEGREES
))
self
.
play
(
circle
.
animate
.
shift
(
2
*
RIGHT
)
.
scale
(
0.25
))
text
=
Text
(
"""
In general, using the interactive shell
is very helpful when developing new scenes
"""
)
self
.
play
(
Write
(
text
))
# In the interactive shell, you can just type
# play, add, remove, clear, wait, save_state and restore,
# instead of self.play, self.add, self.remove, etc.
# To interact with the window, type touch().  You can then
# scroll in the window, or zoom by holding down 'z' while scrolling,
# and change camera perspective by holding down 'd' while moving
# the mouse.  Press 'r' to reset to the standard camera position.
# Press 'q' to stop interacting with the window and go back to
# typing new commands into the shell.
# In principle you can customize a scene to be responsive to
# mouse and keyboard interactions
always
(
circle
.
move_to
,
self
.
mouse_point
)
This scene is similar to what we wrote in
Quick Start
.
And how to interact has been written in the comments.
No more explanation here.
AnimatingMethods
¶
AnimatingMethods
¶
class
AnimatingMethods
(
Scene
):
def
construct
(
self
):
grid
=
OldTex
(
r
"\pi"
)
.
get_grid
(
10
,
10
,
height
=
4
)
self
.
add
(
grid
)
# You can animate the application of mobject methods with the
# ".animate" syntax:
self
.
play
(
grid
.
animate
.
shift
(
LEFT
))
# Alternatively, you can use the older syntax by passing the
# method and then the arguments to the scene's "play" function:
self
.
play
(
grid
.
shift
,
LEFT
)
# Both of those will interpolate between the mobject's initial
# state and whatever happens when you apply that method.
# For this example, calling grid.shift(LEFT) would shift the
# grid one unit to the left, but both of the previous calls to
# "self.play" animate that motion.
# The same applies for any method, including those setting colors.
self
.
play
(
grid
.
animate
.
set_color
(
YELLOW
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_submobject_colors_by_gradient
(
BLUE
,
GREEN
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_height
(
TAU
-
MED_SMALL_BUFF
))
self
.
wait
()
# The method Mobject.apply_complex_function lets you apply arbitrary
# complex functions, treating the points defining the mobject as
# complex numbers.
self
.
play
(
grid
.
animate
.
apply_complex_function
(
np
.
exp
),
run_time
=
5
)
self
.
wait
()
# Even more generally, you could apply Mobject.apply_function,
# which takes in functions form R^3 to R^3
self
.
play
(
grid
.
animate
.
apply_function
(
lambda
p
:
[
p
[
0
]
+
0.5
*
math
.
sin
(
p
[
1
]),
p
[
1
]
+
0.5
*
math
.
sin
(
p
[
0
]),
p
[
2
]
]
),
run_time
=
5
,
)
self
.
wait
()
The new usage in this scene is
.get_grid()
and
self.play(mob.animate.method(args))
.
.get_grid()
method will return a new mobject containing multiple copies of this one arranged in a grid.
self.play(mob.animate.method(args))
animates the method, and the details are in the comments above.
TextExample
¶
TextExample
¶
class
TextExample
(
Scene
):
def
construct
(
self
):
# To run this scene properly, you should have "Consolas" font in your computer
# for full usage, you can see https://github.com/3b1b/manim/pull/680
text
=
Text
(
"Here is a text"
,
font
=
"Consolas"
,
font_size
=
90
)
difference
=
Text
(
"""
The most important difference between Text and TexText is that\n
you can change the font more easily, but can't use the LaTeX grammar
"""
,
font
=
"Arial"
,
font_size
=
24
,
# t2c is a dict that you can choose color for different text
t2c
=
{
"Text"
:
BLUE
,
"TexText"
:
BLUE
,
"LaTeX"
:
ORANGE
}
)
VGroup
(
text
,
difference
)
.
arrange
(
DOWN
,
buff
=
1
)
self
.
play
(
Write
(
text
))
self
.
play
(
FadeIn
(
difference
,
UP
))
self
.
wait
(
3
)
fonts
=
Text
(
"And you can also set the font according to different words"
,
font
=
"Arial"
,
t2f
=
{
"font"
:
"Consolas"
,
"words"
:
"Consolas"
},
t2c
=
{
"font"
:
BLUE
,
"words"
:
GREEN
}
)
fonts
.
set_width
(
FRAME_WIDTH
-
1
)
slant
=
Text
(
"And the same as slant and weight"
,
font
=
"Consolas"
,
t2s
=
{
"slant"
:
ITALIC
},
t2w
=
{
"weight"
:
BOLD
},
t2c
=
{
"slant"
:
ORANGE
,
"weight"
:
RED
}
)
VGroup
(
fonts
,
slant
)
.
arrange
(
DOWN
,
buff
=
0.8
)
self
.
play
(
FadeOut
(
text
),
FadeOut
(
difference
,
shift
=
DOWN
))
self
.
play
(
Write
(
fonts
))
self
.
wait
()
self
.
play
(
Write
(
slant
))
self
.
wait
()
The new classes in this scene are
Text
,
VGroup
,
Write
,
FadeIn
and
FadeOut
.
Text
can create text, define fonts, etc. The usage ais clearly reflected in the above examples.
VGroup
can put multiple
VMobject
together as a whole. In the example, the
.arrange()
method is called to arrange the sub-mobjects in sequence downward (
DOWN
), and the spacing is
buff
.
Write
is an animation that shows similar writing effects.
FadeIn
fades the object in, the second parameter indicates the direction of the fade in.
FadeOut
fades out the object, the second parameter indicates the direction of the fade out.
TexTransformExample
¶
TexTransformExample
¶
class
TexTransformExample
(
Scene
):
def
construct
(
self
):
to_isolate
=
[
"B"
,
"C"
,
"="
,
"("
,
")"
]
lines
=
VGroup
(
# Passing in muliple arguments to Tex will result
# in the same expression as if those arguments had
# been joined together, except that the submobject
# hierarchy of the resulting mobject ensure that the
# Tex mobject has a subject corresponding to
# each of these strings.  For example, the Tex mobject
# below will have 5 subjects, corresponding to the
# expressions [A^2, +, B^2, =, C^2]
OldTex
(
"A^2"
,
"+"
,
"B^2"
,
"="
,
"C^2"
),
# Likewise here
OldTex
(
"A^2"
,
"="
,
"C^2"
,
"-"
,
"B^2"
),
# Alternatively, you can pass in the keyword argument
# "isolate" with a list of strings that should be out as
# their own submobject.  So the line below is equivalent
# to the commented out line below it.
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A^2"
,
*
to_isolate
]),
# OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
OldTex
(
"A =
\\
sqrt{(C + B)(C - B)}"
,
isolate
=
[
"A"
,
*
to_isolate
])
)
lines
.
arrange
(
DOWN
,
buff
=
LARGE_BUFF
)
for
line
in
lines
:
line
.
set_color_by_tex_to_color_map
({
"A"
:
BLUE
,
"B"
:
TEAL
,
"C"
:
GREEN
,
})
play_kw
=
{
"run_time"
:
2
}
self
.
add
(
lines
[
0
])
# The animation TransformMatchingTex will line up parts
# of the source and target which have matching tex strings.
# Here, giving it a little path_arc makes each part sort of
# rotate into their final positions, which feels appropriate
# for the idea of rearranging an equation
self
.
play
(
TransformMatchingTex
(
lines
[
0
]
.
copy
(),
lines
[
1
],
path_arc
=
90
*
DEGREES
,
),
**
play_kw
)
self
.
wait
()
# Now, we could try this again on the next line...
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
]),
**
play_kw
)
self
.
wait
()
# ...and this looks nice enough, but since there's no tex
# in lines[2] which matches "C^2" or "B^2", those terms fade
# out to nothing while the C and B terms fade in from nothing.
# If, however, we want the C^2 to go to C, and B^2 to go to B,
# we can specify that with a key map.
self
.
play
(
FadeOut
(
lines
[
2
]))
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
],
key_map
=
{
"C^2"
:
"C"
,
"B^2"
:
"B"
,
}
),
**
play_kw
)
self
.
wait
()
# And to finish off, a simple TransformMatchingShapes would work
# just fine.  But perhaps we want that exponent on A^2 to transform into
# the square root symbol.  At the moment, lines[2] treats the expression
# A^2 as a unit, so we might create a new version of the same line which
# separates out just the A.  This way, when TransformMatchingTex lines up
# all matching parts, the only mismatch will be between the "^2" from
# new_line2 and the "\sqrt" from the final line.  By passing in,
# transform_mismatches=True, it will transform this "^2" part into
# the "\sqrt" part.
new_line2
=
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A"
,
*
to_isolate
])
new_line2
.
replace
(
lines
[
2
])
new_line2
.
match_style
(
lines
[
2
])
self
.
play
(
TransformMatchingTex
(
new_line2
,
lines
[
3
],
transform_mismatches
=
True
,
),
**
play_kw
)
self
.
wait
(
3
)
self
.
play
(
FadeOut
(
lines
,
RIGHT
))
# Alternatively, if you don't want to think about breaking up
# the tex strings deliberately, you can TransformMatchingShapes,
# which will try to line up all pieces of a source mobject with
# those of a target, regardless of the submobject hierarchy in
# each one, according to whether those pieces have the same
# shape (as best it can).
source
=
Text
(
"the morse code"
,
height
=
1
)
target
=
Text
(
"here come dots"
,
height
=
1
)
self
.
play
(
Write
(
source
))
self
.
wait
()
kw
=
{
"run_time"
:
3
,
"path_arc"
:
PI
/
2
}
self
.
play
(
TransformMatchingShapes
(
source
,
target
,
**
kw
))
self
.
wait
()
self
.
play
(
TransformMatchingShapes
(
target
,
source
,
**
kw
))
self
.
wait
()
The new classes in this scene are
Tex
,
TexText
,
TransformMatchingTex
and
TransformMatchingShapes
.
Tex
uses LaTeX to create mathematical formulas.
TexText
uses LaTeX to create text.
TransformMatchingTeX
automatically transforms sub-objects according to the similarities and differences of tex in
Tex
.
TransformMatchingShapes
automatically transform sub-objects directly based on the similarities and differences of the object point sets.
UpdatersExample
¶
UpdatersExample
¶
class
UpdatersExample
(
Scene
):
def
construct
(
self
):
square
=
Square
()
square
.
set_fill
(
BLUE_E
,
1
)
# On all all frames, the constructor Brace(square, UP) will
# be called, and the mobject brace will set its data to match
# that of the newly constructed object
brace
=
always_redraw
(
Brace
,
square
,
UP
)
text
,
number
=
label
=
VGroup
(
Text
(
"Width = "
),
DecimalNumber
(
0
,
show_ellipsis
=
True
,
num_decimal_places
=
2
,
include_sign
=
True
,
)
)
label
.
arrange
(
RIGHT
)
# This ensures that the method deicmal.next_to(square)
# is called on every frame
always
(
label
.
next_to
,
brace
,
UP
)
# You could also write the following equivalent line
# label.add_updater(lambda m: m.next_to(brace, UP))
# If the argument itself might change, you can use f_always,
# for which the arguments following the initial Mobject method
# should be functions returning arguments to that method.
# The following line ensures that decimal.set_value(square.get_y())
# is called every frame
f_always
(
number
.
set_value
,
square
.
get_width
)
# You could also write the following equivalent line
# number.add_updater(lambda m: m.set_value(square.get_width()))
self
.
add
(
square
,
brace
,
label
)
# Notice that the brace and label track with the square
self
.
play
(
square
.
animate
.
scale
(
2
),
rate_func
=
there_and_back
,
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
5
,
stretch
=
True
),
run_time
=
3
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
2
),
run_time
=
3
)
self
.
wait
()
# In general, you can alway call Mobject.add_updater, and pass in
# a function that you want to be called on every frame.  The function
# should take in either one argument, the mobject, or two arguments,
# the mobject and the amount of time since the last frame.
now
=
self
.
time
w0
=
square
.
get_width
()
square
.
add_updater
(
lambda
m
:
m
.
set_width
(
w0
*
math
.
cos
(
self
.
time
-
now
))
)
self
.
wait
(
4
*
PI
)
The new classes and usage in this scene are
always_redraw()
,
DecimalNumber
,
.to_edge()
,
.center()
,
always()
,
f_always()
,
.set_y()
and
.add_updater()
.
always_redraw()
function create a new mobject every frame.
DecimalNumber
is a variable number, speed it up by breaking it into
Text
characters.
.to_edge()
means to place the object on the edge of the screen.
.center()
means to place the object in the center of the screen.
always(f,
x)
means that a certain function (
f(x)
) is executed every frame.
f_always(f,
g)
is similar to
always
, executed
f(g())
every frame.
.set_y()
means to set the ordinate of the object on the screen.
.add_updater()
sets an update function for the object. For example:
mob1.add_updater(lambda
mob:
mob.next_to(mob2))
means
mob1.next_to(mob2)
is executed every frame.
CoordinateSystemExample
¶
CoordinateSystemExample
¶
class
CoordinateSystemExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
(
# x-axis ranges from -1 to 10, with a default step size of 1
x_range
=
(
-
1
,
10
),
# y-axis ranges from -2 to 2 with a step size of 0.5
y_range
=
(
-
2
,
2
,
0.5
),
# The axes will be stretched so as to match the specified
# height and width
height
=
6
,
width
=
10
,
# Axes is made of two NumberLine mobjects.  You can specify
# their configuration with axis_config
axis_config
=
{
"stroke_color"
:
GREY_A
,
"stroke_width"
:
2
,
},
# Alternatively, you can specify configuration for just one
# of them, like this.
y_axis_config
=
{
"include_tip"
:
False
,
}
)
# Keyword arguments of add_coordinate_labels can be used to
# configure the DecimalNumber mobjects which it creates and
# adds to the axes
axes
.
add_coordinate_labels
(
font_size
=
20
,
num_decimal_places
=
1
,
)
self
.
add
(
axes
)
# Axes descends from the CoordinateSystem class, meaning
# you can call call axes.coords_to_point, abbreviated to
# axes.c2p, to associate a set of coordinates with a point,
# like so:
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
c2p
(
0
,
0
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
5
,
0.5
)))
self
.
wait
()
# Similarly, you can call axes.point_to_coords, or axes.p2c
# print(axes.p2c(dot.get_center()))
# We can draw lines from the axes to better mark the coordinates
# of a given point.
# Here, the always_redraw command means that on each new frame
# the lines will be redrawn
h_line
=
always_redraw
(
lambda
:
axes
.
get_h_line
(
dot
.
get_left
()))
v_line
=
always_redraw
(
lambda
:
axes
.
get_v_line
(
dot
.
get_bottom
()))
self
.
play
(
ShowCreation
(
h_line
),
ShowCreation
(
v_line
),
)
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
-
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
1
,
1
)))
self
.
wait
()
# If we tie the dot to a particular set of coordinates, notice
# that as we move the axes around it respects the coordinate
# system defined by them.
f_always
(
dot
.
move_to
,
lambda
:
axes
.
c2p
(
1
,
1
))
self
.
play
(
axes
.
animate
.
scale
(
0.75
)
.
to_corner
(
UL
),
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
FadeOut
(
VGroup
(
axes
,
dot
,
h_line
,
v_line
)))
# Other coordinate systems you can play around with include
# ThreeDAxes, NumberPlane, and ComplexPlane.
GraphExample
¶
GraphExample
¶
class
GraphExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
((
-
3
,
10
),
(
-
1
,
8
))
axes
.
add_coordinate_labels
()
self
.
play
(
Write
(
axes
,
lag_ratio
=
0.01
,
run_time
=
1
))
# Axes.get_graph will return the graph of a function
sin_graph
=
axes
.
get_graph
(
lambda
x
:
2
*
math
.
sin
(
x
),
color
=
BLUE
,
)
# By default, it draws it so as to somewhat smoothly interpolate
# between sampled points (x, f(x)).  If the graph is meant to have
# a corner, though, you can set use_smoothing to False
relu_graph
=
axes
.
get_graph
(
lambda
x
:
max
(
x
,
0
),
use_smoothing
=
False
,
color
=
YELLOW
,
)
# For discontinuous functions, you can specify the point of
# discontinuity so that it does not try to draw over the gap.
step_graph
=
axes
.
get_graph
(
lambda
x
:
2.0
if
x
>
3
else
1.0
,
discontinuities
=
[
3
],
color
=
GREEN
,
)
# Axes.get_graph_label takes in either a string or a mobject.
# If it's a string, it treats it as a LaTeX expression.  By default
# it places the label next to the graph near the right side, and
# has it match the color of the graph
sin_label
=
axes
.
get_graph_label
(
sin_graph
,
"
\\
sin(x)"
)
relu_label
=
axes
.
get_graph_label
(
relu_graph
,
Text
(
"ReLU"
))
step_label
=
axes
.
get_graph_label
(
step_graph
,
Text
(
"Step"
),
x
=
4
)
self
.
play
(
ShowCreation
(
sin_graph
),
FadeIn
(
sin_label
,
RIGHT
),
)
self
.
wait
(
2
)
self
.
play
(
ReplacementTransform
(
sin_graph
,
relu_graph
),
FadeTransform
(
sin_label
,
relu_label
),
)
self
.
wait
()
self
.
play
(
ReplacementTransform
(
relu_graph
,
step_graph
),
FadeTransform
(
relu_label
,
step_label
),
)
self
.
wait
()
parabola
=
axes
.
get_graph
(
lambda
x
:
0.25
*
x
**
2
)
parabola
.
set_stroke
(
BLUE
)
self
.
play
(
FadeOut
(
step_graph
),
FadeOut
(
step_label
),
ShowCreation
(
parabola
)
)
self
.
wait
()
# You can use axes.input_to_graph_point, abbreviated
# to axes.i2gp, to find a particular point on a graph
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
i2gp
(
2
,
parabola
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
# A value tracker lets us animate a parameter, usually
# with the intent of having other mobjects update based
# on the parameter
x_tracker
=
ValueTracker
(
2
)
f_always
(
dot
.
move_to
,
lambda
:
axes
.
i2gp
(
x_tracker
.
get_value
(),
parabola
)
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
4
),
run_time
=
3
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
-
2
),
run_time
=
3
)
self
.
wait
()
SurfaceExample
¶
SurfaceExample
¶
class
SurfaceExample
(
Scene
):
CONFIG
=
{
"camera_class"
:
ThreeDCamera
,
}
def
construct
(
self
):
surface_text
=
Text
(
"For 3d scenes, try using surfaces"
)
surface_text
.
fix_in_frame
()
surface_text
.
to_edge
(
UP
)
self
.
add
(
surface_text
)
self
.
wait
(
0.1
)
torus1
=
Torus
(
r1
=
1
,
r2
=
1
)
torus2
=
Torus
(
r1
=
3
,
r2
=
1
)
sphere
=
Sphere
(
radius
=
3
,
resolution
=
torus1
.
resolution
)
# You can texture a surface with up to two images, which will
# be interpreted as the side towards the light, and away from
# the light.  These can be either urls, or paths to a local file
# in whatever you've set as the image directory in
# the custom_config.yml file
# day_texture = "EarthTextureMap"
# night_texture = "NightEarthTextureMap"
day_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
night_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"
surfaces
=
[
TexturedSurface
(
surface
,
day_texture
,
night_texture
)
for
surface
in
[
sphere
,
torus1
,
torus2
]
]
for
mob
in
surfaces
:
mob
.
shift
(
IN
)
mob
.
mesh
=
SurfaceMesh
(
mob
)
mob
.
mesh
.
set_stroke
(
BLUE
,
1
,
opacity
=
0.5
)
# Set perspective
frame
=
self
.
camera
.
frame
frame
.
set_euler_angles
(
theta
=-
30
*
DEGREES
,
phi
=
70
*
DEGREES
,
)
surface
=
surfaces
[
0
]
self
.
play
(
FadeIn
(
surface
),
ShowCreation
(
surface
.
mesh
,
lag_ratio
=
0.01
,
run_time
=
3
),
)
for
mob
in
surfaces
:
mob
.
add
(
mob
.
mesh
)
surface
.
save_state
()
self
.
play
(
Rotate
(
surface
,
PI
/
2
),
run_time
=
2
)
for
mob
in
surfaces
[
1
:]:
mob
.
rotate
(
PI
/
2
)
self
.
play
(
Transform
(
surface
,
surfaces
[
1
]),
run_time
=
3
)
self
.
play
(
Transform
(
surface
,
surfaces
[
2
]),
# Move camera frame during the transition
frame
.
animate
.
increment_phi
(
-
10
*
DEGREES
),
frame
.
animate
.
increment_theta
(
-
20
*
DEGREES
),
run_time
=
3
)
# Add ambient rotation
frame
.
add_updater
(
lambda
m
,
dt
:
m
.
increment_theta
(
-
0.1
*
dt
))
# Play around with where the light is
light_text
=
Text
(
"You can move around the light source"
)
light_text
.
move_to
(
surface_text
)
light_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
surface_text
,
light_text
))
light
=
self
.
camera
.
light_source
self
.
add
(
light
)
light
.
save_state
()
self
.
play
(
light
.
animate
.
move_to
(
3
*
IN
),
run_time
=
5
)
self
.
play
(
light
.
animate
.
shift
(
10
*
OUT
),
run_time
=
5
)
drag_text
=
Text
(
"Try moving the mouse while pressing d or s"
)
drag_text
.
move_to
(
light_text
)
drag_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
light_text
,
drag_text
))
self
.
wait
()
This scene shows an example of using a three-dimensional surface, and
the related usage has been briefly described in the notes.
.fix_in_frame()
makes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.
OpeningManimExample
¶
OpeningManimExample
¶
class
OpeningManimExample
(
Scene
):
def
construct
(
self
):
intro_words
=
Text
(
"""
The original motivation for manim was to
better illustrate mathematical functions
as transformations.
"""
)
intro_words
.
to_edge
(
UP
)
self
.
play
(
Write
(
intro_words
))
self
.
wait
(
2
)
# Linear transform
grid
=
NumberPlane
((
-
10
,
10
),
(
-
5
,
5
))
matrix
=
[[
1
,
1
],
[
0
,
1
]]
linear_transform_words
=
VGroup
(
Text
(
"This is what the matrix"
),
IntegerMatrix
(
matrix
,
include_background_rectangle
=
True
),
Text
(
"looks like"
)
)
linear_transform_words
.
arrange
(
RIGHT
)
linear_transform_words
.
to_edge
(
UP
)
linear_transform_words
.
set_stroke
(
BLACK
,
10
,
background
=
True
)
self
.
play
(
ShowCreation
(
grid
),
FadeTransform
(
intro_words
,
linear_transform_words
)
)
self
.
wait
()
self
.
play
(
grid
.
animate
.
apply_matrix
(
matrix
),
run_time
=
3
)
self
.
wait
()
# Complex map
c_grid
=
ComplexPlane
()
moving_c_grid
=
c_grid
.
copy
()
moving_c_grid
.
prepare_for_nonlinear_transform
()
c_grid
.
set_stroke
(
BLUE_E
,
1
)
c_grid
.
add_coordinate_labels
(
font_size
=
24
)
complex_map_words
=
TexText
(
"""
Or thinking of the plane as $
\\
mathds
{C}
$,
\\\\
this is the map $z
\\
rightarrow z^2$
"""
)
complex_map_words
.
to_corner
(
UR
)
complex_map_words
.
set_stroke
(
BLACK
,
5
,
background
=
True
)
self
.
play
(
FadeOut
(
grid
),
Write
(
c_grid
,
run_time
=
3
),
FadeIn
(
moving_c_grid
),
FadeTransform
(
linear_transform_words
,
complex_map_words
),
)
self
.
wait
()
self
.
play
(
moving_c_grid
.
animate
.
apply_complex_function
(
lambda
z
:
z
**
2
),
run_time
=
6
,
)
self
.
wait
(
2
)
This scene is a comprehensive application of a two-dimensional scene.
After seeing these scenes, you have already understood part of the
usage of manim. For more examples, see
the video code of 3b1b
.
Contents
Example Scenes
InteractiveDevlopment
AnimatingMethods
TextExample
TexTransformExample
UpdatersExample
CoordinateSystemExample
GraphExample
SurfaceExample
OpeningManimExample

Code Examples:
Example 1:
```python
example_scenes.py
```
Example 2:
```python
from manimlib import *

class InteractiveDevelopment(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)
        square = Square()

        self.play(ShowCreation(square))
        self.wait()

        # This opens an iPython terminal where you can keep writing
        # lines as if they were part of this construct method.
        # In particular, 'square', 'circle' and 'self' will all be
        # part of the local namespace in that terminal.
        self.embed()

        # Try copying and pasting some of the lines below into
        # the interactive shell
        self.play(ReplacementTransform(square, circle))
        self.wait()
        self.play(circle.animate.stretch(4, 0))
        self.play(Rotate(circle, 90 * DEGREES))
        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))

        text = Text("""
            In general, using the interactive shell
            is very helpful when developing new scenes
        """)
        self.play(Write(text))

        # In the interactive shell, you can just type
        # play, add, remove, clear, wait, save_state and restore,
        # instead of self.play, self.add, self.remove, etc.

        # To interact with the window, type touch().  You can then
        # scroll in the window, or zoom by holding down 'z' while scrolling,
        # and change camera perspective by holding down 'd' while moving
        # the mouse.  Press 'r' to reset to the standard camera position.
        # Press 'q' to stop interacting with the window and go back to
        # typing new commands into the shell.

        # In principle you can customize a scene to be responsive to
        # mouse and keyboard interactions
        always(circle.move_to, self.mouse_point)
```
Example 3:
```python
class AnimatingMethods(Scene):
    def construct(self):
        grid = OldTex(r"\pi").get_grid(10, 10, height=4)
        self.add(grid)

        # You can animate the application of mobject methods with the
        # ".animate" syntax:
        self.play(grid.animate.shift(LEFT))

        # Alternatively, you can use the older syntax by passing the
        # method and then the arguments to the scene's "play" function:
        self.play(grid.shift, LEFT)

        # Both of those will interpolate between the mobject's initial
        # state and whatever happens when you apply that method.
        # For this example, calling grid.shift(LEFT) would shift the
        # grid one unit to the left, but both of the previous calls to
        # "self.play" animate that motion.

        # The same applies for any method, including those setting colors.
        self.play(grid.animate.set_color(YELLOW))
        self.wait()
        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))
        self.wait()
        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))
        self.wait()

        # The method Mobject.apply_complex_function lets you apply arbitrary
        # complex functions, treating the points defining the mobject as
        # complex numbers.
        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)
        self.wait()

        # Even more generally, you could apply Mobject.apply_function,
        # which takes in functions form R^3 to R^3
        self.play(
            grid.animate.apply_function(
                lambda p: [
                    p[0] + 0.5 * math.sin(p[1]),
                    p[1] + 0.5 * math.sin(p[0]),
                    p[2]
                ]
            ),
            run_time=5,
        )
        self.wait()
```
Example 4:
```python
.get_grid()
```
Example 5:
```python
self.play(mob.animate.method(args))
```
Example 6:
```python
.get_grid()
```
Example 7:
```python
self.play(mob.animate.method(args))
```
Example 8:
```python
class TextExample(Scene):
    def construct(self):
        # To run this scene properly, you should have "Consolas" font in your computer
        # for full usage, you can see https://github.com/3b1b/manim/pull/680
        text = Text("Here is a text", font="Consolas", font_size=90)
        difference = Text(
            """
            The most important difference between Text and TexText is that\n
            you can change the font more easily, but can't use the LaTeX grammar
            """,
            font="Arial", font_size=24,
            # t2c is a dict that you can choose color for different text
            t2c={"Text": BLUE, "TexText": BLUE, "LaTeX": ORANGE}
        )
        VGroup(text, difference).arrange(DOWN, buff=1)
        self.play(Write(text))
        self.play(FadeIn(difference, UP))
        self.wait(3)

        fonts = Text(
            "And you can also set the font according to different words",
            font="Arial",
            t2f={"font": "Consolas", "words": "Consolas"},
            t2c={"font": BLUE, "words": GREEN}
        )
        fonts.set_width(FRAME_WIDTH - 1)
        slant = Text(
            "And the same as slant and weight",
            font="Consolas",
            t2s={"slant": ITALIC},
            t2w={"weight": BOLD},
            t2c={"slant": ORANGE, "weight": RED}
        )
        VGroup(fonts, slant).arrange(DOWN, buff=0.8)
        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))
        self.play(Write(fonts))
        self.wait()
        self.play(Write(slant))
        self.wait()
```
Example 9:
```python
class TexTransformExample(Scene):
    def construct(self):
        to_isolate = ["B", "C", "=", "(", ")"]
        lines = VGroup(
            # Passing in muliple arguments to Tex will result
            # in the same expression as if those arguments had
            # been joined together, except that the submobject
            # hierarchy of the resulting mobject ensure that the
            # Tex mobject has a subject corresponding to
            # each of these strings.  For example, the Tex mobject
            # below will have 5 subjects, corresponding to the
            # expressions [A^2, +, B^2, =, C^2]
            OldTex("A^2", "+", "B^2", "=", "C^2"),
            # Likewise here
            OldTex("A^2", "=", "C^2", "-", "B^2"),
            # Alternatively, you can pass in the keyword argument
            # "isolate" with a list of strings that should be out as
            # their own submobject.  So the line below is equivalent
            # to the commented out line below it.
            OldTex("A^2 = (C + B)(C - B)", isolate=["A^2", *to_isolate]),
            # OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
            OldTex("A = \\sqrt{(C + B)(C - B)}", isolate=["A", *to_isolate])
        )
        lines.arrange(DOWN, buff=LARGE_BUFF)
        for line in lines:
            line.set_color_by_tex_to_color_map({
                "A": BLUE,
                "B": TEAL,
                "C": GREEN,
            })

        play_kw = {"run_time": 2}
        self.add(lines[0])
        # The animation TransformMatchingTex will line up parts
        # of the source and target which have matching tex strings.
        # Here, giving it a little path_arc makes each part sort of
        # rotate into their final positions, which feels appropriate
        # for the idea of rearranging an equation
        self.play(
            TransformMatchingTex(
                lines[0].copy(), lines[1],
                path_arc=90 * DEGREES,
            ),
            **play_kw
        )
        self.wait()

        # Now, we could try this again on the next line...
        self.play(
            TransformMatchingTex(lines[1].copy(), lines[2]),
            **play_kw
        )
        self.wait()
        # ...and this looks nice enough, but since there's no tex
        # in lines[2] which matches "C^2" or "B^2", those terms fade
        # out to nothing while the C and B terms fade in from nothing.
        # If, however, we want the C^2 to go to C, and B^2 to go to B,
        # we can specify that with a key map.
        self.play(FadeOut(lines[2]))
        self.play(
            TransformMatchingTex(
                lines[1].copy(), lines[2],
                key_map={
                    "C^2": "C",
                    "B^2": "B",
                }
            ),
            **play_kw
        )
        self.wait()

        # And to finish off, a simple TransformMatchingShapes would work
        # just fine.  But perhaps we want that exponent on A^2 to transform into
        # the square root symbol.  At the moment, lines[2] treats the expression
        # A^2 as a unit, so we might create a new version of the same line which
        # separates out just the A.  This way, when TransformMatchingTex lines up
        # all matching parts, the only mismatch will be between the "^2" from
        # new_line2 and the "\sqrt" from the final line.  By passing in,
        # transform_mismatches=True, it will transform this "^2" part into
        # the "\sqrt" part.
        new_line2 = OldTex("A^2 = (C + B)(C - B)", isolate=["A", *to_isolate])
        new_line2.replace(lines[2])
        new_line2.match_style(lines[2])

        self.play(
            TransformMatchingTex(
                new_line2, lines[3],
                transform_mismatches=True,
            ),
            **play_kw
        )
        self.wait(3)
        self.play(FadeOut(lines, RIGHT))

        # Alternatively, if you don't want to think about breaking up
        # the tex strings deliberately, you can TransformMatchingShapes,
        # which will try to line up all pieces of a source mobject with
        # those of a target, regardless of the submobject hierarchy in
        # each one, according to whether those pieces have the same
        # shape (as best it can).
        source = Text("the morse code", height=1)
        target = Text("here come dots", height=1)

        self.play(Write(source))
        self.wait()
        kw = {"run_time": 3, "path_arc": PI / 2}
        self.play(TransformMatchingShapes(source, target, **kw))
        self.wait()
        self.play(TransformMatchingShapes(target, source, **kw))
        self.wait()
```
Example 10:
```python
TransformMatchingTex
```
Example 11:
```python
TransformMatchingShapes
```
Example 12:
```python
TransformMatchingTeX
```
Example 13:
```python
TransformMatchingShapes
```
Example 14:
```python
class UpdatersExample(Scene):
    def construct(self):
        square = Square()
        square.set_fill(BLUE_E, 1)

        # On all all frames, the constructor Brace(square, UP) will
        # be called, and the mobject brace will set its data to match
        # that of the newly constructed object
        brace = always_redraw(Brace, square, UP)

        text, number = label = VGroup(
            Text("Width = "),
            DecimalNumber(
                0,
                show_ellipsis=True,
                num_decimal_places=2,
                include_sign=True,
            )
        )
        label.arrange(RIGHT)

        # This ensures that the method deicmal.next_to(square)
        # is called on every frame
        always(label.next_to, brace, UP)
        # You could also write the following equivalent line
        # label.add_updater(lambda m: m.next_to(brace, UP))

        # If the argument itself might change, you can use f_always,
        # for which the arguments following the initial Mobject method
        # should be functions returning arguments to that method.
        # The following line ensures that decimal.set_value(square.get_y())
        # is called every frame
        f_always(number.set_value, square.get_width)
        # You could also write the following equivalent line
        # number.add_updater(lambda m: m.set_value(square.get_width()))

        self.add(square, brace, label)

        # Notice that the brace and label track with the square
        self.play(
            square.animate.scale(2),
            rate_func=there_and_back,
            run_time=2,
        )
        self.wait()
        self.play(
            square.animate.set_width(5, stretch=True),
            run_time=3,
        )
        self.wait()
        self.play(
            square.animate.set_width(2),
            run_time=3
        )
        self.wait()

        # In general, you can alway call Mobject.add_updater, and pass in
        # a function that you want to be called on every frame.  The function
        # should take in either one argument, the mobject, or two arguments,
        # the mobject and the amount of time since the last frame.
        now = self.time
        w0 = square.get_width()
        square.add_updater(
            lambda m: m.set_width(w0 * math.cos(self.time - now))
        )
        self.wait(4 * PI)
```
Example 15:
```python
always_redraw()
```
Example 16:
```python
DecimalNumber
```
Example 17:
```python
.add_updater()
```
Example 18:
```python
always_redraw()
```
Example 19:
```python
DecimalNumber
```
Example 20:
```python
always(f, x)
```
Example 21:
```python
f_always(f, g)
```
Example 22:
```python
.add_updater()
```
Example 23:
```python
mob1.add_updater(lambda mob: mob.next_to(mob2))
```
Example 24:
```python
mob1.next_to(mob2)
```
Example 25:
```python
class CoordinateSystemExample(Scene):
    def construct(self):
        axes = Axes(
            # x-axis ranges from -1 to 10, with a default step size of 1
            x_range=(-1, 10),
            # y-axis ranges from -2 to 2 with a step size of 0.5
            y_range=(-2, 2, 0.5),
            # The axes will be stretched so as to match the specified
            # height and width
            height=6,
            width=10,
            # Axes is made of two NumberLine mobjects.  You can specify
            # their configuration with axis_config
            axis_config={
                "stroke_color": GREY_A,
                "stroke_width": 2,
            },
            # Alternatively, you can specify configuration for just one
            # of them, like this.
            y_axis_config={
                "include_tip": False,
            }
        )
        # Keyword arguments of add_coordinate_labels can be used to
        # configure the DecimalNumber mobjects which it creates and
        # adds to the axes
        axes.add_coordinate_labels(
            font_size=20,
            num_decimal_places=1,
        )
        self.add(axes)

        # Axes descends from the CoordinateSystem class, meaning
        # you can call call axes.coords_to_point, abbreviated to
        # axes.c2p, to associate a set of coordinates with a point,
        # like so:
        dot = Dot(color=RED)
        dot.move_to(axes.c2p(0, 0))
        self.play(FadeIn(dot, scale=0.5))
        self.play(dot.animate.move_to(axes.c2p(3, 2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))
        self.wait()

        # Similarly, you can call axes.point_to_coords, or axes.p2c
        # print(axes.p2c(dot.get_center()))

        # We can draw lines from the axes to better mark the coordinates
        # of a given point.
        # Here, the always_redraw command means that on each new frame
        # the lines will be redrawn
        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))
        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))

        self.play(
            ShowCreation(h_line),
            ShowCreation(v_line),
        )
        self.play(dot.animate.move_to(axes.c2p(3, -2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(1, 1)))
        self.wait()

        # If we tie the dot to a particular set of coordinates, notice
        # that as we move the axes around it respects the coordinate
        # system defined by them.
        f_always(dot.move_to, lambda: axes.c2p(1, 1))
        self.play(
            axes.animate.scale(0.75).to_corner(UL),
            run_time=2,
        )
        self.wait()
        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))

        # Other coordinate systems you can play around with include
        # ThreeDAxes, NumberPlane, and ComplexPlane.
```
Example 26:
```python
class GraphExample(Scene):
    def construct(self):
        axes = Axes((-3, 10), (-1, 8))
        axes.add_coordinate_labels()

        self.play(Write(axes, lag_ratio=0.01, run_time=1))

        # Axes.get_graph will return the graph of a function
        sin_graph = axes.get_graph(
            lambda x: 2 * math.sin(x),
            color=BLUE,
        )
        # By default, it draws it so as to somewhat smoothly interpolate
        # between sampled points (x, f(x)).  If the graph is meant to have
        # a corner, though, you can set use_smoothing to False
        relu_graph = axes.get_graph(
            lambda x: max(x, 0),
            use_smoothing=False,
            color=YELLOW,
        )
        # For discontinuous functions, you can specify the point of
        # discontinuity so that it does not try to draw over the gap.
        step_graph = axes.get_graph(
            lambda x: 2.0 if x > 3 else 1.0,
            discontinuities=[3],
            color=GREEN,
        )

        # Axes.get_graph_label takes in either a string or a mobject.
        # If it's a string, it treats it as a LaTeX expression.  By default
        # it places the label next to the graph near the right side, and
        # has it match the color of the graph
        sin_label = axes.get_graph_label(sin_graph, "\\sin(x)")
        relu_label = axes.get_graph_label(relu_graph, Text("ReLU"))
        step_label = axes.get_graph_label(step_graph, Text("Step"), x=4)

        self.play(
            ShowCreation(sin_graph),
            FadeIn(sin_label, RIGHT),
        )
        self.wait(2)
        self.play(
            ReplacementTransform(sin_graph, relu_graph),
            FadeTransform(sin_label, relu_label),
        )
        self.wait()
        self.play(
            ReplacementTransform(relu_graph, step_graph),
            FadeTransform(relu_label, step_label),
        )
        self.wait()

        parabola = axes.get_graph(lambda x: 0.25 * x**2)
        parabola.set_stroke(BLUE)
        self.play(
            FadeOut(step_graph),
            FadeOut(step_label),
            ShowCreation(parabola)
        )
        self.wait()

        # You can use axes.input_to_graph_point, abbreviated
        # to axes.i2gp, to find a particular point on a graph
        dot = Dot(color=RED)
        dot.move_to(axes.i2gp(2, parabola))
        self.play(FadeIn(dot, scale=0.5))

        # A value tracker lets us animate a parameter, usually
        # with the intent of having other mobjects update based
        # on the parameter
        x_tracker = ValueTracker(2)
        f_always(
            dot.move_to,
            lambda: axes.i2gp(x_tracker.get_value(), parabola)
        )

        self.play(x_tracker.animate.set_value(4), run_time=3)
        self.play(x_tracker.animate.set_value(-2), run_time=3)
        self.wait()
```
Example 27:
```python
class SurfaceExample(Scene):
    CONFIG = {
        "camera_class": ThreeDCamera,
    }

    def construct(self):
        surface_text = Text("For 3d scenes, try using surfaces")
        surface_text.fix_in_frame()
        surface_text.to_edge(UP)
        self.add(surface_text)
        self.wait(0.1)

        torus1 = Torus(r1=1, r2=1)
        torus2 = Torus(r1=3, r2=1)
        sphere = Sphere(radius=3, resolution=torus1.resolution)
        # You can texture a surface with up to two images, which will
        # be interpreted as the side towards the light, and away from
        # the light.  These can be either urls, or paths to a local file
        # in whatever you've set as the image directory in
        # the custom_config.yml file

        # day_texture = "EarthTextureMap"
        # night_texture = "NightEarthTextureMap"
        day_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
        night_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"

        surfaces = [
            TexturedSurface(surface, day_texture, night_texture)
            for surface in [sphere, torus1, torus2]
        ]

        for mob in surfaces:
            mob.shift(IN)
            mob.mesh = SurfaceMesh(mob)
            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)

        # Set perspective
        frame = self.camera.frame
        frame.set_euler_angles(
            theta=-30 * DEGREES,
            phi=70 * DEGREES,
        )

        surface = surfaces[0]

        self.play(
            FadeIn(surface),
            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),
        )
        for mob in surfaces:
            mob.add(mob.mesh)
        surface.save_state()
        self.play(Rotate(surface, PI / 2), run_time=2)
        for mob in surfaces[1:]:
            mob.rotate(PI / 2)

        self.play(
            Transform(surface, surfaces[1]),
            run_time=3
        )

        self.play(
            Transform(surface, surfaces[2]),
            # Move camera frame during the transition
            frame.animate.increment_phi(-10 * DEGREES),
            frame.animate.increment_theta(-20 * DEGREES),
            run_time=3
        )
        # Add ambient rotation
        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))

        # Play around with where the light is
        light_text = Text("You can move around the light source")
        light_text.move_to(surface_text)
        light_text.fix_in_frame()

        self.play(FadeTransform(surface_text, light_text))
        light = self.camera.light_source
        self.add(light)
        light.save_state()
        self.play(light.animate.move_to(3 * IN), run_time=5)
        self.play(light.animate.shift(10 * OUT), run_time=5)

        drag_text = Text("Try moving the mouse while pressing d or s")
        drag_text.move_to(light_text)
        drag_text.fix_in_frame()

        self.play(FadeTransform(light_text, drag_text))
        self.wait()
```
Example 28:
```python
.fix_in_frame()
```
Example 29:
```python
class OpeningManimExample(Scene):
    def construct(self):
        intro_words = Text("""
            The original motivation for manim was to
            better illustrate mathematical functions
            as transformations.
        """)
        intro_words.to_edge(UP)

        self.play(Write(intro_words))
        self.wait(2)

        # Linear transform
        grid = NumberPlane((-10, 10), (-5, 5))
        matrix = [[1, 1], [0, 1]]
        linear_transform_words = VGroup(
            Text("This is what the matrix"),
            IntegerMatrix(matrix, include_background_rectangle=True),
            Text("looks like")
        )
        linear_transform_words.arrange(RIGHT)
        linear_transform_words.to_edge(UP)
        linear_transform_words.set_stroke(BLACK, 10, background=True)

        self.play(
            ShowCreation(grid),
            FadeTransform(intro_words, linear_transform_words)
        )
        self.wait()
        self.play(grid.animate.apply_matrix(matrix), run_time=3)
        self.wait()

        # Complex map
        c_grid = ComplexPlane()
        moving_c_grid = c_grid.copy()
        moving_c_grid.prepare_for_nonlinear_transform()
        c_grid.set_stroke(BLUE_E, 1)
        c_grid.add_coordinate_labels(font_size=24)
        complex_map_words = TexText("""
            Or thinking of the plane as $\\mathds{C}$,\\\\
            this is the map $z \\rightarrow z^2$
        """)
        complex_map_words.to_corner(UR)
        complex_map_words.set_stroke(BLACK, 5, background=True)

        self.play(
            FadeOut(grid),
            Write(c_grid, run_time=3),
            FadeIn(moving_c_grid),
            FadeTransform(linear_transform_words, complex_map_words),
        )
        self.wait()
        self.play(
            moving_c_grid.animate.apply_complex_function(lambda z: z**2),
            run_time=6,
        )
        self.wait(2)
```

================================================================================

=== Example Scenes - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/example_scenes.html#graphexample
Content:
Example Scenes
¶
After understanding the previous knowledge, we can understand more scenes.
Many example scenes are given in
example_scenes.py
, let’s start with
the simplest and one by one.
InteractiveDevlopment
¶
InteractiveDevelopment
¶
from
manimlib
import
*
class
InteractiveDevelopment
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
square
=
Square
()
self
.
play
(
ShowCreation
(
square
))
self
.
wait
()
# This opens an iPython terminal where you can keep writing
# lines as if they were part of this construct method.
# In particular, 'square', 'circle' and 'self' will all be
# part of the local namespace in that terminal.
self
.
embed
()
# Try copying and pasting some of the lines below into
# the interactive shell
self
.
play
(
ReplacementTransform
(
square
,
circle
))
self
.
wait
()
self
.
play
(
circle
.
animate
.
stretch
(
4
,
0
))
self
.
play
(
Rotate
(
circle
,
90
*
DEGREES
))
self
.
play
(
circle
.
animate
.
shift
(
2
*
RIGHT
)
.
scale
(
0.25
))
text
=
Text
(
"""
In general, using the interactive shell
is very helpful when developing new scenes
"""
)
self
.
play
(
Write
(
text
))
# In the interactive shell, you can just type
# play, add, remove, clear, wait, save_state and restore,
# instead of self.play, self.add, self.remove, etc.
# To interact with the window, type touch().  You can then
# scroll in the window, or zoom by holding down 'z' while scrolling,
# and change camera perspective by holding down 'd' while moving
# the mouse.  Press 'r' to reset to the standard camera position.
# Press 'q' to stop interacting with the window and go back to
# typing new commands into the shell.
# In principle you can customize a scene to be responsive to
# mouse and keyboard interactions
always
(
circle
.
move_to
,
self
.
mouse_point
)
This scene is similar to what we wrote in
Quick Start
.
And how to interact has been written in the comments.
No more explanation here.
AnimatingMethods
¶
AnimatingMethods
¶
class
AnimatingMethods
(
Scene
):
def
construct
(
self
):
grid
=
OldTex
(
r
"\pi"
)
.
get_grid
(
10
,
10
,
height
=
4
)
self
.
add
(
grid
)
# You can animate the application of mobject methods with the
# ".animate" syntax:
self
.
play
(
grid
.
animate
.
shift
(
LEFT
))
# Alternatively, you can use the older syntax by passing the
# method and then the arguments to the scene's "play" function:
self
.
play
(
grid
.
shift
,
LEFT
)
# Both of those will interpolate between the mobject's initial
# state and whatever happens when you apply that method.
# For this example, calling grid.shift(LEFT) would shift the
# grid one unit to the left, but both of the previous calls to
# "self.play" animate that motion.
# The same applies for any method, including those setting colors.
self
.
play
(
grid
.
animate
.
set_color
(
YELLOW
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_submobject_colors_by_gradient
(
BLUE
,
GREEN
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_height
(
TAU
-
MED_SMALL_BUFF
))
self
.
wait
()
# The method Mobject.apply_complex_function lets you apply arbitrary
# complex functions, treating the points defining the mobject as
# complex numbers.
self
.
play
(
grid
.
animate
.
apply_complex_function
(
np
.
exp
),
run_time
=
5
)
self
.
wait
()
# Even more generally, you could apply Mobject.apply_function,
# which takes in functions form R^3 to R^3
self
.
play
(
grid
.
animate
.
apply_function
(
lambda
p
:
[
p
[
0
]
+
0.5
*
math
.
sin
(
p
[
1
]),
p
[
1
]
+
0.5
*
math
.
sin
(
p
[
0
]),
p
[
2
]
]
),
run_time
=
5
,
)
self
.
wait
()
The new usage in this scene is
.get_grid()
and
self.play(mob.animate.method(args))
.
.get_grid()
method will return a new mobject containing multiple copies of this one arranged in a grid.
self.play(mob.animate.method(args))
animates the method, and the details are in the comments above.
TextExample
¶
TextExample
¶
class
TextExample
(
Scene
):
def
construct
(
self
):
# To run this scene properly, you should have "Consolas" font in your computer
# for full usage, you can see https://github.com/3b1b/manim/pull/680
text
=
Text
(
"Here is a text"
,
font
=
"Consolas"
,
font_size
=
90
)
difference
=
Text
(
"""
The most important difference between Text and TexText is that\n
you can change the font more easily, but can't use the LaTeX grammar
"""
,
font
=
"Arial"
,
font_size
=
24
,
# t2c is a dict that you can choose color for different text
t2c
=
{
"Text"
:
BLUE
,
"TexText"
:
BLUE
,
"LaTeX"
:
ORANGE
}
)
VGroup
(
text
,
difference
)
.
arrange
(
DOWN
,
buff
=
1
)
self
.
play
(
Write
(
text
))
self
.
play
(
FadeIn
(
difference
,
UP
))
self
.
wait
(
3
)
fonts
=
Text
(
"And you can also set the font according to different words"
,
font
=
"Arial"
,
t2f
=
{
"font"
:
"Consolas"
,
"words"
:
"Consolas"
},
t2c
=
{
"font"
:
BLUE
,
"words"
:
GREEN
}
)
fonts
.
set_width
(
FRAME_WIDTH
-
1
)
slant
=
Text
(
"And the same as slant and weight"
,
font
=
"Consolas"
,
t2s
=
{
"slant"
:
ITALIC
},
t2w
=
{
"weight"
:
BOLD
},
t2c
=
{
"slant"
:
ORANGE
,
"weight"
:
RED
}
)
VGroup
(
fonts
,
slant
)
.
arrange
(
DOWN
,
buff
=
0.8
)
self
.
play
(
FadeOut
(
text
),
FadeOut
(
difference
,
shift
=
DOWN
))
self
.
play
(
Write
(
fonts
))
self
.
wait
()
self
.
play
(
Write
(
slant
))
self
.
wait
()
The new classes in this scene are
Text
,
VGroup
,
Write
,
FadeIn
and
FadeOut
.
Text
can create text, define fonts, etc. The usage ais clearly reflected in the above examples.
VGroup
can put multiple
VMobject
together as a whole. In the example, the
.arrange()
method is called to arrange the sub-mobjects in sequence downward (
DOWN
), and the spacing is
buff
.
Write
is an animation that shows similar writing effects.
FadeIn
fades the object in, the second parameter indicates the direction of the fade in.
FadeOut
fades out the object, the second parameter indicates the direction of the fade out.
TexTransformExample
¶
TexTransformExample
¶
class
TexTransformExample
(
Scene
):
def
construct
(
self
):
to_isolate
=
[
"B"
,
"C"
,
"="
,
"("
,
")"
]
lines
=
VGroup
(
# Passing in muliple arguments to Tex will result
# in the same expression as if those arguments had
# been joined together, except that the submobject
# hierarchy of the resulting mobject ensure that the
# Tex mobject has a subject corresponding to
# each of these strings.  For example, the Tex mobject
# below will have 5 subjects, corresponding to the
# expressions [A^2, +, B^2, =, C^2]
OldTex
(
"A^2"
,
"+"
,
"B^2"
,
"="
,
"C^2"
),
# Likewise here
OldTex
(
"A^2"
,
"="
,
"C^2"
,
"-"
,
"B^2"
),
# Alternatively, you can pass in the keyword argument
# "isolate" with a list of strings that should be out as
# their own submobject.  So the line below is equivalent
# to the commented out line below it.
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A^2"
,
*
to_isolate
]),
# OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
OldTex
(
"A =
\\
sqrt{(C + B)(C - B)}"
,
isolate
=
[
"A"
,
*
to_isolate
])
)
lines
.
arrange
(
DOWN
,
buff
=
LARGE_BUFF
)
for
line
in
lines
:
line
.
set_color_by_tex_to_color_map
({
"A"
:
BLUE
,
"B"
:
TEAL
,
"C"
:
GREEN
,
})
play_kw
=
{
"run_time"
:
2
}
self
.
add
(
lines
[
0
])
# The animation TransformMatchingTex will line up parts
# of the source and target which have matching tex strings.
# Here, giving it a little path_arc makes each part sort of
# rotate into their final positions, which feels appropriate
# for the idea of rearranging an equation
self
.
play
(
TransformMatchingTex
(
lines
[
0
]
.
copy
(),
lines
[
1
],
path_arc
=
90
*
DEGREES
,
),
**
play_kw
)
self
.
wait
()
# Now, we could try this again on the next line...
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
]),
**
play_kw
)
self
.
wait
()
# ...and this looks nice enough, but since there's no tex
# in lines[2] which matches "C^2" or "B^2", those terms fade
# out to nothing while the C and B terms fade in from nothing.
# If, however, we want the C^2 to go to C, and B^2 to go to B,
# we can specify that with a key map.
self
.
play
(
FadeOut
(
lines
[
2
]))
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
],
key_map
=
{
"C^2"
:
"C"
,
"B^2"
:
"B"
,
}
),
**
play_kw
)
self
.
wait
()
# And to finish off, a simple TransformMatchingShapes would work
# just fine.  But perhaps we want that exponent on A^2 to transform into
# the square root symbol.  At the moment, lines[2] treats the expression
# A^2 as a unit, so we might create a new version of the same line which
# separates out just the A.  This way, when TransformMatchingTex lines up
# all matching parts, the only mismatch will be between the "^2" from
# new_line2 and the "\sqrt" from the final line.  By passing in,
# transform_mismatches=True, it will transform this "^2" part into
# the "\sqrt" part.
new_line2
=
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A"
,
*
to_isolate
])
new_line2
.
replace
(
lines
[
2
])
new_line2
.
match_style
(
lines
[
2
])
self
.
play
(
TransformMatchingTex
(
new_line2
,
lines
[
3
],
transform_mismatches
=
True
,
),
**
play_kw
)
self
.
wait
(
3
)
self
.
play
(
FadeOut
(
lines
,
RIGHT
))
# Alternatively, if you don't want to think about breaking up
# the tex strings deliberately, you can TransformMatchingShapes,
# which will try to line up all pieces of a source mobject with
# those of a target, regardless of the submobject hierarchy in
# each one, according to whether those pieces have the same
# shape (as best it can).
source
=
Text
(
"the morse code"
,
height
=
1
)
target
=
Text
(
"here come dots"
,
height
=
1
)
self
.
play
(
Write
(
source
))
self
.
wait
()
kw
=
{
"run_time"
:
3
,
"path_arc"
:
PI
/
2
}
self
.
play
(
TransformMatchingShapes
(
source
,
target
,
**
kw
))
self
.
wait
()
self
.
play
(
TransformMatchingShapes
(
target
,
source
,
**
kw
))
self
.
wait
()
The new classes in this scene are
Tex
,
TexText
,
TransformMatchingTex
and
TransformMatchingShapes
.
Tex
uses LaTeX to create mathematical formulas.
TexText
uses LaTeX to create text.
TransformMatchingTeX
automatically transforms sub-objects according to the similarities and differences of tex in
Tex
.
TransformMatchingShapes
automatically transform sub-objects directly based on the similarities and differences of the object point sets.
UpdatersExample
¶
UpdatersExample
¶
class
UpdatersExample
(
Scene
):
def
construct
(
self
):
square
=
Square
()
square
.
set_fill
(
BLUE_E
,
1
)
# On all all frames, the constructor Brace(square, UP) will
# be called, and the mobject brace will set its data to match
# that of the newly constructed object
brace
=
always_redraw
(
Brace
,
square
,
UP
)
text
,
number
=
label
=
VGroup
(
Text
(
"Width = "
),
DecimalNumber
(
0
,
show_ellipsis
=
True
,
num_decimal_places
=
2
,
include_sign
=
True
,
)
)
label
.
arrange
(
RIGHT
)
# This ensures that the method deicmal.next_to(square)
# is called on every frame
always
(
label
.
next_to
,
brace
,
UP
)
# You could also write the following equivalent line
# label.add_updater(lambda m: m.next_to(brace, UP))
# If the argument itself might change, you can use f_always,
# for which the arguments following the initial Mobject method
# should be functions returning arguments to that method.
# The following line ensures that decimal.set_value(square.get_y())
# is called every frame
f_always
(
number
.
set_value
,
square
.
get_width
)
# You could also write the following equivalent line
# number.add_updater(lambda m: m.set_value(square.get_width()))
self
.
add
(
square
,
brace
,
label
)
# Notice that the brace and label track with the square
self
.
play
(
square
.
animate
.
scale
(
2
),
rate_func
=
there_and_back
,
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
5
,
stretch
=
True
),
run_time
=
3
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
2
),
run_time
=
3
)
self
.
wait
()
# In general, you can alway call Mobject.add_updater, and pass in
# a function that you want to be called on every frame.  The function
# should take in either one argument, the mobject, or two arguments,
# the mobject and the amount of time since the last frame.
now
=
self
.
time
w0
=
square
.
get_width
()
square
.
add_updater
(
lambda
m
:
m
.
set_width
(
w0
*
math
.
cos
(
self
.
time
-
now
))
)
self
.
wait
(
4
*
PI
)
The new classes and usage in this scene are
always_redraw()
,
DecimalNumber
,
.to_edge()
,
.center()
,
always()
,
f_always()
,
.set_y()
and
.add_updater()
.
always_redraw()
function create a new mobject every frame.
DecimalNumber
is a variable number, speed it up by breaking it into
Text
characters.
.to_edge()
means to place the object on the edge of the screen.
.center()
means to place the object in the center of the screen.
always(f,
x)
means that a certain function (
f(x)
) is executed every frame.
f_always(f,
g)
is similar to
always
, executed
f(g())
every frame.
.set_y()
means to set the ordinate of the object on the screen.
.add_updater()
sets an update function for the object. For example:
mob1.add_updater(lambda
mob:
mob.next_to(mob2))
means
mob1.next_to(mob2)
is executed every frame.
CoordinateSystemExample
¶
CoordinateSystemExample
¶
class
CoordinateSystemExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
(
# x-axis ranges from -1 to 10, with a default step size of 1
x_range
=
(
-
1
,
10
),
# y-axis ranges from -2 to 2 with a step size of 0.5
y_range
=
(
-
2
,
2
,
0.5
),
# The axes will be stretched so as to match the specified
# height and width
height
=
6
,
width
=
10
,
# Axes is made of two NumberLine mobjects.  You can specify
# their configuration with axis_config
axis_config
=
{
"stroke_color"
:
GREY_A
,
"stroke_width"
:
2
,
},
# Alternatively, you can specify configuration for just one
# of them, like this.
y_axis_config
=
{
"include_tip"
:
False
,
}
)
# Keyword arguments of add_coordinate_labels can be used to
# configure the DecimalNumber mobjects which it creates and
# adds to the axes
axes
.
add_coordinate_labels
(
font_size
=
20
,
num_decimal_places
=
1
,
)
self
.
add
(
axes
)
# Axes descends from the CoordinateSystem class, meaning
# you can call call axes.coords_to_point, abbreviated to
# axes.c2p, to associate a set of coordinates with a point,
# like so:
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
c2p
(
0
,
0
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
5
,
0.5
)))
self
.
wait
()
# Similarly, you can call axes.point_to_coords, or axes.p2c
# print(axes.p2c(dot.get_center()))
# We can draw lines from the axes to better mark the coordinates
# of a given point.
# Here, the always_redraw command means that on each new frame
# the lines will be redrawn
h_line
=
always_redraw
(
lambda
:
axes
.
get_h_line
(
dot
.
get_left
()))
v_line
=
always_redraw
(
lambda
:
axes
.
get_v_line
(
dot
.
get_bottom
()))
self
.
play
(
ShowCreation
(
h_line
),
ShowCreation
(
v_line
),
)
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
-
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
1
,
1
)))
self
.
wait
()
# If we tie the dot to a particular set of coordinates, notice
# that as we move the axes around it respects the coordinate
# system defined by them.
f_always
(
dot
.
move_to
,
lambda
:
axes
.
c2p
(
1
,
1
))
self
.
play
(
axes
.
animate
.
scale
(
0.75
)
.
to_corner
(
UL
),
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
FadeOut
(
VGroup
(
axes
,
dot
,
h_line
,
v_line
)))
# Other coordinate systems you can play around with include
# ThreeDAxes, NumberPlane, and ComplexPlane.
GraphExample
¶
GraphExample
¶
class
GraphExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
((
-
3
,
10
),
(
-
1
,
8
))
axes
.
add_coordinate_labels
()
self
.
play
(
Write
(
axes
,
lag_ratio
=
0.01
,
run_time
=
1
))
# Axes.get_graph will return the graph of a function
sin_graph
=
axes
.
get_graph
(
lambda
x
:
2
*
math
.
sin
(
x
),
color
=
BLUE
,
)
# By default, it draws it so as to somewhat smoothly interpolate
# between sampled points (x, f(x)).  If the graph is meant to have
# a corner, though, you can set use_smoothing to False
relu_graph
=
axes
.
get_graph
(
lambda
x
:
max
(
x
,
0
),
use_smoothing
=
False
,
color
=
YELLOW
,
)
# For discontinuous functions, you can specify the point of
# discontinuity so that it does not try to draw over the gap.
step_graph
=
axes
.
get_graph
(
lambda
x
:
2.0
if
x
>
3
else
1.0
,
discontinuities
=
[
3
],
color
=
GREEN
,
)
# Axes.get_graph_label takes in either a string or a mobject.
# If it's a string, it treats it as a LaTeX expression.  By default
# it places the label next to the graph near the right side, and
# has it match the color of the graph
sin_label
=
axes
.
get_graph_label
(
sin_graph
,
"
\\
sin(x)"
)
relu_label
=
axes
.
get_graph_label
(
relu_graph
,
Text
(
"ReLU"
))
step_label
=
axes
.
get_graph_label
(
step_graph
,
Text
(
"Step"
),
x
=
4
)
self
.
play
(
ShowCreation
(
sin_graph
),
FadeIn
(
sin_label
,
RIGHT
),
)
self
.
wait
(
2
)
self
.
play
(
ReplacementTransform
(
sin_graph
,
relu_graph
),
FadeTransform
(
sin_label
,
relu_label
),
)
self
.
wait
()
self
.
play
(
ReplacementTransform
(
relu_graph
,
step_graph
),
FadeTransform
(
relu_label
,
step_label
),
)
self
.
wait
()
parabola
=
axes
.
get_graph
(
lambda
x
:
0.25
*
x
**
2
)
parabola
.
set_stroke
(
BLUE
)
self
.
play
(
FadeOut
(
step_graph
),
FadeOut
(
step_label
),
ShowCreation
(
parabola
)
)
self
.
wait
()
# You can use axes.input_to_graph_point, abbreviated
# to axes.i2gp, to find a particular point on a graph
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
i2gp
(
2
,
parabola
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
# A value tracker lets us animate a parameter, usually
# with the intent of having other mobjects update based
# on the parameter
x_tracker
=
ValueTracker
(
2
)
f_always
(
dot
.
move_to
,
lambda
:
axes
.
i2gp
(
x_tracker
.
get_value
(),
parabola
)
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
4
),
run_time
=
3
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
-
2
),
run_time
=
3
)
self
.
wait
()
SurfaceExample
¶
SurfaceExample
¶
class
SurfaceExample
(
Scene
):
CONFIG
=
{
"camera_class"
:
ThreeDCamera
,
}
def
construct
(
self
):
surface_text
=
Text
(
"For 3d scenes, try using surfaces"
)
surface_text
.
fix_in_frame
()
surface_text
.
to_edge
(
UP
)
self
.
add
(
surface_text
)
self
.
wait
(
0.1
)
torus1
=
Torus
(
r1
=
1
,
r2
=
1
)
torus2
=
Torus
(
r1
=
3
,
r2
=
1
)
sphere
=
Sphere
(
radius
=
3
,
resolution
=
torus1
.
resolution
)
# You can texture a surface with up to two images, which will
# be interpreted as the side towards the light, and away from
# the light.  These can be either urls, or paths to a local file
# in whatever you've set as the image directory in
# the custom_config.yml file
# day_texture = "EarthTextureMap"
# night_texture = "NightEarthTextureMap"
day_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
night_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"
surfaces
=
[
TexturedSurface
(
surface
,
day_texture
,
night_texture
)
for
surface
in
[
sphere
,
torus1
,
torus2
]
]
for
mob
in
surfaces
:
mob
.
shift
(
IN
)
mob
.
mesh
=
SurfaceMesh
(
mob
)
mob
.
mesh
.
set_stroke
(
BLUE
,
1
,
opacity
=
0.5
)
# Set perspective
frame
=
self
.
camera
.
frame
frame
.
set_euler_angles
(
theta
=-
30
*
DEGREES
,
phi
=
70
*
DEGREES
,
)
surface
=
surfaces
[
0
]
self
.
play
(
FadeIn
(
surface
),
ShowCreation
(
surface
.
mesh
,
lag_ratio
=
0.01
,
run_time
=
3
),
)
for
mob
in
surfaces
:
mob
.
add
(
mob
.
mesh
)
surface
.
save_state
()
self
.
play
(
Rotate
(
surface
,
PI
/
2
),
run_time
=
2
)
for
mob
in
surfaces
[
1
:]:
mob
.
rotate
(
PI
/
2
)
self
.
play
(
Transform
(
surface
,
surfaces
[
1
]),
run_time
=
3
)
self
.
play
(
Transform
(
surface
,
surfaces
[
2
]),
# Move camera frame during the transition
frame
.
animate
.
increment_phi
(
-
10
*
DEGREES
),
frame
.
animate
.
increment_theta
(
-
20
*
DEGREES
),
run_time
=
3
)
# Add ambient rotation
frame
.
add_updater
(
lambda
m
,
dt
:
m
.
increment_theta
(
-
0.1
*
dt
))
# Play around with where the light is
light_text
=
Text
(
"You can move around the light source"
)
light_text
.
move_to
(
surface_text
)
light_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
surface_text
,
light_text
))
light
=
self
.
camera
.
light_source
self
.
add
(
light
)
light
.
save_state
()
self
.
play
(
light
.
animate
.
move_to
(
3
*
IN
),
run_time
=
5
)
self
.
play
(
light
.
animate
.
shift
(
10
*
OUT
),
run_time
=
5
)
drag_text
=
Text
(
"Try moving the mouse while pressing d or s"
)
drag_text
.
move_to
(
light_text
)
drag_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
light_text
,
drag_text
))
self
.
wait
()
This scene shows an example of using a three-dimensional surface, and
the related usage has been briefly described in the notes.
.fix_in_frame()
makes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.
OpeningManimExample
¶
OpeningManimExample
¶
class
OpeningManimExample
(
Scene
):
def
construct
(
self
):
intro_words
=
Text
(
"""
The original motivation for manim was to
better illustrate mathematical functions
as transformations.
"""
)
intro_words
.
to_edge
(
UP
)
self
.
play
(
Write
(
intro_words
))
self
.
wait
(
2
)
# Linear transform
grid
=
NumberPlane
((
-
10
,
10
),
(
-
5
,
5
))
matrix
=
[[
1
,
1
],
[
0
,
1
]]
linear_transform_words
=
VGroup
(
Text
(
"This is what the matrix"
),
IntegerMatrix
(
matrix
,
include_background_rectangle
=
True
),
Text
(
"looks like"
)
)
linear_transform_words
.
arrange
(
RIGHT
)
linear_transform_words
.
to_edge
(
UP
)
linear_transform_words
.
set_stroke
(
BLACK
,
10
,
background
=
True
)
self
.
play
(
ShowCreation
(
grid
),
FadeTransform
(
intro_words
,
linear_transform_words
)
)
self
.
wait
()
self
.
play
(
grid
.
animate
.
apply_matrix
(
matrix
),
run_time
=
3
)
self
.
wait
()
# Complex map
c_grid
=
ComplexPlane
()
moving_c_grid
=
c_grid
.
copy
()
moving_c_grid
.
prepare_for_nonlinear_transform
()
c_grid
.
set_stroke
(
BLUE_E
,
1
)
c_grid
.
add_coordinate_labels
(
font_size
=
24
)
complex_map_words
=
TexText
(
"""
Or thinking of the plane as $
\\
mathds
{C}
$,
\\\\
this is the map $z
\\
rightarrow z^2$
"""
)
complex_map_words
.
to_corner
(
UR
)
complex_map_words
.
set_stroke
(
BLACK
,
5
,
background
=
True
)
self
.
play
(
FadeOut
(
grid
),
Write
(
c_grid
,
run_time
=
3
),
FadeIn
(
moving_c_grid
),
FadeTransform
(
linear_transform_words
,
complex_map_words
),
)
self
.
wait
()
self
.
play
(
moving_c_grid
.
animate
.
apply_complex_function
(
lambda
z
:
z
**
2
),
run_time
=
6
,
)
self
.
wait
(
2
)
This scene is a comprehensive application of a two-dimensional scene.
After seeing these scenes, you have already understood part of the
usage of manim. For more examples, see
the video code of 3b1b
.
Contents
Example Scenes
InteractiveDevlopment
AnimatingMethods
TextExample
TexTransformExample
UpdatersExample
CoordinateSystemExample
GraphExample
SurfaceExample
OpeningManimExample

Code Examples:
Example 1:
```python
example_scenes.py
```
Example 2:
```python
from manimlib import *

class InteractiveDevelopment(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)
        square = Square()

        self.play(ShowCreation(square))
        self.wait()

        # This opens an iPython terminal where you can keep writing
        # lines as if they were part of this construct method.
        # In particular, 'square', 'circle' and 'self' will all be
        # part of the local namespace in that terminal.
        self.embed()

        # Try copying and pasting some of the lines below into
        # the interactive shell
        self.play(ReplacementTransform(square, circle))
        self.wait()
        self.play(circle.animate.stretch(4, 0))
        self.play(Rotate(circle, 90 * DEGREES))
        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))

        text = Text("""
            In general, using the interactive shell
            is very helpful when developing new scenes
        """)
        self.play(Write(text))

        # In the interactive shell, you can just type
        # play, add, remove, clear, wait, save_state and restore,
        # instead of self.play, self.add, self.remove, etc.

        # To interact with the window, type touch().  You can then
        # scroll in the window, or zoom by holding down 'z' while scrolling,
        # and change camera perspective by holding down 'd' while moving
        # the mouse.  Press 'r' to reset to the standard camera position.
        # Press 'q' to stop interacting with the window and go back to
        # typing new commands into the shell.

        # In principle you can customize a scene to be responsive to
        # mouse and keyboard interactions
        always(circle.move_to, self.mouse_point)
```
Example 3:
```python
class AnimatingMethods(Scene):
    def construct(self):
        grid = OldTex(r"\pi").get_grid(10, 10, height=4)
        self.add(grid)

        # You can animate the application of mobject methods with the
        # ".animate" syntax:
        self.play(grid.animate.shift(LEFT))

        # Alternatively, you can use the older syntax by passing the
        # method and then the arguments to the scene's "play" function:
        self.play(grid.shift, LEFT)

        # Both of those will interpolate between the mobject's initial
        # state and whatever happens when you apply that method.
        # For this example, calling grid.shift(LEFT) would shift the
        # grid one unit to the left, but both of the previous calls to
        # "self.play" animate that motion.

        # The same applies for any method, including those setting colors.
        self.play(grid.animate.set_color(YELLOW))
        self.wait()
        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))
        self.wait()
        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))
        self.wait()

        # The method Mobject.apply_complex_function lets you apply arbitrary
        # complex functions, treating the points defining the mobject as
        # complex numbers.
        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)
        self.wait()

        # Even more generally, you could apply Mobject.apply_function,
        # which takes in functions form R^3 to R^3
        self.play(
            grid.animate.apply_function(
                lambda p: [
                    p[0] + 0.5 * math.sin(p[1]),
                    p[1] + 0.5 * math.sin(p[0]),
                    p[2]
                ]
            ),
            run_time=5,
        )
        self.wait()
```
Example 4:
```python
.get_grid()
```
Example 5:
```python
self.play(mob.animate.method(args))
```
Example 6:
```python
.get_grid()
```
Example 7:
```python
self.play(mob.animate.method(args))
```
Example 8:
```python
class TextExample(Scene):
    def construct(self):
        # To run this scene properly, you should have "Consolas" font in your computer
        # for full usage, you can see https://github.com/3b1b/manim/pull/680
        text = Text("Here is a text", font="Consolas", font_size=90)
        difference = Text(
            """
            The most important difference between Text and TexText is that\n
            you can change the font more easily, but can't use the LaTeX grammar
            """,
            font="Arial", font_size=24,
            # t2c is a dict that you can choose color for different text
            t2c={"Text": BLUE, "TexText": BLUE, "LaTeX": ORANGE}
        )
        VGroup(text, difference).arrange(DOWN, buff=1)
        self.play(Write(text))
        self.play(FadeIn(difference, UP))
        self.wait(3)

        fonts = Text(
            "And you can also set the font according to different words",
            font="Arial",
            t2f={"font": "Consolas", "words": "Consolas"},
            t2c={"font": BLUE, "words": GREEN}
        )
        fonts.set_width(FRAME_WIDTH - 1)
        slant = Text(
            "And the same as slant and weight",
            font="Consolas",
            t2s={"slant": ITALIC},
            t2w={"weight": BOLD},
            t2c={"slant": ORANGE, "weight": RED}
        )
        VGroup(fonts, slant).arrange(DOWN, buff=0.8)
        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))
        self.play(Write(fonts))
        self.wait()
        self.play(Write(slant))
        self.wait()
```
Example 9:
```python
class TexTransformExample(Scene):
    def construct(self):
        to_isolate = ["B", "C", "=", "(", ")"]
        lines = VGroup(
            # Passing in muliple arguments to Tex will result
            # in the same expression as if those arguments had
            # been joined together, except that the submobject
            # hierarchy of the resulting mobject ensure that the
            # Tex mobject has a subject corresponding to
            # each of these strings.  For example, the Tex mobject
            # below will have 5 subjects, corresponding to the
            # expressions [A^2, +, B^2, =, C^2]
            OldTex("A^2", "+", "B^2", "=", "C^2"),
            # Likewise here
            OldTex("A^2", "=", "C^2", "-", "B^2"),
            # Alternatively, you can pass in the keyword argument
            # "isolate" with a list of strings that should be out as
            # their own submobject.  So the line below is equivalent
            # to the commented out line below it.
            OldTex("A^2 = (C + B)(C - B)", isolate=["A^2", *to_isolate]),
            # OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
            OldTex("A = \\sqrt{(C + B)(C - B)}", isolate=["A", *to_isolate])
        )
        lines.arrange(DOWN, buff=LARGE_BUFF)
        for line in lines:
            line.set_color_by_tex_to_color_map({
                "A": BLUE,
                "B": TEAL,
                "C": GREEN,
            })

        play_kw = {"run_time": 2}
        self.add(lines[0])
        # The animation TransformMatchingTex will line up parts
        # of the source and target which have matching tex strings.
        # Here, giving it a little path_arc makes each part sort of
        # rotate into their final positions, which feels appropriate
        # for the idea of rearranging an equation
        self.play(
            TransformMatchingTex(
                lines[0].copy(), lines[1],
                path_arc=90 * DEGREES,
            ),
            **play_kw
        )
        self.wait()

        # Now, we could try this again on the next line...
        self.play(
            TransformMatchingTex(lines[1].copy(), lines[2]),
            **play_kw
        )
        self.wait()
        # ...and this looks nice enough, but since there's no tex
        # in lines[2] which matches "C^2" or "B^2", those terms fade
        # out to nothing while the C and B terms fade in from nothing.
        # If, however, we want the C^2 to go to C, and B^2 to go to B,
        # we can specify that with a key map.
        self.play(FadeOut(lines[2]))
        self.play(
            TransformMatchingTex(
                lines[1].copy(), lines[2],
                key_map={
                    "C^2": "C",
                    "B^2": "B",
                }
            ),
            **play_kw
        )
        self.wait()

        # And to finish off, a simple TransformMatchingShapes would work
        # just fine.  But perhaps we want that exponent on A^2 to transform into
        # the square root symbol.  At the moment, lines[2] treats the expression
        # A^2 as a unit, so we might create a new version of the same line which
        # separates out just the A.  This way, when TransformMatchingTex lines up
        # all matching parts, the only mismatch will be between the "^2" from
        # new_line2 and the "\sqrt" from the final line.  By passing in,
        # transform_mismatches=True, it will transform this "^2" part into
        # the "\sqrt" part.
        new_line2 = OldTex("A^2 = (C + B)(C - B)", isolate=["A", *to_isolate])
        new_line2.replace(lines[2])
        new_line2.match_style(lines[2])

        self.play(
            TransformMatchingTex(
                new_line2, lines[3],
                transform_mismatches=True,
            ),
            **play_kw
        )
        self.wait(3)
        self.play(FadeOut(lines, RIGHT))

        # Alternatively, if you don't want to think about breaking up
        # the tex strings deliberately, you can TransformMatchingShapes,
        # which will try to line up all pieces of a source mobject with
        # those of a target, regardless of the submobject hierarchy in
        # each one, according to whether those pieces have the same
        # shape (as best it can).
        source = Text("the morse code", height=1)
        target = Text("here come dots", height=1)

        self.play(Write(source))
        self.wait()
        kw = {"run_time": 3, "path_arc": PI / 2}
        self.play(TransformMatchingShapes(source, target, **kw))
        self.wait()
        self.play(TransformMatchingShapes(target, source, **kw))
        self.wait()
```
Example 10:
```python
TransformMatchingTex
```
Example 11:
```python
TransformMatchingShapes
```
Example 12:
```python
TransformMatchingTeX
```
Example 13:
```python
TransformMatchingShapes
```
Example 14:
```python
class UpdatersExample(Scene):
    def construct(self):
        square = Square()
        square.set_fill(BLUE_E, 1)

        # On all all frames, the constructor Brace(square, UP) will
        # be called, and the mobject brace will set its data to match
        # that of the newly constructed object
        brace = always_redraw(Brace, square, UP)

        text, number = label = VGroup(
            Text("Width = "),
            DecimalNumber(
                0,
                show_ellipsis=True,
                num_decimal_places=2,
                include_sign=True,
            )
        )
        label.arrange(RIGHT)

        # This ensures that the method deicmal.next_to(square)
        # is called on every frame
        always(label.next_to, brace, UP)
        # You could also write the following equivalent line
        # label.add_updater(lambda m: m.next_to(brace, UP))

        # If the argument itself might change, you can use f_always,
        # for which the arguments following the initial Mobject method
        # should be functions returning arguments to that method.
        # The following line ensures that decimal.set_value(square.get_y())
        # is called every frame
        f_always(number.set_value, square.get_width)
        # You could also write the following equivalent line
        # number.add_updater(lambda m: m.set_value(square.get_width()))

        self.add(square, brace, label)

        # Notice that the brace and label track with the square
        self.play(
            square.animate.scale(2),
            rate_func=there_and_back,
            run_time=2,
        )
        self.wait()
        self.play(
            square.animate.set_width(5, stretch=True),
            run_time=3,
        )
        self.wait()
        self.play(
            square.animate.set_width(2),
            run_time=3
        )
        self.wait()

        # In general, you can alway call Mobject.add_updater, and pass in
        # a function that you want to be called on every frame.  The function
        # should take in either one argument, the mobject, or two arguments,
        # the mobject and the amount of time since the last frame.
        now = self.time
        w0 = square.get_width()
        square.add_updater(
            lambda m: m.set_width(w0 * math.cos(self.time - now))
        )
        self.wait(4 * PI)
```
Example 15:
```python
always_redraw()
```
Example 16:
```python
DecimalNumber
```
Example 17:
```python
.add_updater()
```
Example 18:
```python
always_redraw()
```
Example 19:
```python
DecimalNumber
```
Example 20:
```python
always(f, x)
```
Example 21:
```python
f_always(f, g)
```
Example 22:
```python
.add_updater()
```
Example 23:
```python
mob1.add_updater(lambda mob: mob.next_to(mob2))
```
Example 24:
```python
mob1.next_to(mob2)
```
Example 25:
```python
class CoordinateSystemExample(Scene):
    def construct(self):
        axes = Axes(
            # x-axis ranges from -1 to 10, with a default step size of 1
            x_range=(-1, 10),
            # y-axis ranges from -2 to 2 with a step size of 0.5
            y_range=(-2, 2, 0.5),
            # The axes will be stretched so as to match the specified
            # height and width
            height=6,
            width=10,
            # Axes is made of two NumberLine mobjects.  You can specify
            # their configuration with axis_config
            axis_config={
                "stroke_color": GREY_A,
                "stroke_width": 2,
            },
            # Alternatively, you can specify configuration for just one
            # of them, like this.
            y_axis_config={
                "include_tip": False,
            }
        )
        # Keyword arguments of add_coordinate_labels can be used to
        # configure the DecimalNumber mobjects which it creates and
        # adds to the axes
        axes.add_coordinate_labels(
            font_size=20,
            num_decimal_places=1,
        )
        self.add(axes)

        # Axes descends from the CoordinateSystem class, meaning
        # you can call call axes.coords_to_point, abbreviated to
        # axes.c2p, to associate a set of coordinates with a point,
        # like so:
        dot = Dot(color=RED)
        dot.move_to(axes.c2p(0, 0))
        self.play(FadeIn(dot, scale=0.5))
        self.play(dot.animate.move_to(axes.c2p(3, 2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))
        self.wait()

        # Similarly, you can call axes.point_to_coords, or axes.p2c
        # print(axes.p2c(dot.get_center()))

        # We can draw lines from the axes to better mark the coordinates
        # of a given point.
        # Here, the always_redraw command means that on each new frame
        # the lines will be redrawn
        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))
        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))

        self.play(
            ShowCreation(h_line),
            ShowCreation(v_line),
        )
        self.play(dot.animate.move_to(axes.c2p(3, -2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(1, 1)))
        self.wait()

        # If we tie the dot to a particular set of coordinates, notice
        # that as we move the axes around it respects the coordinate
        # system defined by them.
        f_always(dot.move_to, lambda: axes.c2p(1, 1))
        self.play(
            axes.animate.scale(0.75).to_corner(UL),
            run_time=2,
        )
        self.wait()
        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))

        # Other coordinate systems you can play around with include
        # ThreeDAxes, NumberPlane, and ComplexPlane.
```
Example 26:
```python
class GraphExample(Scene):
    def construct(self):
        axes = Axes((-3, 10), (-1, 8))
        axes.add_coordinate_labels()

        self.play(Write(axes, lag_ratio=0.01, run_time=1))

        # Axes.get_graph will return the graph of a function
        sin_graph = axes.get_graph(
            lambda x: 2 * math.sin(x),
            color=BLUE,
        )
        # By default, it draws it so as to somewhat smoothly interpolate
        # between sampled points (x, f(x)).  If the graph is meant to have
        # a corner, though, you can set use_smoothing to False
        relu_graph = axes.get_graph(
            lambda x: max(x, 0),
            use_smoothing=False,
            color=YELLOW,
        )
        # For discontinuous functions, you can specify the point of
        # discontinuity so that it does not try to draw over the gap.
        step_graph = axes.get_graph(
            lambda x: 2.0 if x > 3 else 1.0,
            discontinuities=[3],
            color=GREEN,
        )

        # Axes.get_graph_label takes in either a string or a mobject.
        # If it's a string, it treats it as a LaTeX expression.  By default
        # it places the label next to the graph near the right side, and
        # has it match the color of the graph
        sin_label = axes.get_graph_label(sin_graph, "\\sin(x)")
        relu_label = axes.get_graph_label(relu_graph, Text("ReLU"))
        step_label = axes.get_graph_label(step_graph, Text("Step"), x=4)

        self.play(
            ShowCreation(sin_graph),
            FadeIn(sin_label, RIGHT),
        )
        self.wait(2)
        self.play(
            ReplacementTransform(sin_graph, relu_graph),
            FadeTransform(sin_label, relu_label),
        )
        self.wait()
        self.play(
            ReplacementTransform(relu_graph, step_graph),
            FadeTransform(relu_label, step_label),
        )
        self.wait()

        parabola = axes.get_graph(lambda x: 0.25 * x**2)
        parabola.set_stroke(BLUE)
        self.play(
            FadeOut(step_graph),
            FadeOut(step_label),
            ShowCreation(parabola)
        )
        self.wait()

        # You can use axes.input_to_graph_point, abbreviated
        # to axes.i2gp, to find a particular point on a graph
        dot = Dot(color=RED)
        dot.move_to(axes.i2gp(2, parabola))
        self.play(FadeIn(dot, scale=0.5))

        # A value tracker lets us animate a parameter, usually
        # with the intent of having other mobjects update based
        # on the parameter
        x_tracker = ValueTracker(2)
        f_always(
            dot.move_to,
            lambda: axes.i2gp(x_tracker.get_value(), parabola)
        )

        self.play(x_tracker.animate.set_value(4), run_time=3)
        self.play(x_tracker.animate.set_value(-2), run_time=3)
        self.wait()
```
Example 27:
```python
class SurfaceExample(Scene):
    CONFIG = {
        "camera_class": ThreeDCamera,
    }

    def construct(self):
        surface_text = Text("For 3d scenes, try using surfaces")
        surface_text.fix_in_frame()
        surface_text.to_edge(UP)
        self.add(surface_text)
        self.wait(0.1)

        torus1 = Torus(r1=1, r2=1)
        torus2 = Torus(r1=3, r2=1)
        sphere = Sphere(radius=3, resolution=torus1.resolution)
        # You can texture a surface with up to two images, which will
        # be interpreted as the side towards the light, and away from
        # the light.  These can be either urls, or paths to a local file
        # in whatever you've set as the image directory in
        # the custom_config.yml file

        # day_texture = "EarthTextureMap"
        # night_texture = "NightEarthTextureMap"
        day_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
        night_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"

        surfaces = [
            TexturedSurface(surface, day_texture, night_texture)
            for surface in [sphere, torus1, torus2]
        ]

        for mob in surfaces:
            mob.shift(IN)
            mob.mesh = SurfaceMesh(mob)
            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)

        # Set perspective
        frame = self.camera.frame
        frame.set_euler_angles(
            theta=-30 * DEGREES,
            phi=70 * DEGREES,
        )

        surface = surfaces[0]

        self.play(
            FadeIn(surface),
            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),
        )
        for mob in surfaces:
            mob.add(mob.mesh)
        surface.save_state()
        self.play(Rotate(surface, PI / 2), run_time=2)
        for mob in surfaces[1:]:
            mob.rotate(PI / 2)

        self.play(
            Transform(surface, surfaces[1]),
            run_time=3
        )

        self.play(
            Transform(surface, surfaces[2]),
            # Move camera frame during the transition
            frame.animate.increment_phi(-10 * DEGREES),
            frame.animate.increment_theta(-20 * DEGREES),
            run_time=3
        )
        # Add ambient rotation
        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))

        # Play around with where the light is
        light_text = Text("You can move around the light source")
        light_text.move_to(surface_text)
        light_text.fix_in_frame()

        self.play(FadeTransform(surface_text, light_text))
        light = self.camera.light_source
        self.add(light)
        light.save_state()
        self.play(light.animate.move_to(3 * IN), run_time=5)
        self.play(light.animate.shift(10 * OUT), run_time=5)

        drag_text = Text("Try moving the mouse while pressing d or s")
        drag_text.move_to(light_text)
        drag_text.fix_in_frame()

        self.play(FadeTransform(light_text, drag_text))
        self.wait()
```
Example 28:
```python
.fix_in_frame()
```
Example 29:
```python
class OpeningManimExample(Scene):
    def construct(self):
        intro_words = Text("""
            The original motivation for manim was to
            better illustrate mathematical functions
            as transformations.
        """)
        intro_words.to_edge(UP)

        self.play(Write(intro_words))
        self.wait(2)

        # Linear transform
        grid = NumberPlane((-10, 10), (-5, 5))
        matrix = [[1, 1], [0, 1]]
        linear_transform_words = VGroup(
            Text("This is what the matrix"),
            IntegerMatrix(matrix, include_background_rectangle=True),
            Text("looks like")
        )
        linear_transform_words.arrange(RIGHT)
        linear_transform_words.to_edge(UP)
        linear_transform_words.set_stroke(BLACK, 10, background=True)

        self.play(
            ShowCreation(grid),
            FadeTransform(intro_words, linear_transform_words)
        )
        self.wait()
        self.play(grid.animate.apply_matrix(matrix), run_time=3)
        self.wait()

        # Complex map
        c_grid = ComplexPlane()
        moving_c_grid = c_grid.copy()
        moving_c_grid.prepare_for_nonlinear_transform()
        c_grid.set_stroke(BLUE_E, 1)
        c_grid.add_coordinate_labels(font_size=24)
        complex_map_words = TexText("""
            Or thinking of the plane as $\\mathds{C}$,\\\\
            this is the map $z \\rightarrow z^2$
        """)
        complex_map_words.to_corner(UR)
        complex_map_words.set_stroke(BLACK, 5, background=True)

        self.play(
            FadeOut(grid),
            Write(c_grid, run_time=3),
            FadeIn(moving_c_grid),
            FadeTransform(linear_transform_words, complex_map_words),
        )
        self.wait()
        self.play(
            moving_c_grid.animate.apply_complex_function(lambda z: z**2),
            run_time=6,
        )
        self.wait(2)
```

================================================================================

=== Example Scenes - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/example_scenes.html#surfaceexample
Content:
Example Scenes
¶
After understanding the previous knowledge, we can understand more scenes.
Many example scenes are given in
example_scenes.py
, let’s start with
the simplest and one by one.
InteractiveDevlopment
¶
InteractiveDevelopment
¶
from
manimlib
import
*
class
InteractiveDevelopment
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
square
=
Square
()
self
.
play
(
ShowCreation
(
square
))
self
.
wait
()
# This opens an iPython terminal where you can keep writing
# lines as if they were part of this construct method.
# In particular, 'square', 'circle' and 'self' will all be
# part of the local namespace in that terminal.
self
.
embed
()
# Try copying and pasting some of the lines below into
# the interactive shell
self
.
play
(
ReplacementTransform
(
square
,
circle
))
self
.
wait
()
self
.
play
(
circle
.
animate
.
stretch
(
4
,
0
))
self
.
play
(
Rotate
(
circle
,
90
*
DEGREES
))
self
.
play
(
circle
.
animate
.
shift
(
2
*
RIGHT
)
.
scale
(
0.25
))
text
=
Text
(
"""
In general, using the interactive shell
is very helpful when developing new scenes
"""
)
self
.
play
(
Write
(
text
))
# In the interactive shell, you can just type
# play, add, remove, clear, wait, save_state and restore,
# instead of self.play, self.add, self.remove, etc.
# To interact with the window, type touch().  You can then
# scroll in the window, or zoom by holding down 'z' while scrolling,
# and change camera perspective by holding down 'd' while moving
# the mouse.  Press 'r' to reset to the standard camera position.
# Press 'q' to stop interacting with the window and go back to
# typing new commands into the shell.
# In principle you can customize a scene to be responsive to
# mouse and keyboard interactions
always
(
circle
.
move_to
,
self
.
mouse_point
)
This scene is similar to what we wrote in
Quick Start
.
And how to interact has been written in the comments.
No more explanation here.
AnimatingMethods
¶
AnimatingMethods
¶
class
AnimatingMethods
(
Scene
):
def
construct
(
self
):
grid
=
OldTex
(
r
"\pi"
)
.
get_grid
(
10
,
10
,
height
=
4
)
self
.
add
(
grid
)
# You can animate the application of mobject methods with the
# ".animate" syntax:
self
.
play
(
grid
.
animate
.
shift
(
LEFT
))
# Alternatively, you can use the older syntax by passing the
# method and then the arguments to the scene's "play" function:
self
.
play
(
grid
.
shift
,
LEFT
)
# Both of those will interpolate between the mobject's initial
# state and whatever happens when you apply that method.
# For this example, calling grid.shift(LEFT) would shift the
# grid one unit to the left, but both of the previous calls to
# "self.play" animate that motion.
# The same applies for any method, including those setting colors.
self
.
play
(
grid
.
animate
.
set_color
(
YELLOW
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_submobject_colors_by_gradient
(
BLUE
,
GREEN
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_height
(
TAU
-
MED_SMALL_BUFF
))
self
.
wait
()
# The method Mobject.apply_complex_function lets you apply arbitrary
# complex functions, treating the points defining the mobject as
# complex numbers.
self
.
play
(
grid
.
animate
.
apply_complex_function
(
np
.
exp
),
run_time
=
5
)
self
.
wait
()
# Even more generally, you could apply Mobject.apply_function,
# which takes in functions form R^3 to R^3
self
.
play
(
grid
.
animate
.
apply_function
(
lambda
p
:
[
p
[
0
]
+
0.5
*
math
.
sin
(
p
[
1
]),
p
[
1
]
+
0.5
*
math
.
sin
(
p
[
0
]),
p
[
2
]
]
),
run_time
=
5
,
)
self
.
wait
()
The new usage in this scene is
.get_grid()
and
self.play(mob.animate.method(args))
.
.get_grid()
method will return a new mobject containing multiple copies of this one arranged in a grid.
self.play(mob.animate.method(args))
animates the method, and the details are in the comments above.
TextExample
¶
TextExample
¶
class
TextExample
(
Scene
):
def
construct
(
self
):
# To run this scene properly, you should have "Consolas" font in your computer
# for full usage, you can see https://github.com/3b1b/manim/pull/680
text
=
Text
(
"Here is a text"
,
font
=
"Consolas"
,
font_size
=
90
)
difference
=
Text
(
"""
The most important difference between Text and TexText is that\n
you can change the font more easily, but can't use the LaTeX grammar
"""
,
font
=
"Arial"
,
font_size
=
24
,
# t2c is a dict that you can choose color for different text
t2c
=
{
"Text"
:
BLUE
,
"TexText"
:
BLUE
,
"LaTeX"
:
ORANGE
}
)
VGroup
(
text
,
difference
)
.
arrange
(
DOWN
,
buff
=
1
)
self
.
play
(
Write
(
text
))
self
.
play
(
FadeIn
(
difference
,
UP
))
self
.
wait
(
3
)
fonts
=
Text
(
"And you can also set the font according to different words"
,
font
=
"Arial"
,
t2f
=
{
"font"
:
"Consolas"
,
"words"
:
"Consolas"
},
t2c
=
{
"font"
:
BLUE
,
"words"
:
GREEN
}
)
fonts
.
set_width
(
FRAME_WIDTH
-
1
)
slant
=
Text
(
"And the same as slant and weight"
,
font
=
"Consolas"
,
t2s
=
{
"slant"
:
ITALIC
},
t2w
=
{
"weight"
:
BOLD
},
t2c
=
{
"slant"
:
ORANGE
,
"weight"
:
RED
}
)
VGroup
(
fonts
,
slant
)
.
arrange
(
DOWN
,
buff
=
0.8
)
self
.
play
(
FadeOut
(
text
),
FadeOut
(
difference
,
shift
=
DOWN
))
self
.
play
(
Write
(
fonts
))
self
.
wait
()
self
.
play
(
Write
(
slant
))
self
.
wait
()
The new classes in this scene are
Text
,
VGroup
,
Write
,
FadeIn
and
FadeOut
.
Text
can create text, define fonts, etc. The usage ais clearly reflected in the above examples.
VGroup
can put multiple
VMobject
together as a whole. In the example, the
.arrange()
method is called to arrange the sub-mobjects in sequence downward (
DOWN
), and the spacing is
buff
.
Write
is an animation that shows similar writing effects.
FadeIn
fades the object in, the second parameter indicates the direction of the fade in.
FadeOut
fades out the object, the second parameter indicates the direction of the fade out.
TexTransformExample
¶
TexTransformExample
¶
class
TexTransformExample
(
Scene
):
def
construct
(
self
):
to_isolate
=
[
"B"
,
"C"
,
"="
,
"("
,
")"
]
lines
=
VGroup
(
# Passing in muliple arguments to Tex will result
# in the same expression as if those arguments had
# been joined together, except that the submobject
# hierarchy of the resulting mobject ensure that the
# Tex mobject has a subject corresponding to
# each of these strings.  For example, the Tex mobject
# below will have 5 subjects, corresponding to the
# expressions [A^2, +, B^2, =, C^2]
OldTex
(
"A^2"
,
"+"
,
"B^2"
,
"="
,
"C^2"
),
# Likewise here
OldTex
(
"A^2"
,
"="
,
"C^2"
,
"-"
,
"B^2"
),
# Alternatively, you can pass in the keyword argument
# "isolate" with a list of strings that should be out as
# their own submobject.  So the line below is equivalent
# to the commented out line below it.
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A^2"
,
*
to_isolate
]),
# OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
OldTex
(
"A =
\\
sqrt{(C + B)(C - B)}"
,
isolate
=
[
"A"
,
*
to_isolate
])
)
lines
.
arrange
(
DOWN
,
buff
=
LARGE_BUFF
)
for
line
in
lines
:
line
.
set_color_by_tex_to_color_map
({
"A"
:
BLUE
,
"B"
:
TEAL
,
"C"
:
GREEN
,
})
play_kw
=
{
"run_time"
:
2
}
self
.
add
(
lines
[
0
])
# The animation TransformMatchingTex will line up parts
# of the source and target which have matching tex strings.
# Here, giving it a little path_arc makes each part sort of
# rotate into their final positions, which feels appropriate
# for the idea of rearranging an equation
self
.
play
(
TransformMatchingTex
(
lines
[
0
]
.
copy
(),
lines
[
1
],
path_arc
=
90
*
DEGREES
,
),
**
play_kw
)
self
.
wait
()
# Now, we could try this again on the next line...
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
]),
**
play_kw
)
self
.
wait
()
# ...and this looks nice enough, but since there's no tex
# in lines[2] which matches "C^2" or "B^2", those terms fade
# out to nothing while the C and B terms fade in from nothing.
# If, however, we want the C^2 to go to C, and B^2 to go to B,
# we can specify that with a key map.
self
.
play
(
FadeOut
(
lines
[
2
]))
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
],
key_map
=
{
"C^2"
:
"C"
,
"B^2"
:
"B"
,
}
),
**
play_kw
)
self
.
wait
()
# And to finish off, a simple TransformMatchingShapes would work
# just fine.  But perhaps we want that exponent on A^2 to transform into
# the square root symbol.  At the moment, lines[2] treats the expression
# A^2 as a unit, so we might create a new version of the same line which
# separates out just the A.  This way, when TransformMatchingTex lines up
# all matching parts, the only mismatch will be between the "^2" from
# new_line2 and the "\sqrt" from the final line.  By passing in,
# transform_mismatches=True, it will transform this "^2" part into
# the "\sqrt" part.
new_line2
=
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A"
,
*
to_isolate
])
new_line2
.
replace
(
lines
[
2
])
new_line2
.
match_style
(
lines
[
2
])
self
.
play
(
TransformMatchingTex
(
new_line2
,
lines
[
3
],
transform_mismatches
=
True
,
),
**
play_kw
)
self
.
wait
(
3
)
self
.
play
(
FadeOut
(
lines
,
RIGHT
))
# Alternatively, if you don't want to think about breaking up
# the tex strings deliberately, you can TransformMatchingShapes,
# which will try to line up all pieces of a source mobject with
# those of a target, regardless of the submobject hierarchy in
# each one, according to whether those pieces have the same
# shape (as best it can).
source
=
Text
(
"the morse code"
,
height
=
1
)
target
=
Text
(
"here come dots"
,
height
=
1
)
self
.
play
(
Write
(
source
))
self
.
wait
()
kw
=
{
"run_time"
:
3
,
"path_arc"
:
PI
/
2
}
self
.
play
(
TransformMatchingShapes
(
source
,
target
,
**
kw
))
self
.
wait
()
self
.
play
(
TransformMatchingShapes
(
target
,
source
,
**
kw
))
self
.
wait
()
The new classes in this scene are
Tex
,
TexText
,
TransformMatchingTex
and
TransformMatchingShapes
.
Tex
uses LaTeX to create mathematical formulas.
TexText
uses LaTeX to create text.
TransformMatchingTeX
automatically transforms sub-objects according to the similarities and differences of tex in
Tex
.
TransformMatchingShapes
automatically transform sub-objects directly based on the similarities and differences of the object point sets.
UpdatersExample
¶
UpdatersExample
¶
class
UpdatersExample
(
Scene
):
def
construct
(
self
):
square
=
Square
()
square
.
set_fill
(
BLUE_E
,
1
)
# On all all frames, the constructor Brace(square, UP) will
# be called, and the mobject brace will set its data to match
# that of the newly constructed object
brace
=
always_redraw
(
Brace
,
square
,
UP
)
text
,
number
=
label
=
VGroup
(
Text
(
"Width = "
),
DecimalNumber
(
0
,
show_ellipsis
=
True
,
num_decimal_places
=
2
,
include_sign
=
True
,
)
)
label
.
arrange
(
RIGHT
)
# This ensures that the method deicmal.next_to(square)
# is called on every frame
always
(
label
.
next_to
,
brace
,
UP
)
# You could also write the following equivalent line
# label.add_updater(lambda m: m.next_to(brace, UP))
# If the argument itself might change, you can use f_always,
# for which the arguments following the initial Mobject method
# should be functions returning arguments to that method.
# The following line ensures that decimal.set_value(square.get_y())
# is called every frame
f_always
(
number
.
set_value
,
square
.
get_width
)
# You could also write the following equivalent line
# number.add_updater(lambda m: m.set_value(square.get_width()))
self
.
add
(
square
,
brace
,
label
)
# Notice that the brace and label track with the square
self
.
play
(
square
.
animate
.
scale
(
2
),
rate_func
=
there_and_back
,
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
5
,
stretch
=
True
),
run_time
=
3
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
2
),
run_time
=
3
)
self
.
wait
()
# In general, you can alway call Mobject.add_updater, and pass in
# a function that you want to be called on every frame.  The function
# should take in either one argument, the mobject, or two arguments,
# the mobject and the amount of time since the last frame.
now
=
self
.
time
w0
=
square
.
get_width
()
square
.
add_updater
(
lambda
m
:
m
.
set_width
(
w0
*
math
.
cos
(
self
.
time
-
now
))
)
self
.
wait
(
4
*
PI
)
The new classes and usage in this scene are
always_redraw()
,
DecimalNumber
,
.to_edge()
,
.center()
,
always()
,
f_always()
,
.set_y()
and
.add_updater()
.
always_redraw()
function create a new mobject every frame.
DecimalNumber
is a variable number, speed it up by breaking it into
Text
characters.
.to_edge()
means to place the object on the edge of the screen.
.center()
means to place the object in the center of the screen.
always(f,
x)
means that a certain function (
f(x)
) is executed every frame.
f_always(f,
g)
is similar to
always
, executed
f(g())
every frame.
.set_y()
means to set the ordinate of the object on the screen.
.add_updater()
sets an update function for the object. For example:
mob1.add_updater(lambda
mob:
mob.next_to(mob2))
means
mob1.next_to(mob2)
is executed every frame.
CoordinateSystemExample
¶
CoordinateSystemExample
¶
class
CoordinateSystemExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
(
# x-axis ranges from -1 to 10, with a default step size of 1
x_range
=
(
-
1
,
10
),
# y-axis ranges from -2 to 2 with a step size of 0.5
y_range
=
(
-
2
,
2
,
0.5
),
# The axes will be stretched so as to match the specified
# height and width
height
=
6
,
width
=
10
,
# Axes is made of two NumberLine mobjects.  You can specify
# their configuration with axis_config
axis_config
=
{
"stroke_color"
:
GREY_A
,
"stroke_width"
:
2
,
},
# Alternatively, you can specify configuration for just one
# of them, like this.
y_axis_config
=
{
"include_tip"
:
False
,
}
)
# Keyword arguments of add_coordinate_labels can be used to
# configure the DecimalNumber mobjects which it creates and
# adds to the axes
axes
.
add_coordinate_labels
(
font_size
=
20
,
num_decimal_places
=
1
,
)
self
.
add
(
axes
)
# Axes descends from the CoordinateSystem class, meaning
# you can call call axes.coords_to_point, abbreviated to
# axes.c2p, to associate a set of coordinates with a point,
# like so:
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
c2p
(
0
,
0
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
5
,
0.5
)))
self
.
wait
()
# Similarly, you can call axes.point_to_coords, or axes.p2c
# print(axes.p2c(dot.get_center()))
# We can draw lines from the axes to better mark the coordinates
# of a given point.
# Here, the always_redraw command means that on each new frame
# the lines will be redrawn
h_line
=
always_redraw
(
lambda
:
axes
.
get_h_line
(
dot
.
get_left
()))
v_line
=
always_redraw
(
lambda
:
axes
.
get_v_line
(
dot
.
get_bottom
()))
self
.
play
(
ShowCreation
(
h_line
),
ShowCreation
(
v_line
),
)
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
-
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
1
,
1
)))
self
.
wait
()
# If we tie the dot to a particular set of coordinates, notice
# that as we move the axes around it respects the coordinate
# system defined by them.
f_always
(
dot
.
move_to
,
lambda
:
axes
.
c2p
(
1
,
1
))
self
.
play
(
axes
.
animate
.
scale
(
0.75
)
.
to_corner
(
UL
),
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
FadeOut
(
VGroup
(
axes
,
dot
,
h_line
,
v_line
)))
# Other coordinate systems you can play around with include
# ThreeDAxes, NumberPlane, and ComplexPlane.
GraphExample
¶
GraphExample
¶
class
GraphExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
((
-
3
,
10
),
(
-
1
,
8
))
axes
.
add_coordinate_labels
()
self
.
play
(
Write
(
axes
,
lag_ratio
=
0.01
,
run_time
=
1
))
# Axes.get_graph will return the graph of a function
sin_graph
=
axes
.
get_graph
(
lambda
x
:
2
*
math
.
sin
(
x
),
color
=
BLUE
,
)
# By default, it draws it so as to somewhat smoothly interpolate
# between sampled points (x, f(x)).  If the graph is meant to have
# a corner, though, you can set use_smoothing to False
relu_graph
=
axes
.
get_graph
(
lambda
x
:
max
(
x
,
0
),
use_smoothing
=
False
,
color
=
YELLOW
,
)
# For discontinuous functions, you can specify the point of
# discontinuity so that it does not try to draw over the gap.
step_graph
=
axes
.
get_graph
(
lambda
x
:
2.0
if
x
>
3
else
1.0
,
discontinuities
=
[
3
],
color
=
GREEN
,
)
# Axes.get_graph_label takes in either a string or a mobject.
# If it's a string, it treats it as a LaTeX expression.  By default
# it places the label next to the graph near the right side, and
# has it match the color of the graph
sin_label
=
axes
.
get_graph_label
(
sin_graph
,
"
\\
sin(x)"
)
relu_label
=
axes
.
get_graph_label
(
relu_graph
,
Text
(
"ReLU"
))
step_label
=
axes
.
get_graph_label
(
step_graph
,
Text
(
"Step"
),
x
=
4
)
self
.
play
(
ShowCreation
(
sin_graph
),
FadeIn
(
sin_label
,
RIGHT
),
)
self
.
wait
(
2
)
self
.
play
(
ReplacementTransform
(
sin_graph
,
relu_graph
),
FadeTransform
(
sin_label
,
relu_label
),
)
self
.
wait
()
self
.
play
(
ReplacementTransform
(
relu_graph
,
step_graph
),
FadeTransform
(
relu_label
,
step_label
),
)
self
.
wait
()
parabola
=
axes
.
get_graph
(
lambda
x
:
0.25
*
x
**
2
)
parabola
.
set_stroke
(
BLUE
)
self
.
play
(
FadeOut
(
step_graph
),
FadeOut
(
step_label
),
ShowCreation
(
parabola
)
)
self
.
wait
()
# You can use axes.input_to_graph_point, abbreviated
# to axes.i2gp, to find a particular point on a graph
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
i2gp
(
2
,
parabola
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
# A value tracker lets us animate a parameter, usually
# with the intent of having other mobjects update based
# on the parameter
x_tracker
=
ValueTracker
(
2
)
f_always
(
dot
.
move_to
,
lambda
:
axes
.
i2gp
(
x_tracker
.
get_value
(),
parabola
)
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
4
),
run_time
=
3
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
-
2
),
run_time
=
3
)
self
.
wait
()
SurfaceExample
¶
SurfaceExample
¶
class
SurfaceExample
(
Scene
):
CONFIG
=
{
"camera_class"
:
ThreeDCamera
,
}
def
construct
(
self
):
surface_text
=
Text
(
"For 3d scenes, try using surfaces"
)
surface_text
.
fix_in_frame
()
surface_text
.
to_edge
(
UP
)
self
.
add
(
surface_text
)
self
.
wait
(
0.1
)
torus1
=
Torus
(
r1
=
1
,
r2
=
1
)
torus2
=
Torus
(
r1
=
3
,
r2
=
1
)
sphere
=
Sphere
(
radius
=
3
,
resolution
=
torus1
.
resolution
)
# You can texture a surface with up to two images, which will
# be interpreted as the side towards the light, and away from
# the light.  These can be either urls, or paths to a local file
# in whatever you've set as the image directory in
# the custom_config.yml file
# day_texture = "EarthTextureMap"
# night_texture = "NightEarthTextureMap"
day_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
night_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"
surfaces
=
[
TexturedSurface
(
surface
,
day_texture
,
night_texture
)
for
surface
in
[
sphere
,
torus1
,
torus2
]
]
for
mob
in
surfaces
:
mob
.
shift
(
IN
)
mob
.
mesh
=
SurfaceMesh
(
mob
)
mob
.
mesh
.
set_stroke
(
BLUE
,
1
,
opacity
=
0.5
)
# Set perspective
frame
=
self
.
camera
.
frame
frame
.
set_euler_angles
(
theta
=-
30
*
DEGREES
,
phi
=
70
*
DEGREES
,
)
surface
=
surfaces
[
0
]
self
.
play
(
FadeIn
(
surface
),
ShowCreation
(
surface
.
mesh
,
lag_ratio
=
0.01
,
run_time
=
3
),
)
for
mob
in
surfaces
:
mob
.
add
(
mob
.
mesh
)
surface
.
save_state
()
self
.
play
(
Rotate
(
surface
,
PI
/
2
),
run_time
=
2
)
for
mob
in
surfaces
[
1
:]:
mob
.
rotate
(
PI
/
2
)
self
.
play
(
Transform
(
surface
,
surfaces
[
1
]),
run_time
=
3
)
self
.
play
(
Transform
(
surface
,
surfaces
[
2
]),
# Move camera frame during the transition
frame
.
animate
.
increment_phi
(
-
10
*
DEGREES
),
frame
.
animate
.
increment_theta
(
-
20
*
DEGREES
),
run_time
=
3
)
# Add ambient rotation
frame
.
add_updater
(
lambda
m
,
dt
:
m
.
increment_theta
(
-
0.1
*
dt
))
# Play around with where the light is
light_text
=
Text
(
"You can move around the light source"
)
light_text
.
move_to
(
surface_text
)
light_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
surface_text
,
light_text
))
light
=
self
.
camera
.
light_source
self
.
add
(
light
)
light
.
save_state
()
self
.
play
(
light
.
animate
.
move_to
(
3
*
IN
),
run_time
=
5
)
self
.
play
(
light
.
animate
.
shift
(
10
*
OUT
),
run_time
=
5
)
drag_text
=
Text
(
"Try moving the mouse while pressing d or s"
)
drag_text
.
move_to
(
light_text
)
drag_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
light_text
,
drag_text
))
self
.
wait
()
This scene shows an example of using a three-dimensional surface, and
the related usage has been briefly described in the notes.
.fix_in_frame()
makes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.
OpeningManimExample
¶
OpeningManimExample
¶
class
OpeningManimExample
(
Scene
):
def
construct
(
self
):
intro_words
=
Text
(
"""
The original motivation for manim was to
better illustrate mathematical functions
as transformations.
"""
)
intro_words
.
to_edge
(
UP
)
self
.
play
(
Write
(
intro_words
))
self
.
wait
(
2
)
# Linear transform
grid
=
NumberPlane
((
-
10
,
10
),
(
-
5
,
5
))
matrix
=
[[
1
,
1
],
[
0
,
1
]]
linear_transform_words
=
VGroup
(
Text
(
"This is what the matrix"
),
IntegerMatrix
(
matrix
,
include_background_rectangle
=
True
),
Text
(
"looks like"
)
)
linear_transform_words
.
arrange
(
RIGHT
)
linear_transform_words
.
to_edge
(
UP
)
linear_transform_words
.
set_stroke
(
BLACK
,
10
,
background
=
True
)
self
.
play
(
ShowCreation
(
grid
),
FadeTransform
(
intro_words
,
linear_transform_words
)
)
self
.
wait
()
self
.
play
(
grid
.
animate
.
apply_matrix
(
matrix
),
run_time
=
3
)
self
.
wait
()
# Complex map
c_grid
=
ComplexPlane
()
moving_c_grid
=
c_grid
.
copy
()
moving_c_grid
.
prepare_for_nonlinear_transform
()
c_grid
.
set_stroke
(
BLUE_E
,
1
)
c_grid
.
add_coordinate_labels
(
font_size
=
24
)
complex_map_words
=
TexText
(
"""
Or thinking of the plane as $
\\
mathds
{C}
$,
\\\\
this is the map $z
\\
rightarrow z^2$
"""
)
complex_map_words
.
to_corner
(
UR
)
complex_map_words
.
set_stroke
(
BLACK
,
5
,
background
=
True
)
self
.
play
(
FadeOut
(
grid
),
Write
(
c_grid
,
run_time
=
3
),
FadeIn
(
moving_c_grid
),
FadeTransform
(
linear_transform_words
,
complex_map_words
),
)
self
.
wait
()
self
.
play
(
moving_c_grid
.
animate
.
apply_complex_function
(
lambda
z
:
z
**
2
),
run_time
=
6
,
)
self
.
wait
(
2
)
This scene is a comprehensive application of a two-dimensional scene.
After seeing these scenes, you have already understood part of the
usage of manim. For more examples, see
the video code of 3b1b
.
Contents
Example Scenes
InteractiveDevlopment
AnimatingMethods
TextExample
TexTransformExample
UpdatersExample
CoordinateSystemExample
GraphExample
SurfaceExample
OpeningManimExample

Code Examples:
Example 1:
```python
example_scenes.py
```
Example 2:
```python
from manimlib import *

class InteractiveDevelopment(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)
        square = Square()

        self.play(ShowCreation(square))
        self.wait()

        # This opens an iPython terminal where you can keep writing
        # lines as if they were part of this construct method.
        # In particular, 'square', 'circle' and 'self' will all be
        # part of the local namespace in that terminal.
        self.embed()

        # Try copying and pasting some of the lines below into
        # the interactive shell
        self.play(ReplacementTransform(square, circle))
        self.wait()
        self.play(circle.animate.stretch(4, 0))
        self.play(Rotate(circle, 90 * DEGREES))
        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))

        text = Text("""
            In general, using the interactive shell
            is very helpful when developing new scenes
        """)
        self.play(Write(text))

        # In the interactive shell, you can just type
        # play, add, remove, clear, wait, save_state and restore,
        # instead of self.play, self.add, self.remove, etc.

        # To interact with the window, type touch().  You can then
        # scroll in the window, or zoom by holding down 'z' while scrolling,
        # and change camera perspective by holding down 'd' while moving
        # the mouse.  Press 'r' to reset to the standard camera position.
        # Press 'q' to stop interacting with the window and go back to
        # typing new commands into the shell.

        # In principle you can customize a scene to be responsive to
        # mouse and keyboard interactions
        always(circle.move_to, self.mouse_point)
```
Example 3:
```python
class AnimatingMethods(Scene):
    def construct(self):
        grid = OldTex(r"\pi").get_grid(10, 10, height=4)
        self.add(grid)

        # You can animate the application of mobject methods with the
        # ".animate" syntax:
        self.play(grid.animate.shift(LEFT))

        # Alternatively, you can use the older syntax by passing the
        # method and then the arguments to the scene's "play" function:
        self.play(grid.shift, LEFT)

        # Both of those will interpolate between the mobject's initial
        # state and whatever happens when you apply that method.
        # For this example, calling grid.shift(LEFT) would shift the
        # grid one unit to the left, but both of the previous calls to
        # "self.play" animate that motion.

        # The same applies for any method, including those setting colors.
        self.play(grid.animate.set_color(YELLOW))
        self.wait()
        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))
        self.wait()
        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))
        self.wait()

        # The method Mobject.apply_complex_function lets you apply arbitrary
        # complex functions, treating the points defining the mobject as
        # complex numbers.
        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)
        self.wait()

        # Even more generally, you could apply Mobject.apply_function,
        # which takes in functions form R^3 to R^3
        self.play(
            grid.animate.apply_function(
                lambda p: [
                    p[0] + 0.5 * math.sin(p[1]),
                    p[1] + 0.5 * math.sin(p[0]),
                    p[2]
                ]
            ),
            run_time=5,
        )
        self.wait()
```
Example 4:
```python
.get_grid()
```
Example 5:
```python
self.play(mob.animate.method(args))
```
Example 6:
```python
.get_grid()
```
Example 7:
```python
self.play(mob.animate.method(args))
```
Example 8:
```python
class TextExample(Scene):
    def construct(self):
        # To run this scene properly, you should have "Consolas" font in your computer
        # for full usage, you can see https://github.com/3b1b/manim/pull/680
        text = Text("Here is a text", font="Consolas", font_size=90)
        difference = Text(
            """
            The most important difference between Text and TexText is that\n
            you can change the font more easily, but can't use the LaTeX grammar
            """,
            font="Arial", font_size=24,
            # t2c is a dict that you can choose color for different text
            t2c={"Text": BLUE, "TexText": BLUE, "LaTeX": ORANGE}
        )
        VGroup(text, difference).arrange(DOWN, buff=1)
        self.play(Write(text))
        self.play(FadeIn(difference, UP))
        self.wait(3)

        fonts = Text(
            "And you can also set the font according to different words",
            font="Arial",
            t2f={"font": "Consolas", "words": "Consolas"},
            t2c={"font": BLUE, "words": GREEN}
        )
        fonts.set_width(FRAME_WIDTH - 1)
        slant = Text(
            "And the same as slant and weight",
            font="Consolas",
            t2s={"slant": ITALIC},
            t2w={"weight": BOLD},
            t2c={"slant": ORANGE, "weight": RED}
        )
        VGroup(fonts, slant).arrange(DOWN, buff=0.8)
        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))
        self.play(Write(fonts))
        self.wait()
        self.play(Write(slant))
        self.wait()
```
Example 9:
```python
class TexTransformExample(Scene):
    def construct(self):
        to_isolate = ["B", "C", "=", "(", ")"]
        lines = VGroup(
            # Passing in muliple arguments to Tex will result
            # in the same expression as if those arguments had
            # been joined together, except that the submobject
            # hierarchy of the resulting mobject ensure that the
            # Tex mobject has a subject corresponding to
            # each of these strings.  For example, the Tex mobject
            # below will have 5 subjects, corresponding to the
            # expressions [A^2, +, B^2, =, C^2]
            OldTex("A^2", "+", "B^2", "=", "C^2"),
            # Likewise here
            OldTex("A^2", "=", "C^2", "-", "B^2"),
            # Alternatively, you can pass in the keyword argument
            # "isolate" with a list of strings that should be out as
            # their own submobject.  So the line below is equivalent
            # to the commented out line below it.
            OldTex("A^2 = (C + B)(C - B)", isolate=["A^2", *to_isolate]),
            # OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
            OldTex("A = \\sqrt{(C + B)(C - B)}", isolate=["A", *to_isolate])
        )
        lines.arrange(DOWN, buff=LARGE_BUFF)
        for line in lines:
            line.set_color_by_tex_to_color_map({
                "A": BLUE,
                "B": TEAL,
                "C": GREEN,
            })

        play_kw = {"run_time": 2}
        self.add(lines[0])
        # The animation TransformMatchingTex will line up parts
        # of the source and target which have matching tex strings.
        # Here, giving it a little path_arc makes each part sort of
        # rotate into their final positions, which feels appropriate
        # for the idea of rearranging an equation
        self.play(
            TransformMatchingTex(
                lines[0].copy(), lines[1],
                path_arc=90 * DEGREES,
            ),
            **play_kw
        )
        self.wait()

        # Now, we could try this again on the next line...
        self.play(
            TransformMatchingTex(lines[1].copy(), lines[2]),
            **play_kw
        )
        self.wait()
        # ...and this looks nice enough, but since there's no tex
        # in lines[2] which matches "C^2" or "B^2", those terms fade
        # out to nothing while the C and B terms fade in from nothing.
        # If, however, we want the C^2 to go to C, and B^2 to go to B,
        # we can specify that with a key map.
        self.play(FadeOut(lines[2]))
        self.play(
            TransformMatchingTex(
                lines[1].copy(), lines[2],
                key_map={
                    "C^2": "C",
                    "B^2": "B",
                }
            ),
            **play_kw
        )
        self.wait()

        # And to finish off, a simple TransformMatchingShapes would work
        # just fine.  But perhaps we want that exponent on A^2 to transform into
        # the square root symbol.  At the moment, lines[2] treats the expression
        # A^2 as a unit, so we might create a new version of the same line which
        # separates out just the A.  This way, when TransformMatchingTex lines up
        # all matching parts, the only mismatch will be between the "^2" from
        # new_line2 and the "\sqrt" from the final line.  By passing in,
        # transform_mismatches=True, it will transform this "^2" part into
        # the "\sqrt" part.
        new_line2 = OldTex("A^2 = (C + B)(C - B)", isolate=["A", *to_isolate])
        new_line2.replace(lines[2])
        new_line2.match_style(lines[2])

        self.play(
            TransformMatchingTex(
                new_line2, lines[3],
                transform_mismatches=True,
            ),
            **play_kw
        )
        self.wait(3)
        self.play(FadeOut(lines, RIGHT))

        # Alternatively, if you don't want to think about breaking up
        # the tex strings deliberately, you can TransformMatchingShapes,
        # which will try to line up all pieces of a source mobject with
        # those of a target, regardless of the submobject hierarchy in
        # each one, according to whether those pieces have the same
        # shape (as best it can).
        source = Text("the morse code", height=1)
        target = Text("here come dots", height=1)

        self.play(Write(source))
        self.wait()
        kw = {"run_time": 3, "path_arc": PI / 2}
        self.play(TransformMatchingShapes(source, target, **kw))
        self.wait()
        self.play(TransformMatchingShapes(target, source, **kw))
        self.wait()
```
Example 10:
```python
TransformMatchingTex
```
Example 11:
```python
TransformMatchingShapes
```
Example 12:
```python
TransformMatchingTeX
```
Example 13:
```python
TransformMatchingShapes
```
Example 14:
```python
class UpdatersExample(Scene):
    def construct(self):
        square = Square()
        square.set_fill(BLUE_E, 1)

        # On all all frames, the constructor Brace(square, UP) will
        # be called, and the mobject brace will set its data to match
        # that of the newly constructed object
        brace = always_redraw(Brace, square, UP)

        text, number = label = VGroup(
            Text("Width = "),
            DecimalNumber(
                0,
                show_ellipsis=True,
                num_decimal_places=2,
                include_sign=True,
            )
        )
        label.arrange(RIGHT)

        # This ensures that the method deicmal.next_to(square)
        # is called on every frame
        always(label.next_to, brace, UP)
        # You could also write the following equivalent line
        # label.add_updater(lambda m: m.next_to(brace, UP))

        # If the argument itself might change, you can use f_always,
        # for which the arguments following the initial Mobject method
        # should be functions returning arguments to that method.
        # The following line ensures that decimal.set_value(square.get_y())
        # is called every frame
        f_always(number.set_value, square.get_width)
        # You could also write the following equivalent line
        # number.add_updater(lambda m: m.set_value(square.get_width()))

        self.add(square, brace, label)

        # Notice that the brace and label track with the square
        self.play(
            square.animate.scale(2),
            rate_func=there_and_back,
            run_time=2,
        )
        self.wait()
        self.play(
            square.animate.set_width(5, stretch=True),
            run_time=3,
        )
        self.wait()
        self.play(
            square.animate.set_width(2),
            run_time=3
        )
        self.wait()

        # In general, you can alway call Mobject.add_updater, and pass in
        # a function that you want to be called on every frame.  The function
        # should take in either one argument, the mobject, or two arguments,
        # the mobject and the amount of time since the last frame.
        now = self.time
        w0 = square.get_width()
        square.add_updater(
            lambda m: m.set_width(w0 * math.cos(self.time - now))
        )
        self.wait(4 * PI)
```
Example 15:
```python
always_redraw()
```
Example 16:
```python
DecimalNumber
```
Example 17:
```python
.add_updater()
```
Example 18:
```python
always_redraw()
```
Example 19:
```python
DecimalNumber
```
Example 20:
```python
always(f, x)
```
Example 21:
```python
f_always(f, g)
```
Example 22:
```python
.add_updater()
```
Example 23:
```python
mob1.add_updater(lambda mob: mob.next_to(mob2))
```
Example 24:
```python
mob1.next_to(mob2)
```
Example 25:
```python
class CoordinateSystemExample(Scene):
    def construct(self):
        axes = Axes(
            # x-axis ranges from -1 to 10, with a default step size of 1
            x_range=(-1, 10),
            # y-axis ranges from -2 to 2 with a step size of 0.5
            y_range=(-2, 2, 0.5),
            # The axes will be stretched so as to match the specified
            # height and width
            height=6,
            width=10,
            # Axes is made of two NumberLine mobjects.  You can specify
            # their configuration with axis_config
            axis_config={
                "stroke_color": GREY_A,
                "stroke_width": 2,
            },
            # Alternatively, you can specify configuration for just one
            # of them, like this.
            y_axis_config={
                "include_tip": False,
            }
        )
        # Keyword arguments of add_coordinate_labels can be used to
        # configure the DecimalNumber mobjects which it creates and
        # adds to the axes
        axes.add_coordinate_labels(
            font_size=20,
            num_decimal_places=1,
        )
        self.add(axes)

        # Axes descends from the CoordinateSystem class, meaning
        # you can call call axes.coords_to_point, abbreviated to
        # axes.c2p, to associate a set of coordinates with a point,
        # like so:
        dot = Dot(color=RED)
        dot.move_to(axes.c2p(0, 0))
        self.play(FadeIn(dot, scale=0.5))
        self.play(dot.animate.move_to(axes.c2p(3, 2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))
        self.wait()

        # Similarly, you can call axes.point_to_coords, or axes.p2c
        # print(axes.p2c(dot.get_center()))

        # We can draw lines from the axes to better mark the coordinates
        # of a given point.
        # Here, the always_redraw command means that on each new frame
        # the lines will be redrawn
        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))
        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))

        self.play(
            ShowCreation(h_line),
            ShowCreation(v_line),
        )
        self.play(dot.animate.move_to(axes.c2p(3, -2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(1, 1)))
        self.wait()

        # If we tie the dot to a particular set of coordinates, notice
        # that as we move the axes around it respects the coordinate
        # system defined by them.
        f_always(dot.move_to, lambda: axes.c2p(1, 1))
        self.play(
            axes.animate.scale(0.75).to_corner(UL),
            run_time=2,
        )
        self.wait()
        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))

        # Other coordinate systems you can play around with include
        # ThreeDAxes, NumberPlane, and ComplexPlane.
```
Example 26:
```python
class GraphExample(Scene):
    def construct(self):
        axes = Axes((-3, 10), (-1, 8))
        axes.add_coordinate_labels()

        self.play(Write(axes, lag_ratio=0.01, run_time=1))

        # Axes.get_graph will return the graph of a function
        sin_graph = axes.get_graph(
            lambda x: 2 * math.sin(x),
            color=BLUE,
        )
        # By default, it draws it so as to somewhat smoothly interpolate
        # between sampled points (x, f(x)).  If the graph is meant to have
        # a corner, though, you can set use_smoothing to False
        relu_graph = axes.get_graph(
            lambda x: max(x, 0),
            use_smoothing=False,
            color=YELLOW,
        )
        # For discontinuous functions, you can specify the point of
        # discontinuity so that it does not try to draw over the gap.
        step_graph = axes.get_graph(
            lambda x: 2.0 if x > 3 else 1.0,
            discontinuities=[3],
            color=GREEN,
        )

        # Axes.get_graph_label takes in either a string or a mobject.
        # If it's a string, it treats it as a LaTeX expression.  By default
        # it places the label next to the graph near the right side, and
        # has it match the color of the graph
        sin_label = axes.get_graph_label(sin_graph, "\\sin(x)")
        relu_label = axes.get_graph_label(relu_graph, Text("ReLU"))
        step_label = axes.get_graph_label(step_graph, Text("Step"), x=4)

        self.play(
            ShowCreation(sin_graph),
            FadeIn(sin_label, RIGHT),
        )
        self.wait(2)
        self.play(
            ReplacementTransform(sin_graph, relu_graph),
            FadeTransform(sin_label, relu_label),
        )
        self.wait()
        self.play(
            ReplacementTransform(relu_graph, step_graph),
            FadeTransform(relu_label, step_label),
        )
        self.wait()

        parabola = axes.get_graph(lambda x: 0.25 * x**2)
        parabola.set_stroke(BLUE)
        self.play(
            FadeOut(step_graph),
            FadeOut(step_label),
            ShowCreation(parabola)
        )
        self.wait()

        # You can use axes.input_to_graph_point, abbreviated
        # to axes.i2gp, to find a particular point on a graph
        dot = Dot(color=RED)
        dot.move_to(axes.i2gp(2, parabola))
        self.play(FadeIn(dot, scale=0.5))

        # A value tracker lets us animate a parameter, usually
        # with the intent of having other mobjects update based
        # on the parameter
        x_tracker = ValueTracker(2)
        f_always(
            dot.move_to,
            lambda: axes.i2gp(x_tracker.get_value(), parabola)
        )

        self.play(x_tracker.animate.set_value(4), run_time=3)
        self.play(x_tracker.animate.set_value(-2), run_time=3)
        self.wait()
```
Example 27:
```python
class SurfaceExample(Scene):
    CONFIG = {
        "camera_class": ThreeDCamera,
    }

    def construct(self):
        surface_text = Text("For 3d scenes, try using surfaces")
        surface_text.fix_in_frame()
        surface_text.to_edge(UP)
        self.add(surface_text)
        self.wait(0.1)

        torus1 = Torus(r1=1, r2=1)
        torus2 = Torus(r1=3, r2=1)
        sphere = Sphere(radius=3, resolution=torus1.resolution)
        # You can texture a surface with up to two images, which will
        # be interpreted as the side towards the light, and away from
        # the light.  These can be either urls, or paths to a local file
        # in whatever you've set as the image directory in
        # the custom_config.yml file

        # day_texture = "EarthTextureMap"
        # night_texture = "NightEarthTextureMap"
        day_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
        night_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"

        surfaces = [
            TexturedSurface(surface, day_texture, night_texture)
            for surface in [sphere, torus1, torus2]
        ]

        for mob in surfaces:
            mob.shift(IN)
            mob.mesh = SurfaceMesh(mob)
            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)

        # Set perspective
        frame = self.camera.frame
        frame.set_euler_angles(
            theta=-30 * DEGREES,
            phi=70 * DEGREES,
        )

        surface = surfaces[0]

        self.play(
            FadeIn(surface),
            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),
        )
        for mob in surfaces:
            mob.add(mob.mesh)
        surface.save_state()
        self.play(Rotate(surface, PI / 2), run_time=2)
        for mob in surfaces[1:]:
            mob.rotate(PI / 2)

        self.play(
            Transform(surface, surfaces[1]),
            run_time=3
        )

        self.play(
            Transform(surface, surfaces[2]),
            # Move camera frame during the transition
            frame.animate.increment_phi(-10 * DEGREES),
            frame.animate.increment_theta(-20 * DEGREES),
            run_time=3
        )
        # Add ambient rotation
        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))

        # Play around with where the light is
        light_text = Text("You can move around the light source")
        light_text.move_to(surface_text)
        light_text.fix_in_frame()

        self.play(FadeTransform(surface_text, light_text))
        light = self.camera.light_source
        self.add(light)
        light.save_state()
        self.play(light.animate.move_to(3 * IN), run_time=5)
        self.play(light.animate.shift(10 * OUT), run_time=5)

        drag_text = Text("Try moving the mouse while pressing d or s")
        drag_text.move_to(light_text)
        drag_text.fix_in_frame()

        self.play(FadeTransform(light_text, drag_text))
        self.wait()
```
Example 28:
```python
.fix_in_frame()
```
Example 29:
```python
class OpeningManimExample(Scene):
    def construct(self):
        intro_words = Text("""
            The original motivation for manim was to
            better illustrate mathematical functions
            as transformations.
        """)
        intro_words.to_edge(UP)

        self.play(Write(intro_words))
        self.wait(2)

        # Linear transform
        grid = NumberPlane((-10, 10), (-5, 5))
        matrix = [[1, 1], [0, 1]]
        linear_transform_words = VGroup(
            Text("This is what the matrix"),
            IntegerMatrix(matrix, include_background_rectangle=True),
            Text("looks like")
        )
        linear_transform_words.arrange(RIGHT)
        linear_transform_words.to_edge(UP)
        linear_transform_words.set_stroke(BLACK, 10, background=True)

        self.play(
            ShowCreation(grid),
            FadeTransform(intro_words, linear_transform_words)
        )
        self.wait()
        self.play(grid.animate.apply_matrix(matrix), run_time=3)
        self.wait()

        # Complex map
        c_grid = ComplexPlane()
        moving_c_grid = c_grid.copy()
        moving_c_grid.prepare_for_nonlinear_transform()
        c_grid.set_stroke(BLUE_E, 1)
        c_grid.add_coordinate_labels(font_size=24)
        complex_map_words = TexText("""
            Or thinking of the plane as $\\mathds{C}$,\\\\
            this is the map $z \\rightarrow z^2$
        """)
        complex_map_words.to_corner(UR)
        complex_map_words.set_stroke(BLACK, 5, background=True)

        self.play(
            FadeOut(grid),
            Write(c_grid, run_time=3),
            FadeIn(moving_c_grid),
            FadeTransform(linear_transform_words, complex_map_words),
        )
        self.wait()
        self.play(
            moving_c_grid.animate.apply_complex_function(lambda z: z**2),
            run_time=6,
        )
        self.wait(2)
```

================================================================================

=== Example Scenes - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/example_scenes.html#openingmanimexample
Content:
Example Scenes
¶
After understanding the previous knowledge, we can understand more scenes.
Many example scenes are given in
example_scenes.py
, let’s start with
the simplest and one by one.
InteractiveDevlopment
¶
InteractiveDevelopment
¶
from
manimlib
import
*
class
InteractiveDevelopment
(
Scene
):
def
construct
(
self
):
circle
=
Circle
()
circle
.
set_fill
(
BLUE
,
opacity
=
0.5
)
circle
.
set_stroke
(
BLUE_E
,
width
=
4
)
square
=
Square
()
self
.
play
(
ShowCreation
(
square
))
self
.
wait
()
# This opens an iPython terminal where you can keep writing
# lines as if they were part of this construct method.
# In particular, 'square', 'circle' and 'self' will all be
# part of the local namespace in that terminal.
self
.
embed
()
# Try copying and pasting some of the lines below into
# the interactive shell
self
.
play
(
ReplacementTransform
(
square
,
circle
))
self
.
wait
()
self
.
play
(
circle
.
animate
.
stretch
(
4
,
0
))
self
.
play
(
Rotate
(
circle
,
90
*
DEGREES
))
self
.
play
(
circle
.
animate
.
shift
(
2
*
RIGHT
)
.
scale
(
0.25
))
text
=
Text
(
"""
In general, using the interactive shell
is very helpful when developing new scenes
"""
)
self
.
play
(
Write
(
text
))
# In the interactive shell, you can just type
# play, add, remove, clear, wait, save_state and restore,
# instead of self.play, self.add, self.remove, etc.
# To interact with the window, type touch().  You can then
# scroll in the window, or zoom by holding down 'z' while scrolling,
# and change camera perspective by holding down 'd' while moving
# the mouse.  Press 'r' to reset to the standard camera position.
# Press 'q' to stop interacting with the window and go back to
# typing new commands into the shell.
# In principle you can customize a scene to be responsive to
# mouse and keyboard interactions
always
(
circle
.
move_to
,
self
.
mouse_point
)
This scene is similar to what we wrote in
Quick Start
.
And how to interact has been written in the comments.
No more explanation here.
AnimatingMethods
¶
AnimatingMethods
¶
class
AnimatingMethods
(
Scene
):
def
construct
(
self
):
grid
=
OldTex
(
r
"\pi"
)
.
get_grid
(
10
,
10
,
height
=
4
)
self
.
add
(
grid
)
# You can animate the application of mobject methods with the
# ".animate" syntax:
self
.
play
(
grid
.
animate
.
shift
(
LEFT
))
# Alternatively, you can use the older syntax by passing the
# method and then the arguments to the scene's "play" function:
self
.
play
(
grid
.
shift
,
LEFT
)
# Both of those will interpolate between the mobject's initial
# state and whatever happens when you apply that method.
# For this example, calling grid.shift(LEFT) would shift the
# grid one unit to the left, but both of the previous calls to
# "self.play" animate that motion.
# The same applies for any method, including those setting colors.
self
.
play
(
grid
.
animate
.
set_color
(
YELLOW
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_submobject_colors_by_gradient
(
BLUE
,
GREEN
))
self
.
wait
()
self
.
play
(
grid
.
animate
.
set_height
(
TAU
-
MED_SMALL_BUFF
))
self
.
wait
()
# The method Mobject.apply_complex_function lets you apply arbitrary
# complex functions, treating the points defining the mobject as
# complex numbers.
self
.
play
(
grid
.
animate
.
apply_complex_function
(
np
.
exp
),
run_time
=
5
)
self
.
wait
()
# Even more generally, you could apply Mobject.apply_function,
# which takes in functions form R^3 to R^3
self
.
play
(
grid
.
animate
.
apply_function
(
lambda
p
:
[
p
[
0
]
+
0.5
*
math
.
sin
(
p
[
1
]),
p
[
1
]
+
0.5
*
math
.
sin
(
p
[
0
]),
p
[
2
]
]
),
run_time
=
5
,
)
self
.
wait
()
The new usage in this scene is
.get_grid()
and
self.play(mob.animate.method(args))
.
.get_grid()
method will return a new mobject containing multiple copies of this one arranged in a grid.
self.play(mob.animate.method(args))
animates the method, and the details are in the comments above.
TextExample
¶
TextExample
¶
class
TextExample
(
Scene
):
def
construct
(
self
):
# To run this scene properly, you should have "Consolas" font in your computer
# for full usage, you can see https://github.com/3b1b/manim/pull/680
text
=
Text
(
"Here is a text"
,
font
=
"Consolas"
,
font_size
=
90
)
difference
=
Text
(
"""
The most important difference between Text and TexText is that\n
you can change the font more easily, but can't use the LaTeX grammar
"""
,
font
=
"Arial"
,
font_size
=
24
,
# t2c is a dict that you can choose color for different text
t2c
=
{
"Text"
:
BLUE
,
"TexText"
:
BLUE
,
"LaTeX"
:
ORANGE
}
)
VGroup
(
text
,
difference
)
.
arrange
(
DOWN
,
buff
=
1
)
self
.
play
(
Write
(
text
))
self
.
play
(
FadeIn
(
difference
,
UP
))
self
.
wait
(
3
)
fonts
=
Text
(
"And you can also set the font according to different words"
,
font
=
"Arial"
,
t2f
=
{
"font"
:
"Consolas"
,
"words"
:
"Consolas"
},
t2c
=
{
"font"
:
BLUE
,
"words"
:
GREEN
}
)
fonts
.
set_width
(
FRAME_WIDTH
-
1
)
slant
=
Text
(
"And the same as slant and weight"
,
font
=
"Consolas"
,
t2s
=
{
"slant"
:
ITALIC
},
t2w
=
{
"weight"
:
BOLD
},
t2c
=
{
"slant"
:
ORANGE
,
"weight"
:
RED
}
)
VGroup
(
fonts
,
slant
)
.
arrange
(
DOWN
,
buff
=
0.8
)
self
.
play
(
FadeOut
(
text
),
FadeOut
(
difference
,
shift
=
DOWN
))
self
.
play
(
Write
(
fonts
))
self
.
wait
()
self
.
play
(
Write
(
slant
))
self
.
wait
()
The new classes in this scene are
Text
,
VGroup
,
Write
,
FadeIn
and
FadeOut
.
Text
can create text, define fonts, etc. The usage ais clearly reflected in the above examples.
VGroup
can put multiple
VMobject
together as a whole. In the example, the
.arrange()
method is called to arrange the sub-mobjects in sequence downward (
DOWN
), and the spacing is
buff
.
Write
is an animation that shows similar writing effects.
FadeIn
fades the object in, the second parameter indicates the direction of the fade in.
FadeOut
fades out the object, the second parameter indicates the direction of the fade out.
TexTransformExample
¶
TexTransformExample
¶
class
TexTransformExample
(
Scene
):
def
construct
(
self
):
to_isolate
=
[
"B"
,
"C"
,
"="
,
"("
,
")"
]
lines
=
VGroup
(
# Passing in muliple arguments to Tex will result
# in the same expression as if those arguments had
# been joined together, except that the submobject
# hierarchy of the resulting mobject ensure that the
# Tex mobject has a subject corresponding to
# each of these strings.  For example, the Tex mobject
# below will have 5 subjects, corresponding to the
# expressions [A^2, +, B^2, =, C^2]
OldTex
(
"A^2"
,
"+"
,
"B^2"
,
"="
,
"C^2"
),
# Likewise here
OldTex
(
"A^2"
,
"="
,
"C^2"
,
"-"
,
"B^2"
),
# Alternatively, you can pass in the keyword argument
# "isolate" with a list of strings that should be out as
# their own submobject.  So the line below is equivalent
# to the commented out line below it.
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A^2"
,
*
to_isolate
]),
# OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
OldTex
(
"A =
\\
sqrt{(C + B)(C - B)}"
,
isolate
=
[
"A"
,
*
to_isolate
])
)
lines
.
arrange
(
DOWN
,
buff
=
LARGE_BUFF
)
for
line
in
lines
:
line
.
set_color_by_tex_to_color_map
({
"A"
:
BLUE
,
"B"
:
TEAL
,
"C"
:
GREEN
,
})
play_kw
=
{
"run_time"
:
2
}
self
.
add
(
lines
[
0
])
# The animation TransformMatchingTex will line up parts
# of the source and target which have matching tex strings.
# Here, giving it a little path_arc makes each part sort of
# rotate into their final positions, which feels appropriate
# for the idea of rearranging an equation
self
.
play
(
TransformMatchingTex
(
lines
[
0
]
.
copy
(),
lines
[
1
],
path_arc
=
90
*
DEGREES
,
),
**
play_kw
)
self
.
wait
()
# Now, we could try this again on the next line...
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
]),
**
play_kw
)
self
.
wait
()
# ...and this looks nice enough, but since there's no tex
# in lines[2] which matches "C^2" or "B^2", those terms fade
# out to nothing while the C and B terms fade in from nothing.
# If, however, we want the C^2 to go to C, and B^2 to go to B,
# we can specify that with a key map.
self
.
play
(
FadeOut
(
lines
[
2
]))
self
.
play
(
TransformMatchingTex
(
lines
[
1
]
.
copy
(),
lines
[
2
],
key_map
=
{
"C^2"
:
"C"
,
"B^2"
:
"B"
,
}
),
**
play_kw
)
self
.
wait
()
# And to finish off, a simple TransformMatchingShapes would work
# just fine.  But perhaps we want that exponent on A^2 to transform into
# the square root symbol.  At the moment, lines[2] treats the expression
# A^2 as a unit, so we might create a new version of the same line which
# separates out just the A.  This way, when TransformMatchingTex lines up
# all matching parts, the only mismatch will be between the "^2" from
# new_line2 and the "\sqrt" from the final line.  By passing in,
# transform_mismatches=True, it will transform this "^2" part into
# the "\sqrt" part.
new_line2
=
OldTex
(
"A^2 = (C + B)(C - B)"
,
isolate
=
[
"A"
,
*
to_isolate
])
new_line2
.
replace
(
lines
[
2
])
new_line2
.
match_style
(
lines
[
2
])
self
.
play
(
TransformMatchingTex
(
new_line2
,
lines
[
3
],
transform_mismatches
=
True
,
),
**
play_kw
)
self
.
wait
(
3
)
self
.
play
(
FadeOut
(
lines
,
RIGHT
))
# Alternatively, if you don't want to think about breaking up
# the tex strings deliberately, you can TransformMatchingShapes,
# which will try to line up all pieces of a source mobject with
# those of a target, regardless of the submobject hierarchy in
# each one, according to whether those pieces have the same
# shape (as best it can).
source
=
Text
(
"the morse code"
,
height
=
1
)
target
=
Text
(
"here come dots"
,
height
=
1
)
self
.
play
(
Write
(
source
))
self
.
wait
()
kw
=
{
"run_time"
:
3
,
"path_arc"
:
PI
/
2
}
self
.
play
(
TransformMatchingShapes
(
source
,
target
,
**
kw
))
self
.
wait
()
self
.
play
(
TransformMatchingShapes
(
target
,
source
,
**
kw
))
self
.
wait
()
The new classes in this scene are
Tex
,
TexText
,
TransformMatchingTex
and
TransformMatchingShapes
.
Tex
uses LaTeX to create mathematical formulas.
TexText
uses LaTeX to create text.
TransformMatchingTeX
automatically transforms sub-objects according to the similarities and differences of tex in
Tex
.
TransformMatchingShapes
automatically transform sub-objects directly based on the similarities and differences of the object point sets.
UpdatersExample
¶
UpdatersExample
¶
class
UpdatersExample
(
Scene
):
def
construct
(
self
):
square
=
Square
()
square
.
set_fill
(
BLUE_E
,
1
)
# On all all frames, the constructor Brace(square, UP) will
# be called, and the mobject brace will set its data to match
# that of the newly constructed object
brace
=
always_redraw
(
Brace
,
square
,
UP
)
text
,
number
=
label
=
VGroup
(
Text
(
"Width = "
),
DecimalNumber
(
0
,
show_ellipsis
=
True
,
num_decimal_places
=
2
,
include_sign
=
True
,
)
)
label
.
arrange
(
RIGHT
)
# This ensures that the method deicmal.next_to(square)
# is called on every frame
always
(
label
.
next_to
,
brace
,
UP
)
# You could also write the following equivalent line
# label.add_updater(lambda m: m.next_to(brace, UP))
# If the argument itself might change, you can use f_always,
# for which the arguments following the initial Mobject method
# should be functions returning arguments to that method.
# The following line ensures that decimal.set_value(square.get_y())
# is called every frame
f_always
(
number
.
set_value
,
square
.
get_width
)
# You could also write the following equivalent line
# number.add_updater(lambda m: m.set_value(square.get_width()))
self
.
add
(
square
,
brace
,
label
)
# Notice that the brace and label track with the square
self
.
play
(
square
.
animate
.
scale
(
2
),
rate_func
=
there_and_back
,
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
5
,
stretch
=
True
),
run_time
=
3
,
)
self
.
wait
()
self
.
play
(
square
.
animate
.
set_width
(
2
),
run_time
=
3
)
self
.
wait
()
# In general, you can alway call Mobject.add_updater, and pass in
# a function that you want to be called on every frame.  The function
# should take in either one argument, the mobject, or two arguments,
# the mobject and the amount of time since the last frame.
now
=
self
.
time
w0
=
square
.
get_width
()
square
.
add_updater
(
lambda
m
:
m
.
set_width
(
w0
*
math
.
cos
(
self
.
time
-
now
))
)
self
.
wait
(
4
*
PI
)
The new classes and usage in this scene are
always_redraw()
,
DecimalNumber
,
.to_edge()
,
.center()
,
always()
,
f_always()
,
.set_y()
and
.add_updater()
.
always_redraw()
function create a new mobject every frame.
DecimalNumber
is a variable number, speed it up by breaking it into
Text
characters.
.to_edge()
means to place the object on the edge of the screen.
.center()
means to place the object in the center of the screen.
always(f,
x)
means that a certain function (
f(x)
) is executed every frame.
f_always(f,
g)
is similar to
always
, executed
f(g())
every frame.
.set_y()
means to set the ordinate of the object on the screen.
.add_updater()
sets an update function for the object. For example:
mob1.add_updater(lambda
mob:
mob.next_to(mob2))
means
mob1.next_to(mob2)
is executed every frame.
CoordinateSystemExample
¶
CoordinateSystemExample
¶
class
CoordinateSystemExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
(
# x-axis ranges from -1 to 10, with a default step size of 1
x_range
=
(
-
1
,
10
),
# y-axis ranges from -2 to 2 with a step size of 0.5
y_range
=
(
-
2
,
2
,
0.5
),
# The axes will be stretched so as to match the specified
# height and width
height
=
6
,
width
=
10
,
# Axes is made of two NumberLine mobjects.  You can specify
# their configuration with axis_config
axis_config
=
{
"stroke_color"
:
GREY_A
,
"stroke_width"
:
2
,
},
# Alternatively, you can specify configuration for just one
# of them, like this.
y_axis_config
=
{
"include_tip"
:
False
,
}
)
# Keyword arguments of add_coordinate_labels can be used to
# configure the DecimalNumber mobjects which it creates and
# adds to the axes
axes
.
add_coordinate_labels
(
font_size
=
20
,
num_decimal_places
=
1
,
)
self
.
add
(
axes
)
# Axes descends from the CoordinateSystem class, meaning
# you can call call axes.coords_to_point, abbreviated to
# axes.c2p, to associate a set of coordinates with a point,
# like so:
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
c2p
(
0
,
0
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
5
,
0.5
)))
self
.
wait
()
# Similarly, you can call axes.point_to_coords, or axes.p2c
# print(axes.p2c(dot.get_center()))
# We can draw lines from the axes to better mark the coordinates
# of a given point.
# Here, the always_redraw command means that on each new frame
# the lines will be redrawn
h_line
=
always_redraw
(
lambda
:
axes
.
get_h_line
(
dot
.
get_left
()))
v_line
=
always_redraw
(
lambda
:
axes
.
get_v_line
(
dot
.
get_bottom
()))
self
.
play
(
ShowCreation
(
h_line
),
ShowCreation
(
v_line
),
)
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
3
,
-
2
)))
self
.
wait
()
self
.
play
(
dot
.
animate
.
move_to
(
axes
.
c2p
(
1
,
1
)))
self
.
wait
()
# If we tie the dot to a particular set of coordinates, notice
# that as we move the axes around it respects the coordinate
# system defined by them.
f_always
(
dot
.
move_to
,
lambda
:
axes
.
c2p
(
1
,
1
))
self
.
play
(
axes
.
animate
.
scale
(
0.75
)
.
to_corner
(
UL
),
run_time
=
2
,
)
self
.
wait
()
self
.
play
(
FadeOut
(
VGroup
(
axes
,
dot
,
h_line
,
v_line
)))
# Other coordinate systems you can play around with include
# ThreeDAxes, NumberPlane, and ComplexPlane.
GraphExample
¶
GraphExample
¶
class
GraphExample
(
Scene
):
def
construct
(
self
):
axes
=
Axes
((
-
3
,
10
),
(
-
1
,
8
))
axes
.
add_coordinate_labels
()
self
.
play
(
Write
(
axes
,
lag_ratio
=
0.01
,
run_time
=
1
))
# Axes.get_graph will return the graph of a function
sin_graph
=
axes
.
get_graph
(
lambda
x
:
2
*
math
.
sin
(
x
),
color
=
BLUE
,
)
# By default, it draws it so as to somewhat smoothly interpolate
# between sampled points (x, f(x)).  If the graph is meant to have
# a corner, though, you can set use_smoothing to False
relu_graph
=
axes
.
get_graph
(
lambda
x
:
max
(
x
,
0
),
use_smoothing
=
False
,
color
=
YELLOW
,
)
# For discontinuous functions, you can specify the point of
# discontinuity so that it does not try to draw over the gap.
step_graph
=
axes
.
get_graph
(
lambda
x
:
2.0
if
x
>
3
else
1.0
,
discontinuities
=
[
3
],
color
=
GREEN
,
)
# Axes.get_graph_label takes in either a string or a mobject.
# If it's a string, it treats it as a LaTeX expression.  By default
# it places the label next to the graph near the right side, and
# has it match the color of the graph
sin_label
=
axes
.
get_graph_label
(
sin_graph
,
"
\\
sin(x)"
)
relu_label
=
axes
.
get_graph_label
(
relu_graph
,
Text
(
"ReLU"
))
step_label
=
axes
.
get_graph_label
(
step_graph
,
Text
(
"Step"
),
x
=
4
)
self
.
play
(
ShowCreation
(
sin_graph
),
FadeIn
(
sin_label
,
RIGHT
),
)
self
.
wait
(
2
)
self
.
play
(
ReplacementTransform
(
sin_graph
,
relu_graph
),
FadeTransform
(
sin_label
,
relu_label
),
)
self
.
wait
()
self
.
play
(
ReplacementTransform
(
relu_graph
,
step_graph
),
FadeTransform
(
relu_label
,
step_label
),
)
self
.
wait
()
parabola
=
axes
.
get_graph
(
lambda
x
:
0.25
*
x
**
2
)
parabola
.
set_stroke
(
BLUE
)
self
.
play
(
FadeOut
(
step_graph
),
FadeOut
(
step_label
),
ShowCreation
(
parabola
)
)
self
.
wait
()
# You can use axes.input_to_graph_point, abbreviated
# to axes.i2gp, to find a particular point on a graph
dot
=
Dot
(
color
=
RED
)
dot
.
move_to
(
axes
.
i2gp
(
2
,
parabola
))
self
.
play
(
FadeIn
(
dot
,
scale
=
0.5
))
# A value tracker lets us animate a parameter, usually
# with the intent of having other mobjects update based
# on the parameter
x_tracker
=
ValueTracker
(
2
)
f_always
(
dot
.
move_to
,
lambda
:
axes
.
i2gp
(
x_tracker
.
get_value
(),
parabola
)
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
4
),
run_time
=
3
)
self
.
play
(
x_tracker
.
animate
.
set_value
(
-
2
),
run_time
=
3
)
self
.
wait
()
SurfaceExample
¶
SurfaceExample
¶
class
SurfaceExample
(
Scene
):
CONFIG
=
{
"camera_class"
:
ThreeDCamera
,
}
def
construct
(
self
):
surface_text
=
Text
(
"For 3d scenes, try using surfaces"
)
surface_text
.
fix_in_frame
()
surface_text
.
to_edge
(
UP
)
self
.
add
(
surface_text
)
self
.
wait
(
0.1
)
torus1
=
Torus
(
r1
=
1
,
r2
=
1
)
torus2
=
Torus
(
r1
=
3
,
r2
=
1
)
sphere
=
Sphere
(
radius
=
3
,
resolution
=
torus1
.
resolution
)
# You can texture a surface with up to two images, which will
# be interpreted as the side towards the light, and away from
# the light.  These can be either urls, or paths to a local file
# in whatever you've set as the image directory in
# the custom_config.yml file
# day_texture = "EarthTextureMap"
# night_texture = "NightEarthTextureMap"
day_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
night_texture
=
"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"
surfaces
=
[
TexturedSurface
(
surface
,
day_texture
,
night_texture
)
for
surface
in
[
sphere
,
torus1
,
torus2
]
]
for
mob
in
surfaces
:
mob
.
shift
(
IN
)
mob
.
mesh
=
SurfaceMesh
(
mob
)
mob
.
mesh
.
set_stroke
(
BLUE
,
1
,
opacity
=
0.5
)
# Set perspective
frame
=
self
.
camera
.
frame
frame
.
set_euler_angles
(
theta
=-
30
*
DEGREES
,
phi
=
70
*
DEGREES
,
)
surface
=
surfaces
[
0
]
self
.
play
(
FadeIn
(
surface
),
ShowCreation
(
surface
.
mesh
,
lag_ratio
=
0.01
,
run_time
=
3
),
)
for
mob
in
surfaces
:
mob
.
add
(
mob
.
mesh
)
surface
.
save_state
()
self
.
play
(
Rotate
(
surface
,
PI
/
2
),
run_time
=
2
)
for
mob
in
surfaces
[
1
:]:
mob
.
rotate
(
PI
/
2
)
self
.
play
(
Transform
(
surface
,
surfaces
[
1
]),
run_time
=
3
)
self
.
play
(
Transform
(
surface
,
surfaces
[
2
]),
# Move camera frame during the transition
frame
.
animate
.
increment_phi
(
-
10
*
DEGREES
),
frame
.
animate
.
increment_theta
(
-
20
*
DEGREES
),
run_time
=
3
)
# Add ambient rotation
frame
.
add_updater
(
lambda
m
,
dt
:
m
.
increment_theta
(
-
0.1
*
dt
))
# Play around with where the light is
light_text
=
Text
(
"You can move around the light source"
)
light_text
.
move_to
(
surface_text
)
light_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
surface_text
,
light_text
))
light
=
self
.
camera
.
light_source
self
.
add
(
light
)
light
.
save_state
()
self
.
play
(
light
.
animate
.
move_to
(
3
*
IN
),
run_time
=
5
)
self
.
play
(
light
.
animate
.
shift
(
10
*
OUT
),
run_time
=
5
)
drag_text
=
Text
(
"Try moving the mouse while pressing d or s"
)
drag_text
.
move_to
(
light_text
)
drag_text
.
fix_in_frame
()
self
.
play
(
FadeTransform
(
light_text
,
drag_text
))
self
.
wait
()
This scene shows an example of using a three-dimensional surface, and
the related usage has been briefly described in the notes.
.fix_in_frame()
makes the object not change with the view angle of the screen, and is always displayed at a fixed position on the screen.
OpeningManimExample
¶
OpeningManimExample
¶
class
OpeningManimExample
(
Scene
):
def
construct
(
self
):
intro_words
=
Text
(
"""
The original motivation for manim was to
better illustrate mathematical functions
as transformations.
"""
)
intro_words
.
to_edge
(
UP
)
self
.
play
(
Write
(
intro_words
))
self
.
wait
(
2
)
# Linear transform
grid
=
NumberPlane
((
-
10
,
10
),
(
-
5
,
5
))
matrix
=
[[
1
,
1
],
[
0
,
1
]]
linear_transform_words
=
VGroup
(
Text
(
"This is what the matrix"
),
IntegerMatrix
(
matrix
,
include_background_rectangle
=
True
),
Text
(
"looks like"
)
)
linear_transform_words
.
arrange
(
RIGHT
)
linear_transform_words
.
to_edge
(
UP
)
linear_transform_words
.
set_stroke
(
BLACK
,
10
,
background
=
True
)
self
.
play
(
ShowCreation
(
grid
),
FadeTransform
(
intro_words
,
linear_transform_words
)
)
self
.
wait
()
self
.
play
(
grid
.
animate
.
apply_matrix
(
matrix
),
run_time
=
3
)
self
.
wait
()
# Complex map
c_grid
=
ComplexPlane
()
moving_c_grid
=
c_grid
.
copy
()
moving_c_grid
.
prepare_for_nonlinear_transform
()
c_grid
.
set_stroke
(
BLUE_E
,
1
)
c_grid
.
add_coordinate_labels
(
font_size
=
24
)
complex_map_words
=
TexText
(
"""
Or thinking of the plane as $
\\
mathds
{C}
$,
\\\\
this is the map $z
\\
rightarrow z^2$
"""
)
complex_map_words
.
to_corner
(
UR
)
complex_map_words
.
set_stroke
(
BLACK
,
5
,
background
=
True
)
self
.
play
(
FadeOut
(
grid
),
Write
(
c_grid
,
run_time
=
3
),
FadeIn
(
moving_c_grid
),
FadeTransform
(
linear_transform_words
,
complex_map_words
),
)
self
.
wait
()
self
.
play
(
moving_c_grid
.
animate
.
apply_complex_function
(
lambda
z
:
z
**
2
),
run_time
=
6
,
)
self
.
wait
(
2
)
This scene is a comprehensive application of a two-dimensional scene.
After seeing these scenes, you have already understood part of the
usage of manim. For more examples, see
the video code of 3b1b
.
Contents
Example Scenes
InteractiveDevlopment
AnimatingMethods
TextExample
TexTransformExample
UpdatersExample
CoordinateSystemExample
GraphExample
SurfaceExample
OpeningManimExample

Code Examples:
Example 1:
```python
example_scenes.py
```
Example 2:
```python
from manimlib import *

class InteractiveDevelopment(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(BLUE, opacity=0.5)
        circle.set_stroke(BLUE_E, width=4)
        square = Square()

        self.play(ShowCreation(square))
        self.wait()

        # This opens an iPython terminal where you can keep writing
        # lines as if they were part of this construct method.
        # In particular, 'square', 'circle' and 'self' will all be
        # part of the local namespace in that terminal.
        self.embed()

        # Try copying and pasting some of the lines below into
        # the interactive shell
        self.play(ReplacementTransform(square, circle))
        self.wait()
        self.play(circle.animate.stretch(4, 0))
        self.play(Rotate(circle, 90 * DEGREES))
        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))

        text = Text("""
            In general, using the interactive shell
            is very helpful when developing new scenes
        """)
        self.play(Write(text))

        # In the interactive shell, you can just type
        # play, add, remove, clear, wait, save_state and restore,
        # instead of self.play, self.add, self.remove, etc.

        # To interact with the window, type touch().  You can then
        # scroll in the window, or zoom by holding down 'z' while scrolling,
        # and change camera perspective by holding down 'd' while moving
        # the mouse.  Press 'r' to reset to the standard camera position.
        # Press 'q' to stop interacting with the window and go back to
        # typing new commands into the shell.

        # In principle you can customize a scene to be responsive to
        # mouse and keyboard interactions
        always(circle.move_to, self.mouse_point)
```
Example 3:
```python
class AnimatingMethods(Scene):
    def construct(self):
        grid = OldTex(r"\pi").get_grid(10, 10, height=4)
        self.add(grid)

        # You can animate the application of mobject methods with the
        # ".animate" syntax:
        self.play(grid.animate.shift(LEFT))

        # Alternatively, you can use the older syntax by passing the
        # method and then the arguments to the scene's "play" function:
        self.play(grid.shift, LEFT)

        # Both of those will interpolate between the mobject's initial
        # state and whatever happens when you apply that method.
        # For this example, calling grid.shift(LEFT) would shift the
        # grid one unit to the left, but both of the previous calls to
        # "self.play" animate that motion.

        # The same applies for any method, including those setting colors.
        self.play(grid.animate.set_color(YELLOW))
        self.wait()
        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))
        self.wait()
        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))
        self.wait()

        # The method Mobject.apply_complex_function lets you apply arbitrary
        # complex functions, treating the points defining the mobject as
        # complex numbers.
        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)
        self.wait()

        # Even more generally, you could apply Mobject.apply_function,
        # which takes in functions form R^3 to R^3
        self.play(
            grid.animate.apply_function(
                lambda p: [
                    p[0] + 0.5 * math.sin(p[1]),
                    p[1] + 0.5 * math.sin(p[0]),
                    p[2]
                ]
            ),
            run_time=5,
        )
        self.wait()
```
Example 4:
```python
.get_grid()
```
Example 5:
```python
self.play(mob.animate.method(args))
```
Example 6:
```python
.get_grid()
```
Example 7:
```python
self.play(mob.animate.method(args))
```
Example 8:
```python
class TextExample(Scene):
    def construct(self):
        # To run this scene properly, you should have "Consolas" font in your computer
        # for full usage, you can see https://github.com/3b1b/manim/pull/680
        text = Text("Here is a text", font="Consolas", font_size=90)
        difference = Text(
            """
            The most important difference between Text and TexText is that\n
            you can change the font more easily, but can't use the LaTeX grammar
            """,
            font="Arial", font_size=24,
            # t2c is a dict that you can choose color for different text
            t2c={"Text": BLUE, "TexText": BLUE, "LaTeX": ORANGE}
        )
        VGroup(text, difference).arrange(DOWN, buff=1)
        self.play(Write(text))
        self.play(FadeIn(difference, UP))
        self.wait(3)

        fonts = Text(
            "And you can also set the font according to different words",
            font="Arial",
            t2f={"font": "Consolas", "words": "Consolas"},
            t2c={"font": BLUE, "words": GREEN}
        )
        fonts.set_width(FRAME_WIDTH - 1)
        slant = Text(
            "And the same as slant and weight",
            font="Consolas",
            t2s={"slant": ITALIC},
            t2w={"weight": BOLD},
            t2c={"slant": ORANGE, "weight": RED}
        )
        VGroup(fonts, slant).arrange(DOWN, buff=0.8)
        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))
        self.play(Write(fonts))
        self.wait()
        self.play(Write(slant))
        self.wait()
```
Example 9:
```python
class TexTransformExample(Scene):
    def construct(self):
        to_isolate = ["B", "C", "=", "(", ")"]
        lines = VGroup(
            # Passing in muliple arguments to Tex will result
            # in the same expression as if those arguments had
            # been joined together, except that the submobject
            # hierarchy of the resulting mobject ensure that the
            # Tex mobject has a subject corresponding to
            # each of these strings.  For example, the Tex mobject
            # below will have 5 subjects, corresponding to the
            # expressions [A^2, +, B^2, =, C^2]
            OldTex("A^2", "+", "B^2", "=", "C^2"),
            # Likewise here
            OldTex("A^2", "=", "C^2", "-", "B^2"),
            # Alternatively, you can pass in the keyword argument
            # "isolate" with a list of strings that should be out as
            # their own submobject.  So the line below is equivalent
            # to the commented out line below it.
            OldTex("A^2 = (C + B)(C - B)", isolate=["A^2", *to_isolate]),
            # OldTex("A^2", "=", "(", "C", "+", "B", ")", "(", "C", "-", "B", ")"),
            OldTex("A = \\sqrt{(C + B)(C - B)}", isolate=["A", *to_isolate])
        )
        lines.arrange(DOWN, buff=LARGE_BUFF)
        for line in lines:
            line.set_color_by_tex_to_color_map({
                "A": BLUE,
                "B": TEAL,
                "C": GREEN,
            })

        play_kw = {"run_time": 2}
        self.add(lines[0])
        # The animation TransformMatchingTex will line up parts
        # of the source and target which have matching tex strings.
        # Here, giving it a little path_arc makes each part sort of
        # rotate into their final positions, which feels appropriate
        # for the idea of rearranging an equation
        self.play(
            TransformMatchingTex(
                lines[0].copy(), lines[1],
                path_arc=90 * DEGREES,
            ),
            **play_kw
        )
        self.wait()

        # Now, we could try this again on the next line...
        self.play(
            TransformMatchingTex(lines[1].copy(), lines[2]),
            **play_kw
        )
        self.wait()
        # ...and this looks nice enough, but since there's no tex
        # in lines[2] which matches "C^2" or "B^2", those terms fade
        # out to nothing while the C and B terms fade in from nothing.
        # If, however, we want the C^2 to go to C, and B^2 to go to B,
        # we can specify that with a key map.
        self.play(FadeOut(lines[2]))
        self.play(
            TransformMatchingTex(
                lines[1].copy(), lines[2],
                key_map={
                    "C^2": "C",
                    "B^2": "B",
                }
            ),
            **play_kw
        )
        self.wait()

        # And to finish off, a simple TransformMatchingShapes would work
        # just fine.  But perhaps we want that exponent on A^2 to transform into
        # the square root symbol.  At the moment, lines[2] treats the expression
        # A^2 as a unit, so we might create a new version of the same line which
        # separates out just the A.  This way, when TransformMatchingTex lines up
        # all matching parts, the only mismatch will be between the "^2" from
        # new_line2 and the "\sqrt" from the final line.  By passing in,
        # transform_mismatches=True, it will transform this "^2" part into
        # the "\sqrt" part.
        new_line2 = OldTex("A^2 = (C + B)(C - B)", isolate=["A", *to_isolate])
        new_line2.replace(lines[2])
        new_line2.match_style(lines[2])

        self.play(
            TransformMatchingTex(
                new_line2, lines[3],
                transform_mismatches=True,
            ),
            **play_kw
        )
        self.wait(3)
        self.play(FadeOut(lines, RIGHT))

        # Alternatively, if you don't want to think about breaking up
        # the tex strings deliberately, you can TransformMatchingShapes,
        # which will try to line up all pieces of a source mobject with
        # those of a target, regardless of the submobject hierarchy in
        # each one, according to whether those pieces have the same
        # shape (as best it can).
        source = Text("the morse code", height=1)
        target = Text("here come dots", height=1)

        self.play(Write(source))
        self.wait()
        kw = {"run_time": 3, "path_arc": PI / 2}
        self.play(TransformMatchingShapes(source, target, **kw))
        self.wait()
        self.play(TransformMatchingShapes(target, source, **kw))
        self.wait()
```
Example 10:
```python
TransformMatchingTex
```
Example 11:
```python
TransformMatchingShapes
```
Example 12:
```python
TransformMatchingTeX
```
Example 13:
```python
TransformMatchingShapes
```
Example 14:
```python
class UpdatersExample(Scene):
    def construct(self):
        square = Square()
        square.set_fill(BLUE_E, 1)

        # On all all frames, the constructor Brace(square, UP) will
        # be called, and the mobject brace will set its data to match
        # that of the newly constructed object
        brace = always_redraw(Brace, square, UP)

        text, number = label = VGroup(
            Text("Width = "),
            DecimalNumber(
                0,
                show_ellipsis=True,
                num_decimal_places=2,
                include_sign=True,
            )
        )
        label.arrange(RIGHT)

        # This ensures that the method deicmal.next_to(square)
        # is called on every frame
        always(label.next_to, brace, UP)
        # You could also write the following equivalent line
        # label.add_updater(lambda m: m.next_to(brace, UP))

        # If the argument itself might change, you can use f_always,
        # for which the arguments following the initial Mobject method
        # should be functions returning arguments to that method.
        # The following line ensures that decimal.set_value(square.get_y())
        # is called every frame
        f_always(number.set_value, square.get_width)
        # You could also write the following equivalent line
        # number.add_updater(lambda m: m.set_value(square.get_width()))

        self.add(square, brace, label)

        # Notice that the brace and label track with the square
        self.play(
            square.animate.scale(2),
            rate_func=there_and_back,
            run_time=2,
        )
        self.wait()
        self.play(
            square.animate.set_width(5, stretch=True),
            run_time=3,
        )
        self.wait()
        self.play(
            square.animate.set_width(2),
            run_time=3
        )
        self.wait()

        # In general, you can alway call Mobject.add_updater, and pass in
        # a function that you want to be called on every frame.  The function
        # should take in either one argument, the mobject, or two arguments,
        # the mobject and the amount of time since the last frame.
        now = self.time
        w0 = square.get_width()
        square.add_updater(
            lambda m: m.set_width(w0 * math.cos(self.time - now))
        )
        self.wait(4 * PI)
```
Example 15:
```python
always_redraw()
```
Example 16:
```python
DecimalNumber
```
Example 17:
```python
.add_updater()
```
Example 18:
```python
always_redraw()
```
Example 19:
```python
DecimalNumber
```
Example 20:
```python
always(f, x)
```
Example 21:
```python
f_always(f, g)
```
Example 22:
```python
.add_updater()
```
Example 23:
```python
mob1.add_updater(lambda mob: mob.next_to(mob2))
```
Example 24:
```python
mob1.next_to(mob2)
```
Example 25:
```python
class CoordinateSystemExample(Scene):
    def construct(self):
        axes = Axes(
            # x-axis ranges from -1 to 10, with a default step size of 1
            x_range=(-1, 10),
            # y-axis ranges from -2 to 2 with a step size of 0.5
            y_range=(-2, 2, 0.5),
            # The axes will be stretched so as to match the specified
            # height and width
            height=6,
            width=10,
            # Axes is made of two NumberLine mobjects.  You can specify
            # their configuration with axis_config
            axis_config={
                "stroke_color": GREY_A,
                "stroke_width": 2,
            },
            # Alternatively, you can specify configuration for just one
            # of them, like this.
            y_axis_config={
                "include_tip": False,
            }
        )
        # Keyword arguments of add_coordinate_labels can be used to
        # configure the DecimalNumber mobjects which it creates and
        # adds to the axes
        axes.add_coordinate_labels(
            font_size=20,
            num_decimal_places=1,
        )
        self.add(axes)

        # Axes descends from the CoordinateSystem class, meaning
        # you can call call axes.coords_to_point, abbreviated to
        # axes.c2p, to associate a set of coordinates with a point,
        # like so:
        dot = Dot(color=RED)
        dot.move_to(axes.c2p(0, 0))
        self.play(FadeIn(dot, scale=0.5))
        self.play(dot.animate.move_to(axes.c2p(3, 2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))
        self.wait()

        # Similarly, you can call axes.point_to_coords, or axes.p2c
        # print(axes.p2c(dot.get_center()))

        # We can draw lines from the axes to better mark the coordinates
        # of a given point.
        # Here, the always_redraw command means that on each new frame
        # the lines will be redrawn
        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))
        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))

        self.play(
            ShowCreation(h_line),
            ShowCreation(v_line),
        )
        self.play(dot.animate.move_to(axes.c2p(3, -2)))
        self.wait()
        self.play(dot.animate.move_to(axes.c2p(1, 1)))
        self.wait()

        # If we tie the dot to a particular set of coordinates, notice
        # that as we move the axes around it respects the coordinate
        # system defined by them.
        f_always(dot.move_to, lambda: axes.c2p(1, 1))
        self.play(
            axes.animate.scale(0.75).to_corner(UL),
            run_time=2,
        )
        self.wait()
        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))

        # Other coordinate systems you can play around with include
        # ThreeDAxes, NumberPlane, and ComplexPlane.
```
Example 26:
```python
class GraphExample(Scene):
    def construct(self):
        axes = Axes((-3, 10), (-1, 8))
        axes.add_coordinate_labels()

        self.play(Write(axes, lag_ratio=0.01, run_time=1))

        # Axes.get_graph will return the graph of a function
        sin_graph = axes.get_graph(
            lambda x: 2 * math.sin(x),
            color=BLUE,
        )
        # By default, it draws it so as to somewhat smoothly interpolate
        # between sampled points (x, f(x)).  If the graph is meant to have
        # a corner, though, you can set use_smoothing to False
        relu_graph = axes.get_graph(
            lambda x: max(x, 0),
            use_smoothing=False,
            color=YELLOW,
        )
        # For discontinuous functions, you can specify the point of
        # discontinuity so that it does not try to draw over the gap.
        step_graph = axes.get_graph(
            lambda x: 2.0 if x > 3 else 1.0,
            discontinuities=[3],
            color=GREEN,
        )

        # Axes.get_graph_label takes in either a string or a mobject.
        # If it's a string, it treats it as a LaTeX expression.  By default
        # it places the label next to the graph near the right side, and
        # has it match the color of the graph
        sin_label = axes.get_graph_label(sin_graph, "\\sin(x)")
        relu_label = axes.get_graph_label(relu_graph, Text("ReLU"))
        step_label = axes.get_graph_label(step_graph, Text("Step"), x=4)

        self.play(
            ShowCreation(sin_graph),
            FadeIn(sin_label, RIGHT),
        )
        self.wait(2)
        self.play(
            ReplacementTransform(sin_graph, relu_graph),
            FadeTransform(sin_label, relu_label),
        )
        self.wait()
        self.play(
            ReplacementTransform(relu_graph, step_graph),
            FadeTransform(relu_label, step_label),
        )
        self.wait()

        parabola = axes.get_graph(lambda x: 0.25 * x**2)
        parabola.set_stroke(BLUE)
        self.play(
            FadeOut(step_graph),
            FadeOut(step_label),
            ShowCreation(parabola)
        )
        self.wait()

        # You can use axes.input_to_graph_point, abbreviated
        # to axes.i2gp, to find a particular point on a graph
        dot = Dot(color=RED)
        dot.move_to(axes.i2gp(2, parabola))
        self.play(FadeIn(dot, scale=0.5))

        # A value tracker lets us animate a parameter, usually
        # with the intent of having other mobjects update based
        # on the parameter
        x_tracker = ValueTracker(2)
        f_always(
            dot.move_to,
            lambda: axes.i2gp(x_tracker.get_value(), parabola)
        )

        self.play(x_tracker.animate.set_value(4), run_time=3)
        self.play(x_tracker.animate.set_value(-2), run_time=3)
        self.wait()
```
Example 27:
```python
class SurfaceExample(Scene):
    CONFIG = {
        "camera_class": ThreeDCamera,
    }

    def construct(self):
        surface_text = Text("For 3d scenes, try using surfaces")
        surface_text.fix_in_frame()
        surface_text.to_edge(UP)
        self.add(surface_text)
        self.wait(0.1)

        torus1 = Torus(r1=1, r2=1)
        torus2 = Torus(r1=3, r2=1)
        sphere = Sphere(radius=3, resolution=torus1.resolution)
        # You can texture a surface with up to two images, which will
        # be interpreted as the side towards the light, and away from
        # the light.  These can be either urls, or paths to a local file
        # in whatever you've set as the image directory in
        # the custom_config.yml file

        # day_texture = "EarthTextureMap"
        # night_texture = "NightEarthTextureMap"
        day_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
        night_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"

        surfaces = [
            TexturedSurface(surface, day_texture, night_texture)
            for surface in [sphere, torus1, torus2]
        ]

        for mob in surfaces:
            mob.shift(IN)
            mob.mesh = SurfaceMesh(mob)
            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)

        # Set perspective
        frame = self.camera.frame
        frame.set_euler_angles(
            theta=-30 * DEGREES,
            phi=70 * DEGREES,
        )

        surface = surfaces[0]

        self.play(
            FadeIn(surface),
            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),
        )
        for mob in surfaces:
            mob.add(mob.mesh)
        surface.save_state()
        self.play(Rotate(surface, PI / 2), run_time=2)
        for mob in surfaces[1:]:
            mob.rotate(PI / 2)

        self.play(
            Transform(surface, surfaces[1]),
            run_time=3
        )

        self.play(
            Transform(surface, surfaces[2]),
            # Move camera frame during the transition
            frame.animate.increment_phi(-10 * DEGREES),
            frame.animate.increment_theta(-20 * DEGREES),
            run_time=3
        )
        # Add ambient rotation
        frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))

        # Play around with where the light is
        light_text = Text("You can move around the light source")
        light_text.move_to(surface_text)
        light_text.fix_in_frame()

        self.play(FadeTransform(surface_text, light_text))
        light = self.camera.light_source
        self.add(light)
        light.save_state()
        self.play(light.animate.move_to(3 * IN), run_time=5)
        self.play(light.animate.shift(10 * OUT), run_time=5)

        drag_text = Text("Try moving the mouse while pressing d or s")
        drag_text.move_to(light_text)
        drag_text.fix_in_frame()

        self.play(FadeTransform(light_text, drag_text))
        self.wait()
```
Example 28:
```python
.fix_in_frame()
```
Example 29:
```python
class OpeningManimExample(Scene):
    def construct(self):
        intro_words = Text("""
            The original motivation for manim was to
            better illustrate mathematical functions
            as transformations.
        """)
        intro_words.to_edge(UP)

        self.play(Write(intro_words))
        self.wait(2)

        # Linear transform
        grid = NumberPlane((-10, 10), (-5, 5))
        matrix = [[1, 1], [0, 1]]
        linear_transform_words = VGroup(
            Text("This is what the matrix"),
            IntegerMatrix(matrix, include_background_rectangle=True),
            Text("looks like")
        )
        linear_transform_words.arrange(RIGHT)
        linear_transform_words.to_edge(UP)
        linear_transform_words.set_stroke(BLACK, 10, background=True)

        self.play(
            ShowCreation(grid),
            FadeTransform(intro_words, linear_transform_words)
        )
        self.wait()
        self.play(grid.animate.apply_matrix(matrix), run_time=3)
        self.wait()

        # Complex map
        c_grid = ComplexPlane()
        moving_c_grid = c_grid.copy()
        moving_c_grid.prepare_for_nonlinear_transform()
        c_grid.set_stroke(BLUE_E, 1)
        c_grid.add_coordinate_labels(font_size=24)
        complex_map_words = TexText("""
            Or thinking of the plane as $\\mathds{C}$,\\\\
            this is the map $z \\rightarrow z^2$
        """)
        complex_map_words.to_corner(UR)
        complex_map_words.set_stroke(BLACK, 5, background=True)

        self.play(
            FadeOut(grid),
            Write(c_grid, run_time=3),
            FadeIn(moving_c_grid),
            FadeTransform(linear_transform_words, complex_map_words),
        )
        self.wait()
        self.play(
            moving_c_grid.animate.apply_complex_function(lambda z: z**2),
            run_time=6,
        )
        self.wait(2)
```

================================================================================

=== Manim’s structure - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/structure.html#manim-s-directory-structure
Content:
Manim’s structure
¶
Manim’s directory structure
¶
The manim directory looks very complicated, with a lot of files,
but the structure is clear.
Below is the directory structure of manim:
manimlib/ # manim library
├── __init__.py
├── __main__.py
├── default_config.yml   # Default configuration file
├── config.py            # Process CLI flags
├── constants.py         # Defined some constants
├── extract_scene.py     # Extract and run the scene
├── shader_wrapper.py    # Shaders' Wrapper for convenient control
├── window.py            # Playback window
├── tex_templates/ # Templates preset for LaTeX
│   ├── tex_templates.tex   # Tex template (will be compiled with latex, default)
│   └── ctex_templates.tex  # Tex template that support Chinese (will be compiled with xelatex)
├── camera/
│   └── camera.py        # Including Camera and CameraFrame
├── scene/
│   ├── scene_file_writer.py     # Used to write scene to video file
│   ├── scene.py                 # The basic Scene class
│   ├── three_d_scene.py         # Three-dimensional scene
│   ├── sample_space_scene.py    # Probability related sample space scene
│   └── vector_space_scene.py    # Vector field scene
├── animation/
│   ├── animation.py     # The basic class of animation
│   ├── composition.py   # Animation group
│   ├── creation.py      # Animation related to Create
│   ├── fading.py        # Fade related animation
│   ├── growing.py       # Animation related to Grow
│   ├── indication.py    # Some animations for emphasis
│   ├── movement.py      # Animation related to movement
│   ├── numbers.py       # Realize changes to DecimalNumber
│   ├── rotation.py      # Animation related to rotation
│   ├── specialized.py   # Some uncommon animations for special projects
│   ├── transform_matching_parts.py # Transform which can automatically match parts
│   ├── transform.py     # Some Transforms
│   └── update.py        # Realize update from function
├── mobject/
│   ├── mobject.py       # The basic class of all math object
│   ├── types/ # 4 types of mobject
│   │   ├── dot_cloud.py            # Dot cloud (an subclass of PMobject)
│   │   ├── image_mobject.py        # Insert pictures
│   │   ├── point_cloud_mobject.py  # PMobject (mobject composed of points)
│   │   ├── surface.py              # ParametricSurface
│   │   └── vectorized_mobject.py   # VMobject (vectorized mobject)
│   ├── svg/ # mobject related to svg
│   │   ├── svg_mobject.py          # SVGMobject
│   │   ├── brace.py                # Brace
│   │   ├── drawings.py             # Some special mobject of svg image
│   │   ├── tex_mobject.py          # Tex and TexText implemented by LaTeX
│   │   └── text_mobject.py         # Text implemented by manimpango
│   ├── changing.py             # Dynamically changing mobject
│   ├── coordinate_systems.py   # coordinate system
│   ├── frame.py                # mobject related to frame
│   ├── functions.py            # ParametricFunction
│   ├── geometry.py             # geometry mobjects
│   ├── matrix.py               # matrix
│   ├── mobject_update_utils.py # some defined updater
│   ├── number_line.py          # Number line
│   ├── numbers.py              # Numbers that can be changed
│   ├── probability.py          # mobject related to probability
│   ├── shape_matchers.py       # mobject adapted to the size of other objects
│   ├── three_dimensions.py     # Three-dimensional objects
│   ├── value_tracker.py        # ValueTracker which storage number
│   └── vector_field.py         # VectorField
├── once_useful_constructs/  # 3b1b's Common scenes written for some videos
│   └── ...
├── shaders/ # GLSL scripts for rendering
│   ├── simple_vert.glsl    # a simple glsl script for position
│   ├── insert/ # glsl scripts to be inserted in other glsl scripts
│   │   ├── NOTE.md   # explain how to insert glsl scripts
│   │   └── ...       # useful scripts
│   ├── image/ # glsl for images
│   │   └── ... # containing shaders for vertex and fragment
│   ├── quadratic_bezier_fill/ # glsl for the fill of quadratic bezier curve
│   │   └── ... # containing shaders for vertex, fragment and geometry
│   ├── quadratic_bezier_stroke/ # glsl for the stroke of quadratic bezier curve
│   │   └── ... # containing shaders for vertex, fragment and geometry
│   ├── surface/ # glsl for surfaces
│   │   └── ... # containing shaders for vertex and fragment
│   ├── textured_surface/ # glsl for textured_surface
│   │   └── ... # containing shaders for vertex and fragment
│   └── true_dot/ # glsl for a dot
│       └── ... # containing shaders for vertex, fragment and geometry
└── utils/ # Some useful utility functions
    ├── bezier.py             # For bezier curve
    ├── color.py              # For color
    ├── dict_ops.py           # Functions related to dictionary processing
    ├── customization.py      # Read from custom_config.yml
    ├── debug.py              # Utilities for debugging in program
    ├── directories.py        # Read directories from config file
    ├── family_ops.py         # Process family members
    ├── file_ops.py           # Process files and directories
    ├── images.py             # Read image
    ├── init_config.py        # Configuration guide
    ├── iterables.py          # Functions related to list/dictionary processing
    ├── paths.py              # Curve path
    ├── rate_functions.py     # Some defined rate_functions
    ├── simple_functions.py   # Some commonly used functions
    ├── sounds.py             # Process sounds
    ├── space_ops.py          # Space coordinate calculation
    ├── strings.py            # Process strings
    └── tex_file_writing.py   # Use LaTeX to write strings as svg
Inheritance structure of manim’s classes
¶
Here
is a pdf showed inheritance structure of manim’s classes, large,
but basically all classes have included:
Manim execution process
¶
Contents
Manim’s structure
Manim’s directory structure
Inheritance structure of manim’s classes
Manim execution process

Code Examples:
Example 1:
```python
manimlib/ # manim library
├── __init__.py
├── __main__.py
├── default_config.yml   # Default configuration file
├── config.py            # Process CLI flags
├── constants.py         # Defined some constants
├── extract_scene.py     # Extract and run the scene
├── shader_wrapper.py    # Shaders' Wrapper for convenient control
├── window.py            # Playback window
├── tex_templates/ # Templates preset for LaTeX
│   ├── tex_templates.tex   # Tex template (will be compiled with latex, default)
│   └── ctex_templates.tex  # Tex template that support Chinese (will be compiled with xelatex)
├── camera/
│   └── camera.py        # Including Camera and CameraFrame
├── scene/
│   ├── scene_file_writer.py     # Used to write scene to video file
│   ├── scene.py                 # The basic Scene class
│   ├── three_d_scene.py         # Three-dimensional scene
│   ├── sample_space_scene.py    # Probability related sample space scene
│   └── vector_space_scene.py    # Vector field scene
├── animation/
│   ├── animation.py     # The basic class of animation
│   ├── composition.py   # Animation group
│   ├── creation.py      # Animation related to Create
│   ├── fading.py        # Fade related animation
│   ├── growing.py       # Animation related to Grow
│   ├── indication.py    # Some animations for emphasis
│   ├── movement.py      # Animation related to movement
│   ├── numbers.py       # Realize changes to DecimalNumber
│   ├── rotation.py      # Animation related to rotation
│   ├── specialized.py   # Some uncommon animations for special projects
│   ├── transform_matching_parts.py # Transform which can automatically match parts
│   ├── transform.py     # Some Transforms
│   └── update.py        # Realize update from function
├── mobject/
│   ├── mobject.py       # The basic class of all math object
│   ├── types/ # 4 types of mobject
│   │   ├── dot_cloud.py            # Dot cloud (an subclass of PMobject)
│   │   ├── image_mobject.py        # Insert pictures
│   │   ├── point_cloud_mobject.py  # PMobject (mobject composed of points)
│   │   ├── surface.py              # ParametricSurface
│   │   └── vectorized_mobject.py   # VMobject (vectorized mobject)
│   ├── svg/ # mobject related to svg
│   │   ├── svg_mobject.py          # SVGMobject
│   │   ├── brace.py                # Brace
│   │   ├── drawings.py             # Some special mobject of svg image
│   │   ├── tex_mobject.py          # Tex and TexText implemented by LaTeX
│   │   └── text_mobject.py         # Text implemented by manimpango
│   ├── changing.py             # Dynamically changing mobject
│   ├── coordinate_systems.py   # coordinate system
│   ├── frame.py                # mobject related to frame
│   ├── functions.py            # ParametricFunction
│   ├── geometry.py             # geometry mobjects
│   ├── matrix.py               # matrix
│   ├── mobject_update_utils.py # some defined updater
│   ├── number_line.py          # Number line
│   ├── numbers.py              # Numbers that can be changed
│   ├── probability.py          # mobject related to probability
│   ├── shape_matchers.py       # mobject adapted to the size of other objects
│   ├── three_dimensions.py     # Three-dimensional objects
│   ├── value_tracker.py        # ValueTracker which storage number
│   └── vector_field.py         # VectorField
├── once_useful_constructs/  # 3b1b's Common scenes written for some videos
│   └── ...
├── shaders/ # GLSL scripts for rendering
│   ├── simple_vert.glsl    # a simple glsl script for position
│   ├── insert/ # glsl scripts to be inserted in other glsl scripts
│   │   ├── NOTE.md   # explain how to insert glsl scripts
│   │   └── ...       # useful scripts
│   ├── image/ # glsl for images
│   │   └── ... # containing shaders for vertex and fragment
│   ├── quadratic_bezier_fill/ # glsl for the fill of quadratic bezier curve
│   │   └── ... # containing shaders for vertex, fragment and geometry
│   ├── quadratic_bezier_stroke/ # glsl for the stroke of quadratic bezier curve
│   │   └── ... # containing shaders for vertex, fragment and geometry
│   ├── surface/ # glsl for surfaces
│   │   └── ... # containing shaders for vertex and fragment
│   ├── textured_surface/ # glsl for textured_surface
│   │   └── ... # containing shaders for vertex and fragment
│   └── true_dot/ # glsl for a dot
│       └── ... # containing shaders for vertex, fragment and geometry
└── utils/ # Some useful utility functions
    ├── bezier.py             # For bezier curve
    ├── color.py              # For color
    ├── dict_ops.py           # Functions related to dictionary processing
    ├── customization.py      # Read from custom_config.yml
    ├── debug.py              # Utilities for debugging in program
    ├── directories.py        # Read directories from config file
    ├── family_ops.py         # Process family members
    ├── file_ops.py           # Process files and directories
    ├── images.py             # Read image
    ├── init_config.py        # Configuration guide
    ├── iterables.py          # Functions related to list/dictionary processing
    ├── paths.py              # Curve path
    ├── rate_functions.py     # Some defined rate_functions
    ├── simple_functions.py   # Some commonly used functions
    ├── sounds.py             # Process sounds
    ├── space_ops.py          # Space coordinate calculation
    ├── strings.py            # Process strings
    └── tex_file_writing.py   # Use LaTeX to write strings as svg
```

================================================================================

=== Manim’s structure - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/structure.html#inheritance-structure-of-manim-s-classes
Content:
Manim’s structure
¶
Manim’s directory structure
¶
The manim directory looks very complicated, with a lot of files,
but the structure is clear.
Below is the directory structure of manim:
manimlib/ # manim library
├── __init__.py
├── __main__.py
├── default_config.yml   # Default configuration file
├── config.py            # Process CLI flags
├── constants.py         # Defined some constants
├── extract_scene.py     # Extract and run the scene
├── shader_wrapper.py    # Shaders' Wrapper for convenient control
├── window.py            # Playback window
├── tex_templates/ # Templates preset for LaTeX
│   ├── tex_templates.tex   # Tex template (will be compiled with latex, default)
│   └── ctex_templates.tex  # Tex template that support Chinese (will be compiled with xelatex)
├── camera/
│   └── camera.py        # Including Camera and CameraFrame
├── scene/
│   ├── scene_file_writer.py     # Used to write scene to video file
│   ├── scene.py                 # The basic Scene class
│   ├── three_d_scene.py         # Three-dimensional scene
│   ├── sample_space_scene.py    # Probability related sample space scene
│   └── vector_space_scene.py    # Vector field scene
├── animation/
│   ├── animation.py     # The basic class of animation
│   ├── composition.py   # Animation group
│   ├── creation.py      # Animation related to Create
│   ├── fading.py        # Fade related animation
│   ├── growing.py       # Animation related to Grow
│   ├── indication.py    # Some animations for emphasis
│   ├── movement.py      # Animation related to movement
│   ├── numbers.py       # Realize changes to DecimalNumber
│   ├── rotation.py      # Animation related to rotation
│   ├── specialized.py   # Some uncommon animations for special projects
│   ├── transform_matching_parts.py # Transform which can automatically match parts
│   ├── transform.py     # Some Transforms
│   └── update.py        # Realize update from function
├── mobject/
│   ├── mobject.py       # The basic class of all math object
│   ├── types/ # 4 types of mobject
│   │   ├── dot_cloud.py            # Dot cloud (an subclass of PMobject)
│   │   ├── image_mobject.py        # Insert pictures
│   │   ├── point_cloud_mobject.py  # PMobject (mobject composed of points)
│   │   ├── surface.py              # ParametricSurface
│   │   └── vectorized_mobject.py   # VMobject (vectorized mobject)
│   ├── svg/ # mobject related to svg
│   │   ├── svg_mobject.py          # SVGMobject
│   │   ├── brace.py                # Brace
│   │   ├── drawings.py             # Some special mobject of svg image
│   │   ├── tex_mobject.py          # Tex and TexText implemented by LaTeX
│   │   └── text_mobject.py         # Text implemented by manimpango
│   ├── changing.py             # Dynamically changing mobject
│   ├── coordinate_systems.py   # coordinate system
│   ├── frame.py                # mobject related to frame
│   ├── functions.py            # ParametricFunction
│   ├── geometry.py             # geometry mobjects
│   ├── matrix.py               # matrix
│   ├── mobject_update_utils.py # some defined updater
│   ├── number_line.py          # Number line
│   ├── numbers.py              # Numbers that can be changed
│   ├── probability.py          # mobject related to probability
│   ├── shape_matchers.py       # mobject adapted to the size of other objects
│   ├── three_dimensions.py     # Three-dimensional objects
│   ├── value_tracker.py        # ValueTracker which storage number
│   └── vector_field.py         # VectorField
├── once_useful_constructs/  # 3b1b's Common scenes written for some videos
│   └── ...
├── shaders/ # GLSL scripts for rendering
│   ├── simple_vert.glsl    # a simple glsl script for position
│   ├── insert/ # glsl scripts to be inserted in other glsl scripts
│   │   ├── NOTE.md   # explain how to insert glsl scripts
│   │   └── ...       # useful scripts
│   ├── image/ # glsl for images
│   │   └── ... # containing shaders for vertex and fragment
│   ├── quadratic_bezier_fill/ # glsl for the fill of quadratic bezier curve
│   │   └── ... # containing shaders for vertex, fragment and geometry
│   ├── quadratic_bezier_stroke/ # glsl for the stroke of quadratic bezier curve
│   │   └── ... # containing shaders for vertex, fragment and geometry
│   ├── surface/ # glsl for surfaces
│   │   └── ... # containing shaders for vertex and fragment
│   ├── textured_surface/ # glsl for textured_surface
│   │   └── ... # containing shaders for vertex and fragment
│   └── true_dot/ # glsl for a dot
│       └── ... # containing shaders for vertex, fragment and geometry
└── utils/ # Some useful utility functions
    ├── bezier.py             # For bezier curve
    ├── color.py              # For color
    ├── dict_ops.py           # Functions related to dictionary processing
    ├── customization.py      # Read from custom_config.yml
    ├── debug.py              # Utilities for debugging in program
    ├── directories.py        # Read directories from config file
    ├── family_ops.py         # Process family members
    ├── file_ops.py           # Process files and directories
    ├── images.py             # Read image
    ├── init_config.py        # Configuration guide
    ├── iterables.py          # Functions related to list/dictionary processing
    ├── paths.py              # Curve path
    ├── rate_functions.py     # Some defined rate_functions
    ├── simple_functions.py   # Some commonly used functions
    ├── sounds.py             # Process sounds
    ├── space_ops.py          # Space coordinate calculation
    ├── strings.py            # Process strings
    └── tex_file_writing.py   # Use LaTeX to write strings as svg
Inheritance structure of manim’s classes
¶
Here
is a pdf showed inheritance structure of manim’s classes, large,
but basically all classes have included:
Manim execution process
¶
Contents
Manim’s structure
Manim’s directory structure
Inheritance structure of manim’s classes
Manim execution process

Code Examples:
Example 1:
```python
manimlib/ # manim library
├── __init__.py
├── __main__.py
├── default_config.yml   # Default configuration file
├── config.py            # Process CLI flags
├── constants.py         # Defined some constants
├── extract_scene.py     # Extract and run the scene
├── shader_wrapper.py    # Shaders' Wrapper for convenient control
├── window.py            # Playback window
├── tex_templates/ # Templates preset for LaTeX
│   ├── tex_templates.tex   # Tex template (will be compiled with latex, default)
│   └── ctex_templates.tex  # Tex template that support Chinese (will be compiled with xelatex)
├── camera/
│   └── camera.py        # Including Camera and CameraFrame
├── scene/
│   ├── scene_file_writer.py     # Used to write scene to video file
│   ├── scene.py                 # The basic Scene class
│   ├── three_d_scene.py         # Three-dimensional scene
│   ├── sample_space_scene.py    # Probability related sample space scene
│   └── vector_space_scene.py    # Vector field scene
├── animation/
│   ├── animation.py     # The basic class of animation
│   ├── composition.py   # Animation group
│   ├── creation.py      # Animation related to Create
│   ├── fading.py        # Fade related animation
│   ├── growing.py       # Animation related to Grow
│   ├── indication.py    # Some animations for emphasis
│   ├── movement.py      # Animation related to movement
│   ├── numbers.py       # Realize changes to DecimalNumber
│   ├── rotation.py      # Animation related to rotation
│   ├── specialized.py   # Some uncommon animations for special projects
│   ├── transform_matching_parts.py # Transform which can automatically match parts
│   ├── transform.py     # Some Transforms
│   └── update.py        # Realize update from function
├── mobject/
│   ├── mobject.py       # The basic class of all math object
│   ├── types/ # 4 types of mobject
│   │   ├── dot_cloud.py            # Dot cloud (an subclass of PMobject)
│   │   ├── image_mobject.py        # Insert pictures
│   │   ├── point_cloud_mobject.py  # PMobject (mobject composed of points)
│   │   ├── surface.py              # ParametricSurface
│   │   └── vectorized_mobject.py   # VMobject (vectorized mobject)
│   ├── svg/ # mobject related to svg
│   │   ├── svg_mobject.py          # SVGMobject
│   │   ├── brace.py                # Brace
│   │   ├── drawings.py             # Some special mobject of svg image
│   │   ├── tex_mobject.py          # Tex and TexText implemented by LaTeX
│   │   └── text_mobject.py         # Text implemented by manimpango
│   ├── changing.py             # Dynamically changing mobject
│   ├── coordinate_systems.py   # coordinate system
│   ├── frame.py                # mobject related to frame
│   ├── functions.py            # ParametricFunction
│   ├── geometry.py             # geometry mobjects
│   ├── matrix.py               # matrix
│   ├── mobject_update_utils.py # some defined updater
│   ├── number_line.py          # Number line
│   ├── numbers.py              # Numbers that can be changed
│   ├── probability.py          # mobject related to probability
│   ├── shape_matchers.py       # mobject adapted to the size of other objects
│   ├── three_dimensions.py     # Three-dimensional objects
│   ├── value_tracker.py        # ValueTracker which storage number
│   └── vector_field.py         # VectorField
├── once_useful_constructs/  # 3b1b's Common scenes written for some videos
│   └── ...
├── shaders/ # GLSL scripts for rendering
│   ├── simple_vert.glsl    # a simple glsl script for position
│   ├── insert/ # glsl scripts to be inserted in other glsl scripts
│   │   ├── NOTE.md   # explain how to insert glsl scripts
│   │   └── ...       # useful scripts
│   ├── image/ # glsl for images
│   │   └── ... # containing shaders for vertex and fragment
│   ├── quadratic_bezier_fill/ # glsl for the fill of quadratic bezier curve
│   │   └── ... # containing shaders for vertex, fragment and geometry
│   ├── quadratic_bezier_stroke/ # glsl for the stroke of quadratic bezier curve
│   │   └── ... # containing shaders for vertex, fragment and geometry
│   ├── surface/ # glsl for surfaces
│   │   └── ... # containing shaders for vertex and fragment
│   ├── textured_surface/ # glsl for textured_surface
│   │   └── ... # containing shaders for vertex and fragment
│   └── true_dot/ # glsl for a dot
│       └── ... # containing shaders for vertex, fragment and geometry
└── utils/ # Some useful utility functions
    ├── bezier.py             # For bezier curve
    ├── color.py              # For color
    ├── dict_ops.py           # Functions related to dictionary processing
    ├── customization.py      # Read from custom_config.yml
    ├── debug.py              # Utilities for debugging in program
    ├── directories.py        # Read directories from config file
    ├── family_ops.py         # Process family members
    ├── file_ops.py           # Process files and directories
    ├── images.py             # Read image
    ├── init_config.py        # Configuration guide
    ├── iterables.py          # Functions related to list/dictionary processing
    ├── paths.py              # Curve path
    ├── rate_functions.py     # Some defined rate_functions
    ├── simple_functions.py   # Some commonly used functions
    ├── sounds.py             # Process sounds
    ├── space_ops.py          # Space coordinate calculation
    ├── strings.py            # Process strings
    └── tex_file_writing.py   # Use LaTeX to write strings as svg
```

================================================================================

=== Manim’s structure - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/structure.html#manim-execution-process
Content:
Manim’s structure
¶
Manim’s directory structure
¶
The manim directory looks very complicated, with a lot of files,
but the structure is clear.
Below is the directory structure of manim:
manimlib/ # manim library
├── __init__.py
├── __main__.py
├── default_config.yml   # Default configuration file
├── config.py            # Process CLI flags
├── constants.py         # Defined some constants
├── extract_scene.py     # Extract and run the scene
├── shader_wrapper.py    # Shaders' Wrapper for convenient control
├── window.py            # Playback window
├── tex_templates/ # Templates preset for LaTeX
│   ├── tex_templates.tex   # Tex template (will be compiled with latex, default)
│   └── ctex_templates.tex  # Tex template that support Chinese (will be compiled with xelatex)
├── camera/
│   └── camera.py        # Including Camera and CameraFrame
├── scene/
│   ├── scene_file_writer.py     # Used to write scene to video file
│   ├── scene.py                 # The basic Scene class
│   ├── three_d_scene.py         # Three-dimensional scene
│   ├── sample_space_scene.py    # Probability related sample space scene
│   └── vector_space_scene.py    # Vector field scene
├── animation/
│   ├── animation.py     # The basic class of animation
│   ├── composition.py   # Animation group
│   ├── creation.py      # Animation related to Create
│   ├── fading.py        # Fade related animation
│   ├── growing.py       # Animation related to Grow
│   ├── indication.py    # Some animations for emphasis
│   ├── movement.py      # Animation related to movement
│   ├── numbers.py       # Realize changes to DecimalNumber
│   ├── rotation.py      # Animation related to rotation
│   ├── specialized.py   # Some uncommon animations for special projects
│   ├── transform_matching_parts.py # Transform which can automatically match parts
│   ├── transform.py     # Some Transforms
│   └── update.py        # Realize update from function
├── mobject/
│   ├── mobject.py       # The basic class of all math object
│   ├── types/ # 4 types of mobject
│   │   ├── dot_cloud.py            # Dot cloud (an subclass of PMobject)
│   │   ├── image_mobject.py        # Insert pictures
│   │   ├── point_cloud_mobject.py  # PMobject (mobject composed of points)
│   │   ├── surface.py              # ParametricSurface
│   │   └── vectorized_mobject.py   # VMobject (vectorized mobject)
│   ├── svg/ # mobject related to svg
│   │   ├── svg_mobject.py          # SVGMobject
│   │   ├── brace.py                # Brace
│   │   ├── drawings.py             # Some special mobject of svg image
│   │   ├── tex_mobject.py          # Tex and TexText implemented by LaTeX
│   │   └── text_mobject.py         # Text implemented by manimpango
│   ├── changing.py             # Dynamically changing mobject
│   ├── coordinate_systems.py   # coordinate system
│   ├── frame.py                # mobject related to frame
│   ├── functions.py            # ParametricFunction
│   ├── geometry.py             # geometry mobjects
│   ├── matrix.py               # matrix
│   ├── mobject_update_utils.py # some defined updater
│   ├── number_line.py          # Number line
│   ├── numbers.py              # Numbers that can be changed
│   ├── probability.py          # mobject related to probability
│   ├── shape_matchers.py       # mobject adapted to the size of other objects
│   ├── three_dimensions.py     # Three-dimensional objects
│   ├── value_tracker.py        # ValueTracker which storage number
│   └── vector_field.py         # VectorField
├── once_useful_constructs/  # 3b1b's Common scenes written for some videos
│   └── ...
├── shaders/ # GLSL scripts for rendering
│   ├── simple_vert.glsl    # a simple glsl script for position
│   ├── insert/ # glsl scripts to be inserted in other glsl scripts
│   │   ├── NOTE.md   # explain how to insert glsl scripts
│   │   └── ...       # useful scripts
│   ├── image/ # glsl for images
│   │   └── ... # containing shaders for vertex and fragment
│   ├── quadratic_bezier_fill/ # glsl for the fill of quadratic bezier curve
│   │   └── ... # containing shaders for vertex, fragment and geometry
│   ├── quadratic_bezier_stroke/ # glsl for the stroke of quadratic bezier curve
│   │   └── ... # containing shaders for vertex, fragment and geometry
│   ├── surface/ # glsl for surfaces
│   │   └── ... # containing shaders for vertex and fragment
│   ├── textured_surface/ # glsl for textured_surface
│   │   └── ... # containing shaders for vertex and fragment
│   └── true_dot/ # glsl for a dot
│       └── ... # containing shaders for vertex, fragment and geometry
└── utils/ # Some useful utility functions
    ├── bezier.py             # For bezier curve
    ├── color.py              # For color
    ├── dict_ops.py           # Functions related to dictionary processing
    ├── customization.py      # Read from custom_config.yml
    ├── debug.py              # Utilities for debugging in program
    ├── directories.py        # Read directories from config file
    ├── family_ops.py         # Process family members
    ├── file_ops.py           # Process files and directories
    ├── images.py             # Read image
    ├── init_config.py        # Configuration guide
    ├── iterables.py          # Functions related to list/dictionary processing
    ├── paths.py              # Curve path
    ├── rate_functions.py     # Some defined rate_functions
    ├── simple_functions.py   # Some commonly used functions
    ├── sounds.py             # Process sounds
    ├── space_ops.py          # Space coordinate calculation
    ├── strings.py            # Process strings
    └── tex_file_writing.py   # Use LaTeX to write strings as svg
Inheritance structure of manim’s classes
¶
Here
is a pdf showed inheritance structure of manim’s classes, large,
but basically all classes have included:
Manim execution process
¶
Contents
Manim’s structure
Manim’s directory structure
Inheritance structure of manim’s classes
Manim execution process

Code Examples:
Example 1:
```python
manimlib/ # manim library
├── __init__.py
├── __main__.py
├── default_config.yml   # Default configuration file
├── config.py            # Process CLI flags
├── constants.py         # Defined some constants
├── extract_scene.py     # Extract and run the scene
├── shader_wrapper.py    # Shaders' Wrapper for convenient control
├── window.py            # Playback window
├── tex_templates/ # Templates preset for LaTeX
│   ├── tex_templates.tex   # Tex template (will be compiled with latex, default)
│   └── ctex_templates.tex  # Tex template that support Chinese (will be compiled with xelatex)
├── camera/
│   └── camera.py        # Including Camera and CameraFrame
├── scene/
│   ├── scene_file_writer.py     # Used to write scene to video file
│   ├── scene.py                 # The basic Scene class
│   ├── three_d_scene.py         # Three-dimensional scene
│   ├── sample_space_scene.py    # Probability related sample space scene
│   └── vector_space_scene.py    # Vector field scene
├── animation/
│   ├── animation.py     # The basic class of animation
│   ├── composition.py   # Animation group
│   ├── creation.py      # Animation related to Create
│   ├── fading.py        # Fade related animation
│   ├── growing.py       # Animation related to Grow
│   ├── indication.py    # Some animations for emphasis
│   ├── movement.py      # Animation related to movement
│   ├── numbers.py       # Realize changes to DecimalNumber
│   ├── rotation.py      # Animation related to rotation
│   ├── specialized.py   # Some uncommon animations for special projects
│   ├── transform_matching_parts.py # Transform which can automatically match parts
│   ├── transform.py     # Some Transforms
│   └── update.py        # Realize update from function
├── mobject/
│   ├── mobject.py       # The basic class of all math object
│   ├── types/ # 4 types of mobject
│   │   ├── dot_cloud.py            # Dot cloud (an subclass of PMobject)
│   │   ├── image_mobject.py        # Insert pictures
│   │   ├── point_cloud_mobject.py  # PMobject (mobject composed of points)
│   │   ├── surface.py              # ParametricSurface
│   │   └── vectorized_mobject.py   # VMobject (vectorized mobject)
│   ├── svg/ # mobject related to svg
│   │   ├── svg_mobject.py          # SVGMobject
│   │   ├── brace.py                # Brace
│   │   ├── drawings.py             # Some special mobject of svg image
│   │   ├── tex_mobject.py          # Tex and TexText implemented by LaTeX
│   │   └── text_mobject.py         # Text implemented by manimpango
│   ├── changing.py             # Dynamically changing mobject
│   ├── coordinate_systems.py   # coordinate system
│   ├── frame.py                # mobject related to frame
│   ├── functions.py            # ParametricFunction
│   ├── geometry.py             # geometry mobjects
│   ├── matrix.py               # matrix
│   ├── mobject_update_utils.py # some defined updater
│   ├── number_line.py          # Number line
│   ├── numbers.py              # Numbers that can be changed
│   ├── probability.py          # mobject related to probability
│   ├── shape_matchers.py       # mobject adapted to the size of other objects
│   ├── three_dimensions.py     # Three-dimensional objects
│   ├── value_tracker.py        # ValueTracker which storage number
│   └── vector_field.py         # VectorField
├── once_useful_constructs/  # 3b1b's Common scenes written for some videos
│   └── ...
├── shaders/ # GLSL scripts for rendering
│   ├── simple_vert.glsl    # a simple glsl script for position
│   ├── insert/ # glsl scripts to be inserted in other glsl scripts
│   │   ├── NOTE.md   # explain how to insert glsl scripts
│   │   └── ...       # useful scripts
│   ├── image/ # glsl for images
│   │   └── ... # containing shaders for vertex and fragment
│   ├── quadratic_bezier_fill/ # glsl for the fill of quadratic bezier curve
│   │   └── ... # containing shaders for vertex, fragment and geometry
│   ├── quadratic_bezier_stroke/ # glsl for the stroke of quadratic bezier curve
│   │   └── ... # containing shaders for vertex, fragment and geometry
│   ├── surface/ # glsl for surfaces
│   │   └── ... # containing shaders for vertex and fragment
│   ├── textured_surface/ # glsl for textured_surface
│   │   └── ... # containing shaders for vertex and fragment
│   └── true_dot/ # glsl for a dot
│       └── ... # containing shaders for vertex, fragment and geometry
└── utils/ # Some useful utility functions
    ├── bezier.py             # For bezier curve
    ├── color.py              # For color
    ├── dict_ops.py           # Functions related to dictionary processing
    ├── customization.py      # Read from custom_config.yml
    ├── debug.py              # Utilities for debugging in program
    ├── directories.py        # Read directories from config file
    ├── family_ops.py         # Process family members
    ├── file_ops.py           # Process files and directories
    ├── images.py             # Read image
    ├── init_config.py        # Configuration guide
    ├── iterables.py          # Functions related to list/dictionary processing
    ├── paths.py              # Curve path
    ├── rate_functions.py     # Some defined rate_functions
    ├── simple_functions.py   # Some commonly used functions
    ├── sounds.py             # Process sounds
    ├── space_ops.py          # Space coordinate calculation
    ├── strings.py            # Process strings
    └── tex_file_writing.py   # Use LaTeX to write strings as svg
```

================================================================================

=== What’s new - manim  documentation ===
URL: https://3b1b.github.io/manim/getting_started/whatsnew.html#usage-changes-of-new-version-manim
Content:
What’s new
¶
Usage changes of new version manim
¶
There are many changes in the new version of manim, and here are only the changes that
may have an impact at the code writing level.
Some of the changes here may not have any major impact on the use, and some changes
that affect the use are not mentioned below.
This document is for reference only, see the source code for details.
Animation
Added
Fade
as the parent class of
FadeIn
and
FadeOut
FadeIn
and
FadeOut
can be passed in
shift
and
scale
parameters
Deleted
FadeInFrom,
FadeInFromDown,
FadeOutAndShift,
FadeOutAndShiftDown,
FadeInFromLarge
, these can be used
FadeIn,
FadeOut
to achieve the same effect more easily
Added
FadeTransform
to cross fade between two objects, and subclass
FadeTransformPieces
Added
CountInFrom(decimal_mob,
source_number=0)
to count
decimal_mob
from
source_number
to the current value
Rotating
can directly pass in
angle
and
axis
without writing keywords
angle=,
axis=
Rotate
has become a subclass of
Rotating
, and the distortion effect in
Transform
will not appear
Removed
MoveCar
animation
Added
TransformMatchingShapes(mobject,
target_mobject)
and
TransformMatchingTex(mobject,
target_mobject)
Camera
Removed all camera classes except
Camera
(
MappingCamera
,
MovingCamera
,
MultiCamera
) and all functions in
ThreeDCamera
Implemented
CameraFrame
(as a
Mobject
)
Can be called by
self.camera.frame
in
Scene
All methods of
Mobject
can be used, such as
.shift()
,
.scale()
, etc.
Call
.to_default_state()
to place in the default position
Set the Euler angles of the camera by
.set_euler_angles(theta,
phi,
gamma)
Set three single Euler angles by
.set_theta(theta)
,
.set_phi(phi)
,
.set_gamma(gamma)
Use
.increment_theta(dtheta)
,
.increment_phi(dphi)
,
.increment_gamma(gamma)
to increase the three Euler angles by a certain value. Can be used to realize automatic rotation
self.camera.frame.add_updater(lambda
mob,
dt:
mob.increment_theta(0.1
*
dt))
Camera
adds a light source, which is a
Point
, which can be called by
self.camera.light_source
in
Scene
to move and so on. The default position is
(-
10,
10,
10)
Delete
Container
Mobject
svg
related
Added
Checkmark
and
Exmark
Some unnecessary classes have been removed from
drawings.py
Removed
Code
and
Paragraph
(by mistake)
TexMobject
is renamed to
Tex
,
TextMobject
is renamed to
TexText
font_size
has been added to
Tex
,
TexText
and
Text
Tex
and
TexText
added
isolate
, which is a list, which will be automatically split
Mobject
types
Added a new class
Surface
, which is the parent class of
ParametricSurface
and
TexturedSurface
.
Added the group
SGroup
for
Surface
Added
TexturedSurface(uv_surface,
image_file,
dark_image_file=None)
, where
uv_surface
is a
Surface
,
image_file
is the image to be posted, and
dark_image_file
is the image to be posted in the dark (default and
image_file
is the same)
Deleted
Mobject1D
,
Mobject2D
,
PointCloudDot
Added
DotCloud
(a
PMobject
), which has been greatly optimized
Removed
AbstractImageMobject
,
ImageMobjectFromCamera
Removed
sheen
from
VMobject
Mobject
Added
gloss
and
shadow
, which are the numbers between
[0,
1]
respectively. There are four methods of
.get_gloss()
,
.set_gloss(gloss)
,
.get_shadow()
,
.set_shadow(shadow)
Added
.get_grid(n_rows,
n_cols)
to copy into grid
Added
.set_color_by_code(glsl_code)
to use GLSL code to change the color
Added
.set_color_by_xyz_func(glsl_snippet,
min_value=-5.0,
max_value=5.0,
colormap="viridis")
to pass in GLSL expression in the form of
x,y,z
, the return value should be a floating point number
Coordinate system (including
Axes
,
ThreeDAxes
,
NumberPlane
,
ComplexPlane
)
No longer use
x_min
,
x_max
,
y_min
,
y_max
, but use
x_range
,
y_range
as a
np.array()
, containing three numbers
np.array([
Minimum,
maximum,
step
size])
Added the abbreviation
.i2gp(x,
graph)
of
.input_to_graph_point(x,
graph)
Added some functions of the original
GraphScene
Added
.get_v_line(point)
,
.get_h_line(point)
to return the line from
point
to the two coordinate axes, and specify the line type through the keyword argument of
line_func
(default
DashedLine
)
Added
.get_graph_label(graph,
label,
x,
direction,
buff,
color)
to return the label added to the image
Added
.get_v_line_to_graph(x,
graph)
,
.get_h_line_to_graph(x,
graph)
to return the line from the point with the abscissa of
x
on the
graph
to the two- axis line
Added
.angle_of_tangent(x,
graph,
dx=EPSILON)
, returns the inclination angle of
graph
at
x
Added
.slope_of_tangent(x,
graph,
dx=EPSILON)
, returns the slope of tangent line of
graph
at
x
Added
.get_tangent_line(x,
graph,
length=5)
to return the tangent line of
graph
at
x
Added
.get_riemann_rectangles(graph,
x_range,
dx,
input_sample_type,
...)
to return Riemann rectangles (a
VGroup
)
The attribute
number_line_config
of
Axes
is renamed to
axis_config
Axes
original
.get_coordinate_labels(x_values,
y_values)
method was renamed to
.add_coordinate_labels(x_values,
y_values)
(but it is not added to the screen)
.add_coordinate_labels(numbers)
of
ComplexPlane
will directly add the coordinates to the screen
NumberLine
No longer use
x_min
,
x_max
,
tick_frequency
, but use
x_range
, which is an array containing three numbers
[min,
max,
step]
The original
label_direction
attribute changed to the
line_to_number_direction
attribute
Replace
tip_width
and
tip_height
with
tip_config
(dictionary) attributes
The original
exclude_zero_from_default
attribute is modified to the
numbers_to_exclude
attribute (default is None)
The original
.add_tick_marks()
method was changed to the
.add_ticks()
method
Delete the
.get_number_mobjects(*numbers)
method, only use the
.add_numbers(x_values=None,
excluding=None)
method
Three-dimensional objects
Added
SurfaceMesh(uv_surface)
, pass in a
Surface
to generate its uv mesh
ParametricSurface
no longer uses
u_min,
u_max,
v_min,
v_max
, but instead uses
u_range,
v_range
, which is a tuple (
(min,
max)
), and
resolution
can be set larger, don’t worry Speed ​​issue
Added
Torus
, controlled by
r1,
r2
keyword parameters
Added
Cylinder
, controlled by
height,
radius
keyword parameters
Added
Line3D
(extremely thin cylinder), controlled by the
width
keyword parameter
Added
Disk3D
, controlled by
radius
keyword parameter
Add
Square3D
, controlled by
side_length
keyword parameter
Improved
Cube
and
Prism
, the usage remains unchanged
Other objects
ParametricFunction
is renamed to
ParametricCurve
. Instead of using
t_min,
t_max,
step_size
, use
t_range
, which is an array of three numbers (
[t_min,
t_max,
step_size]
).
dt
was renamed to
epsilon
. Other usage remains unchanged
All
TipableVMobject
can pass in
tip_length
to control the style of
tip
Line
adds
.set_points_by_ends(start,
end,
buff=0,
path_arc=0)
method
Line
added
.get_projection(point)
to return the projection position of
point
on a straight line
Arrow
adds three attributes of
thickness,
tip_width_ratio,
tip_angle
CubicBezier
is changed to
a0,
h0,
h1,
a1
, that is, only a third-order Bezier curve is supported
Square
can be initialized directly by passing in
side_length
instead of using the keyword
side_length=
always_redraw(func,
*args,
**kwargs)
supports incoming parameters
*args,
**kwargs
The
digit_to_digit_buff
property of
DecimalNumber
has been renamed to
digit_buff_per_font_unit
, and the
.scale()
method has been improved
ValueTracker
adds
value_type
attribute, the default is
np.float64
Scene
Removed all functions of
GraphScene
(moved to
once_useful_constructs
),
MovingCameraScene
,
ReconfigurableScene
,
SceneFromVideo
,
ZoomedScene
, and
ThreeDScene
. Because these can basically be achieved by adjusting
CameraFrame
(
self.camera.frame
)
Currently
SampleSpaceScene
and
VectorScene
have not been changed for the new version, so it is not recommended to use (only
Scene
is recommended)
Fix the export of gif, just use the
-i
option directly
Added the
.interact()
method, during which the mouse and keyboard can be used to continue the interaction, which will be executed by default after the scene ends
Added
.embed()
method, open iPython terminal to enter interactive mode
Added
.save_state()
method to save the current state of the scene
Added
.restore()
method to restore the entire scene to the saved state
utils
A series of functions related to second-order Bezier have been added to
utils/bezier.py
Added a function to read color map from
matplotlib
in
utils/color.py
Added a series of related functions for processing folders/custom styles/object families
resize_array
,
resize_preserving_order
,
resize_with_interpolation
three functions have been added to
utils/iterables.py
The definition of
smooth
is updated in
utils/rate_functions.py
clip(a,
min_a,
max_a)
function has been added to
utils/simple_functions.py
Some functions have been improved in
utils/space_ops.py
, some functions for space calculation, and functions for processing triangulation have been added
constants
Fixed the aspect ratio of the screen to 16:9
Deleted the old gray series (
LIGHT_GREY
,
GREY
,
DARK_GREY
,
DARKER_GREY
), added a new series of gray
GREY_A
~
GREY_E
Contents
What’s new
Usage changes of new version manim

Code Examples:
Example 1:
```python
FadeInFrom, FadeInFromDown, FadeOutAndShift, FadeOutAndShiftDown, FadeInFromLarge
```
Example 2:
```python
FadeIn, FadeOut
```
Example 3:
```python
FadeTransform
```
Example 4:
```python
FadeTransformPieces
```
Example 5:
```python
CountInFrom(decimal_mob, source_number=0)
```
Example 6:
```python
decimal_mob
```
Example 7:
```python
source_number
```
Example 8:
```python
angle=, axis=
```
Example 9:
```python
TransformMatchingShapes(mobject, target_mobject)
```
Example 10:
```python
TransformMatchingTex(mobject, target_mobject)
```
Example 11:
```python
MappingCamera
```
Example 12:
```python
MovingCamera
```
Example 13:
```python
MultiCamera
```
Example 14:
```python
ThreeDCamera
```
Example 15:
```python
CameraFrame
```
Example 16:
```python
self.camera.frame
```
Example 17:
```python
.to_default_state()
```
Example 18:
```python
.set_euler_angles(theta, phi, gamma)
```
Example 19:
```python
.set_theta(theta)
```
Example 20:
```python
.set_phi(phi)
```
Example 21:
```python
.set_gamma(gamma)
```
Example 22:
```python
.increment_theta(dtheta)
```
Example 23:
```python
.increment_phi(dphi)
```
Example 24:
```python
.increment_gamma(gamma)
```
Example 25:
```python
self.camera.frame.add_updater(lambda mob, dt: mob.increment_theta(0.1 * dt))
```
Example 26:
```python
self.camera.light_source
```
Example 27:
```python
(- 10, 10, 10)
```
Example 28:
```python
drawings.py
```
Example 29:
```python
TextMobject
```
Example 30:
```python
ParametricSurface
```
Example 31:
```python
TexturedSurface
```
Example 32:
```python
TexturedSurface(uv_surface, image_file, dark_image_file=None)
```
Example 33:
```python
dark_image_file
```
Example 34:
```python
PointCloudDot
```
Example 35:
```python
AbstractImageMobject
```
Example 36:
```python
ImageMobjectFromCamera
```
Example 37:
```python
.get_gloss()
```
Example 38:
```python
.set_gloss(gloss)
```
Example 39:
```python
.get_shadow()
```
Example 40:
```python
.set_shadow(shadow)
```
Example 41:
```python
.get_grid(n_rows, n_cols)
```
Example 42:
```python
.set_color_by_code(glsl_code)
```
Example 43:
```python
.set_color_by_xyz_func(glsl_snippet, min_value=-5.0, max_value=5.0, colormap="viridis")
```
Example 44:
```python
NumberPlane
```
Example 45:
```python
ComplexPlane
```
Example 46:
```python
np.array([ Minimum, maximum, step size])
```
Example 47:
```python
.i2gp(x, graph)
```
Example 48:
```python
.input_to_graph_point(x, graph)
```
Example 49:
```python
.get_v_line(point)
```
Example 50:
```python
.get_h_line(point)
```
Example 51:
```python
.get_graph_label(graph, label, x, direction, buff, color)
```
Example 52:
```python
.get_v_line_to_graph(x, graph)
```
Example 53:
```python
.get_h_line_to_graph(x, graph)
```
Example 54:
```python
.angle_of_tangent(x, graph, dx=EPSILON)
```
Example 55:
```python
.slope_of_tangent(x, graph, dx=EPSILON)
```
Example 56:
```python
.get_tangent_line(x, graph, length=5)
```
Example 57:
```python
.get_riemann_rectangles(graph, x_range, dx, input_sample_type, ...)
```
Example 58:
```python
number_line_config
```
Example 59:
```python
axis_config
```
Example 60:
```python
.get_coordinate_labels(x_values, y_values)
```
Example 61:
```python
.add_coordinate_labels(x_values, y_values)
```
Example 62:
```python
.add_coordinate_labels(numbers)
```
Example 63:
```python
ComplexPlane
```
Example 64:
```python
tick_frequency
```
Example 65:
```python
[min, max, step]
```
Example 66:
```python
label_direction
```
Example 67:
```python
line_to_number_direction
```
Example 68:
```python
exclude_zero_from_default
```
Example 69:
```python
numbers_to_exclude
```
Example 70:
```python
.add_tick_marks()
```
Example 71:
```python
.add_ticks()
```
Example 72:
```python
.get_number_mobjects(*numbers)
```
Example 73:
```python
.add_numbers(x_values=None, excluding=None)
```
Example 74:
```python
SurfaceMesh(uv_surface)
```
Example 75:
```python
ParametricSurface
```
Example 76:
```python
u_min, u_max, v_min, v_max
```
Example 77:
```python
u_range, v_range
```
Example 78:
```python
height, radius
```
Example 79:
```python
side_length
```
Example 80:
```python
ParametricFunction
```
Example 81:
```python
ParametricCurve
```
Example 82:
```python
t_min, t_max, step_size
```
Example 83:
```python
[t_min, t_max, step_size]
```
Example 84:
```python
TipableVMobject
```
Example 85:
```python
.set_points_by_ends(start, end, buff=0, path_arc=0)
```
Example 86:
```python
.get_projection(point)
```
Example 87:
```python
thickness, tip_width_ratio, tip_angle
```
Example 88:
```python
CubicBezier
```
Example 89:
```python
a0, h0, h1, a1
```
Example 90:
```python
side_length
```
Example 91:
```python
side_length=
```
Example 92:
```python
always_redraw(func, *args, **kwargs)
```
Example 93:
```python
*args, **kwargs
```
Example 94:
```python
digit_to_digit_buff
```
Example 95:
```python
DecimalNumber
```
Example 96:
```python
digit_buff_per_font_unit
```
Example 97:
```python
ValueTracker
```
Example 98:
```python
once_useful_constructs
```
Example 99:
```python
MovingCameraScene
```
Example 100:
```python
ReconfigurableScene
```
Example 101:
```python
SceneFromVideo
```
Example 102:
```python
ZoomedScene
```
Example 103:
```python
ThreeDScene
```
Example 104:
```python
CameraFrame
```
Example 105:
```python
self.camera.frame
```
Example 106:
```python
SampleSpaceScene
```
Example 107:
```python
VectorScene
```
Example 108:
```python
.interact()
```
Example 109:
```python
.save_state()
```
Example 110:
```python
utils/bezier.py
```
Example 111:
```python
utils/color.py
```
Example 112:
```python
resize_array
```
Example 113:
```python
resize_preserving_order
```
Example 114:
```python
resize_with_interpolation
```
Example 115:
```python
utils/iterables.py
```
Example 116:
```python
utils/rate_functions.py
```
Example 117:
```python
clip(a, min_a, max_a)
```
Example 118:
```python
utils/simple_functions.py
```
Example 119:
```python
utils/space_ops.py
```
Example 120:
```python
DARKER_GREY
```

================================================================================

=== constants - manim  documentation ===
URL: https://3b1b.github.io/manim/documentation/constants.html#frame-and-pixel-shape
Content:
constants
¶
The
constants.py
in the
manimlib
folder defines the constants
needed when running manim. Some constants are not explained here because
they are only used inside manim.
Frame and pixel shape
¶
ASPECT_RATIO
=
16.0
/
9.0
FRAME_HEIGHT
=
8.0
FRAME_WIDTH
=
FRAME_HEIGHT
*
ASPECT_RATIO
FRAME_Y_RADIUS
=
FRAME_HEIGHT
/
2
FRAME_X_RADIUS
=
FRAME_WIDTH
/
2
DEFAULT_PIXEL_HEIGHT
=
1080
DEFAULT_PIXEL_WIDTH
=
1920
DEFAULT_FPS
=
30
Buffs
¶
SMALL_BUFF
=
0.1
MED_SMALL_BUFF
=
0.25
MED_LARGE_BUFF
=
0.5
LARGE_BUFF
=
1
DEFAULT_MOBJECT_TO_EDGE_BUFFER
=
MED_LARGE_BUFF
# Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER
=
MED_SMALL_BUFF
# Distance between objects
Run times
¶
DEFAULT_POINTWISE_FUNCTION_RUN_TIME
=
3.0
DEFAULT_WAIT_TIME
=
1.0
Coordinates
¶
manim uses three-dimensional coordinates and uses the type of
ndarray
ORIGIN
=
np
.
array
((
0.
,
0.
,
0.
))
UP
=
np
.
array
((
0.
,
1.
,
0.
))
DOWN
=
np
.
array
((
0.
,
-
1.
,
0.
))
RIGHT
=
np
.
array
((
1.
,
0.
,
0.
))
LEFT
=
np
.
array
((
-
1.
,
0.
,
0.
))
IN
=
np
.
array
((
0.
,
0.
,
-
1.
))
OUT
=
np
.
array
((
0.
,
0.
,
1.
))
X_AXIS
=
np
.
array
((
1.
,
0.
,
0.
))
Y_AXIS
=
np
.
array
((
0.
,
1.
,
0.
))
Z_AXIS
=
np
.
array
((
0.
,
0.
,
1.
))
# Useful abbreviations for diagonals
UL
=
UP
+
LEFT
UR
=
UP
+
RIGHT
DL
=
DOWN
+
LEFT
DR
=
DOWN
+
RIGHT
TOP
=
FRAME_Y_RADIUS
*
UP
BOTTOM
=
FRAME_Y_RADIUS
*
DOWN
LEFT_SIDE
=
FRAME_X_RADIUS
*
LEFT
RIGHT_SIDE
=
FRAME_X_RADIUS
*
RIGHT
Mathematical constant
¶
PI
=
np
.
pi
TAU
=
2
*
PI
DEGREES
=
TAU
/
360
Text
¶
NORMAL
=
"NORMAL"
ITALIC
=
"ITALIC"
OBLIQUE
=
"OBLIQUE"
BOLD
=
"BOLD"
Stroke width
¶
DEFAULT_STROKE_WIDTH
=
4
Colours
¶
Here are the preview of default colours. (Modified from
elteoremadebeethoven
)
BLUE
BLUE_E
BLUE_D
BLUE_C
BLUE_B
BLUE_A
TEAL
TEAL_E
TEAL_D
TEAL_C
TEAL_B
TEAL_A
GREEN
GREEN_E
GREEN_D
GREEN_C
GREEN_B
GREEN_A
YELLOW
YELLOW_E
YELLOW_D
YELLOW_C
YELLOW_B
YELLOW_A
GOLD
GOLD_E
GOLD_D
GOLD_C
GOLD_B
GOLD_A
RED
RED_E
RED_D
RED_C
RED_B
RED_A
MAROON
MAROON_E
MAROON_D
MAROON_C
MAROON_B
MAROON_A
PURPLE
PURPLE_E
PURPLE_D
PURPLE_C
PURPLE_B
PURPLE_A
GREY
GREY_E
GREY_D
GREY_C
GREY_B
GREY_A
Others
WHITE
BLACK
GREY_BROWN
DARK_BROWN
LIGHT_BROWN
PINK
LIGHT_PINK
GREEN_SCREEN
ORANGE
Contents
constants
Frame and pixel shape
Buffs
Run times
Coordinates
Mathematical constant
Text
Stroke width
Colours

Code Examples:
Example 1:
```python
constants.py
```
Example 2:
```python
ASPECT_RATIO = 16.0 / 9.0
FRAME_HEIGHT = 8.0
FRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO
FRAME_Y_RADIUS = FRAME_HEIGHT / 2
FRAME_X_RADIUS = FRAME_WIDTH / 2

DEFAULT_PIXEL_HEIGHT = 1080
DEFAULT_PIXEL_WIDTH = 1920
DEFAULT_FPS = 30
```
Example 3:
```python
SMALL_BUFF = 0.1
MED_SMALL_BUFF = 0.25
MED_LARGE_BUFF = 0.5
LARGE_BUFF = 1

DEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects
```
Example 4:
```python
DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0
DEFAULT_WAIT_TIME = 1.0
```
Example 5:
```python
ORIGIN = np.array((0., 0., 0.))
UP = np.array((0., 1., 0.))
DOWN = np.array((0., -1., 0.))
RIGHT = np.array((1., 0., 0.))
LEFT = np.array((-1., 0., 0.))
IN = np.array((0., 0., -1.))
OUT = np.array((0., 0., 1.))
X_AXIS = np.array((1., 0., 0.))
Y_AXIS = np.array((0., 1., 0.))
Z_AXIS = np.array((0., 0., 1.))

# Useful abbreviations for diagonals
UL = UP + LEFT
UR = UP + RIGHT
DL = DOWN + LEFT
DR = DOWN + RIGHT

TOP = FRAME_Y_RADIUS * UP
BOTTOM = FRAME_Y_RADIUS * DOWN
LEFT_SIDE = FRAME_X_RADIUS * LEFT
RIGHT_SIDE = FRAME_X_RADIUS * RIGHT
```
Example 6:
```python
PI = np.pi
TAU = 2 * PI
DEGREES = TAU / 360
```
Example 7:
```python
NORMAL = "NORMAL"
ITALIC = "ITALIC"
OBLIQUE = "OBLIQUE"
BOLD = "BOLD"
```
Example 8:
```python
DEFAULT_STROKE_WIDTH = 4
```

================================================================================

=== constants - manim  documentation ===
URL: https://3b1b.github.io/manim/documentation/constants.html#buffs
Content:
constants
¶
The
constants.py
in the
manimlib
folder defines the constants
needed when running manim. Some constants are not explained here because
they are only used inside manim.
Frame and pixel shape
¶
ASPECT_RATIO
=
16.0
/
9.0
FRAME_HEIGHT
=
8.0
FRAME_WIDTH
=
FRAME_HEIGHT
*
ASPECT_RATIO
FRAME_Y_RADIUS
=
FRAME_HEIGHT
/
2
FRAME_X_RADIUS
=
FRAME_WIDTH
/
2
DEFAULT_PIXEL_HEIGHT
=
1080
DEFAULT_PIXEL_WIDTH
=
1920
DEFAULT_FPS
=
30
Buffs
¶
SMALL_BUFF
=
0.1
MED_SMALL_BUFF
=
0.25
MED_LARGE_BUFF
=
0.5
LARGE_BUFF
=
1
DEFAULT_MOBJECT_TO_EDGE_BUFFER
=
MED_LARGE_BUFF
# Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER
=
MED_SMALL_BUFF
# Distance between objects
Run times
¶
DEFAULT_POINTWISE_FUNCTION_RUN_TIME
=
3.0
DEFAULT_WAIT_TIME
=
1.0
Coordinates
¶
manim uses three-dimensional coordinates and uses the type of
ndarray
ORIGIN
=
np
.
array
((
0.
,
0.
,
0.
))
UP
=
np
.
array
((
0.
,
1.
,
0.
))
DOWN
=
np
.
array
((
0.
,
-
1.
,
0.
))
RIGHT
=
np
.
array
((
1.
,
0.
,
0.
))
LEFT
=
np
.
array
((
-
1.
,
0.
,
0.
))
IN
=
np
.
array
((
0.
,
0.
,
-
1.
))
OUT
=
np
.
array
((
0.
,
0.
,
1.
))
X_AXIS
=
np
.
array
((
1.
,
0.
,
0.
))
Y_AXIS
=
np
.
array
((
0.
,
1.
,
0.
))
Z_AXIS
=
np
.
array
((
0.
,
0.
,
1.
))
# Useful abbreviations for diagonals
UL
=
UP
+
LEFT
UR
=
UP
+
RIGHT
DL
=
DOWN
+
LEFT
DR
=
DOWN
+
RIGHT
TOP
=
FRAME_Y_RADIUS
*
UP
BOTTOM
=
FRAME_Y_RADIUS
*
DOWN
LEFT_SIDE
=
FRAME_X_RADIUS
*
LEFT
RIGHT_SIDE
=
FRAME_X_RADIUS
*
RIGHT
Mathematical constant
¶
PI
=
np
.
pi
TAU
=
2
*
PI
DEGREES
=
TAU
/
360
Text
¶
NORMAL
=
"NORMAL"
ITALIC
=
"ITALIC"
OBLIQUE
=
"OBLIQUE"
BOLD
=
"BOLD"
Stroke width
¶
DEFAULT_STROKE_WIDTH
=
4
Colours
¶
Here are the preview of default colours. (Modified from
elteoremadebeethoven
)
BLUE
BLUE_E
BLUE_D
BLUE_C
BLUE_B
BLUE_A
TEAL
TEAL_E
TEAL_D
TEAL_C
TEAL_B
TEAL_A
GREEN
GREEN_E
GREEN_D
GREEN_C
GREEN_B
GREEN_A
YELLOW
YELLOW_E
YELLOW_D
YELLOW_C
YELLOW_B
YELLOW_A
GOLD
GOLD_E
GOLD_D
GOLD_C
GOLD_B
GOLD_A
RED
RED_E
RED_D
RED_C
RED_B
RED_A
MAROON
MAROON_E
MAROON_D
MAROON_C
MAROON_B
MAROON_A
PURPLE
PURPLE_E
PURPLE_D
PURPLE_C
PURPLE_B
PURPLE_A
GREY
GREY_E
GREY_D
GREY_C
GREY_B
GREY_A
Others
WHITE
BLACK
GREY_BROWN
DARK_BROWN
LIGHT_BROWN
PINK
LIGHT_PINK
GREEN_SCREEN
ORANGE
Contents
constants
Frame and pixel shape
Buffs
Run times
Coordinates
Mathematical constant
Text
Stroke width
Colours

Code Examples:
Example 1:
```python
constants.py
```
Example 2:
```python
ASPECT_RATIO = 16.0 / 9.0
FRAME_HEIGHT = 8.0
FRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO
FRAME_Y_RADIUS = FRAME_HEIGHT / 2
FRAME_X_RADIUS = FRAME_WIDTH / 2

DEFAULT_PIXEL_HEIGHT = 1080
DEFAULT_PIXEL_WIDTH = 1920
DEFAULT_FPS = 30
```
Example 3:
```python
SMALL_BUFF = 0.1
MED_SMALL_BUFF = 0.25
MED_LARGE_BUFF = 0.5
LARGE_BUFF = 1

DEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects
```
Example 4:
```python
DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0
DEFAULT_WAIT_TIME = 1.0
```
Example 5:
```python
ORIGIN = np.array((0., 0., 0.))
UP = np.array((0., 1., 0.))
DOWN = np.array((0., -1., 0.))
RIGHT = np.array((1., 0., 0.))
LEFT = np.array((-1., 0., 0.))
IN = np.array((0., 0., -1.))
OUT = np.array((0., 0., 1.))
X_AXIS = np.array((1., 0., 0.))
Y_AXIS = np.array((0., 1., 0.))
Z_AXIS = np.array((0., 0., 1.))

# Useful abbreviations for diagonals
UL = UP + LEFT
UR = UP + RIGHT
DL = DOWN + LEFT
DR = DOWN + RIGHT

TOP = FRAME_Y_RADIUS * UP
BOTTOM = FRAME_Y_RADIUS * DOWN
LEFT_SIDE = FRAME_X_RADIUS * LEFT
RIGHT_SIDE = FRAME_X_RADIUS * RIGHT
```
Example 6:
```python
PI = np.pi
TAU = 2 * PI
DEGREES = TAU / 360
```
Example 7:
```python
NORMAL = "NORMAL"
ITALIC = "ITALIC"
OBLIQUE = "OBLIQUE"
BOLD = "BOLD"
```
Example 8:
```python
DEFAULT_STROKE_WIDTH = 4
```

================================================================================

=== constants - manim  documentation ===
URL: https://3b1b.github.io/manim/documentation/constants.html#run-times
Content:
constants
¶
The
constants.py
in the
manimlib
folder defines the constants
needed when running manim. Some constants are not explained here because
they are only used inside manim.
Frame and pixel shape
¶
ASPECT_RATIO
=
16.0
/
9.0
FRAME_HEIGHT
=
8.0
FRAME_WIDTH
=
FRAME_HEIGHT
*
ASPECT_RATIO
FRAME_Y_RADIUS
=
FRAME_HEIGHT
/
2
FRAME_X_RADIUS
=
FRAME_WIDTH
/
2
DEFAULT_PIXEL_HEIGHT
=
1080
DEFAULT_PIXEL_WIDTH
=
1920
DEFAULT_FPS
=
30
Buffs
¶
SMALL_BUFF
=
0.1
MED_SMALL_BUFF
=
0.25
MED_LARGE_BUFF
=
0.5
LARGE_BUFF
=
1
DEFAULT_MOBJECT_TO_EDGE_BUFFER
=
MED_LARGE_BUFF
# Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER
=
MED_SMALL_BUFF
# Distance between objects
Run times
¶
DEFAULT_POINTWISE_FUNCTION_RUN_TIME
=
3.0
DEFAULT_WAIT_TIME
=
1.0
Coordinates
¶
manim uses three-dimensional coordinates and uses the type of
ndarray
ORIGIN
=
np
.
array
((
0.
,
0.
,
0.
))
UP
=
np
.
array
((
0.
,
1.
,
0.
))
DOWN
=
np
.
array
((
0.
,
-
1.
,
0.
))
RIGHT
=
np
.
array
((
1.
,
0.
,
0.
))
LEFT
=
np
.
array
((
-
1.
,
0.
,
0.
))
IN
=
np
.
array
((
0.
,
0.
,
-
1.
))
OUT
=
np
.
array
((
0.
,
0.
,
1.
))
X_AXIS
=
np
.
array
((
1.
,
0.
,
0.
))
Y_AXIS
=
np
.
array
((
0.
,
1.
,
0.
))
Z_AXIS
=
np
.
array
((
0.
,
0.
,
1.
))
# Useful abbreviations for diagonals
UL
=
UP
+
LEFT
UR
=
UP
+
RIGHT
DL
=
DOWN
+
LEFT
DR
=
DOWN
+
RIGHT
TOP
=
FRAME_Y_RADIUS
*
UP
BOTTOM
=
FRAME_Y_RADIUS
*
DOWN
LEFT_SIDE
=
FRAME_X_RADIUS
*
LEFT
RIGHT_SIDE
=
FRAME_X_RADIUS
*
RIGHT
Mathematical constant
¶
PI
=
np
.
pi
TAU
=
2
*
PI
DEGREES
=
TAU
/
360
Text
¶
NORMAL
=
"NORMAL"
ITALIC
=
"ITALIC"
OBLIQUE
=
"OBLIQUE"
BOLD
=
"BOLD"
Stroke width
¶
DEFAULT_STROKE_WIDTH
=
4
Colours
¶
Here are the preview of default colours. (Modified from
elteoremadebeethoven
)
BLUE
BLUE_E
BLUE_D
BLUE_C
BLUE_B
BLUE_A
TEAL
TEAL_E
TEAL_D
TEAL_C
TEAL_B
TEAL_A
GREEN
GREEN_E
GREEN_D
GREEN_C
GREEN_B
GREEN_A
YELLOW
YELLOW_E
YELLOW_D
YELLOW_C
YELLOW_B
YELLOW_A
GOLD
GOLD_E
GOLD_D
GOLD_C
GOLD_B
GOLD_A
RED
RED_E
RED_D
RED_C
RED_B
RED_A
MAROON
MAROON_E
MAROON_D
MAROON_C
MAROON_B
MAROON_A
PURPLE
PURPLE_E
PURPLE_D
PURPLE_C
PURPLE_B
PURPLE_A
GREY
GREY_E
GREY_D
GREY_C
GREY_B
GREY_A
Others
WHITE
BLACK
GREY_BROWN
DARK_BROWN
LIGHT_BROWN
PINK
LIGHT_PINK
GREEN_SCREEN
ORANGE
Contents
constants
Frame and pixel shape
Buffs
Run times
Coordinates
Mathematical constant
Text
Stroke width
Colours

Code Examples:
Example 1:
```python
constants.py
```
Example 2:
```python
ASPECT_RATIO = 16.0 / 9.0
FRAME_HEIGHT = 8.0
FRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO
FRAME_Y_RADIUS = FRAME_HEIGHT / 2
FRAME_X_RADIUS = FRAME_WIDTH / 2

DEFAULT_PIXEL_HEIGHT = 1080
DEFAULT_PIXEL_WIDTH = 1920
DEFAULT_FPS = 30
```
Example 3:
```python
SMALL_BUFF = 0.1
MED_SMALL_BUFF = 0.25
MED_LARGE_BUFF = 0.5
LARGE_BUFF = 1

DEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects
```
Example 4:
```python
DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0
DEFAULT_WAIT_TIME = 1.0
```
Example 5:
```python
ORIGIN = np.array((0., 0., 0.))
UP = np.array((0., 1., 0.))
DOWN = np.array((0., -1., 0.))
RIGHT = np.array((1., 0., 0.))
LEFT = np.array((-1., 0., 0.))
IN = np.array((0., 0., -1.))
OUT = np.array((0., 0., 1.))
X_AXIS = np.array((1., 0., 0.))
Y_AXIS = np.array((0., 1., 0.))
Z_AXIS = np.array((0., 0., 1.))

# Useful abbreviations for diagonals
UL = UP + LEFT
UR = UP + RIGHT
DL = DOWN + LEFT
DR = DOWN + RIGHT

TOP = FRAME_Y_RADIUS * UP
BOTTOM = FRAME_Y_RADIUS * DOWN
LEFT_SIDE = FRAME_X_RADIUS * LEFT
RIGHT_SIDE = FRAME_X_RADIUS * RIGHT
```
Example 6:
```python
PI = np.pi
TAU = 2 * PI
DEGREES = TAU / 360
```
Example 7:
```python
NORMAL = "NORMAL"
ITALIC = "ITALIC"
OBLIQUE = "OBLIQUE"
BOLD = "BOLD"
```
Example 8:
```python
DEFAULT_STROKE_WIDTH = 4
```

================================================================================

=== constants - manim  documentation ===
URL: https://3b1b.github.io/manim/documentation/constants.html#coordinates
Content:
constants
¶
The
constants.py
in the
manimlib
folder defines the constants
needed when running manim. Some constants are not explained here because
they are only used inside manim.
Frame and pixel shape
¶
ASPECT_RATIO
=
16.0
/
9.0
FRAME_HEIGHT
=
8.0
FRAME_WIDTH
=
FRAME_HEIGHT
*
ASPECT_RATIO
FRAME_Y_RADIUS
=
FRAME_HEIGHT
/
2
FRAME_X_RADIUS
=
FRAME_WIDTH
/
2
DEFAULT_PIXEL_HEIGHT
=
1080
DEFAULT_PIXEL_WIDTH
=
1920
DEFAULT_FPS
=
30
Buffs
¶
SMALL_BUFF
=
0.1
MED_SMALL_BUFF
=
0.25
MED_LARGE_BUFF
=
0.5
LARGE_BUFF
=
1
DEFAULT_MOBJECT_TO_EDGE_BUFFER
=
MED_LARGE_BUFF
# Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER
=
MED_SMALL_BUFF
# Distance between objects
Run times
¶
DEFAULT_POINTWISE_FUNCTION_RUN_TIME
=
3.0
DEFAULT_WAIT_TIME
=
1.0
Coordinates
¶
manim uses three-dimensional coordinates and uses the type of
ndarray
ORIGIN
=
np
.
array
((
0.
,
0.
,
0.
))
UP
=
np
.
array
((
0.
,
1.
,
0.
))
DOWN
=
np
.
array
((
0.
,
-
1.
,
0.
))
RIGHT
=
np
.
array
((
1.
,
0.
,
0.
))
LEFT
=
np
.
array
((
-
1.
,
0.
,
0.
))
IN
=
np
.
array
((
0.
,
0.
,
-
1.
))
OUT
=
np
.
array
((
0.
,
0.
,
1.
))
X_AXIS
=
np
.
array
((
1.
,
0.
,
0.
))
Y_AXIS
=
np
.
array
((
0.
,
1.
,
0.
))
Z_AXIS
=
np
.
array
((
0.
,
0.
,
1.
))
# Useful abbreviations for diagonals
UL
=
UP
+
LEFT
UR
=
UP
+
RIGHT
DL
=
DOWN
+
LEFT
DR
=
DOWN
+
RIGHT
TOP
=
FRAME_Y_RADIUS
*
UP
BOTTOM
=
FRAME_Y_RADIUS
*
DOWN
LEFT_SIDE
=
FRAME_X_RADIUS
*
LEFT
RIGHT_SIDE
=
FRAME_X_RADIUS
*
RIGHT
Mathematical constant
¶
PI
=
np
.
pi
TAU
=
2
*
PI
DEGREES
=
TAU
/
360
Text
¶
NORMAL
=
"NORMAL"
ITALIC
=
"ITALIC"
OBLIQUE
=
"OBLIQUE"
BOLD
=
"BOLD"
Stroke width
¶
DEFAULT_STROKE_WIDTH
=
4
Colours
¶
Here are the preview of default colours. (Modified from
elteoremadebeethoven
)
BLUE
BLUE_E
BLUE_D
BLUE_C
BLUE_B
BLUE_A
TEAL
TEAL_E
TEAL_D
TEAL_C
TEAL_B
TEAL_A
GREEN
GREEN_E
GREEN_D
GREEN_C
GREEN_B
GREEN_A
YELLOW
YELLOW_E
YELLOW_D
YELLOW_C
YELLOW_B
YELLOW_A
GOLD
GOLD_E
GOLD_D
GOLD_C
GOLD_B
GOLD_A
RED
RED_E
RED_D
RED_C
RED_B
RED_A
MAROON
MAROON_E
MAROON_D
MAROON_C
MAROON_B
MAROON_A
PURPLE
PURPLE_E
PURPLE_D
PURPLE_C
PURPLE_B
PURPLE_A
GREY
GREY_E
GREY_D
GREY_C
GREY_B
GREY_A
Others
WHITE
BLACK
GREY_BROWN
DARK_BROWN
LIGHT_BROWN
PINK
LIGHT_PINK
GREEN_SCREEN
ORANGE
Contents
constants
Frame and pixel shape
Buffs
Run times
Coordinates
Mathematical constant
Text
Stroke width
Colours

Code Examples:
Example 1:
```python
constants.py
```
Example 2:
```python
ASPECT_RATIO = 16.0 / 9.0
FRAME_HEIGHT = 8.0
FRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO
FRAME_Y_RADIUS = FRAME_HEIGHT / 2
FRAME_X_RADIUS = FRAME_WIDTH / 2

DEFAULT_PIXEL_HEIGHT = 1080
DEFAULT_PIXEL_WIDTH = 1920
DEFAULT_FPS = 30
```
Example 3:
```python
SMALL_BUFF = 0.1
MED_SMALL_BUFF = 0.25
MED_LARGE_BUFF = 0.5
LARGE_BUFF = 1

DEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects
```
Example 4:
```python
DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0
DEFAULT_WAIT_TIME = 1.0
```
Example 5:
```python
ORIGIN = np.array((0., 0., 0.))
UP = np.array((0., 1., 0.))
DOWN = np.array((0., -1., 0.))
RIGHT = np.array((1., 0., 0.))
LEFT = np.array((-1., 0., 0.))
IN = np.array((0., 0., -1.))
OUT = np.array((0., 0., 1.))
X_AXIS = np.array((1., 0., 0.))
Y_AXIS = np.array((0., 1., 0.))
Z_AXIS = np.array((0., 0., 1.))

# Useful abbreviations for diagonals
UL = UP + LEFT
UR = UP + RIGHT
DL = DOWN + LEFT
DR = DOWN + RIGHT

TOP = FRAME_Y_RADIUS * UP
BOTTOM = FRAME_Y_RADIUS * DOWN
LEFT_SIDE = FRAME_X_RADIUS * LEFT
RIGHT_SIDE = FRAME_X_RADIUS * RIGHT
```
Example 6:
```python
PI = np.pi
TAU = 2 * PI
DEGREES = TAU / 360
```
Example 7:
```python
NORMAL = "NORMAL"
ITALIC = "ITALIC"
OBLIQUE = "OBLIQUE"
BOLD = "BOLD"
```
Example 8:
```python
DEFAULT_STROKE_WIDTH = 4
```

================================================================================

=== constants - manim  documentation ===
URL: https://3b1b.github.io/manim/documentation/constants.html#mathematical-constant
Content:
constants
¶
The
constants.py
in the
manimlib
folder defines the constants
needed when running manim. Some constants are not explained here because
they are only used inside manim.
Frame and pixel shape
¶
ASPECT_RATIO
=
16.0
/
9.0
FRAME_HEIGHT
=
8.0
FRAME_WIDTH
=
FRAME_HEIGHT
*
ASPECT_RATIO
FRAME_Y_RADIUS
=
FRAME_HEIGHT
/
2
FRAME_X_RADIUS
=
FRAME_WIDTH
/
2
DEFAULT_PIXEL_HEIGHT
=
1080
DEFAULT_PIXEL_WIDTH
=
1920
DEFAULT_FPS
=
30
Buffs
¶
SMALL_BUFF
=
0.1
MED_SMALL_BUFF
=
0.25
MED_LARGE_BUFF
=
0.5
LARGE_BUFF
=
1
DEFAULT_MOBJECT_TO_EDGE_BUFFER
=
MED_LARGE_BUFF
# Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER
=
MED_SMALL_BUFF
# Distance between objects
Run times
¶
DEFAULT_POINTWISE_FUNCTION_RUN_TIME
=
3.0
DEFAULT_WAIT_TIME
=
1.0
Coordinates
¶
manim uses three-dimensional coordinates and uses the type of
ndarray
ORIGIN
=
np
.
array
((
0.
,
0.
,
0.
))
UP
=
np
.
array
((
0.
,
1.
,
0.
))
DOWN
=
np
.
array
((
0.
,
-
1.
,
0.
))
RIGHT
=
np
.
array
((
1.
,
0.
,
0.
))
LEFT
=
np
.
array
((
-
1.
,
0.
,
0.
))
IN
=
np
.
array
((
0.
,
0.
,
-
1.
))
OUT
=
np
.
array
((
0.
,
0.
,
1.
))
X_AXIS
=
np
.
array
((
1.
,
0.
,
0.
))
Y_AXIS
=
np
.
array
((
0.
,
1.
,
0.
))
Z_AXIS
=
np
.
array
((
0.
,
0.
,
1.
))
# Useful abbreviations for diagonals
UL
=
UP
+
LEFT
UR
=
UP
+
RIGHT
DL
=
DOWN
+
LEFT
DR
=
DOWN
+
RIGHT
TOP
=
FRAME_Y_RADIUS
*
UP
BOTTOM
=
FRAME_Y_RADIUS
*
DOWN
LEFT_SIDE
=
FRAME_X_RADIUS
*
LEFT
RIGHT_SIDE
=
FRAME_X_RADIUS
*
RIGHT
Mathematical constant
¶
PI
=
np
.
pi
TAU
=
2
*
PI
DEGREES
=
TAU
/
360
Text
¶
NORMAL
=
"NORMAL"
ITALIC
=
"ITALIC"
OBLIQUE
=
"OBLIQUE"
BOLD
=
"BOLD"
Stroke width
¶
DEFAULT_STROKE_WIDTH
=
4
Colours
¶
Here are the preview of default colours. (Modified from
elteoremadebeethoven
)
BLUE
BLUE_E
BLUE_D
BLUE_C
BLUE_B
BLUE_A
TEAL
TEAL_E
TEAL_D
TEAL_C
TEAL_B
TEAL_A
GREEN
GREEN_E
GREEN_D
GREEN_C
GREEN_B
GREEN_A
YELLOW
YELLOW_E
YELLOW_D
YELLOW_C
YELLOW_B
YELLOW_A
GOLD
GOLD_E
GOLD_D
GOLD_C
GOLD_B
GOLD_A
RED
RED_E
RED_D
RED_C
RED_B
RED_A
MAROON
MAROON_E
MAROON_D
MAROON_C
MAROON_B
MAROON_A
PURPLE
PURPLE_E
PURPLE_D
PURPLE_C
PURPLE_B
PURPLE_A
GREY
GREY_E
GREY_D
GREY_C
GREY_B
GREY_A
Others
WHITE
BLACK
GREY_BROWN
DARK_BROWN
LIGHT_BROWN
PINK
LIGHT_PINK
GREEN_SCREEN
ORANGE
Contents
constants
Frame and pixel shape
Buffs
Run times
Coordinates
Mathematical constant
Text
Stroke width
Colours

Code Examples:
Example 1:
```python
constants.py
```
Example 2:
```python
ASPECT_RATIO = 16.0 / 9.0
FRAME_HEIGHT = 8.0
FRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO
FRAME_Y_RADIUS = FRAME_HEIGHT / 2
FRAME_X_RADIUS = FRAME_WIDTH / 2

DEFAULT_PIXEL_HEIGHT = 1080
DEFAULT_PIXEL_WIDTH = 1920
DEFAULT_FPS = 30
```
Example 3:
```python
SMALL_BUFF = 0.1
MED_SMALL_BUFF = 0.25
MED_LARGE_BUFF = 0.5
LARGE_BUFF = 1

DEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects
```
Example 4:
```python
DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0
DEFAULT_WAIT_TIME = 1.0
```
Example 5:
```python
ORIGIN = np.array((0., 0., 0.))
UP = np.array((0., 1., 0.))
DOWN = np.array((0., -1., 0.))
RIGHT = np.array((1., 0., 0.))
LEFT = np.array((-1., 0., 0.))
IN = np.array((0., 0., -1.))
OUT = np.array((0., 0., 1.))
X_AXIS = np.array((1., 0., 0.))
Y_AXIS = np.array((0., 1., 0.))
Z_AXIS = np.array((0., 0., 1.))

# Useful abbreviations for diagonals
UL = UP + LEFT
UR = UP + RIGHT
DL = DOWN + LEFT
DR = DOWN + RIGHT

TOP = FRAME_Y_RADIUS * UP
BOTTOM = FRAME_Y_RADIUS * DOWN
LEFT_SIDE = FRAME_X_RADIUS * LEFT
RIGHT_SIDE = FRAME_X_RADIUS * RIGHT
```
Example 6:
```python
PI = np.pi
TAU = 2 * PI
DEGREES = TAU / 360
```
Example 7:
```python
NORMAL = "NORMAL"
ITALIC = "ITALIC"
OBLIQUE = "OBLIQUE"
BOLD = "BOLD"
```
Example 8:
```python
DEFAULT_STROKE_WIDTH = 4
```

================================================================================

=== constants - manim  documentation ===
URL: https://3b1b.github.io/manim/documentation/constants.html#text
Content:
constants
¶
The
constants.py
in the
manimlib
folder defines the constants
needed when running manim. Some constants are not explained here because
they are only used inside manim.
Frame and pixel shape
¶
ASPECT_RATIO
=
16.0
/
9.0
FRAME_HEIGHT
=
8.0
FRAME_WIDTH
=
FRAME_HEIGHT
*
ASPECT_RATIO
FRAME_Y_RADIUS
=
FRAME_HEIGHT
/
2
FRAME_X_RADIUS
=
FRAME_WIDTH
/
2
DEFAULT_PIXEL_HEIGHT
=
1080
DEFAULT_PIXEL_WIDTH
=
1920
DEFAULT_FPS
=
30
Buffs
¶
SMALL_BUFF
=
0.1
MED_SMALL_BUFF
=
0.25
MED_LARGE_BUFF
=
0.5
LARGE_BUFF
=
1
DEFAULT_MOBJECT_TO_EDGE_BUFFER
=
MED_LARGE_BUFF
# Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER
=
MED_SMALL_BUFF
# Distance between objects
Run times
¶
DEFAULT_POINTWISE_FUNCTION_RUN_TIME
=
3.0
DEFAULT_WAIT_TIME
=
1.0
Coordinates
¶
manim uses three-dimensional coordinates and uses the type of
ndarray
ORIGIN
=
np
.
array
((
0.
,
0.
,
0.
))
UP
=
np
.
array
((
0.
,
1.
,
0.
))
DOWN
=
np
.
array
((
0.
,
-
1.
,
0.
))
RIGHT
=
np
.
array
((
1.
,
0.
,
0.
))
LEFT
=
np
.
array
((
-
1.
,
0.
,
0.
))
IN
=
np
.
array
((
0.
,
0.
,
-
1.
))
OUT
=
np
.
array
((
0.
,
0.
,
1.
))
X_AXIS
=
np
.
array
((
1.
,
0.
,
0.
))
Y_AXIS
=
np
.
array
((
0.
,
1.
,
0.
))
Z_AXIS
=
np
.
array
((
0.
,
0.
,
1.
))
# Useful abbreviations for diagonals
UL
=
UP
+
LEFT
UR
=
UP
+
RIGHT
DL
=
DOWN
+
LEFT
DR
=
DOWN
+
RIGHT
TOP
=
FRAME_Y_RADIUS
*
UP
BOTTOM
=
FRAME_Y_RADIUS
*
DOWN
LEFT_SIDE
=
FRAME_X_RADIUS
*
LEFT
RIGHT_SIDE
=
FRAME_X_RADIUS
*
RIGHT
Mathematical constant
¶
PI
=
np
.
pi
TAU
=
2
*
PI
DEGREES
=
TAU
/
360
Text
¶
NORMAL
=
"NORMAL"
ITALIC
=
"ITALIC"
OBLIQUE
=
"OBLIQUE"
BOLD
=
"BOLD"
Stroke width
¶
DEFAULT_STROKE_WIDTH
=
4
Colours
¶
Here are the preview of default colours. (Modified from
elteoremadebeethoven
)
BLUE
BLUE_E
BLUE_D
BLUE_C
BLUE_B
BLUE_A
TEAL
TEAL_E
TEAL_D
TEAL_C
TEAL_B
TEAL_A
GREEN
GREEN_E
GREEN_D
GREEN_C
GREEN_B
GREEN_A
YELLOW
YELLOW_E
YELLOW_D
YELLOW_C
YELLOW_B
YELLOW_A
GOLD
GOLD_E
GOLD_D
GOLD_C
GOLD_B
GOLD_A
RED
RED_E
RED_D
RED_C
RED_B
RED_A
MAROON
MAROON_E
MAROON_D
MAROON_C
MAROON_B
MAROON_A
PURPLE
PURPLE_E
PURPLE_D
PURPLE_C
PURPLE_B
PURPLE_A
GREY
GREY_E
GREY_D
GREY_C
GREY_B
GREY_A
Others
WHITE
BLACK
GREY_BROWN
DARK_BROWN
LIGHT_BROWN
PINK
LIGHT_PINK
GREEN_SCREEN
ORANGE
Contents
constants
Frame and pixel shape
Buffs
Run times
Coordinates
Mathematical constant
Text
Stroke width
Colours

Code Examples:
Example 1:
```python
constants.py
```
Example 2:
```python
ASPECT_RATIO = 16.0 / 9.0
FRAME_HEIGHT = 8.0
FRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO
FRAME_Y_RADIUS = FRAME_HEIGHT / 2
FRAME_X_RADIUS = FRAME_WIDTH / 2

DEFAULT_PIXEL_HEIGHT = 1080
DEFAULT_PIXEL_WIDTH = 1920
DEFAULT_FPS = 30
```
Example 3:
```python
SMALL_BUFF = 0.1
MED_SMALL_BUFF = 0.25
MED_LARGE_BUFF = 0.5
LARGE_BUFF = 1

DEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects
```
Example 4:
```python
DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0
DEFAULT_WAIT_TIME = 1.0
```
Example 5:
```python
ORIGIN = np.array((0., 0., 0.))
UP = np.array((0., 1., 0.))
DOWN = np.array((0., -1., 0.))
RIGHT = np.array((1., 0., 0.))
LEFT = np.array((-1., 0., 0.))
IN = np.array((0., 0., -1.))
OUT = np.array((0., 0., 1.))
X_AXIS = np.array((1., 0., 0.))
Y_AXIS = np.array((0., 1., 0.))
Z_AXIS = np.array((0., 0., 1.))

# Useful abbreviations for diagonals
UL = UP + LEFT
UR = UP + RIGHT
DL = DOWN + LEFT
DR = DOWN + RIGHT

TOP = FRAME_Y_RADIUS * UP
BOTTOM = FRAME_Y_RADIUS * DOWN
LEFT_SIDE = FRAME_X_RADIUS * LEFT
RIGHT_SIDE = FRAME_X_RADIUS * RIGHT
```
Example 6:
```python
PI = np.pi
TAU = 2 * PI
DEGREES = TAU / 360
```
Example 7:
```python
NORMAL = "NORMAL"
ITALIC = "ITALIC"
OBLIQUE = "OBLIQUE"
BOLD = "BOLD"
```
Example 8:
```python
DEFAULT_STROKE_WIDTH = 4
```

================================================================================

=== constants - manim  documentation ===
URL: https://3b1b.github.io/manim/documentation/constants.html#stroke-width
Content:
constants
¶
The
constants.py
in the
manimlib
folder defines the constants
needed when running manim. Some constants are not explained here because
they are only used inside manim.
Frame and pixel shape
¶
ASPECT_RATIO
=
16.0
/
9.0
FRAME_HEIGHT
=
8.0
FRAME_WIDTH
=
FRAME_HEIGHT
*
ASPECT_RATIO
FRAME_Y_RADIUS
=
FRAME_HEIGHT
/
2
FRAME_X_RADIUS
=
FRAME_WIDTH
/
2
DEFAULT_PIXEL_HEIGHT
=
1080
DEFAULT_PIXEL_WIDTH
=
1920
DEFAULT_FPS
=
30
Buffs
¶
SMALL_BUFF
=
0.1
MED_SMALL_BUFF
=
0.25
MED_LARGE_BUFF
=
0.5
LARGE_BUFF
=
1
DEFAULT_MOBJECT_TO_EDGE_BUFFER
=
MED_LARGE_BUFF
# Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER
=
MED_SMALL_BUFF
# Distance between objects
Run times
¶
DEFAULT_POINTWISE_FUNCTION_RUN_TIME
=
3.0
DEFAULT_WAIT_TIME
=
1.0
Coordinates
¶
manim uses three-dimensional coordinates and uses the type of
ndarray
ORIGIN
=
np
.
array
((
0.
,
0.
,
0.
))
UP
=
np
.
array
((
0.
,
1.
,
0.
))
DOWN
=
np
.
array
((
0.
,
-
1.
,
0.
))
RIGHT
=
np
.
array
((
1.
,
0.
,
0.
))
LEFT
=
np
.
array
((
-
1.
,
0.
,
0.
))
IN
=
np
.
array
((
0.
,
0.
,
-
1.
))
OUT
=
np
.
array
((
0.
,
0.
,
1.
))
X_AXIS
=
np
.
array
((
1.
,
0.
,
0.
))
Y_AXIS
=
np
.
array
((
0.
,
1.
,
0.
))
Z_AXIS
=
np
.
array
((
0.
,
0.
,
1.
))
# Useful abbreviations for diagonals
UL
=
UP
+
LEFT
UR
=
UP
+
RIGHT
DL
=
DOWN
+
LEFT
DR
=
DOWN
+
RIGHT
TOP
=
FRAME_Y_RADIUS
*
UP
BOTTOM
=
FRAME_Y_RADIUS
*
DOWN
LEFT_SIDE
=
FRAME_X_RADIUS
*
LEFT
RIGHT_SIDE
=
FRAME_X_RADIUS
*
RIGHT
Mathematical constant
¶
PI
=
np
.
pi
TAU
=
2
*
PI
DEGREES
=
TAU
/
360
Text
¶
NORMAL
=
"NORMAL"
ITALIC
=
"ITALIC"
OBLIQUE
=
"OBLIQUE"
BOLD
=
"BOLD"
Stroke width
¶
DEFAULT_STROKE_WIDTH
=
4
Colours
¶
Here are the preview of default colours. (Modified from
elteoremadebeethoven
)
BLUE
BLUE_E
BLUE_D
BLUE_C
BLUE_B
BLUE_A
TEAL
TEAL_E
TEAL_D
TEAL_C
TEAL_B
TEAL_A
GREEN
GREEN_E
GREEN_D
GREEN_C
GREEN_B
GREEN_A
YELLOW
YELLOW_E
YELLOW_D
YELLOW_C
YELLOW_B
YELLOW_A
GOLD
GOLD_E
GOLD_D
GOLD_C
GOLD_B
GOLD_A
RED
RED_E
RED_D
RED_C
RED_B
RED_A
MAROON
MAROON_E
MAROON_D
MAROON_C
MAROON_B
MAROON_A
PURPLE
PURPLE_E
PURPLE_D
PURPLE_C
PURPLE_B
PURPLE_A
GREY
GREY_E
GREY_D
GREY_C
GREY_B
GREY_A
Others
WHITE
BLACK
GREY_BROWN
DARK_BROWN
LIGHT_BROWN
PINK
LIGHT_PINK
GREEN_SCREEN
ORANGE
Contents
constants
Frame and pixel shape
Buffs
Run times
Coordinates
Mathematical constant
Text
Stroke width
Colours

Code Examples:
Example 1:
```python
constants.py
```
Example 2:
```python
ASPECT_RATIO = 16.0 / 9.0
FRAME_HEIGHT = 8.0
FRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO
FRAME_Y_RADIUS = FRAME_HEIGHT / 2
FRAME_X_RADIUS = FRAME_WIDTH / 2

DEFAULT_PIXEL_HEIGHT = 1080
DEFAULT_PIXEL_WIDTH = 1920
DEFAULT_FPS = 30
```
Example 3:
```python
SMALL_BUFF = 0.1
MED_SMALL_BUFF = 0.25
MED_LARGE_BUFF = 0.5
LARGE_BUFF = 1

DEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects
```
Example 4:
```python
DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0
DEFAULT_WAIT_TIME = 1.0
```
Example 5:
```python
ORIGIN = np.array((0., 0., 0.))
UP = np.array((0., 1., 0.))
DOWN = np.array((0., -1., 0.))
RIGHT = np.array((1., 0., 0.))
LEFT = np.array((-1., 0., 0.))
IN = np.array((0., 0., -1.))
OUT = np.array((0., 0., 1.))
X_AXIS = np.array((1., 0., 0.))
Y_AXIS = np.array((0., 1., 0.))
Z_AXIS = np.array((0., 0., 1.))

# Useful abbreviations for diagonals
UL = UP + LEFT
UR = UP + RIGHT
DL = DOWN + LEFT
DR = DOWN + RIGHT

TOP = FRAME_Y_RADIUS * UP
BOTTOM = FRAME_Y_RADIUS * DOWN
LEFT_SIDE = FRAME_X_RADIUS * LEFT
RIGHT_SIDE = FRAME_X_RADIUS * RIGHT
```
Example 6:
```python
PI = np.pi
TAU = 2 * PI
DEGREES = TAU / 360
```
Example 7:
```python
NORMAL = "NORMAL"
ITALIC = "ITALIC"
OBLIQUE = "OBLIQUE"
BOLD = "BOLD"
```
Example 8:
```python
DEFAULT_STROKE_WIDTH = 4
```

================================================================================

=== constants - manim  documentation ===
URL: https://3b1b.github.io/manim/documentation/constants.html#colours
Content:
constants
¶
The
constants.py
in the
manimlib
folder defines the constants
needed when running manim. Some constants are not explained here because
they are only used inside manim.
Frame and pixel shape
¶
ASPECT_RATIO
=
16.0
/
9.0
FRAME_HEIGHT
=
8.0
FRAME_WIDTH
=
FRAME_HEIGHT
*
ASPECT_RATIO
FRAME_Y_RADIUS
=
FRAME_HEIGHT
/
2
FRAME_X_RADIUS
=
FRAME_WIDTH
/
2
DEFAULT_PIXEL_HEIGHT
=
1080
DEFAULT_PIXEL_WIDTH
=
1920
DEFAULT_FPS
=
30
Buffs
¶
SMALL_BUFF
=
0.1
MED_SMALL_BUFF
=
0.25
MED_LARGE_BUFF
=
0.5
LARGE_BUFF
=
1
DEFAULT_MOBJECT_TO_EDGE_BUFFER
=
MED_LARGE_BUFF
# Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER
=
MED_SMALL_BUFF
# Distance between objects
Run times
¶
DEFAULT_POINTWISE_FUNCTION_RUN_TIME
=
3.0
DEFAULT_WAIT_TIME
=
1.0
Coordinates
¶
manim uses three-dimensional coordinates and uses the type of
ndarray
ORIGIN
=
np
.
array
((
0.
,
0.
,
0.
))
UP
=
np
.
array
((
0.
,
1.
,
0.
))
DOWN
=
np
.
array
((
0.
,
-
1.
,
0.
))
RIGHT
=
np
.
array
((
1.
,
0.
,
0.
))
LEFT
=
np
.
array
((
-
1.
,
0.
,
0.
))
IN
=
np
.
array
((
0.
,
0.
,
-
1.
))
OUT
=
np
.
array
((
0.
,
0.
,
1.
))
X_AXIS
=
np
.
array
((
1.
,
0.
,
0.
))
Y_AXIS
=
np
.
array
((
0.
,
1.
,
0.
))
Z_AXIS
=
np
.
array
((
0.
,
0.
,
1.
))
# Useful abbreviations for diagonals
UL
=
UP
+
LEFT
UR
=
UP
+
RIGHT
DL
=
DOWN
+
LEFT
DR
=
DOWN
+
RIGHT
TOP
=
FRAME_Y_RADIUS
*
UP
BOTTOM
=
FRAME_Y_RADIUS
*
DOWN
LEFT_SIDE
=
FRAME_X_RADIUS
*
LEFT
RIGHT_SIDE
=
FRAME_X_RADIUS
*
RIGHT
Mathematical constant
¶
PI
=
np
.
pi
TAU
=
2
*
PI
DEGREES
=
TAU
/
360
Text
¶
NORMAL
=
"NORMAL"
ITALIC
=
"ITALIC"
OBLIQUE
=
"OBLIQUE"
BOLD
=
"BOLD"
Stroke width
¶
DEFAULT_STROKE_WIDTH
=
4
Colours
¶
Here are the preview of default colours. (Modified from
elteoremadebeethoven
)
BLUE
BLUE_E
BLUE_D
BLUE_C
BLUE_B
BLUE_A
TEAL
TEAL_E
TEAL_D
TEAL_C
TEAL_B
TEAL_A
GREEN
GREEN_E
GREEN_D
GREEN_C
GREEN_B
GREEN_A
YELLOW
YELLOW_E
YELLOW_D
YELLOW_C
YELLOW_B
YELLOW_A
GOLD
GOLD_E
GOLD_D
GOLD_C
GOLD_B
GOLD_A
RED
RED_E
RED_D
RED_C
RED_B
RED_A
MAROON
MAROON_E
MAROON_D
MAROON_C
MAROON_B
MAROON_A
PURPLE
PURPLE_E
PURPLE_D
PURPLE_C
PURPLE_B
PURPLE_A
GREY
GREY_E
GREY_D
GREY_C
GREY_B
GREY_A
Others
WHITE
BLACK
GREY_BROWN
DARK_BROWN
LIGHT_BROWN
PINK
LIGHT_PINK
GREEN_SCREEN
ORANGE
Contents
constants
Frame and pixel shape
Buffs
Run times
Coordinates
Mathematical constant
Text
Stroke width
Colours

Code Examples:
Example 1:
```python
constants.py
```
Example 2:
```python
ASPECT_RATIO = 16.0 / 9.0
FRAME_HEIGHT = 8.0
FRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO
FRAME_Y_RADIUS = FRAME_HEIGHT / 2
FRAME_X_RADIUS = FRAME_WIDTH / 2

DEFAULT_PIXEL_HEIGHT = 1080
DEFAULT_PIXEL_WIDTH = 1920
DEFAULT_FPS = 30
```
Example 3:
```python
SMALL_BUFF = 0.1
MED_SMALL_BUFF = 0.25
MED_LARGE_BUFF = 0.5
LARGE_BUFF = 1

DEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF    # Distance between object and edge
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF # Distance between objects
```
Example 4:
```python
DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0
DEFAULT_WAIT_TIME = 1.0
```
Example 5:
```python
ORIGIN = np.array((0., 0., 0.))
UP = np.array((0., 1., 0.))
DOWN = np.array((0., -1., 0.))
RIGHT = np.array((1., 0., 0.))
LEFT = np.array((-1., 0., 0.))
IN = np.array((0., 0., -1.))
OUT = np.array((0., 0., 1.))
X_AXIS = np.array((1., 0., 0.))
Y_AXIS = np.array((0., 1., 0.))
Z_AXIS = np.array((0., 0., 1.))

# Useful abbreviations for diagonals
UL = UP + LEFT
UR = UP + RIGHT
DL = DOWN + LEFT
DR = DOWN + RIGHT

TOP = FRAME_Y_RADIUS * UP
BOTTOM = FRAME_Y_RADIUS * DOWN
LEFT_SIDE = FRAME_X_RADIUS * LEFT
RIGHT_SIDE = FRAME_X_RADIUS * RIGHT
```
Example 6:
```python
PI = np.pi
TAU = 2 * PI
DEGREES = TAU / 360
```
Example 7:
```python
NORMAL = "NORMAL"
ITALIC = "ITALIC"
OBLIQUE = "OBLIQUE"
BOLD = "BOLD"
```
Example 8:
```python
DEFAULT_STROKE_WIDTH = 4
```

================================================================================

=== custom_config - manim  documentation ===
URL: https://3b1b.github.io/manim/documentation/custom_config.html#directories
Content:
custom_config
¶
directories
¶
mirror_module_path
(
True
or
False
) Whether to create a folder named the name of the
running file under the
output
path, and save the output (
images/
or
videos/
) in it.
output
Output file path, the videos will be saved in the
videos/
folder under it,
and the pictures will be saved in the
images/
folder under it.
For example, if you set
output
to
"/.../manim/output"
and
mirror_module_path
to
False
, then you exported
Scene1
in the code
file and saved the last frame, then the final directory structure will be like:
manim/
    ├── manimlib/
    │   ├── animation/
    │   ├── ...
    │   ├── default_config.yml
    │   └── window.py
    ├── output/
    │   ├── images
│   │   └── Scene1.png
│   └── videos
│       └── Scene1.mp4
├── code.py
    └── custom_config.yml
But if you set
mirror_module_path
to
True
, the directory structure will be:
manim/
    ├── manimlib/
    │   ├── animation/
    │   ├── ...
    │   ├── default_config.yml
    │   └── window.py
    ├── output/
│   └── code/
│       ├── images
    │       │   └── Scene1.png
    │       └── videos
    │           └── Scene1.mp4
    ├── code.py
    └── custom_config.yml
raster_images
The directory for storing raster images to be used in the code (including
.jpg
,
.jpeg
,
.png
and
.gif
), which will be read by
ImageMobject
.
vector_images
The directory for storing vector images to be used in the code (including
.svg
and
.xdv
), which will be read by
SVGMobject
.
sounds
The directory for storing sound files to be used in
Scene.add_sound()
(
including
.wav
and
.mp3
).
temporary_storage
The directory for storing temporarily generated cache files, including
Tex
cache,
Text
cache and storage of object points.
tex
¶
executable
The executable program used to compile LaTeX (
latex
or
xelatex
-no-pdf
is recommended)
template_file
LaTeX template used, in
manimlib/tex_templates
intermediate_filetype
The type of intermediate vector file generated after compilation (
dvi
if
latex
is used,
xdv
if
xelatex
is used)
text_to_replace
The text to be replaced in the template (needn’t to change)
universal_import_line
¶
Import line that need to execute when entering interactive mode directly.
style
¶
font
Default font of Text
text_alignment
Default text alignment for LaTeX
background_color
Default background color
window_position
¶
The relative position of the playback window on the display (two characters,
the first character means upper(U) / middle(O) / lower(D), the second character
means left(L) / middle(O) / right(R)).
window_monitor
¶
The number of the monitor you want the preview window to pop up on. (default is 0)
full_screen
¶
Whether open the window in full screen. (default is false)
break_into_partial_movies
¶
If this is set to
True
, then many small files will be written corresponding
to each
Scene.play
and
Scene.wait
call, and these files will then be combined
to form the full scene.
Sometimes video-editing is made easier when working with the broken up scene, which
effectively has cuts at all the places you might want.
camera_resolutions
¶
Export resolutions
low
Low resolutions (default is 480p)
medium
Medium resolutions (default is 720p)
high
High resolutions (default is 1080p)
ultra_high
Ultra high resolutions (default is 4K)
default_resolutions
Default resolutions (one of the above four, default is high)
fps
¶
Export frame rate. (default is 30)
Contents
custom_config
directories
tex
universal_import_line
style
window_position
window_monitor
full_screen
break_into_partial_movies
camera_resolutions
fps

Code Examples:
Example 1:
```python
directories
```
Example 2:
```python
mirror_module_path
```
Example 3:
```python
"/.../manim/output"
```
Example 4:
```python
mirror_module_path
```
Example 5:
```python
manim/
    ├── manimlib/
    │   ├── animation/
    │   ├── ...
    │   ├── default_config.yml
    │   └── window.py
    ├── output/
    │   ├── images
    │   │   └── Scene1.png
    │   └── videos
    │       └── Scene1.mp4
    ├── code.py
    └── custom_config.yml
```
Example 6:
```python
mirror_module_path
```
Example 7:
```python
manim/
    ├── manimlib/
    │   ├── animation/
    │   ├── ...
    │   ├── default_config.yml
    │   └── window.py
    ├── output/
    │   └── code/
    │       ├── images
    │       │   └── Scene1.png
    │       └── videos
    │           └── Scene1.mp4
    ├── code.py
    └── custom_config.yml
```
Example 8:
```python
raster_images
```
Example 9:
```python
ImageMobject
```
Example 10:
```python
vector_images
```
Example 11:
```python
Scene.add_sound()
```
Example 12:
```python
temporary_storage
```
Example 13:
```python
xelatex -no-pdf
```
Example 14:
```python
template_file
```
Example 15:
```python
manimlib/tex_templates
```
Example 16:
```python
intermediate_filetype
```
Example 17:
```python
text_to_replace
```
Example 18:
```python
universal_import_line
```
Example 19:
```python
text_alignment
```
Example 20:
```python
background_color
```
Example 21:
```python
window_position
```
Example 22:
```python
window_monitor
```
Example 23:
```python
full_screen
```
Example 24:
```python
break_into_partial_movies
```
Example 25:
```python
camera_resolutions
```
Example 26:
```python
default_resolutions
```
Example 27:
```python
directories
```
Example 28:
```python
universal_import_line
```
Example 29:
```python
window_position
```
Example 30:
```python
window_monitor
```
Example 31:
```python
full_screen
```
Example 32:
```python
break_into_partial_movies
```
Example 33:
```python
camera_resolutions
```

================================================================================

=== custom_config - manim  documentation ===
URL: https://3b1b.github.io/manim/documentation/custom_config.html#tex
Content:
custom_config
¶
directories
¶
mirror_module_path
(
True
or
False
) Whether to create a folder named the name of the
running file under the
output
path, and save the output (
images/
or
videos/
) in it.
output
Output file path, the videos will be saved in the
videos/
folder under it,
and the pictures will be saved in the
images/
folder under it.
For example, if you set
output
to
"/.../manim/output"
and
mirror_module_path
to
False
, then you exported
Scene1
in the code
file and saved the last frame, then the final directory structure will be like:
manim/
    ├── manimlib/
    │   ├── animation/
    │   ├── ...
    │   ├── default_config.yml
    │   └── window.py
    ├── output/
    │   ├── images
│   │   └── Scene1.png
│   └── videos
│       └── Scene1.mp4
├── code.py
    └── custom_config.yml
But if you set
mirror_module_path
to
True
, the directory structure will be:
manim/
    ├── manimlib/
    │   ├── animation/
    │   ├── ...
    │   ├── default_config.yml
    │   └── window.py
    ├── output/
│   └── code/
│       ├── images
    │       │   └── Scene1.png
    │       └── videos
    │           └── Scene1.mp4
    ├── code.py
    └── custom_config.yml
raster_images
The directory for storing raster images to be used in the code (including
.jpg
,
.jpeg
,
.png
and
.gif
), which will be read by
ImageMobject
.
vector_images
The directory for storing vector images to be used in the code (including
.svg
and
.xdv
), which will be read by
SVGMobject
.
sounds
The directory for storing sound files to be used in
Scene.add_sound()
(
including
.wav
and
.mp3
).
temporary_storage
The directory for storing temporarily generated cache files, including
Tex
cache,
Text
cache and storage of object points.
tex
¶
executable
The executable program used to compile LaTeX (
latex
or
xelatex
-no-pdf
is recommended)
template_file
LaTeX template used, in
manimlib/tex_templates
intermediate_filetype
The type of intermediate vector file generated after compilation (
dvi
if
latex
is used,
xdv
if
xelatex
is used)
text_to_replace
The text to be replaced in the template (needn’t to change)
universal_import_line
¶
Import line that need to execute when entering interactive mode directly.
style
¶
font
Default font of Text
text_alignment
Default text alignment for LaTeX
background_color
Default background color
window_position
¶
The relative position of the playback window on the display (two characters,
the first character means upper(U) / middle(O) / lower(D), the second character
means left(L) / middle(O) / right(R)).
window_monitor
¶
The number of the monitor you want the preview window to pop up on. (default is 0)
full_screen
¶
Whether open the window in full screen. (default is false)
break_into_partial_movies
¶
If this is set to
True
, then many small files will be written corresponding
to each
Scene.play
and
Scene.wait
call, and these files will then be combined
to form the full scene.
Sometimes video-editing is made easier when working with the broken up scene, which
effectively has cuts at all the places you might want.
camera_resolutions
¶
Export resolutions
low
Low resolutions (default is 480p)
medium
Medium resolutions (default is 720p)
high
High resolutions (default is 1080p)
ultra_high
Ultra high resolutions (default is 4K)
default_resolutions
Default resolutions (one of the above four, default is high)
fps
¶
Export frame rate. (default is 30)
Contents
custom_config
directories
tex
universal_import_line
style
window_position
window_monitor
full_screen
break_into_partial_movies
camera_resolutions
fps

Code Examples:
Example 1:
```python
directories
```
Example 2:
```python
mirror_module_path
```
Example 3:
```python
"/.../manim/output"
```
Example 4:
```python
mirror_module_path
```
Example 5:
```python
manim/
    ├── manimlib/
    │   ├── animation/
    │   ├── ...
    │   ├── default_config.yml
    │   └── window.py
    ├── output/
    │   ├── images
    │   │   └── Scene1.png
    │   └── videos
    │       └── Scene1.mp4
    ├── code.py
    └── custom_config.yml
```
Example 6:
```python
mirror_module_path
```
Example 7:
```python
manim/
    ├── manimlib/
    │   ├── animation/
    │   ├── ...
    │   ├── default_config.yml
    │   └── window.py
    ├── output/
    │   └── code/
    │       ├── images
    │       │   └── Scene1.png
    │       └── videos
    │           └── Scene1.mp4
    ├── code.py
    └── custom_config.yml
```
Example 8:
```python
raster_images
```
Example 9:
```python
ImageMobject
```
Example 10:
```python
vector_images
```
Example 11:
```python
Scene.add_sound()
```
Example 12:
```python
temporary_storage
```
Example 13:
```python
xelatex -no-pdf
```
Example 14:
```python
template_file
```
Example 15:
```python
manimlib/tex_templates
```
Example 16:
```python
intermediate_filetype
```
Example 17:
```python
text_to_replace
```
Example 18:
```python
universal_import_line
```
Example 19:
```python
text_alignment
```
Example 20:
```python
background_color
```
Example 21:
```python
window_position
```
Example 22:
```python
window_monitor
```
Example 23:
```python
full_screen
```
Example 24:
```python
break_into_partial_movies
```
Example 25:
```python
camera_resolutions
```
Example 26:
```python
default_resolutions
```
Example 27:
```python
directories
```
Example 28:
```python
universal_import_line
```
Example 29:
```python
window_position
```
Example 30:
```python
window_monitor
```
Example 31:
```python
full_screen
```
Example 32:
```python
break_into_partial_movies
```
Example 33:
```python
camera_resolutions
```

================================================================================

=== custom_config - manim  documentation ===
URL: https://3b1b.github.io/manim/documentation/custom_config.html#universal-import-line
Content:
custom_config
¶
directories
¶
mirror_module_path
(
True
or
False
) Whether to create a folder named the name of the
running file under the
output
path, and save the output (
images/
or
videos/
) in it.
output
Output file path, the videos will be saved in the
videos/
folder under it,
and the pictures will be saved in the
images/
folder under it.
For example, if you set
output
to
"/.../manim/output"
and
mirror_module_path
to
False
, then you exported
Scene1
in the code
file and saved the last frame, then the final directory structure will be like:
manim/
    ├── manimlib/
    │   ├── animation/
    │   ├── ...
    │   ├── default_config.yml
    │   └── window.py
    ├── output/
    │   ├── images
│   │   └── Scene1.png
│   └── videos
│       └── Scene1.mp4
├── code.py
    └── custom_config.yml
But if you set
mirror_module_path
to
True
, the directory structure will be:
manim/
    ├── manimlib/
    │   ├── animation/
    │   ├── ...
    │   ├── default_config.yml
    │   └── window.py
    ├── output/
│   └── code/
│       ├── images
    │       │   └── Scene1.png
    │       └── videos
    │           └── Scene1.mp4
    ├── code.py
    └── custom_config.yml
raster_images
The directory for storing raster images to be used in the code (including
.jpg
,
.jpeg
,
.png
and
.gif
), which will be read by
ImageMobject
.
vector_images
The directory for storing vector images to be used in the code (including
.svg
and
.xdv
), which will be read by
SVGMobject
.
sounds
The directory for storing sound files to be used in
Scene.add_sound()
(
including
.wav
and
.mp3
).
temporary_storage
The directory for storing temporarily generated cache files, including
Tex
cache,
Text
cache and storage of object points.
tex
¶
executable
The executable program used to compile LaTeX (
latex
or
xelatex
-no-pdf
is recommended)
template_file
LaTeX template used, in
manimlib/tex_templates
intermediate_filetype
The type of intermediate vector file generated after compilation (
dvi
if
latex
is used,
xdv
if
xelatex
is used)
text_to_replace
The text to be replaced in the template (needn’t to change)
universal_import_line
¶
Import line that need to execute when entering interactive mode directly.
style
¶
font
Default font of Text
text_alignment
Default text alignment for LaTeX
background_color
Default background color
window_position
¶
The relative position of the playback window on the display (two characters,
the first character means upper(U) / middle(O) / lower(D), the second character
means left(L) / middle(O) / right(R)).
window_monitor
¶
The number of the monitor you want the preview window to pop up on. (default is 0)
full_screen
¶
Whether open the window in full screen. (default is false)
break_into_partial_movies
¶
If this is set to
True
, then many small files will be written corresponding
to each
Scene.play
and
Scene.wait
call, and these files will then be combined
to form the full scene.
Sometimes video-editing is made easier when working with the broken up scene, which
effectively has cuts at all the places you might want.
camera_resolutions
¶
Export resolutions
low
Low resolutions (default is 480p)
medium
Medium resolutions (default is 720p)
high
High resolutions (default is 1080p)
ultra_high
Ultra high resolutions (default is 4K)
default_resolutions
Default resolutions (one of the above four, default is high)
fps
¶
Export frame rate. (default is 30)
Contents
custom_config
directories
tex
universal_import_line
style
window_position
window_monitor
full_screen
break_into_partial_movies
camera_resolutions
fps

Code Examples:
Example 1:
```python
directories
```
Example 2:
```python
mirror_module_path
```
Example 3:
```python
"/.../manim/output"
```
Example 4:
```python
mirror_module_path
```
Example 5:
```python
manim/
    ├── manimlib/
    │   ├── animation/
    │   ├── ...
    │   ├── default_config.yml
    │   └── window.py
    ├── output/
    │   ├── images
    │   │   └── Scene1.png
    │   └── videos
    │       └── Scene1.mp4
    ├── code.py
    └── custom_config.yml
```
Example 6:
```python
mirror_module_path
```
Example 7:
```python
manim/
    ├── manimlib/
    │   ├── animation/
    │   ├── ...
    │   ├── default_config.yml
    │   └── window.py
    ├── output/
    │   └── code/
    │       ├── images
    │       │   └── Scene1.png
    │       └── videos
    │           └── Scene1.mp4
    ├── code.py
    └── custom_config.yml
```
Example 8:
```python
raster_images
```
Example 9:
```python
ImageMobject
```
Example 10:
```python
vector_images
```
Example 11:
```python
Scene.add_sound()
```
Example 12:
```python
temporary_storage
```
Example 13:
```python
xelatex -no-pdf
```
Example 14:
```python
template_file
```
Example 15:
```python
manimlib/tex_templates
```
Example 16:
```python
intermediate_filetype
```
Example 17:
```python
text_to_replace
```
Example 18:
```python
universal_import_line
```
Example 19:
```python
text_alignment
```
Example 20:
```python
background_color
```
Example 21:
```python
window_position
```
Example 22:
```python
window_monitor
```
Example 23:
```python
full_screen
```
Example 24:
```python
break_into_partial_movies
```
Example 25:
```python
camera_resolutions
```
Example 26:
```python
default_resolutions
```
Example 27:
```python
directories
```
Example 28:
```python
universal_import_line
```
Example 29:
```python
window_position
```
Example 30:
```python
window_monitor
```
Example 31:
```python
full_screen
```
Example 32:
```python
break_into_partial_movies
```
Example 33:
```python
camera_resolutions
```

================================================================================
